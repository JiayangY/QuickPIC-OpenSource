var tipuesearch = {"pages":[{"title":" QuickPIC ","text":"QuickPIC QuickPIC is a 3D parallel (MPI & OpenMP Hybrid) Quasi-Static PIC code, which is developed based on the framework UPIC. This is the UCLA Plasma Simulation Group's official open-source repository for QuickPIC. Upon cloning the repository If you clone this repository, we ask that you please contact Weiming An (anweiming@ucla.edu). The development of QuickPIC relies on grant funding for which we are required to report code usage, and we would greatly appreciate being able to maintain accurate user-number tallies. Todo Add comments in the source code. Add User Guide Developer Info Weiming An","tags":"home","loc":"index.html"},{"title":"perrors_class.f03 – QuickPIC","text":"This file depends on sourcefile~~perrors_class.f03~~EfferentGraph sourcefile~perrors_class.f03 perrors_class.f03 sourcefile~parallel_class.f03 parallel_class.f03 sourcefile~perrors_class.f03->sourcefile~parallel_class.f03 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~perrors_class.f03~~AfferentGraph sourcefile~perrors_class.f03 perrors_class.f03 sourcefile~fdist3d_class.f03 fdist3d_class.f03 sourcefile~fdist3d_class.f03->sourcefile~perrors_class.f03 sourcefile~spect3d_class.f03 spect3d_class.f03 sourcefile~fdist3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~ufield3d_class.f03 ufield3d_class.f03 sourcefile~fdist3d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~input_class.f03 input_class.f03 sourcefile~fdist3d_class.f03->sourcefile~input_class.f03 sourcefile~field3d_class.f03 field3d_class.f03 sourcefile~field3d_class.f03->sourcefile~perrors_class.f03 sourcefile~hdf5io_class.f03 hdf5io_class.f03 sourcefile~field3d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~field3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~field3d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~hdf5io_class.f03->sourcefile~perrors_class.f03 sourcefile~spect3d_class.f03->sourcefile~perrors_class.f03 sourcefile~spect2d_class.f03 spect2d_class.f03 sourcefile~spect3d_class.f03->sourcefile~spect2d_class.f03 sourcefile~simulation_class.f03 simulation_class.f03 sourcefile~simulation_class.f03->sourcefile~perrors_class.f03 sourcefile~simulation_class.f03->sourcefile~fdist3d_class.f03 sourcefile~simulation_class.f03->sourcefile~field3d_class.f03 sourcefile~simulation_class.f03->sourcefile~hdf5io_class.f03 sourcefile~simulation_class.f03->sourcefile~spect3d_class.f03 sourcefile~simulation_class.f03->sourcefile~spect2d_class.f03 sourcefile~simulation_class.f03->sourcefile~input_class.f03 sourcefile~fdist2d_class.f03 fdist2d_class.f03 sourcefile~simulation_class.f03->sourcefile~fdist2d_class.f03 sourcefile~field2d_class.f03 field2d_class.f03 sourcefile~simulation_class.f03->sourcefile~field2d_class.f03 sourcefile~species2d_class.f03 species2d_class.f03 sourcefile~simulation_class.f03->sourcefile~species2d_class.f03 sourcefile~beam3d_class.f03 beam3d_class.f03 sourcefile~simulation_class.f03->sourcefile~beam3d_class.f03 sourcefile~ufield3d_class.f03->sourcefile~perrors_class.f03 sourcefile~ufield3d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~ufield3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~ufield2d_class.f03 ufield2d_class.f03 sourcefile~ufield3d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~part3d_class.f03 part3d_class.f03 sourcefile~part3d_class.f03->sourcefile~perrors_class.f03 sourcefile~part3d_class.f03->sourcefile~fdist3d_class.f03 sourcefile~part3d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~part3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~part3d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~part2d_class.f03 part2d_class.f03 sourcefile~part2d_class.f03->sourcefile~perrors_class.f03 sourcefile~part2d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~part2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~part2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~part2d_class.f03->sourcefile~fdist2d_class.f03 sourcefile~ufield2d_class.f03->sourcefile~perrors_class.f03 sourcefile~ufield2d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~ufield2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~spect2d_class.f03->sourcefile~perrors_class.f03 sourcefile~input_class.f03->sourcefile~perrors_class.f03 sourcefile~input_class.f03->sourcefile~spect3d_class.f03 sourcefile~fpois2d_class.f03 fpois2d_class.f03 sourcefile~fpois2d_class.f03->sourcefile~perrors_class.f03 sourcefile~fpois2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~fpois2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~fdist2d_class.f03->sourcefile~perrors_class.f03 sourcefile~fdist2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~fdist2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~fdist2d_class.f03->sourcefile~input_class.f03 sourcefile~field2d_class.f03->sourcefile~perrors_class.f03 sourcefile~field2d_class.f03->sourcefile~field3d_class.f03 sourcefile~field2d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~field2d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~field2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~field2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~field2d_class.f03->sourcefile~fpois2d_class.f03 sourcefile~fft2d_class.f03 fft2d_class.f03 sourcefile~field2d_class.f03->sourcefile~fft2d_class.f03 sourcefile~species2d_class.f03->sourcefile~perrors_class.f03 sourcefile~species2d_class.f03->sourcefile~field3d_class.f03 sourcefile~species2d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~species2d_class.f03->sourcefile~spect3d_class.f03 sourcefile~species2d_class.f03->sourcefile~part2d_class.f03 sourcefile~species2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~species2d_class.f03->sourcefile~fdist2d_class.f03 sourcefile~species2d_class.f03->sourcefile~field2d_class.f03 sourcefile~beam3d_class.f03->sourcefile~perrors_class.f03 sourcefile~beam3d_class.f03->sourcefile~fdist3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~field3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~beam3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~part3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~field2d_class.f03 sourcefile~fft2d_class.f03->sourcefile~perrors_class.f03 sourcefile~fft2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~fft2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~main.f03 main.f03 sourcefile~main.f03->sourcefile~simulation_class.f03 var pansourcefileperrors_classf03AfferentGraph = svgPanZoom('#sourcefileperrors_classf03AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules perrors_class Source Code perrors_class.f03 Source Code ! Perrors class for QuickPIC Open Source 1.0 ! update: 04/18/2016 module perrors_class use mpi use parallel_class implicit none private public :: perrors type perrors private class ( parallel ), pointer , public :: p => null () integer :: eunit = 2 integer :: monitor = 0 contains generic :: new => init_perrors generic :: del => end_perrors procedure , private :: init_perrors procedure , private :: end_perrors procedure :: equit procedure :: werrfl0 procedure :: werrfl1 procedure :: werrfl2 procedure :: setmonitor end type perrors integer , dimension ( 4 ), save :: itime double precision , save :: dtime contains ! subroutine init_perrors ( this , prl , eunit , monitor ) implicit none class ( perrors ), intent ( inout ) :: this class ( parallel ), intent ( in ), pointer :: prl integer , intent ( in ) :: eunit , monitor ! local data character ( len = 20 ) :: str character ( len = 8 ) :: cn integer :: k , l integer :: ierror write ( str , * ) prl % getidproc () cn = '00000000' str = trim ( adjustl ( str )) l = len_trim ( str ) k = 8 cn ( k + 1 - l : k ) = str ( 1 : l ) this % p => prl this % eunit = eunit this % monitor = monitor if ( this % p % getidproc () == 0 ) then call system ( 'mkdir ./ELOG' ) endif call MPI_BARRIER ( this % p % getlworld (), ierror ) call set_ename ( eunit , './ELOG/elog-' // cn ) call dtimer ( dtime , itime , - 1 ) end subroutine init_perrors ! subroutine set_ename ( eunit , ename ) implicit none ! this subroutine sets the name of the error file and opens it ! ename = new error file name character ( len =* ), intent ( in ) :: ename integer , intent ( in ) :: eunit open ( unit = eunit , file = trim ( ename ), form = 'formatted' , status = 'repla& &ce' ) end subroutine set_ename ! subroutine end_perrors ( this ) implicit none class ( perrors ), intent ( inout ) :: this close ( unit = this % eunit ) end subroutine end_perrors ! subroutine equit ( this , estr ) ! this subroutine handles errors and optionally logs error message ! if estr is present, prepends the node number to the output string ! how = keyword on how to handle error ! estr = optional error message string to be logged in error file implicit none class ( perrors ), intent ( in ) :: this character ( len =* ), intent ( in ), optional :: estr ! loccal data character ( len = 20 ) :: tstr integer :: ierror call dtimer ( dtime , itime , 1 ) write ( tstr , '(f12.3)' ) dtime if ( present ( estr )) write ( this % eunit , * ) trim ( tstr ) // \" : \" // trim ( adjustl ( estr )) flush ( this % eunit ) call MPI_ABORT ( this % p % getlworld (), 1 , ierror ) !         call MPI_FINALIZE(ierror) print * , 'Error!' stop end subroutine equit ! subroutine werrfl0 ( this , estr ) ! this subroutine handles error message on level 0 implicit none class ( perrors ), intent ( in ) :: this character ( len =* ), intent ( in ) :: estr ! local data character ( len = 20 ) :: tstr call dtimer ( dtime , itime , 1 ) write ( tstr , '(f12.3)' ) dtime write ( this % eunit , * ) trim ( tstr ) // \" : \" // trim ( adjustl ( estr )) flush ( this % eunit ) end subroutine werrfl0 ! subroutine werrfl1 ( this , estr ) ! this subroutine handles error message on level 1 implicit none class ( perrors ), intent ( in ) :: this character ( len =* ), intent ( in ) :: estr ! local data character ( len = 20 ) :: tstr if ( this % monitor < 1 ) then return else call dtimer ( dtime , itime , 1 ) write ( tstr , '(f12.3)' ) dtime write ( this % eunit , * ) trim ( tstr ) // \" : \" // trim ( adjustl ( estr )) flush ( this % eunit ) endif end subroutine werrfl1 ! subroutine werrfl2 ( this , estr ) ! this subroutine handles error message on level 2 implicit none class ( perrors ), intent ( in ) :: this character ( len =* ), intent ( in ) :: estr ! local data character ( len = 20 ) :: tstr if ( this % monitor < 2 ) then return else call dtimer ( dtime , itime , 1 ) write ( tstr , '(f12.3)' ) dtime write ( this % eunit , * ) trim ( tstr ) // \" : \" // trim ( adjustl ( estr )) flush ( this % eunit ) endif end subroutine werrfl2 ! subroutine setmonitor ( this , moniter ) implicit none class ( perrors ), intent ( inout ) :: this integer , intent ( in ) :: moniter this % monitor = moniter end subroutine ! end module perrors_class","tags":"","loc":"sourcefile/perrors_class.f03.html"},{"title":"spect2d_class.f03 – QuickPIC","text":"This file depends on sourcefile~~spect2d_class.f03~~EfferentGraph sourcefile~spect2d_class.f03 spect2d_class.f03 sourcefile~parallel_pipe_class.f03 parallel_pipe_class.f03 sourcefile~spect2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~perrors_class.f03 perrors_class.f03 sourcefile~spect2d_class.f03->sourcefile~perrors_class.f03 sourcefile~parallel_class.f03 parallel_class.f03 sourcefile~parallel_pipe_class.f03->sourcefile~parallel_class.f03 sourcefile~perrors_class.f03->sourcefile~parallel_class.f03 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~spect2d_class.f03~~AfferentGraph sourcefile~spect2d_class.f03 spect2d_class.f03 sourcefile~simulation_class.f03 simulation_class.f03 sourcefile~simulation_class.f03->sourcefile~spect2d_class.f03 sourcefile~spect3d_class.f03 spect3d_class.f03 sourcefile~simulation_class.f03->sourcefile~spect3d_class.f03 sourcefile~fdist2d_class.f03 fdist2d_class.f03 sourcefile~simulation_class.f03->sourcefile~fdist2d_class.f03 sourcefile~field2d_class.f03 field2d_class.f03 sourcefile~simulation_class.f03->sourcefile~field2d_class.f03 sourcefile~species2d_class.f03 species2d_class.f03 sourcefile~simulation_class.f03->sourcefile~species2d_class.f03 sourcefile~fdist3d_class.f03 fdist3d_class.f03 sourcefile~simulation_class.f03->sourcefile~fdist3d_class.f03 sourcefile~field3d_class.f03 field3d_class.f03 sourcefile~simulation_class.f03->sourcefile~field3d_class.f03 sourcefile~input_class.f03 input_class.f03 sourcefile~simulation_class.f03->sourcefile~input_class.f03 sourcefile~beam3d_class.f03 beam3d_class.f03 sourcefile~simulation_class.f03->sourcefile~beam3d_class.f03 sourcefile~part2d_class.f03 part2d_class.f03 sourcefile~part2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~ufield2d_class.f03 ufield2d_class.f03 sourcefile~part2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~part2d_class.f03->sourcefile~fdist2d_class.f03 sourcefile~spect3d_class.f03->sourcefile~spect2d_class.f03 sourcefile~ufield2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~fpois2d_class.f03 fpois2d_class.f03 sourcefile~fpois2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~fpois2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~fdist2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~fdist2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~fdist2d_class.f03->sourcefile~input_class.f03 sourcefile~field2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~field2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~field2d_class.f03->sourcefile~fpois2d_class.f03 sourcefile~fft2d_class.f03 fft2d_class.f03 sourcefile~field2d_class.f03->sourcefile~fft2d_class.f03 sourcefile~field2d_class.f03->sourcefile~field3d_class.f03 sourcefile~ufield3d_class.f03 ufield3d_class.f03 sourcefile~field2d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~species2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~species2d_class.f03->sourcefile~part2d_class.f03 sourcefile~species2d_class.f03->sourcefile~spect3d_class.f03 sourcefile~species2d_class.f03->sourcefile~fdist2d_class.f03 sourcefile~species2d_class.f03->sourcefile~field2d_class.f03 sourcefile~species2d_class.f03->sourcefile~field3d_class.f03 sourcefile~fft2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~fft2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~fdist3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~fdist3d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~fdist3d_class.f03->sourcefile~input_class.f03 sourcefile~field3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~field3d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~ufield3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~ufield3d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~part3d_class.f03 part3d_class.f03 sourcefile~part3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~part3d_class.f03->sourcefile~fdist3d_class.f03 sourcefile~part3d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~main.f03 main.f03 sourcefile~main.f03->sourcefile~simulation_class.f03 sourcefile~input_class.f03->sourcefile~spect3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~field2d_class.f03 sourcefile~beam3d_class.f03->sourcefile~fdist3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~field3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~part3d_class.f03 var pansourcefilespect2d_classf03AfferentGraph = svgPanZoom('#sourcefilespect2d_classf03AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules spect2d_class Source Code spect2d_class.f03 Source Code ! Spect2d class for QuickPIC Open Source 1.0 ! update: 04/18/2016 module spect2d_class use perrors_class use parallel_pipe_class implicit none private public :: spect2d type spect2d private ! psolver = solver type = (1) = (conductive) ! inorder = (1) = (linear) integer :: indx , indy , psolver , inorder class ( perrors ), pointer , public :: err => null () class ( parallel_pipe ), pointer , public :: p => null () contains procedure , private :: init_spect2d procedure , private :: end_spect2d generic :: new => init_spect2d generic :: del => end_spect2d procedure :: getindx procedure :: getindy procedure :: getpsolver procedure :: getinorder end type spect2d contains ! subroutine init_spect2d ( this , pp , perr , indx , indy , psolver , inorder ) implicit none class ( spect2d ), intent ( inout ) :: this class ( perrors ), intent ( in ), pointer :: perr class ( parallel_pipe ), intent ( in ), pointer :: pp integer , intent ( in ) :: indx , indy , psolver , inorder this % indx = indx this % indy = indy this % psolver = psolver this % inorder = inorder this % err => perr this % p => pp end subroutine init_spect2d ! subroutine end_spect2d ( this ) implicit none class ( spect2d ), intent ( inout ) :: this return end subroutine end_spect2d ! function getindx ( this ) implicit none class ( spect2d ), intent ( in ) :: this integer :: getindx getindx = this % indx end function getindx ! function getindy ( this ) implicit none class ( spect2d ), intent ( in ) :: this integer :: getindy getindy = this % indy end function getindy ! function getpsolver ( this ) implicit none class ( spect2d ), intent ( in ) :: this integer :: getpsolver getpsolver = this % psolver end function getpsolver ! function getinorder ( this ) implicit none class ( spect2d ), intent ( in ) :: this integer :: getinorder getinorder = this % inorder end function getinorder ! end module spect2d_class","tags":"","loc":"sourcefile/spect2d_class.f03.html"},{"title":"input_class.f03 – QuickPIC","text":"This file depends on sourcefile~~input_class.f03~~EfferentGraph sourcefile~input_class.f03 input_class.f03 sourcefile~parallel_pipe_class.f03 parallel_pipe_class.f03 sourcefile~input_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~perrors_class.f03 perrors_class.f03 sourcefile~input_class.f03->sourcefile~perrors_class.f03 sourcefile~parallel_class.f03 parallel_class.f03 sourcefile~input_class.f03->sourcefile~parallel_class.f03 sourcefile~spect3d_class.f03 spect3d_class.f03 sourcefile~input_class.f03->sourcefile~spect3d_class.f03 sourcefile~parallel_pipe_class.f03->sourcefile~parallel_class.f03 sourcefile~perrors_class.f03->sourcefile~parallel_class.f03 sourcefile~spect3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~spect3d_class.f03->sourcefile~perrors_class.f03 sourcefile~spect2d_class.f03 spect2d_class.f03 sourcefile~spect3d_class.f03->sourcefile~spect2d_class.f03 sourcefile~spect2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~spect2d_class.f03->sourcefile~perrors_class.f03 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~input_class.f03~~AfferentGraph sourcefile~input_class.f03 input_class.f03 sourcefile~fdist3d_class.f03 fdist3d_class.f03 sourcefile~fdist3d_class.f03->sourcefile~input_class.f03 sourcefile~fdist2d_class.f03 fdist2d_class.f03 sourcefile~fdist2d_class.f03->sourcefile~input_class.f03 sourcefile~simulation_class.f03 simulation_class.f03 sourcefile~simulation_class.f03->sourcefile~input_class.f03 sourcefile~simulation_class.f03->sourcefile~fdist3d_class.f03 sourcefile~simulation_class.f03->sourcefile~fdist2d_class.f03 sourcefile~species2d_class.f03 species2d_class.f03 sourcefile~simulation_class.f03->sourcefile~species2d_class.f03 sourcefile~beam3d_class.f03 beam3d_class.f03 sourcefile~simulation_class.f03->sourcefile~beam3d_class.f03 sourcefile~part2d_class.f03 part2d_class.f03 sourcefile~part2d_class.f03->sourcefile~fdist2d_class.f03 sourcefile~main.f03 main.f03 sourcefile~main.f03->sourcefile~simulation_class.f03 sourcefile~part3d_class.f03 part3d_class.f03 sourcefile~part3d_class.f03->sourcefile~fdist3d_class.f03 sourcefile~species2d_class.f03->sourcefile~fdist2d_class.f03 sourcefile~species2d_class.f03->sourcefile~part2d_class.f03 sourcefile~beam3d_class.f03->sourcefile~fdist3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~part3d_class.f03 var pansourcefileinput_classf03AfferentGraph = svgPanZoom('#sourcefileinput_classf03AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules input_class Source Code input_class.f03 Source Code ! input class for QuickPIC Open Source 1.0 ! update: 04/18/2016 module input_class use perrors_class use parallel_class use parallel_pipe_class use spect3d_class use mpi use json_module implicit none private public :: input_json type input_json class ( spect3d ), pointer :: sp => null () class ( perrors ), pointer :: err => null () class ( parallel ), pointer :: p => null () class ( parallel_pipe ), pointer :: pp => null () type ( json_file ), private , pointer :: input => null () contains generic :: new => read_input_json generic :: get => json_file_get_object , json_file_get_integer ,& & json_file_get_double , json_file_get_logical ,& & json_file_get_string , json_file_get_integer_vec ,& & json_file_get_double_vec , json_file_get_logical_vec ,& & json_file_get_string_vec , json_file_get_alloc_string_vec ,& & json_file_get_root generic :: info => json_file_variable_info procedure :: found procedure , private :: read_input_json procedure , private :: initialize , set_json_core_in_file procedure , private :: load_file , print_to_string procedure , private :: load_from_string procedure , private :: json_file_get_object , json_file_get_integer ,& & json_file_get_double , json_file_get_logical ,& & json_file_get_string , json_file_get_integer_vec ,& & json_file_get_double_vec , json_file_get_logical_vec ,& & json_file_get_string_vec , json_file_get_alloc_string_vec ,& & json_file_get_root procedure , private :: json_file_variable_info end type character ( len = 10 ), save :: class = 'input:' character ( len = 128 ), save :: erstr type ( spect3d ), save , target :: sp type ( perrors ), save , target :: err type ( parallel ), save , target :: p type ( parallel_pipe ), save , target :: pp contains ! subroutine read_input_json ( this ) implicit none class ( input_json ), intent ( inout ) :: this ! local data character ( len = 18 ), save :: sname = 'read_input_json:' logical :: found , stat character ( len = :), allocatable :: ff , boundary , error_msg integer :: length , num_stages , verbose , indx , indy , indz , psolve , ierr call p % new () this % p => p call err % new ( this % p , 2 , monitor = 0 ) this % err => err call this % err % werrfl0 ( class // sname // ' started' ) call this % initialize ( comment_char = '!' ) if ( p % getidproc () == 0 ) then inquire ( FILE = './qpinput.json' , EXIST = found ) if ( found ) then ! read the file call this % load_file ( filename = './qpinput.json' ) call this % input % check_for_errors ( stat , error_msg ) if (. not . stat ) then call this % err % equit ( class // sname // trim ( error_msg )) return end if else write ( erstr , * ) 'error: cannot find the input file' call this % err % equit ( class // sname // erstr ) return end if call this % print_to_string ( ff ) length = len ( ff ) end if call MPI_BCAST ( length , 1 , this % p % getmint (), 0 , this % p % getlworld (), ierr ) if (. not . allocated ( ff )) allocate ( character ( len = length ) :: ff ) call MPI_BCAST ( ff , length , this % p % getmchar (), 0 , this % p % getlworld (), ierr ) call this % load_from_string ( ff ) call this % get ( 'simulation.nodes(2)' , num_stages ) call pp % new ( nst = num_stages ) this % pp => pp call this % get ( 'simulation.indx' , indx ) call this % get ( 'simulation.indy' , indy ) call this % get ( 'simulation.indz' , indz ) call this % get ( 'simulation.boundary' , boundary ) select case ( trim ( boundary )) case ( \"conducting\" ) psolve = 1 case default psolve = 1 end select call sp % new ( this % pp , this % err , indx , indy , indz , psolve , 1 ) this % sp => sp call this % err % werrfl0 ( ff ) call this % err % werrfl0 ( class // sname // ' ended' ) call this % get ( 'simulation.verbose' , verbose ) call err % setmonitor ( verbose ) end subroutine read_input_json ! subroutine initialize ( this , verbose , compact_reals , print_signs ,& & real_format , spaces_per_tab , strict_type_checking , trailing_spaces_significant ,& & case_sensitive_keys , no_whitespace , unescape_strings , comment_char , path_mode ,& & path_separator , compress_vectors , allow_duplicate_keys ) implicit none class ( input_json ), intent ( inout ) :: this logical , intent ( in ), optional :: verbose logical , intent ( in ), optional :: compact_reals logical , intent ( in ), optional :: print_signs character ( len =* ), intent ( in ), optional :: real_format integer , intent ( in ), optional :: spaces_per_tab logical , intent ( in ), optional :: strict_type_checking logical , intent ( in ), optional :: trailing_spaces_significant logical , intent ( in ), optional :: case_sensitive_keys logical , intent ( in ), optional :: no_whitespace logical , intent ( in ), optional :: unescape_strings character ( len = 1 ), intent ( in ), optional :: comment_char integer , intent ( in ), optional :: path_mode character ( len = 1 ), intent ( in ), optional :: path_separator logical , intent ( in ), optional :: compress_vectors logical , intent ( in ), optional :: allow_duplicate_keys ! local data character ( len = 38 ), save :: sname = 'initialize_json_core_in_file:' call this % err % werrfl2 ( class // sname // ' started' ) allocate ( this % input ) call this % input % initialize ( verbose , compact_reals , print_signs ,& & real_format , spaces_per_tab , strict_type_checking , trailing_spaces_significant ,& & case_sensitive_keys , no_whitespace , unescape_strings , comment_char , path_mode ,& & path_separator , compress_vectors , allow_duplicate_keys ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine initialize ! subroutine set_json_core_in_file ( this , core ) implicit none class ( input_json ), intent ( inout ) :: this type ( json_core ), intent ( in ) :: core ! local data character ( len = 38 ), save :: sname = 'set_json_core_in_file:' call this % err % werrfl2 ( class // sname // ' started' ) call this % input % initialize ( core ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine set_json_core_in_file ! subroutine load_file ( this , filename , unit ) implicit none class ( input_json ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: filename integer , intent ( in ), optional :: unit ! local data character ( len = 18 ), save :: sname = 'json_file_load:' call this % err % werrfl2 ( class // sname // ' started' ) call this % input % load_file ( filename , unit ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine load_file ! subroutine print_to_string ( this , str ) implicit none class ( input_json ), intent ( inout ) :: this character ( len = :), allocatable , intent ( out ) :: str ! local data character ( len = 38 ), save :: sname = 'json_file_print_to_string:' call this % err % werrfl2 ( class // sname // ' started' ) call this % input % print_to_string ( str ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine print_to_string ! subroutine load_from_string ( this , str ) implicit none class ( input_json ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: str ! local data character ( len = 38 ), save :: sname = 'json_file_load_from_string:' call this % err % werrfl2 ( class // sname // ' started' ) call this % input % load_from_string ( str ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine load_from_string ! function found ( this , path ) implicit none class ( input_json ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: path logical :: found ! local data character ( len = 38 ), save :: sname = 'json_file_found:' call this % err % werrfl2 ( class // sname // ' started' ) call this % input % info ( path , found = found ) call this % err % werrfl2 ( class // sname // ' ended' ) end function found ! subroutine json_file_get_object ( this , path , p ) implicit none class ( input_json ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: path type ( json_value ), pointer , intent ( out ) :: p ! local data character ( len = 38 ), save :: sname = 'json_file_get_object:' character ( len = :), allocatable :: error logical :: st call this % err % werrfl2 ( class // sname // ' started' ) call this % input % get ( path , p ) if ( this % input % failed ()) then call this % input % check_for_errors ( st , error ) call this % input % clear_exceptions () call this % err % equit ( class // sname // error ) end if call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine json_file_get_object ! subroutine json_file_get_integer ( this , path , val ) implicit none class ( input_json ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: path integer , intent ( out ) :: val ! local data character ( len = 38 ), save :: sname = 'json_file_get_integer:' character ( len = :), allocatable :: error logical :: st call this % err % werrfl2 ( class // sname // ' started' ) call this % input % get ( path , val ) if ( this % input % failed ()) then call this % input % check_for_errors ( st , error ) call this % input % clear_exceptions () call this % err % equit ( class // sname // error ) end if call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine json_file_get_integer ! subroutine json_file_get_double ( this , path , val ) implicit none class ( input_json ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: path real , intent ( out ) :: val ! local data character ( len = 38 ), save :: sname = 'json_file_get_double:' character ( len = :), allocatable :: error logical :: st call this % err % werrfl2 ( class // sname // ' started' ) call this % input % get ( path , val ) if ( this % input % failed ()) then call this % input % check_for_errors ( st , error ) call this % input % clear_exceptions () call this % err % equit ( class // sname // error ) end if call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine json_file_get_double ! subroutine json_file_get_logical ( this , path , val ) implicit none class ( input_json ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: path logical , intent ( out ) :: val ! local data character ( len = 38 ), save :: sname = 'json_file_get_logical:' character ( len = :), allocatable :: error logical :: st call this % err % werrfl2 ( class // sname // ' started' ) call this % input % get ( path , val ) if ( this % input % failed ()) then call this % input % check_for_errors ( st , error ) call this % input % clear_exceptions () call this % err % equit ( class // sname // error ) end if call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine json_file_get_logical ! subroutine json_file_get_string ( this , path , val ) implicit none class ( input_json ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: path character ( len = :), allocatable , intent ( out ) :: val ! local data character ( len = 38 ), save :: sname = 'json_file_get_string:' character ( len = :), allocatable :: error logical :: st call this % err % werrfl2 ( class // sname // ' started' ) call this % input % get ( path , val ) if ( this % input % failed ()) then call this % input % check_for_errors ( st , error ) call this % input % clear_exceptions () call this % err % equit ( class // sname // error ) end if call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine json_file_get_string ! subroutine json_file_get_integer_vec ( this , path , vec ) implicit none class ( input_json ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: path integer , dimension (:), allocatable , intent ( out ) :: vec ! local data character ( len = 38 ), save :: sname = 'json_file_get_integer_vec:' character ( len = :), allocatable :: error logical :: st call this % err % werrfl2 ( class // sname // ' started' ) call this % input % get ( path , vec ) if ( this % input % failed ()) then call this % input % check_for_errors ( st , error ) call this % input % clear_exceptions () call this % err % equit ( class // sname // error ) end if call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine json_file_get_integer_vec ! subroutine json_file_get_double_vec ( this , path , vec ) implicit none class ( input_json ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: path real , dimension (:), allocatable , intent ( out ) :: vec ! local data character ( len = 38 ), save :: sname = 'json_file_get_double_vec:' character ( len = :), allocatable :: error logical :: st call this % err % werrfl2 ( class // sname // ' started' ) call this % input % get ( path , vec ) if ( this % input % failed ()) then call this % input % check_for_errors ( st , error ) call this % input % clear_exceptions () call this % err % equit ( class // sname // error ) end if call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine json_file_get_double_vec ! subroutine json_file_get_logical_vec ( this , path , vec ) implicit none class ( input_json ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: path logical , dimension (:), allocatable , intent ( out ) :: vec ! local data character ( len = 38 ), save :: sname = 'json_file_get_logical_vec:' character ( len = :), allocatable :: error logical :: st call this % err % werrfl2 ( class // sname // ' started' ) call this % input % get ( path , vec ) if ( this % input % failed ()) then call this % input % check_for_errors ( st , error ) call this % input % clear_exceptions () call this % err % equit ( class // sname // error ) end if call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine json_file_get_logical_vec ! subroutine json_file_get_string_vec ( this , path , vec ) implicit none class ( input_json ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: path character ( len =* ), dimension (:), allocatable , intent ( out ) :: vec ! local data character ( len = 38 ), save :: sname = 'json_file_get_string_vec:' character ( len = :), allocatable :: error logical :: st call this % err % werrfl2 ( class // sname // ' started' ) call this % input % get ( path , vec ) if ( this % input % failed ()) then call this % input % check_for_errors ( st , error ) call this % input % clear_exceptions () call this % err % equit ( class // sname // error ) end if call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine json_file_get_string_vec ! subroutine json_file_get_alloc_string_vec ( this , path , vec , ilen ) implicit none class ( input_json ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: path character ( len = :), dimension (:), allocatable , intent ( out ) :: vec integer , dimension (:), allocatable , intent ( out ) :: ilen ! local data character ( len = 38 ), save :: sname = 'json_file_get_alloc_string_vec:' character ( len = :), allocatable :: error logical :: st call this % err % werrfl2 ( class // sname // ' started' ) call this % input % get ( path , vec , ilen ) if ( this % input % failed ()) then call this % input % check_for_errors ( st , error ) call this % input % clear_exceptions () call this % err % equit ( class // sname // error ) end if call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine json_file_get_alloc_string_vec ! subroutine json_file_get_root ( this , p ) implicit none class ( input_json ), intent ( inout ) :: this type ( json_value ), pointer , intent ( out ) :: p ! local data character ( len = 38 ), save :: sname = 'json_file_get_root:' call this % err % werrfl2 ( class // sname // ' started' ) call this % input % get ( p ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine json_file_get_root ! subroutine json_file_variable_info ( this , path , n_children ) implicit none class ( input_json ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: path integer , intent ( out ) :: n_children ! local data character ( len = 38 ), save :: sname = 'json_file_variable_info:' character ( len = :), allocatable :: error logical :: st integer :: var_type character ( len = :), allocatable :: name call this % err % werrfl2 ( class // sname // ' started' ) call this % input % info ( path , var_type = var_type , n_children = n_children , name = name ) if ( this % input % failed ()) then call this % input % check_for_errors ( st , error ) call this % input % clear_exceptions () call this % err % equit ( class // sname // error ) end if call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine json_file_variable_info ! end module input_class","tags":"","loc":"sourcefile/input_class.f03.html"},{"title":"fft2d_lib77.f – QuickPIC","text":"Contents Subroutines WPFST2RINIT WPFSST2R WPFCCT2R PFST2RXX PFCT2RXX PFST2RXY PFCT2RXY WPFCST2R2 WPFSCT2R2 PFCST2R2X PFSCT2R2X PFSCT2R2Y PFCST2R2Y WPFCST2R3 WPFSCT2R3 PFCSST2R3X PFSCCT2R3X PFSCST2R3Y PFCSCT2R3Y PFSSCT2R3Y PFSSCT2R3X WPFS3T2R3 PRTPOSE PR2TPOSE PR3TPOSE PWTIMERA PDIVFD2 PGRADFD2 PCURLFD22 PCURLFD2 WPPFSST2RM WPPFSCT2RM WPPFCST2RM WPPFCCT2RM PPFST2RMXX PPFCT2RMXX PPFST2RMXY PPFCT2RMXY WPPFCST2RM2 WPPFSCT2RM2 PPFCST2RM2X PPFSCT2RM2X PPFSCT2RM2Y PPFCST2RM2Y WPPFCST2RM3 WPPFSCT2RM3 PPFCSST2RM3X PPFSCCT2RM3X PPFSCST2RM3Y PPFCSCT2RM3Y WPPFSCT2RM4 PPFSCCST2RM4X PPFSCSCT2RM4Y WPPFSCT2RM22 PPFSCCST2RM22X PPFSCSCT2RM22Y WPPFSST2RM23 PPFSSCT2RM23X PPFSSCT2RM23Y MPPDIVFD2 MPPGRADFD2 MPPCURLFD2 Source Code fft2d_lib77.f Source Code c 2d parallel PIC library for fast fourier transforms c----------------------------------------------------------------------- subroutine WPFST2RINIT ( mixup , sctd , indx , indy , nxhyd , nxyd ) c this subroutine calculates tables needed by a two dimensional c fast real sine and cosine transforms and their inverses. c input: indx, indy, nxhyd, nxyd c output: mixup, sctd c mixup = array of bit reversed addresses c sctd = sine/cosine table c indx/indy = exponent which determines length in x/y direction, c where nx=2**indx, ny=2**indy c nxhyd = maximum of (nx/2,ny) c nxyd = maximum of (nx,ny) c written by viktor k. decyk, ucla implicit none integer indx , indy , nxhyd , nxyd integer mixup complex sctd dimension mixup ( nxhyd ), sctd ( nxyd ) c local data integer indx1 , indx1y , nx , ny , nxy , nxhy integer j , k , lb , ll , jb , it real dnxy , arg indx1 = indx - 1 indx1y = max0 ( indx1 , indy ) nx = 2 ** indx ny = 2 ** indy nxy = max0 ( nx , ny ) nxhy = 2 ** indx1y c bit-reverse index table: mixup(j) = 1 + reversed bits of (j - 1) do 20 j = 1 , nxhy lb = j - 1 ll = 0 do 10 k = 1 , indx1y jb = lb / 2 it = lb - 2 * jb lb = jb ll = 2 * ll + it 10 continue mixup ( j ) = ll + 1 20 continue c sine/cosine table for the angles n*pi/nxy dnxy = 0.5 * 6.28318530717959 / float ( nxy ) do 30 j = 1 , nxy arg = dnxy * float ( j - 1 ) sctd ( j ) = cmplx ( cos ( arg ), - sin ( arg )) 30 continue return end c----------------------------------------------------------------------- subroutine WPFSST2R ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp , indx , ind 1 y , kstrt , nxvh , nyv , kxp2 , kyp , kypd , kxp2d , jblok , kblok , nxhyd , nxyd ) c wrapper function for parallel real sine/sine transform implicit none integer isign , ntpose , mixup , indx , indy , kstrt , nxvh , nyv integer kxp2 , kyp , kypd , kxp2d , jblok , kblok , nxhyd , nxyd real f , g , bs , br , ttp complex sctd dimension f ( 2 * nxvh , kypd , kblok ), g ( nyv , kxp2d , jblok ) dimension bs ( kxp2 + 1 , kyp + 1 , kblok ), br ( kxp2 + 1 , kyp + 1 , jblok ) dimension mixup ( nxhyd ), sctd ( nxyd ) c local data integer nx , ny , kxpi , kypi real tf double precision dtime data kxpi , kypi / 1 , 1 / c calculate range of indices nx = 2 ** indx ny = 2 ** indy c inverse fourier transform if ( isign . lt . 0 ) then c perform x sine transform call PFST2RXX ( f , isign , mixup , sctd , indx , indy , kstrt , kyp , kypi , kyp , n 1 xvh , kypd , kblok , nxhyd , nxyd ) c transpose f array to g call PWTIMERA ( - 1 , ttp , dtime ) call PRTPOSE ( f , g , bs , br , nx , ny , kstrt , 2 * nxvh , nyv , kxp2 , kyp , kxp2d , ky 1 pd , jblok , kblok ) call PWTIMERA ( 1 , ttp , dtime ) c perform y sine transform call PFST2RXY ( g , isign , mixup , sctd , indx , indy , kstrt , kxp2 , kxpi , kxp2 1 , nyv , kxp2d , jblok , nxhyd , nxyd ) c transpose g array to f if ( ntpose . eq . 0 ) then call PWTIMERA ( - 1 , tf , dtime ) call PRTPOSE ( g , f , br , bs , ny , nx , kstrt , nyv , 2 * nxvh , kyp , kxp2 , kypd , 1 kxp2d , kblok , jblok ) call PWTIMERA ( 1 , tf , dtime ) endif c forward fourier transform else if ( isign . gt . 0 ) then c transpose f array to g if ( ntpose . eq . 0 ) then call PWTIMERA ( - 1 , tf , dtime ) call PRTPOSE ( f , g , bs , br , nx , ny , kstrt , 2 * nxvh , nyv , kxp2 , kyp , kxp2d 1 , kypd , jblok , kblok ) call PWTIMERA ( 1 , tf , dtime ) endif c perform y sine transform call PFST2RXY ( g , isign , mixup , sctd , indx , indy , kstrt , kxp2 , kxpi , kxp2 1 , nyv , kxp2d , jblok , nxhyd , nxyd ) c transpose g array to f call PWTIMERA ( - 1 , ttp , dtime ) call PRTPOSE ( g , f , br , bs , ny , nx , kstrt , nyv , 2 * nxvh , kyp , kxp2 , kypd , kxp 1 2 d , kblok , jblok ) call PWTIMERA ( 1 , ttp , dtime ) c perform x sine transform call PFST2RXX ( f , isign , mixup , sctd , indx , indy , kstrt , kyp , kypi , kyp , n 1 xvh , kypd , kblok , nxhyd , nxyd ) endif if ( ntpose . eq . 0 ) ttp = ttp + tf return end c----------------------------------------------------------------------- subroutine WPFCCT2R ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp , indx , ind 1 y , kstrt , nxvh , nyv , kxp2 , kyp , kypd , kxp2d , jblok , kblok , nxhyd , nxyd ) c wrapper function for parallel real cosine/cosine transform implicit none integer isign , ntpose , mixup , indx , indy , kstrt , nxvh , nyv integer kxp2 , kyp , kypd , kxp2d , jblok , kblok , nxhyd , nxyd real f , g , bs , br , ttp complex sctd dimension f ( 2 * nxvh , kypd , kblok ), g ( nyv , kxp2d , jblok ) dimension bs ( kxp2 + 1 , kyp + 1 , kblok ), br ( kxp2 + 1 , kyp + 1 , jblok ) dimension mixup ( nxhyd ), sctd ( nxyd ) c local data integer nx , ny , kxpi , kypi real tf double precision dtime data kxpi , kypi / 1 , 1 / c calculate range of indices nx = 2 ** indx ny = 2 ** indy c inverse fourier transform if ( isign . lt . 0 ) then c perform x cosine transform call PFCT2RXX ( f , isign , mixup , sctd , indx , indy , kstrt , kyp , kypi , kyp , n 1 xvh , kypd , kblok , nxhyd , nxyd ) c transpose f array to g call PWTIMERA ( - 1 , ttp , dtime ) call PRTPOSE ( f , g , bs , br , nx , ny , kstrt , 2 * nxvh , nyv , kxp2 , kyp , kxp2d , ky 1 pd , jblok , kblok ) call PWTIMERA ( 1 , ttp , dtime ) c perform y cosine transform call PFCT2RXY ( g , isign , mixup , sctd , indx , indy , kstrt , kxp2 , kxpi , kxp2 1 , nyv , kxp2d , jblok , nxhyd , nxyd ) c transpose g array to f if ( ntpose . eq . 0 ) then call PWTIMERA ( - 1 , tf , dtime ) call PRTPOSE ( g , f , br , bs , ny , nx , kstrt , nyv , 2 * nxvh , kyp , kxp2 , kypd , 1 kxp2d , kblok , jblok ) call PWTIMERA ( 1 , tf , dtime ) endif c forward fourier transform else if ( isign . gt . 0 ) then c transpose f array to g if ( ntpose . eq . 0 ) then call PWTIMERA ( - 1 , tf , dtime ) call PRTPOSE ( f , g , bs , br , nx , ny , kstrt , 2 * nxvh , nyv , kxp2 , kyp , kxp2d 1 , kypd , jblok , kblok ) call PWTIMERA ( 1 , tf , dtime ) endif c perform y cosine transform call PFCT2RXY ( g , isign , mixup , sctd , indx , indy , kstrt , kxp2 , kxpi , kxp2 1 , nyv , kxp2d , jblok , nxhyd , nxyd ) c transpose g array to f call PWTIMERA ( - 1 , ttp , dtime ) call PRTPOSE ( g , f , br , bs , ny , nx , kstrt , nyv , 2 * nxvh , kyp , kxp2 , kypd , kxp 1 2 d , kblok , jblok ) call PWTIMERA ( 1 , ttp , dtime ) c perform x cosine transform call PFCT2RXX ( f , isign , mixup , sctd , indx , indy , kstrt , kyp , kypi , kyp , n 1 xvh , kypd , kblok , nxhyd , nxyd ) endif if ( ntpose . eq . 0 ) ttp = ttp + tf return end c----------------------------------------------------------------------- subroutine PFST2RXX ( f , isign , mixup , sctd , indx , indy , kstrt , kyp , kypi , ky 1 pp , nxvh , kypd , kblok , nxhyd , nxyd ) c this subroutine performs the x part of a two dimensional fast real c sine transform and its inverse, for a subset of y, c using real arithmetic, for data which is distributed in blocks c algorithm is described in Numerical Recipies in Fortran, Second Ed., c by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, c [Cambridge Univ. Press, 1992], p. 508. c for isign = (-1,1), input: all, output: f c approximate flop count: N*(5*log2(N) + 18)/nvp c where N = (nx/2)*ny c indx/indy = exponent which determines length in x/y direction, c where nx=2**indx, ny=2**indy c if isign = -1, an inverse sine transform is performed c f(n,k,i) = (1/nx*ny)*sum(f(j,k,i)*sin(pi*n*j/nx)) c if isign = 1, a forward sine transform is performed c f(j,k,i) = sum(f(n,k,i)*sin(pi*n*j/nx)) c mixup = array of bit reversed addresses c sctd = sine/cosine table c kstrt = starting data block number c kyp = number of data values per block in y c kypi = initial y index used c kypp = number of y indices used c nxvh = first dimension of f >= nx/2 + 1 c kypd = second dimension of f >= kyp + 1 c kblok = number of data blocks in y c nxhyd = maximum of (nx/2,ny) c nxyd = maximum of (nx,ny) c written by viktor k. decyk, ucla implicit none integer isign , mixup , indx , indy , kstrt , kyp , kypi , kypp integer nxvh , kypd , kblok , nxhyd , nxyd real f complex sctd dimension f ( 2 * nxvh , kypd , kblok ) dimension mixup ( nxhyd ), sctd ( nxyd ) c local data integer indx1 , indx1y , nx , nxh , nxhh , nx3 , ny , nxy , nxhy , ks , kypt integer i , j , k , l , m , km , kmr , nrx , j1 , j2 , ns , ns2 , k1 , k2 , kyps real at1 , at2 , t2 , t3 , t4 , t5 , t6 , ani , sum1 complex t1 indx1 = indx - 1 indx1y = max0 ( indx1 , indy ) nx = 2 ** indx nxh = nx / 2 nxhh = nx / 4 nx3 = nx + 3 ny = 2 ** indy nxy = max0 ( nx , ny ) nxhy = 2 ** indx1y ks = kstrt - 2 kyps = kypi + kypp - 1 if ( kstrt . gt . ny ) return if ( isign . eq . 0 ) return c create auxiliary array in x kmr = nxy / nx kypt = kyps do 30 l = 1 , kblok if (( kyps + kyp * ( l + ks )). eq . ny ) kypt = kyps + 1 do 20 k = kypi , kypt do 10 j = 2 , nxh j1 = 1 + kmr * ( j - 1 ) at2 = f ( nx + 2 - j , k , l ) at1 = f ( j , k , l ) + at2 at2 = f ( j , k , l ) - at2 at1 = - aimag ( sctd ( j1 )) * at1 at2 = . 5 * at2 f ( j , k , l ) = at1 + at2 f ( nx + 2 - j , k , l ) = at1 - at2 10 continue f ( 1 , k , l ) = 0.0 f ( nxh + 1 , k , l ) = 2.0 * f ( nxh + 1 , k , l ) 20 continue 30 continue c bit-reverse array elements in x nrx = nxhy / nxh kypt = kyps do 60 l = 1 , kblok if (( kyps + kyp * ( l + ks )). eq . ny ) kypt = kyps + 1 do 50 j = 1 , nxh j1 = ( mixup ( j ) - 1 ) / nrx + 1 if ( j . ge . j1 ) go to 50 do 40 k = kypi , kypt t2 = f ( 2 * j1 - 1 , k , l ) t3 = f ( 2 * j1 , k , l ) f ( 2 * j1 - 1 , k , l ) = f ( 2 * j - 1 , k , l ) f ( 2 * j1 , k , l ) = f ( 2 * j , k , l ) f ( 2 * j - 1 , k , l ) = t2 f ( 2 * j , k , l ) = t3 40 continue 50 continue 60 continue c first transform in x nrx = nxy / nxh do 110 m = 1 , indx1 ns = 2 ** ( m - 1 ) ns2 = ns + ns km = nxhh / ns kmr = 2 * km * nrx kypt = kyps do 100 l = 1 , kblok if (( kyps + kyp * ( l + ks )). eq . ny ) kypt = kyps + 1 do 90 k = 1 , km k1 = ns2 * ( k - 1 ) k2 = k1 + ns do 80 j = 1 , ns j1 = j + k1 j2 = j + k2 t1 = sctd ( 1 + kmr * ( j - 1 )) do 70 i = kypi , kypt t2 = real ( t1 ) * f ( 2 * j2 - 1 , i , l ) - aimag ( t1 ) * f ( 2 * j2 , i , l ) t3 = aimag ( t1 ) * f ( 2 * j2 - 1 , i , l ) + real ( t1 ) * f ( 2 * j2 , i , l ) f ( 2 * j2 - 1 , i , l ) = f ( 2 * j1 - 1 , i , l ) - t2 f ( 2 * j2 , i , l ) = f ( 2 * j1 , i , l ) - t3 f ( 2 * j1 - 1 , i , l ) = f ( 2 * j1 - 1 , i , l ) + t2 f ( 2 * j1 , i , l ) = f ( 2 * j1 , i , l ) + t3 70 continue 80 continue 90 continue 100 continue 110 continue c unscramble coefficients and normalize c inverse fourier transform if ( isign . lt . 0 ) then kmr = nxy / nxh ani = 1. / float ( 2 * nx * ny ) kypt = kyps do 150 l = 1 , kblok if (( kyps + kyp * ( l + ks )). eq . ny ) kypt = kyps + 1 do 130 j = 2 , nxhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( j - 1 ))), - real ( sctd ( 1 + kmr * ( j - 1 )))) do 120 k = kypi , kypt t4 = f ( nx3 - 2 * j , k , l ) t5 = - f ( nx3 - 2 * j + 1 , k , l ) t2 = f ( 2 * j - 1 , k , l ) + t4 t3 = f ( 2 * j , k , l ) + t5 t6 = f ( 2 * j - 1 , k , l ) - t4 t5 = f ( 2 * j , k , l ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) f ( 2 * j - 1 , k , l ) = ani * ( t2 + t4 ) f ( 2 * j , k , l ) = ani * ( t3 + t5 ) f ( nx3 - 2 * j , k , l ) = ani * ( t2 - t4 ) f ( nx3 - 2 * j + 1 , k , l ) = ani * ( t5 - t3 ) 120 continue 130 continue ani = 2. * ani do 140 k = kypi , kypt f ( nxh + 1 , k , l ) = ani * f ( nxh + 1 , k , l ) f ( nxh + 2 , k , l ) = - ani * f ( nxh + 2 , k , l ) t2 = ani * ( f ( 1 , k , l ) + f ( 2 , k , l )) f ( 2 , k , l ) = ani * ( f ( 1 , k , l ) - f ( 2 , k , l )) f ( 1 , k , l ) = t2 f ( nx + 1 , k , l ) = ani * f ( nx + 1 , k , l ) 140 continue 150 continue c forward fourier transform else if ( isign . gt . 0 ) then kmr = nxy / nxh kypt = kyps do 190 l = 1 , kblok if (( kyps + kyp * ( l + ks )). eq . ny ) kypt = kyps + 1 do 170 j = 2 , nxhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( j - 1 ))), - real ( sctd ( 1 + kmr * ( j - 1 )))) do 160 k = kypi , kypt t4 = f ( nx3 - 2 * j , k , l ) t5 = - f ( nx3 - 2 * j + 1 , k , l ) t2 = f ( 2 * j - 1 , k , l ) + t4 t3 = f ( 2 * j , k , l ) + t5 t6 = f ( 2 * j - 1 , k , l ) - t4 t5 = f ( 2 * j , k , l ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) f ( 2 * j - 1 , k , l ) = t2 + t4 f ( 2 * j , k , l ) = t3 + t5 f ( nx3 - 2 * j , k , l ) = t2 - t4 f ( nx3 - 2 * j + 1 , k , l ) = t5 - t3 160 continue 170 continue do 180 k = kypi , kypt f ( nxh + 1 , k , l ) = 2.0 * f ( nxh + 1 , k , l ) f ( nxh + 2 , k , l ) = - 2.0 * f ( nxh + 2 , k , l ) t2 = 2.0 * ( f ( 1 , k , l ) + f ( 2 , k , l )) f ( 2 , k , l ) = 2.0 * ( f ( 1 , k , l ) - f ( 2 , k , l )) f ( 1 , k , l ) = t2 f ( nx + 1 , k , l ) = 2.0 * f ( nx + 1 , k , l ) 180 continue 190 continue endif c perform recursion for sine transform kypt = kyps do 220 l = 1 , kblok if (( kyps + kyp * ( l + ks )). eq . ny ) kypt = kyps + 1 do 210 k = kypi , kypt sum1 = . 5 * f ( 1 , k , l ) f ( 1 , k , l ) = 0.0 f ( 2 , k , l ) = sum1 do 200 j = 2 , nxh sum1 = sum1 + f ( 2 * j - 1 , k , l ) f ( 2 * j - 1 , k , l ) = - f ( 2 * j , k , l ) f ( 2 * j , k , l ) = sum1 200 continue f ( nx + 1 , k , l ) = 0.0 210 continue 220 continue return end c----------------------------------------------------------------------- subroutine PFCT2RXX ( f , isign , mixup , sctd , indx , indy , kstrt , kyp , kypi , ky 1 pp , nxvh , kypd , kblok , nxhyd , nxyd ) c this subroutine performs the x part of a two dimensional fast real c cosine transform and its inverse, for a subset of y, c using real arithmetic, for data which is distributed in blocks c algorithm is described in Numerical Recipies in Fortran, Second Ed., c by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, c [Cambridge Univ. Press, 1992], p. 508. c for isign = (-1,1), input: all, output: f c approximate flop count: N*(5*log2(N) + 18)/nvp c where N = (nx/2)*ny c indx/indy = exponent which determines length in x/y direction, c where nx=2**indx, ny=2**indy c if isign = -1, an inverse cosine transform is performed c f(n,k,i) = (1/nx*ny)*(.5*f(1,k,i) + ((-1)**n)*f(nx+1,k,i) c            + sum(f(j,k,i)*cos(pi*n*j/nx))) c if isign = 1, a forward cosine transform is performed c f(j,k,i) = 2*(.5*f(1,k,i) + ((-1)**j)*f(n+1,k,i) + sum(f(n,k,i)* c            cos(pi*n*j/nx)) c mixup = array of bit reversed addresses c sctd = sine/cosine table c kstrt = starting data block number c kyp = number of data values per block in y c kypi = initial y index used c kypp = number of y indices used c nxvh = first dimension of f >= nx/2 + 1 c kypd = second dimension of f >= kyp+1 c kblok = number of data blocks in y c nxhyd = maximum of (nx/2,ny) c nxyd = maximum of (nx,ny) c written by viktor k. decyk, ucla implicit none integer isign , mixup , indx , indy , kstrt , kyp , kypi , kypp integer nxvh , kypd , kblok , nxhyd , nxyd real f complex sctd dimension f ( 2 * nxvh , kypd , kblok ) dimension mixup ( nxhyd ), sctd ( nxyd ) c local data integer indx1 , indx1y , nx , nxh , nxhh , nx3 , ny , nxy , nxhy , ks , kypt integer i , j , k , l , m , km , kmr , nrx , j1 , j2 , ns , ns2 , k1 , k2 , kyps real at1 , at2 , t2 , t3 , t4 , t5 , t6 , ani , sum1 complex t1 indx1 = indx - 1 indx1y = max0 ( indx1 , indy ) nx = 2 ** indx nxh = nx / 2 nxhh = nx / 4 nx3 = nx + 3 ny = 2 ** indy nxy = max0 ( nx , ny ) nxhy = 2 ** indx1y ks = kstrt - 2 kyps = kypi + kypp - 1 if ( kstrt . gt . ny ) return if ( isign . eq . 0 ) return c create auxiliary array in x kmr = nxy / nx kypt = kyps do 30 l = 1 , kblok if (( kyps + kyp * ( l + ks )). eq . ny ) kypt = kyps + 1 do 20 k = kypi , kypt sum1 = . 5 * ( f ( 1 , k , l ) - f ( nx + 1 , k , l )) do 10 j = 2 , nxh j1 = 1 + kmr * ( j - 1 ) at2 = f ( nx + 2 - j , k , l ) at1 = f ( j , k , l ) + at2 at2 = f ( j , k , l ) - at2 sum1 = sum1 + real ( sctd ( j1 )) * at2 at2 = - aimag ( sctd ( j1 )) * at2 at1 = . 5 * at1 f ( j , k , l ) = at1 - at2 f ( nx + 2 - j , k , l ) = at1 + at2 10 continue f ( 1 , k , l ) = . 5 * ( f ( 1 , k , l ) + f ( nx + 1 , k , l )) f ( nx + 1 , k , l ) = sum1 20 continue 30 continue c bit-reverse array elements in x nrx = nxhy / nxh kypt = kyps do 60 l = 1 , kblok if (( kyps + kyp * ( l + ks )). eq . ny ) kypt = kyps + 1 do 50 j = 1 , nxh j1 = ( mixup ( j ) - 1 ) / nrx + 1 if ( j . ge . j1 ) go to 50 do 40 k = kypi , kypt t2 = f ( 2 * j1 - 1 , k , l ) t3 = f ( 2 * j1 , k , l ) f ( 2 * j1 - 1 , k , l ) = f ( 2 * j - 1 , k , l ) f ( 2 * j1 , k , l ) = f ( 2 * j , k , l ) f ( 2 * j - 1 , k , l ) = t2 f ( 2 * j , k , l ) = t3 40 continue 50 continue 60 continue c first transform in x nrx = nxy / nxh do 110 m = 1 , indx1 ns = 2 ** ( m - 1 ) ns2 = ns + ns km = nxhh / ns kmr = 2 * km * nrx kypt = kyps do 100 l = 1 , kblok if (( kyps + kyp * ( l + ks )). eq . ny ) kypt = kyps + 1 do 90 k = 1 , km k1 = ns2 * ( k - 1 ) k2 = k1 + ns do 80 j = 1 , ns j1 = j + k1 j2 = j + k2 t1 = sctd ( 1 + kmr * ( j - 1 )) do 70 i = kypi , kypt t2 = real ( t1 ) * f ( 2 * j2 - 1 , i , l ) - aimag ( t1 ) * f ( 2 * j2 , i , l ) t3 = aimag ( t1 ) * f ( 2 * j2 - 1 , i , l ) + real ( t1 ) * f ( 2 * j2 , i , l ) f ( 2 * j2 - 1 , i , l ) = f ( 2 * j1 - 1 , i , l ) - t2 f ( 2 * j2 , i , l ) = f ( 2 * j1 , i , l ) - t3 f ( 2 * j1 - 1 , i , l ) = f ( 2 * j1 - 1 , i , l ) + t2 f ( 2 * j1 , i , l ) = f ( 2 * j1 , i , l ) + t3 70 continue 80 continue 90 continue 100 continue 110 continue c unscramble coefficients and normalize c inverse fourier transform if ( isign . lt . 0 ) then kmr = nxy / nxh ani = 1. / float ( 2 * nx * ny ) kypt = kyps do 150 l = 1 , kblok if (( kyps + kyp * ( l + ks )). eq . ny ) kypt = kyps + 1 do 130 j = 2 , nxhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( j - 1 ))), - real ( sctd ( 1 + kmr * ( j - 1 )))) do 120 k = kypi , kypt t4 = f ( nx3 - 2 * j , k , l ) t5 = - f ( nx3 - 2 * j + 1 , k , l ) t2 = f ( 2 * j - 1 , k , l ) + t4 t3 = f ( 2 * j , k , l ) + t5 t6 = f ( 2 * j - 1 , k , l ) - t4 t5 = f ( 2 * j , k , l ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) f ( 2 * j - 1 , k , l ) = ani * ( t2 + t4 ) f ( 2 * j , k , l ) = ani * ( t3 + t5 ) f ( nx3 - 2 * j , k , l ) = ani * ( t2 - t4 ) f ( nx3 - 2 * j + 1 , k , l ) = ani * ( t5 - t3 ) 120 continue 130 continue ani = 2. * ani do 140 k = kypi , kypt f ( nxh + 1 , k , l ) = ani * f ( nxh + 1 , k , l ) f ( nxh + 2 , k , l ) = - ani * f ( nxh + 2 , k , l ) t2 = ani * ( f ( 1 , k , l ) + f ( 2 , k , l )) f ( 2 , k , l ) = ani * ( f ( 1 , k , l ) - f ( 2 , k , l )) f ( 1 , k , l ) = t2 f ( nx + 1 , k , l ) = ani * f ( nx + 1 , k , l ) 140 continue 150 continue c forward fourier transform else if ( isign . gt . 0 ) then kmr = nxy / nxh kypt = kyps do 190 l = 1 , kblok if (( kyps + kyp * ( l + ks )). eq . ny ) kypt = kyps + 1 do 170 j = 2 , nxhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( j - 1 ))), - real ( sctd ( 1 + kmr * ( j - 1 )))) do 160 k = kypi , kypt t4 = f ( nx3 - 2 * j , k , l ) t5 = - f ( nx3 - 2 * j + 1 , k , l ) t2 = f ( 2 * j - 1 , k , l ) + t4 t3 = f ( 2 * j , k , l ) + t5 t6 = f ( 2 * j - 1 , k , l ) - t4 t5 = f ( 2 * j , k , l ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) f ( 2 * j - 1 , k , l ) = t2 + t4 f ( 2 * j , k , l ) = t3 + t5 f ( nx3 - 2 * j , k , l ) = t2 - t4 f ( nx3 - 2 * j + 1 , k , l ) = t5 - t3 160 continue 170 continue do 180 k = kypi , kypt f ( nxh + 1 , k , l ) = 2.0 * f ( nxh + 1 , k , l ) f ( nxh + 2 , k , l ) = - 2.0 * f ( nxh + 2 , k , l ) t2 = 2.0 * ( f ( 1 , k , l ) + f ( 2 , k , l )) f ( 2 , k , l ) = 2.0 * ( f ( 1 , k , l ) - f ( 2 , k , l )) f ( 1 , k , l ) = t2 f ( nx + 1 , k , l ) = 2.0 * f ( nx + 1 , k , l ) 180 continue 190 continue endif c perform recursion for cosine transform kypt = kyps do 220 l = 1 , kblok if (( kyps + kyp * ( l + ks )). eq . ny ) kypt = kyps + 1 do 210 k = kypi , kypt sum1 = f ( nx + 1 , k , l ) f ( nx + 1 , k , l ) = f ( 2 , k , l ) f ( 2 , k , l ) = sum1 do 200 j = 2 , nxh sum1 = sum1 - f ( 2 * j , k , l ) f ( 2 * j , k , l ) = sum1 200 continue 210 continue 220 continue return end c----------------------------------------------------------------------- subroutine PFST2RXY ( g , isign , mixup , sctd , indx , indy , kstrt , kxp , kxpi , kx 1 pp , nyv , kxpd , jblok , nxhyd , nxyd ) c this subroutine performs the y part of a two dimensional fast real c sine transform and its inverse, for a subset of x, c using real arithmetic, for data which is distributed in blocks c algorithm is described in Numerical Recipies in Fortran, Second Ed., c by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, c [Cambridge Univ. Press, 1992], p. 508. c for isign = (-1,1), input: all, output: f c approximate flop count: N*(5*log2(N) + 18)/nvp c where N = (nx/2)*ny c indx/indy = exponent which determines length in x/y direction, c where nx=2**indx, ny=2**indy c if isign = -1, an inverse sine transform is performed c g(m,n,i) = sum(g(k,n,i)*sin(pi*m*k/ny)) c if isign = 1, a forward sine transform is performed c g(k,n,i) = sum(g(m,n,i)*sin(pi*m*k/ny)) c mixup = array of bit reversed addresses c sctd = sine/cosine table c kstrt = starting data block number c kxp = number of data values per block in x c kxpi = initial x index used c kxpp = number of x indices used c nyv = first dimension of g >= ny + 1 c kxpd = second dimension of g >= kxp + 1 c jblok = number of data blocks in x c nxhyd = maximum of (nx/2,ny) c nxyd = maximum of (nx,ny) c written by viktor k. decyk, ucla implicit none integer isign , mixup , indx , indy , kstrt , kxp , kxpi , kxpp integer nyv , kxpd , jblok , nxhyd , nxyd real g complex sctd dimension g ( nyv , kxpd , jblok ) dimension mixup ( nxhyd ), sctd ( nxyd ) c local data integer indx1 , indy1 , indx1y , nx , ny , nyh , nyhh , ny3 , nxy , nxhy integer i , j , k , l , m , ks , km , kmr , nry , j1 , j2 , ns , ns2 , k1 , k2 integer kxps , kxpt real at1 , at2 , t2 , t3 , t4 , t5 , t6 , ani , sum1 complex t1 indx1 = indx - 1 indy1 = indy - 1 indx1y = max0 ( indx1 , indy ) nx = 2 ** indx ny = 2 ** indy nyh = ny / 2 nyhh = ny / 4 ny3 = ny + 3 nxy = max0 ( nx , ny ) nxhy = 2 ** indx1y ks = kstrt - 2 kxps = kxpi + kxpp - 1 if ( kstrt . gt . nx ) return if ( isign . eq . 0 ) return c create auxiliary array in y kmr = nxy / ny kxpt = kxps do 30 l = 1 , jblok if (( kxps + kxp * ( l + ks )). eq . nx ) kxpt = kxps + 1 do 20 j = kxpi , kxpt do 10 k = 2 , nyh k1 = 1 + kmr * ( k - 1 ) at2 = g ( ny + 2 - k , j , l ) at1 = g ( k , j , l ) + at2 at2 = g ( k , j , l ) - at2 at1 = - aimag ( sctd ( k1 )) * at1 at2 = . 5 * at2 g ( k , j , l ) = at1 + at2 g ( ny + 2 - k , j , l ) = at1 - at2 10 continue g ( 1 , j , l ) = 0.0 g ( nyh + 1 , j , l ) = 2.0 * g ( nyh + 1 , j , l ) 20 continue 30 continue c bit-reverse array elements in y nry = nxhy / nyh kxpt = kxps do 60 l = 1 , jblok if (( kxps + kxp * ( l + ks )). eq . nx ) kxpt = kxps + 1 do 50 k = 1 , nyh k1 = ( mixup ( k ) - 1 ) / nry + 1 if ( k . ge . k1 ) go to 50 do 40 j = kxpi , kxpt t2 = g ( 2 * k1 - 1 , j , l ) t3 = g ( 2 * k1 , j , l ) g ( 2 * k1 - 1 , j , l ) = g ( 2 * k - 1 , j , l ) g ( 2 * k1 , j , l ) = g ( 2 * k , j , l ) g ( 2 * k - 1 , j , l ) = t2 g ( 2 * k , j , l ) = t3 40 continue 50 continue 60 continue c first transform in y nry = nxy / nyh do 110 m = 1 , indy1 ns = 2 ** ( m - 1 ) ns2 = ns + ns km = nyhh / ns kmr = 2 * km * nry kxpt = kxps do 100 l = 1 , jblok if (( kxps + kxp * ( l + ks )). eq . nx ) kxpt = kxps + 1 do 90 k = 1 , km k1 = ns2 * ( k - 1 ) k2 = k1 + ns do 80 j = 1 , ns j1 = j + k1 j2 = j + k2 t1 = sctd ( 1 + kmr * ( j - 1 )) do 70 i = kxpi , kxpt t2 = real ( t1 ) * g ( 2 * j2 - 1 , i , l ) - aimag ( t1 ) * g ( 2 * j2 , i , l ) t3 = aimag ( t1 ) * g ( 2 * j2 - 1 , i , l ) + real ( t1 ) * g ( 2 * j2 , i , l ) g ( 2 * j2 - 1 , i , l ) = g ( 2 * j1 - 1 , i , l ) - t2 g ( 2 * j2 , i , l ) = g ( 2 * j1 , i , l ) - t3 g ( 2 * j1 - 1 , i , l ) = g ( 2 * j1 - 1 , i , l ) + t2 g ( 2 * j1 , i , l ) = g ( 2 * j1 , i , l ) + t3 70 continue 80 continue 90 continue 100 continue 110 continue c unscramble coefficients and normalize c inverse fourier transform if ( isign . lt . 0 ) then kmr = nxy / nyh ani = 0.5 kxpt = kxps do 150 l = 1 , jblok if (( kxps + kxp * ( l + ks )). eq . nx ) kxpt = kxps + 1 do 130 k = 2 , nyhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( k - 1 ))), - real ( sctd ( 1 + kmr * ( k - 1 )))) do 120 j = kxpi , kxpt t4 = g ( ny3 - 2 * k , j , l ) t5 = - g ( ny3 - 2 * k + 1 , j , l ) t2 = g ( 2 * k - 1 , j , l ) + t4 t3 = g ( 2 * k , j , l ) + t5 t6 = g ( 2 * k - 1 , j , l ) - t4 t5 = g ( 2 * k , j , l ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) g ( 2 * k - 1 , j , l ) = ani * ( t2 + t4 ) g ( 2 * k , j , l ) = ani * ( t3 + t5 ) g ( ny3 - 2 * k , j , l ) = ani * ( t2 - t4 ) g ( ny3 - 2 * k + 1 , j , l ) = ani * ( t5 - t3 ) 120 continue 130 continue do 140 j = kxpi , kxpt g ( nyh + 1 , j , l ) = g ( nyh + 1 , j , l ) g ( nyh + 2 , j , l ) = - g ( nyh + 2 , j , l ) t2 = g ( 1 , j , l ) + g ( 2 , j , l ) g ( 2 , j , l ) = g ( 1 , j , l ) - g ( 2 , j , l ) g ( 1 , j , l ) = t2 g ( ny + 1 , j , l ) = g ( ny + 1 , j , l ) 140 continue 150 continue c forward fourier transform else if ( isign . gt . 0 ) then kmr = nxy / nyh kxpt = kxps do 190 l = 1 , jblok if (( kxps + kxp * ( l + ks )). eq . nx ) kxpt = kxps + 1 do 170 k = 2 , nyhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( k - 1 ))), - real ( sctd ( 1 + kmr * ( k - 1 )))) do 160 j = kxpi , kxpt t4 = g ( ny3 - 2 * k , j , l ) t5 = - g ( ny3 - 2 * k + 1 , j , l ) t2 = g ( 2 * k - 1 , j , l ) + t4 t3 = g ( 2 * k , j , l ) + t5 t6 = g ( 2 * k - 1 , j , l ) - t4 t5 = g ( 2 * k , j , l ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) g ( 2 * k - 1 , j , l ) = t2 + t4 g ( 2 * k , j , l ) = t3 + t5 g ( ny3 - 2 * k , j , l ) = t2 - t4 g ( ny3 - 2 * k + 1 , j , l ) = t5 - t3 160 continue 170 continue do 180 j = kxpi , kxpt g ( nyh + 1 , j , l ) = 2.0 * g ( nyh + 1 , j , l ) g ( nyh + 2 , j , l ) = - 2.0 * g ( nyh + 2 , j , l ) t2 = 2.0 * ( g ( 1 , j , l ) + g ( 2 , j , l )) g ( 2 , j , l ) = 2.0 * ( g ( 1 , j , l ) - g ( 2 , j , l )) g ( 1 , j , l ) = t2 g ( ny + 1 , j , l ) = 2.0 * g ( ny + 1 , j , l ) 180 continue 190 continue endif c perform recursion for sine transform kxpt = kxps do 220 l = 1 , jblok if (( kxps + kxp * ( l + ks )). eq . nx ) kxpt = kxps + 1 do 210 j = kxpi , kxpt sum1 = . 5 * g ( 1 , j , l ) g ( 1 , j , l ) = 0.0 g ( 2 , j , l ) = sum1 do 200 k = 2 , nyh sum1 = sum1 + g ( 2 * k - 1 , j , l ) g ( 2 * k - 1 , j , l ) = - g ( 2 * k , j , l ) g ( 2 * k , j , l ) = sum1 200 continue g ( ny + 1 , j , l ) = 0.0 210 continue 220 continue return end c----------------------------------------------------------------------- subroutine PFCT2RXY ( g , isign , mixup , sctd , indx , indy , kstrt , kxp , kxpi , kx 1 pp , nyv , kxpd , jblok , nxhyd , nxyd ) c this subroutine performs the y part of a two dimensional fast real c cosine transform and its inverse, for a subset of x, c using real arithmetic, for data which is distributed in blocks c algorithm is described in Numerical Recipies in Fortran, Second Ed., c by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, c [Cambridge Univ. Press, 1992], p. 508. c for isign = (-1,1), input: all, output: f c approximate flop count: N*(5*log2(N) + 18)/nvp c where N = (nx/2)*ny c indx/indy = exponent which determines length in x/y direction, c where nx=2**indx, ny=2**indy c if isign = -1, an inverse cosine transform is performed c g(m,n,i) = (.5*g(1,n,i) + ((-1)**m)*g(ny+1,n,i) c            + sum(g(k,n,i)*cos(pi*m*k/ny)) c if isign = 1, a forward cosine transform is performed c g(k,n,i) = 2*(.5*g(1,n,i) + ((-1)**m)*g(ny+1,n,i) + sum(g(m,n,i)* c            cos(pi*m*k/ny)) c mixup = array of bit reversed addresses c sctd = sine/cosine table c kstrt = starting data block number c kxp = number of data values per block in x c kxpi = initial x index used c kxpp = number of x indices used c nyv = first dimension of g >= ny + 1 c kxpd = second dimension of g >= kxp + 1 c jblok = number of data blocks in x c nxhyd = maximum of (nx/2,ny) c nxyd = maximum of (nx,ny) c written by viktor k. decyk, ucla implicit none integer isign , mixup , indx , indy , kstrt , kxp , kxpi , kxpp integer nyv , kxpd , jblok , nxhyd , nxyd real g complex sctd dimension g ( nyv , kxpd , jblok ) dimension mixup ( nxhyd ), sctd ( nxyd ) c local data integer indx1 , indy1 , indx1y , nx , ny , nyh , nyhh , ny3 , nxy , nxhy integer i , j , k , l , m , ks , km , kmr , nry , j1 , j2 , ns , ns2 , k1 , k2 integer kxps , kxpt real at1 , at2 , t2 , t3 , t4 , t5 , t6 , ani , sum1 complex t1 indx1 = indx - 1 indy1 = indy - 1 indx1y = max0 ( indx1 , indy ) nx = 2 ** indx ny = 2 ** indy nyh = ny / 2 nyhh = ny / 4 ny3 = ny + 3 nxy = max0 ( nx , ny ) nxhy = 2 ** indx1y ks = kstrt - 2 kxps = kxpi + kxpp - 1 if ( kstrt . gt . nx ) return if ( isign . eq . 0 ) return c create auxiliary array in y kmr = nxy / ny kxpt = kxps do 30 l = 1 , jblok if (( kxps + kxp * ( l + ks )). eq . nx ) kxpt = kxps + 1 do 20 j = kxpi , kxpt sum1 = . 5 * ( g ( 1 , j , l ) - g ( ny + 1 , j , l )) do 10 k = 2 , nyh k1 = 1 + kmr * ( k - 1 ) at2 = g ( ny + 2 - k , j , l ) at1 = g ( k , j , l ) + at2 at2 = g ( k , j , l ) - at2 sum1 = sum1 + real ( sctd ( k1 )) * at2 at2 = - aimag ( sctd ( k1 )) * at2 at1 = . 5 * at1 g ( k , j , l ) = at1 - at2 g ( ny + 2 - k , j , l ) = at1 + at2 10 continue g ( 1 , j , l ) = . 5 * ( g ( 1 , j , l ) + g ( ny + 1 , j , l )) g ( ny + 1 , j , l ) = sum1 20 continue 30 continue c bit-reverse array elements in y nry = nxhy / nyh kxpt = kxps do 60 l = 1 , jblok if (( kxps + kxp * ( l + ks )). eq . nx ) kxpt = kxps + 1 do 50 k = 1 , nyh k1 = ( mixup ( k ) - 1 ) / nry + 1 if ( k . ge . k1 ) go to 50 do 40 j = kxpi , kxpt t2 = g ( 2 * k1 - 1 , j , l ) t3 = g ( 2 * k1 , j , l ) g ( 2 * k1 - 1 , j , l ) = g ( 2 * k - 1 , j , l ) g ( 2 * k1 , j , l ) = g ( 2 * k , j , l ) g ( 2 * k - 1 , j , l ) = t2 g ( 2 * k , j , l ) = t3 40 continue 50 continue 60 continue c first transform in y nry = nxy / nyh do 110 m = 1 , indy1 ns = 2 ** ( m - 1 ) ns2 = ns + ns km = nyhh / ns kmr = 2 * km * nry kxpt = kxps do 100 l = 1 , jblok if (( kxps + kxp * ( l + ks )). eq . nx ) kxpt = kxps + 1 do 90 k = 1 , km k1 = ns2 * ( k - 1 ) k2 = k1 + ns do 80 j = 1 , ns j1 = j + k1 j2 = j + k2 t1 = sctd ( 1 + kmr * ( j - 1 )) do 70 i = kxpi , kxpt t2 = real ( t1 ) * g ( 2 * j2 - 1 , i , l ) - aimag ( t1 ) * g ( 2 * j2 , i , l ) t3 = aimag ( t1 ) * g ( 2 * j2 - 1 , i , l ) + real ( t1 ) * g ( 2 * j2 , i , l ) g ( 2 * j2 - 1 , i , l ) = g ( 2 * j1 - 1 , i , l ) - t2 g ( 2 * j2 , i , l ) = g ( 2 * j1 , i , l ) - t3 g ( 2 * j1 - 1 , i , l ) = g ( 2 * j1 - 1 , i , l ) + t2 g ( 2 * j1 , i , l ) = g ( 2 * j1 , i , l ) + t3 70 continue 80 continue 90 continue 100 continue 110 continue c unscramble coefficients and normalize c inverse fourier transform if ( isign . lt . 0 ) then kmr = nxy / nyh ani = 0.5 kxpt = kxps do 150 l = 1 , jblok if (( kxps + kxp * ( l + ks )). eq . nx ) kxpt = kxps + 1 do 130 k = 2 , nyhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( k - 1 ))), - real ( sctd ( 1 + kmr * ( k - 1 )))) do 120 j = kxpi , kxpt t4 = g ( ny3 - 2 * k , j , l ) t5 = - g ( ny3 - 2 * k + 1 , j , l ) t2 = g ( 2 * k - 1 , j , l ) + t4 t3 = g ( 2 * k , j , l ) + t5 t6 = g ( 2 * k - 1 , j , l ) - t4 t5 = g ( 2 * k , j , l ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) g ( 2 * k - 1 , j , l ) = ani * ( t2 + t4 ) g ( 2 * k , j , l ) = ani * ( t3 + t5 ) g ( ny3 - 2 * k , j , l ) = ani * ( t2 - t4 ) g ( ny3 - 2 * k + 1 , j , l ) = ani * ( t5 - t3 ) 120 continue 130 continue do 140 j = kxpi , kxpt g ( nyh + 1 , j , l ) = g ( nyh + 1 , j , l ) g ( nyh + 2 , j , l ) = - g ( nyh + 2 , j , l ) t2 = g ( 1 , j , l ) + g ( 2 , j , l ) g ( 2 , j , l ) = g ( 1 , j , l ) - g ( 2 , j , l ) g ( 1 , j , l ) = t2 g ( ny + 1 , j , l ) = g ( ny + 1 , j , l ) 140 continue 150 continue c forward fourier transform else if ( isign . gt . 0 ) then kmr = nxy / nyh kxpt = kxps do 190 l = 1 , jblok if (( kxps + kxp * ( l + ks )). eq . nx ) kxpt = kxps + 1 do 170 k = 2 , nyhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( k - 1 ))), - real ( sctd ( 1 + kmr * ( k - 1 )))) do 160 j = kxpi , kxpt t4 = g ( ny3 - 2 * k , j , l ) t5 = - g ( ny3 - 2 * k + 1 , j , l ) t2 = g ( 2 * k - 1 , j , l ) + t4 t3 = g ( 2 * k , j , l ) + t5 t6 = g ( 2 * k - 1 , j , l ) - t4 t5 = g ( 2 * k , j , l ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) g ( 2 * k - 1 , j , l ) = t2 + t4 g ( 2 * k , j , l ) = t3 + t5 g ( ny3 - 2 * k , j , l ) = t2 - t4 g ( ny3 - 2 * k + 1 , j , l ) = t5 - t3 160 continue 170 continue do 180 j = kxpi , kxpt g ( nyh + 1 , j , l ) = 2.0 * g ( nyh + 1 , j , l ) g ( nyh + 2 , j , l ) = - 2.0 * g ( nyh + 2 , j , l ) t2 = 2.0 * ( g ( 1 , j , l ) + g ( 2 , j , l )) g ( 2 , j , l ) = 2.0 * ( g ( 1 , j , l ) - g ( 2 , j , l )) g ( 1 , j , l ) = t2 g ( ny + 1 , j , l ) = 2.0 * g ( ny + 1 , j , l ) 180 continue 190 continue endif c perform recursion for cosine transform kxpt = kxps do 220 l = 1 , jblok if (( kxps + kxp * ( l + ks )). eq . nx ) kxpt = kxps + 1 do 210 j = kxpi , kxpt sum1 = g ( ny + 1 , j , l ) g ( ny + 1 , j , l ) = g ( 2 , j , l ) g ( 2 , j , l ) = sum1 do 200 k = 2 , nyh sum1 = sum1 - g ( 2 * k , j , l ) g ( 2 * k , j , l ) = sum1 200 continue 210 continue 220 continue return end c----------------------------------------------------------------------- subroutine WPFCST2R2 ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp , indx , in 1 dy , kstrt , nxvh , nyv , kxp2 , kyp , kypd , kxp2d , jblok , kblok , nxhyd , nxyd ) c wrapper function for 2 parallel real sine/sine transforms c for the electric field with dirichlet or magnetic field with neumann c boundary conditions implicit none integer isign , ntpose , mixup , indx , indy , kstrt , nxvh , nyv integer kxp2 , kyp , kypd , kxp2d , jblok , kblok , nxhyd , nxyd real f , g , bs , br , ttp complex sctd dimension f ( 2 , 2 * nxvh , kypd , kblok ), g ( 2 , nyv , kxp2d , jblok ) dimension bs ( 2 , kxp2 + 1 , kyp + 1 , kblok ), br ( 2 , kxp2 + 1 , kyp + 1 , jblok ) dimension mixup ( nxhyd ), sctd ( nxyd ) c local data integer nx , ny , kxpi , kypi real tf double precision dtime data kxpi , kypi / 1 , 1 / c calculate range of indices nx = 2 ** indx ny = 2 ** indy c inverse fourier transform if ( isign . lt . 0 ) then c perform x cosine-sine transform call PFCST2R2X ( f , isign , mixup , sctd , indx , indy , kstrt , kyp , kypi , kyp , 1 nxvh , kypd , kblok , nxhyd , nxyd ) c transpose f array to g call PWTIMERA ( - 1 , ttp , dtime ) call PR2TPOSE ( f , g , bs , br , nx , ny , kstrt , 2 * nxvh , nyv , kxp2 , kyp , kxp2d , k 1 ypd , jblok , kblok ) call PWTIMERA ( 1 , ttp , dtime ) c perform y sine-cosine transform call PFSCT2R2Y ( g , isign , mixup , sctd , indx , indy , kstrt , kxp2 , kxpi , kxp 1 2 , nyv , kxp2d , jblok , nxhyd , nxyd ) c transpose g array to f if ( ntpose . eq . 0 ) then call PWTIMERA ( - 1 , tf , dtime ) call PR2TPOSE ( g , f , br , bs , ny , nx , kstrt , nyv , 2 * nxvh , kyp , kxp2 , kypd 1 , kxp2d , kblok , jblok ) call PWTIMERA ( 1 , tf , dtime ) endif c forward fourier transform else if ( isign . gt . 0 ) then c transpose f array to g if ( ntpose . eq . 0 ) then call PWTIMERA ( - 1 , tf , dtime ) call PR2TPOSE ( f , g , bs , br , nx , ny , kstrt , 2 * nxvh , nyv , kxp2 , kyp , kxp2 1 d , kypd , jblok , kblok ) call PWTIMERA ( 1 , tf , dtime ) endif c perform y sine-cosine transform call PFSCT2R2Y ( g , isign , mixup , sctd , indx , indy , kstrt , kxp2 , kxpi , kxp 1 2 , nyv , kxp2d , jblok , nxhyd , nxyd ) c transpose g array to f call PWTIMERA ( - 1 , ttp , dtime ) call PR2TPOSE ( g , f , br , bs , ny , nx , kstrt , nyv , 2 * nxvh , kyp , kxp2 , kypd , kx 1 p2d , kblok , jblok ) call PWTIMERA ( 1 , ttp , dtime ) c perform x cosine-sine transform call PFCST2R2X ( f , isign , mixup , sctd , indx , indy , kstrt , kyp , kypi , kyp , 1 nxvh , kypd , kblok , nxhyd , nxyd ) endif if ( ntpose . eq . 0 ) ttp = ttp + tf return end c----------------------------------------------------------------------- subroutine WPFSCT2R2 ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp , indx , in 1 dy , kstrt , nxvh , nyv , kxp2 , kyp , kypd , kxp2d , jblok , kblok , nxhyd , nxyd ) c wrapper function for 2 parallel real sine/sine transforms c for the magnetic field with dirichlet or electric field with neumann c boundary conditions implicit none integer isign , ntpose , mixup , indx , indy , kstrt , nxvh , nyv integer kxp2 , kyp , kypd , kxp2d , jblok , kblok , nxhyd , nxyd real f , g , bs , br , ttp complex sctd dimension f ( 2 , 2 * nxvh , kypd , kblok ), g ( 2 , nyv , kxp2d , jblok ) dimension bs ( 2 , kxp2 + 1 , kyp + 1 , kblok ), br ( 2 , kxp2 + 1 , kyp + 1 , jblok ) dimension mixup ( nxhyd ), sctd ( nxyd ) c local data integer nx , ny , kxpi , kypi real tf double precision dtime data kxpi , kypi / 1 , 1 / c calculate range of indices nx = 2 ** indx ny = 2 ** indy c inverse fourier transform if ( isign . lt . 0 ) then c perform x sine-cosine transform call PFSCT2R2X ( f , isign , mixup , sctd , indx , indy , kstrt , kyp , kypi , kyp , 1 nxvh , kypd , kblok , nxhyd , nxyd ) c transpose f array to g call PWTIMERA ( - 1 , ttp , dtime ) call PR2TPOSE ( f , g , bs , br , nx , ny , kstrt , 2 * nxvh , nyv , kxp2 , kyp , kxp2d , k 1 ypd , jblok , kblok ) call PWTIMERA ( 1 , ttp , dtime ) c perform y cosine-sine transform call PFCST2R2Y ( g , isign , mixup , sctd , indx , indy , kstrt , kxp2 , kxpi , kxp 1 2 , nyv , kxp2d , jblok , nxhyd , nxyd ) c transpose g array to f if ( ntpose . eq . 0 ) then call PWTIMERA ( - 1 , tf , dtime ) call PR2TPOSE ( g , f , br , bs , ny , nx , kstrt , nyv , 2 * nxvh , kyp , kxp2 , kypd 1 , kxp2d , kblok , jblok ) call PWTIMERA ( 1 , tf , dtime ) endif c forward fourier transform else if ( isign . gt . 0 ) then c transpose f array to g if ( ntpose . eq . 0 ) then call PWTIMERA ( - 1 , tf , dtime ) call PR2TPOSE ( f , g , bs , br , nx , ny , kstrt , 2 * nxvh , nyv , kxp2 , kyp , kxp2 1 d , kypd , jblok , kblok ) call PWTIMERA ( 1 , tf , dtime ) endif c perform y cosine-sine transform call PFCST2R2Y ( g , isign , mixup , sctd , indx , indy , kstrt , kxp2 , kxpi , kxp 1 2 , nyv , kxp2d , jblok , nxhyd , nxyd ) c transpose g array to f call PWTIMERA ( - 1 , ttp , dtime ) call PR2TPOSE ( g , f , br , bs , ny , nx , kstrt , nyv , 2 * nxvh , kyp , kxp2 , kypd , kx 1 p2d , kblok , jblok ) call PWTIMERA ( 1 , ttp , dtime ) c perform x sine-cosine transform call PFSCT2R2X ( f , isign , mixup , sctd , indx , indy , kstrt , kyp , kypi , kyp , 1 nxvh , kypd , kblok , nxhyd , nxyd ) endif if ( ntpose . eq . 0 ) ttp = ttp + tf return end c----------------------------------------------------------------------- subroutine PFCST2R2X ( f , isign , mixup , sctd , indx , indy , kstrt , kyp , kypi , k 1 ypp , nxvh , kypd , kblok , nxhyd , nxyd ) c this subroutine performs the x part of 2 two dimensional fast real c sine and cosine transforms and their inverses, for a subset of y, c using real arithmetic, for data which is distributed in blocks c algorithm is described in Numerical Recipies in Fortran, Second Ed., c by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, c [Cambridge Univ. Press, 1992], p. 508. c for isign = (-1,1), input: all, output: f c approximate flop count: N*(5*log2(N) + 18)/nvp c where N = (nx/2)*ny c indx/indy = exponent which determines length in x/y direction, c where nx=2**indx, ny=2**indy c if isign = -1, inverse sine-cosine transforms are performed c f(1,n,k,i) = (1/nx*ny)*(.5*f(1,1,k,i) + ((-1)**n)*f(1,nx+1,k,i) c              + sum(f(1,j,k,i)*cos(pi*n*j/nx))) c f(2,n,k,i) = (1/nx*ny)*sum(f(2,j,k,i)*sin(pi*n*j/nx)) c if isign = 1, forward sine transforms are performed c f(1,j,k,i) = 2*(.5*f(1,1,k,i) + ((-1)**j)*f(1,n+1,k,i) c              + sum(f(1,n,k,i)*cos(pi*n*j/nx)) c f(2,j,k,i) = sum(f(2,n,k,i)*sin(pi*n*j/nx)) c mixup = array of bit reversed addresses c sctd = sine/cosine table c kstrt = starting data block number c kyp = number of data values per block in y c kypi = initial y index used c kypp = number of y indices used c nxvh = first dimension of f >= nx/2 + 1 c kypd = second dimension of f >= kyp + 1 c kblok = number of data blocks in y c nxhyd = maximum of (nx/2,ny) c nxyd = maximum of (nx,ny) c written by viktor k. decyk, ucla implicit none integer isign , mixup , indx , indy , kstrt , kyp , kypi , kypp integer nxvh , kypd , kblok , nxhyd , nxyd real f complex sctd dimension f ( 2 , 2 * nxvh , kypd , kblok ) dimension mixup ( nxhyd ), sctd ( nxyd ) c local data integer indx1 , indx1y , nx , nxh , nxhh , nx3 , ny , nxy , nxhy , ks , kypt integer i , j , k , l , m , km , kmr , nrx , j1 , j2 , ns , ns2 , k1 , k2 , kyps integer jj real at1 , at2 , at3 , t2 , t3 , t4 , t5 , t6 , ani , sum1 , sum2 complex t1 indx1 = indx - 1 indx1y = max0 ( indx1 , indy ) nx = 2 ** indx nxh = nx / 2 nxhh = nx / 4 nx3 = nx + 3 ny = 2 ** indy nxy = max0 ( nx , ny ) nxhy = 2 ** indx1y ks = kstrt - 2 kyps = kypi + kypp - 1 if ( kstrt . gt . ny ) return if ( isign . eq . 0 ) return c create auxiliary array in x kmr = nxy / nx kypt = kyps do 30 l = 1 , kblok if (( kyps + kyp * ( l + ks )). eq . ny ) kypt = kyps + 1 do 20 k = kypi , kypt sum1 = . 5 * ( f ( 1 , 1 , k , l ) - f ( 1 , nx + 1 , k , l )) do 10 j = 2 , nxh j1 = 1 + kmr * ( j - 1 ) at3 = - aimag ( sctd ( j1 )) at2 = f ( 1 , nx + 2 - j , k , l ) at1 = f ( 1 , j , k , l ) + at2 at2 = f ( 1 , j , k , l ) - at2 sum1 = sum1 + real ( sctd ( j1 )) * at2 at2 = at3 * at2 at1 = . 5 * at1 f ( 1 , j , k , l ) = at1 - at2 f ( 1 , nx + 2 - j , k , l ) = at1 + at2 at2 = f ( 2 , nx + 2 - j , k , l ) at1 = f ( 2 , j , k , l ) + at2 at2 = f ( 2 , j , k , l ) - at2 at1 = at3 * at1 at2 = . 5 * at2 f ( 2 , j , k , l ) = at1 + at2 f ( 2 , nx + 2 - j , k , l ) = at1 - at2 10 continue f ( 1 , 1 , k , l ) = . 5 * ( f ( 1 , 1 , k , l ) + f ( 1 , nx + 1 , k , l )) f ( 1 , nx + 1 , k , l ) = sum1 f ( 2 , 1 , k , l ) = 0.0 f ( 2 , nxh + 1 , k , l ) = 2.0 * f ( 2 , nxh + 1 , k , l ) 20 continue 30 continue c bit-reverse array elements in x nrx = nxhy / nxh kypt = kyps do 70 l = 1 , kblok if (( kyps + kyp * ( l + ks )). eq . ny ) kypt = kyps + 1 do 60 j = 1 , nxh j1 = ( mixup ( j ) - 1 ) / nrx + 1 if ( j . ge . j1 ) go to 60 do 50 k = kypi , kypt do 40 jj = 1 , 2 t2 = f ( jj , 2 * j1 - 1 , k , l ) t3 = f ( jj , 2 * j1 , k , l ) f ( jj , 2 * j1 - 1 , k , l ) = f ( jj , 2 * j - 1 , k , l ) f ( jj , 2 * j1 , k , l ) = f ( jj , 2 * j , k , l ) f ( jj , 2 * j - 1 , k , l ) = t2 f ( jj , 2 * j , k , l ) = t3 40 continue 50 continue 60 continue 70 continue c first transform in x nrx = nxy / nxh do 130 m = 1 , indx1 ns = 2 ** ( m - 1 ) ns2 = ns + ns km = nxhh / ns kmr = 2 * km * nrx kypt = kyps do 120 l = 1 , kblok if (( kyps + kyp * ( l + ks )). eq . ny ) kypt = kyps + 1 do 110 k = 1 , km k1 = ns2 * ( k - 1 ) k2 = k1 + ns do 100 j = 1 , ns j1 = j + k1 j2 = j + k2 t1 = sctd ( 1 + kmr * ( j - 1 )) do 90 i = kypi , kypt do 80 jj = 1 , 2 t2 = real ( t1 ) * f ( jj , 2 * j2 - 1 , i , l ) - aimag ( t1 ) * f ( jj , 2 * j2 , i , l ) t3 = aimag ( t1 ) * f ( jj , 2 * j2 - 1 , i , l ) + real ( t1 ) * f ( jj , 2 * j2 , i , l ) f ( jj , 2 * j2 - 1 , i , l ) = f ( jj , 2 * j1 - 1 , i , l ) - t2 f ( jj , 2 * j2 , i , l ) = f ( jj , 2 * j1 , i , l ) - t3 f ( jj , 2 * j1 - 1 , i , l ) = f ( jj , 2 * j1 - 1 , i , l ) + t2 f ( jj , 2 * j1 , i , l ) = f ( jj , 2 * j1 , i , l ) + t3 80 continue 90 continue 100 continue 110 continue 120 continue 130 continue c unscramble coefficients and normalize c inverse fourier transform if ( isign . lt . 0 ) then kmr = nxy / nxh ani = 1. / float ( 2 * nx * ny ) kypt = kyps do 190 l = 1 , kblok if (( kyps + kyp * ( l + ks )). eq . ny ) kypt = kyps + 1 do 160 j = 2 , nxhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( j - 1 ))), - real ( sctd ( 1 + kmr * ( j - 1 )))) do 150 k = kypi , kypt do 140 jj = 1 , 2 t4 = f ( jj , nx3 - 2 * j , k , l ) t5 = - f ( jj , nx3 - 2 * j + 1 , k , l ) t2 = f ( jj , 2 * j - 1 , k , l ) + t4 t3 = f ( jj , 2 * j , k , l ) + t5 t6 = f ( jj , 2 * j - 1 , k , l ) - t4 t5 = f ( jj , 2 * j , k , l ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) f ( jj , 2 * j - 1 , k , l ) = ani * ( t2 + t4 ) f ( jj , 2 * j , k , l ) = ani * ( t3 + t5 ) f ( jj , nx3 - 2 * j , k , l ) = ani * ( t2 - t4 ) f ( jj , nx3 - 2 * j + 1 , k , l ) = ani * ( t5 - t3 ) 140 continue 150 continue 160 continue ani = 2. * ani do 180 k = kypi , kypt do 170 jj = 1 , 2 f ( jj , nxh + 1 , k , l ) = ani * f ( jj , nxh + 1 , k , l ) f ( jj , nxh + 2 , k , l ) = - ani * f ( jj , nxh + 2 , k , l ) t2 = ani * ( f ( jj , 1 , k , l ) + f ( jj , 2 , k , l )) f ( jj , 2 , k , l ) = ani * ( f ( jj , 1 , k , l ) - f ( jj , 2 , k , l )) f ( jj , 1 , k , l ) = t2 f ( jj , nx + 1 , k , l ) = ani * f ( jj , nx + 1 , k , l ) 170 continue 180 continue 190 continue c forward fourier transform else if ( isign . gt . 0 ) then kmr = nxy / nxh kypt = kyps do 250 l = 1 , kblok if (( kyps + kyp * ( l + ks )). eq . ny ) kypt = kyps + 1 do 220 j = 2 , nxhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( j - 1 ))), - real ( sctd ( 1 + kmr * ( j - 1 )))) do 210 k = kypi , kypt do 200 jj = 1 , 2 t4 = f ( jj , nx3 - 2 * j , k , l ) t5 = - f ( jj , nx3 - 2 * j + 1 , k , l ) t2 = f ( jj , 2 * j - 1 , k , l ) + t4 t3 = f ( jj , 2 * j , k , l ) + t5 t6 = f ( jj , 2 * j - 1 , k , l ) - t4 t5 = f ( jj , 2 * j , k , l ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) f ( jj , 2 * j - 1 , k , l ) = t2 + t4 f ( jj , 2 * j , k , l ) = t3 + t5 f ( jj , nx3 - 2 * j , k , l ) = t2 - t4 f ( jj , nx3 - 2 * j + 1 , k , l ) = t5 - t3 200 continue 210 continue 220 continue do 240 k = kypi , kypt do 230 jj = 1 , 2 f ( jj , nxh + 1 , k , l ) = 2.0 * f ( jj , nxh + 1 , k , l ) f ( jj , nxh + 2 , k , l ) = - 2.0 * f ( jj , nxh + 2 , k , l ) t2 = 2.0 * ( f ( jj , 1 , k , l ) + f ( jj , 2 , k , l )) f ( jj , 2 , k , l ) = 2.0 * ( f ( jj , 1 , k , l ) - f ( jj , 2 , k , l )) f ( jj , 1 , k , l ) = t2 f ( jj , nx + 1 , k , l ) = 2.0 * f ( jj , nx + 1 , k , l ) 230 continue 240 continue 250 continue endif c perform recursion for cosine-sine transform kypt = kyps do 280 l = 1 , kblok if (( kyps + kyp * ( l + ks )). eq . ny ) kypt = kyps + 1 do 270 k = kypi , kypt sum1 = f ( 1 , nx + 1 , k , l ) f ( 1 , nx + 1 , k , l ) = f ( 1 , 2 , k , l ) f ( 1 , 2 , k , l ) = sum1 sum2 = . 5 * f ( 2 , 1 , k , l ) f ( 2 , 1 , k , l ) = 0.0 f ( 2 , 2 , k , l ) = sum2 do 260 j = 2 , nxh sum1 = sum1 - f ( 1 , 2 * j , k , l ) f ( 1 , 2 * j , k , l ) = sum1 sum2 = sum2 + f ( 2 , 2 * j - 1 , k , l ) f ( 2 , 2 * j - 1 , k , l ) = - f ( 2 , 2 * j , k , l ) f ( 2 , 2 * j , k , l ) = sum2 260 continue f ( 2 , nx + 1 , k , l ) = 0.0 270 continue 280 continue return end c----------------------------------------------------------------------- subroutine PFSCT2R2X ( f , isign , mixup , sctd , indx , indy , kstrt , kyp , kypi , k 1 ypp , nxvh , kypd , kblok , nxhyd , nxyd ) c this subroutine performs the x part of 2 two dimensional fast real c sine and cosine transforms and their inverses, for a subset of y, c using real arithmetic, for data which is distributed in blocks c algorithm is described in Numerical Recipies in Fortran, Second Ed., c by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, c [Cambridge Univ. Press, 1992], p. 508. c for isign = (-1,1), input: all, output: f c approximate flop count: N*(5*log2(N) + 18)/nvp c where N = (nx/2)*ny c indx/indy = exponent which determines length in x/y direction, c where nx=2**indx, ny=2**indy c if isign = -1, inverse sine-cosine transforms are performed c f(1,n,k,i) = (1/nx*ny)*sum(f(1,j,k,i)*sin(pi*n*j/nx)) c f(2,n,k,i) = (1/nx*ny)*(.5*f(2,1,k,i) + ((-1)**n)*f(2,nx+1,k,i) c              + sum(f(2,j,k,i)*cos(pi*n*j/nx))) c if isign = 1, forward sine transforms are performed c f(1,j,k,i) = sum(f(1,n,k,i)*sin(pi*n*j/nx)) c f(2,j,k,i) = 2*(.5*f(2,1,k,i) + ((-1)**j)*f(2,n+1,k,i) c              + sum(f(2,n,k,i)*cos(pi*n*j/nx)) c mixup = array of bit reversed addresses c sctd = sine/cosine table c kstrt = starting data block number c kyp = number of data values per block in y c kypi = initial y index used c kypp = number of y indices used c nxvh = first dimension of f >= nx/2 + 1 c kypd = second dimension of f >= kyp + 1 c kblok = number of data blocks in y c nxhyd = maximum of (nx/2,ny) c nxyd = maximum of (nx,ny) c written by viktor k. decyk, ucla implicit none integer isign , mixup , indx , indy , kstrt , kyp , kypi , kypp integer nxvh , kypd , kblok , nxhyd , nxyd real f complex sctd dimension f ( 2 , 2 * nxvh , kypd , kblok ) dimension mixup ( nxhyd ), sctd ( nxyd ) c local data integer indx1 , indx1y , nx , nxh , nxhh , nx3 , ny , nxy , nxhy , ks , kypt integer i , j , k , l , m , km , kmr , nrx , j1 , j2 , ns , ns2 , k1 , k2 , kyps integer jj real at1 , at2 , at3 , t2 , t3 , t4 , t5 , t6 , ani , sum1 , sum2 complex t1 indx1 = indx - 1 indx1y = max0 ( indx1 , indy ) nx = 2 ** indx nxh = nx / 2 nxhh = nx / 4 nx3 = nx + 3 ny = 2 ** indy nxy = max0 ( nx , ny ) nxhy = 2 ** indx1y ks = kstrt - 2 kyps = kypi + kypp - 1 if ( kstrt . gt . ny ) return if ( isign . eq . 0 ) return c create auxiliary array in x kmr = nxy / nx kypt = kyps do 30 l = 1 , kblok if (( kyps + kyp * ( l + ks )). eq . ny ) kypt = kyps + 1 do 20 k = kypi , kypt sum1 = . 5 * ( f ( 2 , 1 , k , l ) - f ( 2 , nx + 1 , k , l )) do 10 j = 2 , nxh j1 = 1 + kmr * ( j - 1 ) at3 = - aimag ( sctd ( j1 )) at2 = f ( 1 , nx + 2 - j , k , l ) at1 = f ( 1 , j , k , l ) + at2 at2 = f ( 1 , j , k , l ) - at2 at1 = at3 * at1 at2 = . 5 * at2 f ( 1 , j , k , l ) = at1 + at2 f ( 1 , nx + 2 - j , k , l ) = at1 - at2 at2 = f ( 2 , nx + 2 - j , k , l ) at1 = f ( 2 , j , k , l ) + at2 at2 = f ( 2 , j , k , l ) - at2 sum1 = sum1 + real ( sctd ( j1 )) * at2 at2 = at3 * at2 at1 = . 5 * at1 f ( 2 , j , k , l ) = at1 - at2 f ( 2 , nx + 2 - j , k , l ) = at1 + at2 10 continue f ( 1 , 1 , k , l ) = 0.0 f ( 1 , nxh + 1 , k , l ) = 2.0 * f ( 1 , nxh + 1 , k , l ) f ( 2 , 1 , k , l ) = . 5 * ( f ( 2 , 1 , k , l ) + f ( 2 , nx + 1 , k , l )) f ( 2 , nx + 1 , k , l ) = sum1 20 continue 30 continue c bit-reverse array elements in x nrx = nxhy / nxh kypt = kyps do 70 l = 1 , kblok if (( kyps + kyp * ( l + ks )). eq . ny ) kypt = kyps + 1 do 60 j = 1 , nxh j1 = ( mixup ( j ) - 1 ) / nrx + 1 if ( j . ge . j1 ) go to 60 do 50 k = kypi , kypt do 40 jj = 1 , 2 t2 = f ( jj , 2 * j1 - 1 , k , l ) t3 = f ( jj , 2 * j1 , k , l ) f ( jj , 2 * j1 - 1 , k , l ) = f ( jj , 2 * j - 1 , k , l ) f ( jj , 2 * j1 , k , l ) = f ( jj , 2 * j , k , l ) f ( jj , 2 * j - 1 , k , l ) = t2 f ( jj , 2 * j , k , l ) = t3 40 continue 50 continue 60 continue 70 continue c first transform in x nrx = nxy / nxh do 130 m = 1 , indx1 ns = 2 ** ( m - 1 ) ns2 = ns + ns km = nxhh / ns kmr = 2 * km * nrx kypt = kyps do 120 l = 1 , kblok if (( kyps + kyp * ( l + ks )). eq . ny ) kypt = kyps + 1 do 110 k = 1 , km k1 = ns2 * ( k - 1 ) k2 = k1 + ns do 100 j = 1 , ns j1 = j + k1 j2 = j + k2 t1 = sctd ( 1 + kmr * ( j - 1 )) do 90 i = kypi , kypt do 80 jj = 1 , 2 t2 = real ( t1 ) * f ( jj , 2 * j2 - 1 , i , l ) - aimag ( t1 ) * f ( jj , 2 * j2 , i , l ) t3 = aimag ( t1 ) * f ( jj , 2 * j2 - 1 , i , l ) + real ( t1 ) * f ( jj , 2 * j2 , i , l ) f ( jj , 2 * j2 - 1 , i , l ) = f ( jj , 2 * j1 - 1 , i , l ) - t2 f ( jj , 2 * j2 , i , l ) = f ( jj , 2 * j1 , i , l ) - t3 f ( jj , 2 * j1 - 1 , i , l ) = f ( jj , 2 * j1 - 1 , i , l ) + t2 f ( jj , 2 * j1 , i , l ) = f ( jj , 2 * j1 , i , l ) + t3 80 continue 90 continue 100 continue 110 continue 120 continue 130 continue c unscramble coefficients and normalize c inverse fourier transform if ( isign . lt . 0 ) then kmr = nxy / nxh ani = 1. / float ( 2 * nx * ny ) kypt = kyps do 190 l = 1 , kblok if (( kyps + kyp * ( l + ks )). eq . ny ) kypt = kyps + 1 do 160 j = 2 , nxhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( j - 1 ))), - real ( sctd ( 1 + kmr * ( j - 1 )))) do 150 k = kypi , kypt do 140 jj = 1 , 2 t4 = f ( jj , nx3 - 2 * j , k , l ) t5 = - f ( jj , nx3 - 2 * j + 1 , k , l ) t2 = f ( jj , 2 * j - 1 , k , l ) + t4 t3 = f ( jj , 2 * j , k , l ) + t5 t6 = f ( jj , 2 * j - 1 , k , l ) - t4 t5 = f ( jj , 2 * j , k , l ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) f ( jj , 2 * j - 1 , k , l ) = ani * ( t2 + t4 ) f ( jj , 2 * j , k , l ) = ani * ( t3 + t5 ) f ( jj , nx3 - 2 * j , k , l ) = ani * ( t2 - t4 ) f ( jj , nx3 - 2 * j + 1 , k , l ) = ani * ( t5 - t3 ) 140 continue 150 continue 160 continue ani = 2. * ani do 180 k = kypi , kypt do 170 jj = 1 , 2 f ( jj , nxh + 1 , k , l ) = ani * f ( jj , nxh + 1 , k , l ) f ( jj , nxh + 2 , k , l ) = - ani * f ( jj , nxh + 2 , k , l ) t2 = ani * ( f ( jj , 1 , k , l ) + f ( jj , 2 , k , l )) f ( jj , 2 , k , l ) = ani * ( f ( jj , 1 , k , l ) - f ( jj , 2 , k , l )) f ( jj , 1 , k , l ) = t2 f ( jj , nx + 1 , k , l ) = ani * f ( jj , nx + 1 , k , l ) 170 continue 180 continue 190 continue c forward fourier transform else if ( isign . gt . 0 ) then kmr = nxy / nxh kypt = kyps do 250 l = 1 , kblok if (( kyps + kyp * ( l + ks )). eq . ny ) kypt = kyps + 1 do 220 j = 2 , nxhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( j - 1 ))), - real ( sctd ( 1 + kmr * ( j - 1 )))) do 210 k = kypi , kypt do 200 jj = 1 , 2 t4 = f ( jj , nx3 - 2 * j , k , l ) t5 = - f ( jj , nx3 - 2 * j + 1 , k , l ) t2 = f ( jj , 2 * j - 1 , k , l ) + t4 t3 = f ( jj , 2 * j , k , l ) + t5 t6 = f ( jj , 2 * j - 1 , k , l ) - t4 t5 = f ( jj , 2 * j , k , l ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) f ( jj , 2 * j - 1 , k , l ) = t2 + t4 f ( jj , 2 * j , k , l ) = t3 + t5 f ( jj , nx3 - 2 * j , k , l ) = t2 - t4 f ( jj , nx3 - 2 * j + 1 , k , l ) = t5 - t3 200 continue 210 continue 220 continue do 240 k = kypi , kypt do 230 jj = 1 , 2 f ( jj , nxh + 1 , k , l ) = 2.0 * f ( jj , nxh + 1 , k , l ) f ( jj , nxh + 2 , k , l ) = - 2.0 * f ( jj , nxh + 2 , k , l ) t2 = 2.0 * ( f ( jj , 1 , k , l ) + f ( jj , 2 , k , l )) f ( jj , 2 , k , l ) = 2.0 * ( f ( jj , 1 , k , l ) - f ( jj , 2 , k , l )) f ( jj , 1 , k , l ) = t2 f ( jj , nx + 1 , k , l ) = 2.0 * f ( jj , nx + 1 , k , l ) 230 continue 240 continue 250 continue endif c perform recursion for cosine-sine transform kypt = kyps do 280 l = 1 , kblok if (( kyps + kyp * ( l + ks )). eq . ny ) kypt = kyps + 1 do 270 k = kypi , kypt sum1 = . 5 * f ( 1 , 1 , k , l ) f ( 1 , 1 , k , l ) = 0.0 f ( 1 , 2 , k , l ) = sum1 sum2 = f ( 2 , nx + 1 , k , l ) f ( 2 , nx + 1 , k , l ) = f ( 2 , 2 , k , l ) f ( 2 , 2 , k , l ) = sum2 do 260 j = 2 , nxh sum1 = sum1 + f ( 1 , 2 * j - 1 , k , l ) f ( 1 , 2 * j - 1 , k , l ) = - f ( 1 , 2 * j , k , l ) f ( 1 , 2 * j , k , l ) = sum1 sum2 = sum2 - f ( 2 , 2 * j , k , l ) f ( 2 , 2 * j , k , l ) = sum2 260 continue f ( 1 , nx + 1 , k , l ) = 0.0 270 continue 280 continue return end c----------------------------------------------------------------------- subroutine PFSCT2R2Y ( g , isign , mixup , sctd , indx , indy , kstrt , kxp , kxpi , k 1 xpp , nyv , kxpd , jblok , nxhyd , nxyd ) c this subroutine performs the y part of 2 two dimensional fast real c sine and cosine transforms and their inverses, for a subset of x, c using real arithmetic, for data which is distributed in blocks c algorithm is described in Numerical Recipies in Fortran, Second Ed., c by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, c [Cambridge Univ. Press, 1992], p. 508. c for isign = (-1,1), input: all, output: f c approximate flop count: N*(5*log2(N) + 18)/nvp c where N = (nx/2)*ny c indx/indy = exponent which determines length in x/y direction, c where nx=2**indx, ny=2**indy c if isign = -1, inverse sine-cosine transform are performed c g(1,m,n,i) = sum(g(1,k,n,i)*sin(pi*m*k/ny)) c g(2,m,n,i) = (.5*g(2,1,n,i) + ((-1)**m)*g(2,ny+1,n,i) c              + sum(g(2,k,n,i)*cos(pi*m*k/ny)) c if isign = 1, a forward sine-cosine transforms are performed c g(1,k,n,i) = sum(g(1,m,n,i)*sin(pi*m*k/ny)) c g(2,k,n,i) = 2*(.5*g(2,1,n,i) + ((-1)**m)*g(2,ny+1,n,i) c              + sum(g(2,m,n,i)*cos(pi*m*k/ny)) c mixup = array of bit reversed addresses c sctd = sine/cosine table c kstrt = starting data block number c kxp = number of data values per block in x c kxpi = initial x index used c kxpp = number of x indices used c nyv = first dimension of g >= ny + 1 c kxpd = second dimension of g >= kxp + 1 c jblok = number of data blocks in x c nxhyd = maximum of (nx/2,ny) c nxyd = maximum of (nx,ny) c written by viktor k. decyk, ucla implicit none integer isign , mixup , indx , indy , kstrt , kxp , kxpi , kxpp integer nyv , kxpd , jblok , nxhyd , nxyd real g complex sctd dimension g ( 2 , nyv , kxpd , jblok ) dimension mixup ( nxhyd ), sctd ( nxyd ) c local data integer indx1 , indy1 , indx1y , nx , ny , nyh , nyhh , ny3 , nxy , nxhy integer i , j , k , l , m , ks , km , kmr , nry , j1 , j2 , ns , ns2 , k1 , k2 integer kxps , kxpt , jj real at1 , at2 , at3 , t2 , t3 , t4 , t5 , t6 , ani , sum1 , sum2 complex t1 indx1 = indx - 1 indy1 = indy - 1 indx1y = max0 ( indx1 , indy ) nx = 2 ** indx ny = 2 ** indy nyh = ny / 2 nyhh = ny / 4 ny3 = ny + 3 nxy = max0 ( nx , ny ) nxhy = 2 ** indx1y ks = kstrt - 2 kxps = kxpi + kxpp - 1 if ( kstrt . gt . nx ) return if ( isign . eq . 0 ) return c create auxiliary array in y kmr = nxy / ny kxpt = kxps do 30 l = 1 , jblok if (( kxps + kxp * ( l + ks )). eq . nx ) kxpt = kxps + 1 do 20 j = kxpi , kxpt sum1 = . 5 * ( g ( 2 , 1 , j , l ) - g ( 2 , ny + 1 , j , l )) do 10 k = 2 , nyh k1 = 1 + kmr * ( k - 1 ) at3 = - aimag ( sctd ( k1 )) at2 = g ( 1 , ny + 2 - k , j , l ) at1 = g ( 1 , k , j , l ) + at2 at2 = g ( 1 , k , j , l ) - at2 at1 = at3 * at1 at2 = . 5 * at2 g ( 1 , k , j , l ) = at1 + at2 g ( 1 , ny + 2 - k , j , l ) = at1 - at2 at2 = g ( 2 , ny + 2 - k , j , l ) at1 = g ( 2 , k , j , l ) + at2 at2 = g ( 2 , k , j , l ) - at2 sum1 = sum1 + real ( sctd ( k1 )) * at2 at2 = at3 * at2 at1 = . 5 * at1 g ( 2 , k , j , l ) = at1 - at2 g ( 2 , ny + 2 - k , j , l ) = at1 + at2 10 continue g ( 1 , 1 , j , l ) = 0.0 g ( 1 , nyh + 1 , j , l ) = 2.0 * g ( 1 , nyh + 1 , j , l ) g ( 2 , 1 , j , l ) = . 5 * ( g ( 2 , 1 , j , l ) + g ( 2 , ny + 1 , j , l )) g ( 2 , ny + 1 , j , l ) = sum1 20 continue 30 continue c bit-reverse array elements in y nry = nxhy / nyh kxpt = kxps do 70 l = 1 , jblok if (( kxps + kxp * ( l + ks )). eq . nx ) kxpt = kxps + 1 do 60 k = 1 , nyh k1 = ( mixup ( k ) - 1 ) / nry + 1 if ( k . ge . k1 ) go to 60 do 50 j = kxpi , kxpt do 40 jj = 1 , 2 t2 = g ( jj , 2 * k1 - 1 , j , l ) t3 = g ( jj , 2 * k1 , j , l ) g ( jj , 2 * k1 - 1 , j , l ) = g ( jj , 2 * k - 1 , j , l ) g ( jj , 2 * k1 , j , l ) = g ( jj , 2 * k , j , l ) g ( jj , 2 * k - 1 , j , l ) = t2 g ( jj , 2 * k , j , l ) = t3 40 continue 50 continue 60 continue 70 continue c first transform in y nry = nxy / nyh do 130 m = 1 , indy1 ns = 2 ** ( m - 1 ) ns2 = ns + ns km = nyhh / ns kmr = 2 * km * nry kxpt = kxps do 120 l = 1 , jblok if (( kxps + kxp * ( l + ks )). eq . nx ) kxpt = kxps + 1 do 110 k = 1 , km k1 = ns2 * ( k - 1 ) k2 = k1 + ns do 100 j = 1 , ns j1 = j + k1 j2 = j + k2 t1 = sctd ( 1 + kmr * ( j - 1 )) do 90 i = kxpi , kxpt do 80 jj = 1 , 2 t2 = real ( t1 ) * g ( jj , 2 * j2 - 1 , i , l ) - aimag ( t1 ) * g ( jj , 2 * j2 , i , l ) t3 = aimag ( t1 ) * g ( jj , 2 * j2 - 1 , i , l ) + real ( t1 ) * g ( jj , 2 * j2 , i , l ) g ( jj , 2 * j2 - 1 , i , l ) = g ( jj , 2 * j1 - 1 , i , l ) - t2 g ( jj , 2 * j2 , i , l ) = g ( jj , 2 * j1 , i , l ) - t3 g ( jj , 2 * j1 - 1 , i , l ) = g ( jj , 2 * j1 - 1 , i , l ) + t2 g ( jj , 2 * j1 , i , l ) = g ( jj , 2 * j1 , i , l ) + t3 80 continue 90 continue 100 continue 110 continue 120 continue 130 continue c unscramble coefficients and normalize c inverse fourier transform if ( isign . lt . 0 ) then kmr = nxy / nyh ani = 0.5 kxpt = kxps do 190 l = 1 , jblok if (( kxps + kxp * ( l + ks )). eq . nx ) kxpt = kxps + 1 do 160 k = 2 , nyhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( k - 1 ))), - real ( sctd ( 1 + kmr * ( k - 1 )))) do 150 j = kxpi , kxpt do 140 jj = 1 , 2 t4 = g ( jj , ny3 - 2 * k , j , l ) t5 = - g ( jj , ny3 - 2 * k + 1 , j , l ) t2 = g ( jj , 2 * k - 1 , j , l ) + t4 t3 = g ( jj , 2 * k , j , l ) + t5 t6 = g ( jj , 2 * k - 1 , j , l ) - t4 t5 = g ( jj , 2 * k , j , l ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) g ( jj , 2 * k - 1 , j , l ) = ani * ( t2 + t4 ) g ( jj , 2 * k , j , l ) = ani * ( t3 + t5 ) g ( jj , ny3 - 2 * k , j , l ) = ani * ( t2 - t4 ) g ( jj , ny3 - 2 * k + 1 , j , l ) = ani * ( t5 - t3 ) 140 continue 150 continue 160 continue do 180 j = kxpi , kxpt do 170 jj = 1 , 2 g ( jj , nyh + 1 , j , l ) = g ( jj , nyh + 1 , j , l ) g ( jj , nyh + 2 , j , l ) = - g ( jj , nyh + 2 , j , l ) t2 = g ( jj , 1 , j , l ) + g ( jj , 2 , j , l ) g ( jj , 2 , j , l ) = g ( jj , 1 , j , l ) - g ( jj , 2 , j , l ) g ( jj , 1 , j , l ) = t2 g ( jj , ny + 1 , j , l ) = g ( jj , ny + 1 , j , l ) 170 continue 180 continue 190 continue c forward fourier transform else if ( isign . gt . 0 ) then kmr = nxy / nyh kxpt = kxps do 250 l = 1 , jblok if (( kxps + kxp * ( l + ks )). eq . nx ) kxpt = kxps + 1 do 220 k = 2 , nyhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( k - 1 ))), - real ( sctd ( 1 + kmr * ( k - 1 )))) do 210 j = kxpi , kxpt do 200 jj = 1 , 2 t4 = g ( jj , ny3 - 2 * k , j , l ) t5 = - g ( jj , ny3 - 2 * k + 1 , j , l ) t2 = g ( jj , 2 * k - 1 , j , l ) + t4 t3 = g ( jj , 2 * k , j , l ) + t5 t6 = g ( jj , 2 * k - 1 , j , l ) - t4 t5 = g ( jj , 2 * k , j , l ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) g ( jj , 2 * k - 1 , j , l ) = t2 + t4 g ( jj , 2 * k , j , l ) = t3 + t5 g ( jj , ny3 - 2 * k , j , l ) = t2 - t4 g ( jj , ny3 - 2 * k + 1 , j , l ) = t5 - t3 200 continue 210 continue 220 continue do 240 j = kxpi , kxpt do 230 jj = 1 , 2 g ( jj , nyh + 1 , j , l ) = 2.0 * g ( jj , nyh + 1 , j , l ) g ( jj , nyh + 2 , j , l ) = - 2.0 * g ( jj , nyh + 2 , j , l ) t2 = 2.0 * ( g ( jj , 1 , j , l ) + g ( jj , 2 , j , l )) g ( jj , 2 , j , l ) = 2.0 * ( g ( jj , 1 , j , l ) - g ( jj , 2 , j , l )) g ( jj , 1 , j , l ) = t2 g ( jj , ny + 1 , j , l ) = 2.0 * g ( jj , ny + 1 , j , l ) 230 continue 240 continue 250 continue endif c perform recursion for sine-cosine transform kxpt = kxps do 280 l = 1 , jblok if (( kxps + kxp * ( l + ks )). eq . nx ) kxpt = kxps + 1 do 270 j = kxpi , kxpt sum1 = . 5 * g ( 1 , 1 , j , l ) g ( 1 , 1 , j , l ) = 0.0 g ( 1 , 2 , j , l ) = sum1 sum2 = g ( 2 , ny + 1 , j , l ) g ( 2 , ny + 1 , j , l ) = g ( 2 , 2 , j , l ) g ( 2 , 2 , j , l ) = sum2 do 260 k = 2 , nyh sum1 = sum1 + g ( 1 , 2 * k - 1 , j , l ) g ( 1 , 2 * k - 1 , j , l ) = - g ( 1 , 2 * k , j , l ) g ( 1 , 2 * k , j , l ) = sum1 sum2 = sum2 - g ( 2 , 2 * k , j , l ) g ( 2 , 2 * k , j , l ) = sum2 260 continue g ( 1 , ny + 1 , j , l ) = 0.0 270 continue 280 continue return end c----------------------------------------------------------------------- subroutine PFCST2R2Y ( g , isign , mixup , sctd , indx , indy , kstrt , kxp , kxpi , k 1 xpp , nyv , kxpd , jblok , nxhyd , nxyd ) c this subroutine performs the y part of 2 two dimensional fast real c sine and cosine transforms and their inverses, for a subset of x, c using real arithmetic, for data which is distributed in blocks c algorithm is described in Numerical Recipies in Fortran, Second Ed., c by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, c [Cambridge Univ. Press, 1992], p. 508. c for isign = (-1,1), input: all, output: f c approximate flop count: N*(5*log2(N) + 18)/nvp c where N = (nx/2)*ny c indx/indy = exponent which determines length in x/y direction, c where nx=2**indx, ny=2**indy c if isign = -1, inverse sine-cosine transform are performed c g(1,m,n,i) = (.5*g(1,1,n,i) + ((-1)**m)*g(1,ny+1,n,i) c              + sum(g(1,k,n,i)*cos(pi*m*k/ny)) c g(2,m,n,i) = sum(g(2,k,n,i)*sin(pi*m*k/ny)) c if isign = 1, a forward sine-cosine transforms are performed c g(1,k,n,i) = 2*(.5*g(1,1,n,i) + ((-1)**m)*g(1,ny+1,n,i) c              + sum(g(1,m,n,i)*cos(pi*m*k/ny)) c g(2,k,n,i) = sum(g(2,m,n,i)*sin(pi*m*k/ny)) c mixup = array of bit reversed addresses c sctd = sine/cosine table c kstrt = starting data block number c kxp = number of data values per block in x c kxpi = initial x index used c kxpp = number of x indices used c nyv = first dimension of g >= ny + 1 c kxpd = second dimension of g >= kxp + 1 c jblok = number of data blocks in x c nxhyd = maximum of (nx/2,ny) c nxyd = maximum of (nx,ny) c written by viktor k. decyk, ucla implicit none integer isign , mixup , indx , indy , kstrt , kxp , kxpi , kxpp integer nyv , kxpd , jblok , nxhyd , nxyd real g complex sctd dimension g ( 2 , nyv , kxpd , jblok ) dimension mixup ( nxhyd ), sctd ( nxyd ) c local data integer indx1 , indy1 , indx1y , nx , ny , nyh , nyhh , ny3 , nxy , nxhy integer i , j , k , l , m , ks , km , kmr , nry , j1 , j2 , ns , ns2 , k1 , k2 integer kxps , kxpt , jj real at1 , at2 , at3 , t2 , t3 , t4 , t5 , t6 , ani , sum1 , sum2 complex t1 indx1 = indx - 1 indy1 = indy - 1 indx1y = max0 ( indx1 , indy ) nx = 2 ** indx ny = 2 ** indy nyh = ny / 2 nyhh = ny / 4 ny3 = ny + 3 nxy = max0 ( nx , ny ) nxhy = 2 ** indx1y ks = kstrt - 2 kxps = kxpi + kxpp - 1 if ( kstrt . gt . nx ) return if ( isign . eq . 0 ) return c create auxiliary array in y kmr = nxy / ny kxpt = kxps do 30 l = 1 , jblok if (( kxps + kxp * ( l + ks )). eq . nx ) kxpt = kxps + 1 do 20 j = kxpi , kxpt sum1 = . 5 * ( g ( 1 , 1 , j , l ) - g ( 1 , ny + 1 , j , l )) do 10 k = 2 , nyh k1 = 1 + kmr * ( k - 1 ) at3 = - aimag ( sctd ( k1 )) at2 = g ( 1 , ny + 2 - k , j , l ) at1 = g ( 1 , k , j , l ) + at2 at2 = g ( 1 , k , j , l ) - at2 sum1 = sum1 + real ( sctd ( k1 )) * at2 at2 = at3 * at2 at1 = . 5 * at1 g ( 1 , k , j , l ) = at1 - at2 g ( 1 , ny + 2 - k , j , l ) = at1 + at2 at2 = g ( 2 , ny + 2 - k , j , l ) at1 = g ( 2 , k , j , l ) + at2 at2 = g ( 2 , k , j , l ) - at2 at1 = at3 * at1 at2 = . 5 * at2 g ( 2 , k , j , l ) = at1 + at2 g ( 2 , ny + 2 - k , j , l ) = at1 - at2 10 continue g ( 1 , 1 , j , l ) = . 5 * ( g ( 1 , 1 , j , l ) + g ( 1 , ny + 1 , j , l )) g ( 1 , ny + 1 , j , l ) = sum1 g ( 2 , 1 , j , l ) = 0.0 g ( 2 , nyh + 1 , j , l ) = 2.0 * g ( 2 , nyh + 1 , j , l ) 20 continue 30 continue c bit-reverse array elements in y nry = nxhy / nyh kxpt = kxps do 70 l = 1 , jblok if (( kxps + kxp * ( l + ks )). eq . nx ) kxpt = kxps + 1 do 60 k = 1 , nyh k1 = ( mixup ( k ) - 1 ) / nry + 1 if ( k . ge . k1 ) go to 60 do 50 j = kxpi , kxpt do 40 jj = 1 , 2 t2 = g ( jj , 2 * k1 - 1 , j , l ) t3 = g ( jj , 2 * k1 , j , l ) g ( jj , 2 * k1 - 1 , j , l ) = g ( jj , 2 * k - 1 , j , l ) g ( jj , 2 * k1 , j , l ) = g ( jj , 2 * k , j , l ) g ( jj , 2 * k - 1 , j , l ) = t2 g ( jj , 2 * k , j , l ) = t3 40 continue 50 continue 60 continue 70 continue c first transform in y nry = nxy / nyh do 130 m = 1 , indy1 ns = 2 ** ( m - 1 ) ns2 = ns + ns km = nyhh / ns kmr = 2 * km * nry kxpt = kxps do 120 l = 1 , jblok if (( kxps + kxp * ( l + ks )). eq . nx ) kxpt = kxps + 1 do 110 k = 1 , km k1 = ns2 * ( k - 1 ) k2 = k1 + ns do 100 j = 1 , ns j1 = j + k1 j2 = j + k2 t1 = sctd ( 1 + kmr * ( j - 1 )) do 90 i = kxpi , kxpt do 80 jj = 1 , 2 t2 = real ( t1 ) * g ( jj , 2 * j2 - 1 , i , l ) - aimag ( t1 ) * g ( jj , 2 * j2 , i , l ) t3 = aimag ( t1 ) * g ( jj , 2 * j2 - 1 , i , l ) + real ( t1 ) * g ( jj , 2 * j2 , i , l ) g ( jj , 2 * j2 - 1 , i , l ) = g ( jj , 2 * j1 - 1 , i , l ) - t2 g ( jj , 2 * j2 , i , l ) = g ( jj , 2 * j1 , i , l ) - t3 g ( jj , 2 * j1 - 1 , i , l ) = g ( jj , 2 * j1 - 1 , i , l ) + t2 g ( jj , 2 * j1 , i , l ) = g ( jj , 2 * j1 , i , l ) + t3 80 continue 90 continue 100 continue 110 continue 120 continue 130 continue c unscramble coefficients and normalize c inverse fourier transform if ( isign . lt . 0 ) then kmr = nxy / nyh ani = 0.5 kxpt = kxps do 190 l = 1 , jblok if (( kxps + kxp * ( l + ks )). eq . nx ) kxpt = kxps + 1 do 160 k = 2 , nyhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( k - 1 ))), - real ( sctd ( 1 + kmr * ( k - 1 )))) do 150 j = kxpi , kxpt do 140 jj = 1 , 2 t4 = g ( jj , ny3 - 2 * k , j , l ) t5 = - g ( jj , ny3 - 2 * k + 1 , j , l ) t2 = g ( jj , 2 * k - 1 , j , l ) + t4 t3 = g ( jj , 2 * k , j , l ) + t5 t6 = g ( jj , 2 * k - 1 , j , l ) - t4 t5 = g ( jj , 2 * k , j , l ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) g ( jj , 2 * k - 1 , j , l ) = ani * ( t2 + t4 ) g ( jj , 2 * k , j , l ) = ani * ( t3 + t5 ) g ( jj , ny3 - 2 * k , j , l ) = ani * ( t2 - t4 ) g ( jj , ny3 - 2 * k + 1 , j , l ) = ani * ( t5 - t3 ) 140 continue 150 continue 160 continue do 180 j = kxpi , kxpt do 170 jj = 1 , 2 g ( jj , nyh + 1 , j , l ) = g ( jj , nyh + 1 , j , l ) g ( jj , nyh + 2 , j , l ) = - g ( jj , nyh + 2 , j , l ) t2 = g ( jj , 1 , j , l ) + g ( jj , 2 , j , l ) g ( jj , 2 , j , l ) = g ( jj , 1 , j , l ) - g ( jj , 2 , j , l ) g ( jj , 1 , j , l ) = t2 g ( jj , ny + 1 , j , l ) = g ( jj , ny + 1 , j , l ) 170 continue 180 continue 190 continue c forward fourier transform else if ( isign . gt . 0 ) then kmr = nxy / nyh kxpt = kxps do 250 l = 1 , jblok if (( kxps + kxp * ( l + ks )). eq . nx ) kxpt = kxps + 1 do 220 k = 2 , nyhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( k - 1 ))), - real ( sctd ( 1 + kmr * ( k - 1 )))) do 210 j = kxpi , kxpt do 200 jj = 1 , 2 t4 = g ( jj , ny3 - 2 * k , j , l ) t5 = - g ( jj , ny3 - 2 * k + 1 , j , l ) t2 = g ( jj , 2 * k - 1 , j , l ) + t4 t3 = g ( jj , 2 * k , j , l ) + t5 t6 = g ( jj , 2 * k - 1 , j , l ) - t4 t5 = g ( jj , 2 * k , j , l ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) g ( jj , 2 * k - 1 , j , l ) = t2 + t4 g ( jj , 2 * k , j , l ) = t3 + t5 g ( jj , ny3 - 2 * k , j , l ) = t2 - t4 g ( jj , ny3 - 2 * k + 1 , j , l ) = t5 - t3 200 continue 210 continue 220 continue do 240 j = kxpi , kxpt do 230 jj = 1 , 2 g ( jj , nyh + 1 , j , l ) = 2.0 * g ( jj , nyh + 1 , j , l ) g ( jj , nyh + 2 , j , l ) = - 2.0 * g ( jj , nyh + 2 , j , l ) t2 = 2.0 * ( g ( jj , 1 , j , l ) + g ( jj , 2 , j , l )) g ( jj , 2 , j , l ) = 2.0 * ( g ( jj , 1 , j , l ) - g ( jj , 2 , j , l )) g ( jj , 1 , j , l ) = t2 g ( jj , ny + 1 , j , l ) = 2.0 * g ( jj , ny + 1 , j , l ) 230 continue 240 continue 250 continue endif c perform recursion for sine-cosine transform kxpt = kxps do 280 l = 1 , jblok if (( kxps + kxp * ( l + ks )). eq . nx ) kxpt = kxps + 1 do 270 j = kxpi , kxpt sum1 = g ( 1 , ny + 1 , j , l ) g ( 1 , ny + 1 , j , l ) = g ( 1 , 2 , j , l ) g ( 1 , 2 , j , l ) = sum1 sum2 = . 5 * g ( 2 , 1 , j , l ) g ( 2 , 1 , j , l ) = 0.0 g ( 2 , 2 , j , l ) = sum2 do 260 k = 2 , nyh sum1 = sum1 - g ( 1 , 2 * k , j , l ) g ( 1 , 2 * k , j , l ) = sum1 sum2 = sum2 + g ( 2 , 2 * k - 1 , j , l ) g ( 2 , 2 * k - 1 , j , l ) = - g ( 2 , 2 * k , j , l ) g ( 2 , 2 * k , j , l ) = sum2 260 continue g ( 2 , ny + 1 , j , l ) = 0.0 270 continue 280 continue return end c----------------------------------------------------------------------- subroutine WPFCST2R3 ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp , indx , in 1 dy , kstrt , nxvh , nyv , kxp2 , kyp , kypd , kxp2d , jblok , kblok , nxhyd , nxyd ) c wrapper function for 3 parallel real sine/sine transforms c for the electric field with dirichlet or magnetic field with neumann c boundary conditions implicit none integer isign , ntpose , mixup , indx , indy , kstrt , nxvh , nyv integer kxp2 , kyp , kypd , kxp2d , jblok , kblok , nxhyd , nxyd real f , g , bs , br , ttp complex sctd dimension f ( 3 , 2 * nxvh , kypd , kblok ), g ( 3 , nyv , kxp2d , jblok ) dimension bs ( 3 , kxp2 + 1 , kyp + 1 , kblok ), br ( 3 , kxp2 + 1 , kyp + 1 , jblok ) dimension mixup ( nxhyd ), sctd ( nxyd ) c local data integer nx , ny , kxpi , kypi real tf double precision dtime data kxpi , kypi / 1 , 1 / c calculate range of indices nx = 2 ** indx ny = 2 ** indy c inverse fourier transform if ( isign . lt . 0 ) then c perform x cosine-sine transform call PFCSST2R3X ( f , isign , mixup , sctd , indx , indy , kstrt , kyp , kypi , kyp 1 , nxvh , kypd , kblok , nxhyd , nxyd ) c transpose f array to g call PWTIMERA ( - 1 , ttp , dtime ) call PR3TPOSE ( f , g , bs , br , nx , ny , kstrt , 2 * nxvh , nyv , kxp2 , kyp , kxp2d , k 1 ypd , jblok , kblok ) call PWTIMERA ( 1 , ttp , dtime ) c perform y sine-cosine transform call PFSCST2R3Y ( g , isign , mixup , sctd , indx , indy , kstrt , kxp2 , kxpi , kx 1 p2 , nyv , kxp2d , jblok , nxhyd , nxyd ) c transpose g array to f if ( ntpose . eq . 0 ) then call PWTIMERA ( - 1 , tf , dtime ) call PR3TPOSE ( g , f , br , bs , ny , nx , kstrt , nyv , 2 * nxvh , kyp , kxp2 , kypd 1 , kxp2d , kblok , jblok ) call PWTIMERA ( 1 , tf , dtime ) endif c forward fourier transform else if ( isign . gt . 0 ) then c transpose f array to g if ( ntpose . eq . 0 ) then call PWTIMERA ( - 1 , tf , dtime ) call PR3TPOSE ( f , g , bs , br , nx , ny , kstrt , 2 * nxvh , nyv , kxp2 , kyp , kxp2 1 d , kypd , jblok , kblok ) call PWTIMERA ( 1 , tf , dtime ) endif c perform y sine-cosine transform call PFSCST2R3Y ( g , isign , mixup , sctd , indx , indy , kstrt , kxp2 , kxpi , kx 1 p2 , nyv , kxp2d , jblok , nxhyd , nxyd ) c transpose g array to f call PWTIMERA ( - 1 , ttp , dtime ) call PR3TPOSE ( g , f , br , bs , ny , nx , kstrt , nyv , 2 * nxvh , kyp , kxp2 , kypd , kx 1 p2d , kblok , jblok ) call PWTIMERA ( 1 , ttp , dtime ) c perform x cosine-sine transform call PFCSST2R3X ( f , isign , mixup , sctd , indx , indy , kstrt , kyp , kypi , kyp 1 , nxvh , kypd , kblok , nxhyd , nxyd ) endif if ( ntpose . eq . 0 ) ttp = ttp + tf return end c----------------------------------------------------------------------- subroutine WPFSCT2R3 ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp , indx , in 1 dy , kstrt , nxvh , nyv , kxp2 , kyp , kypd , kxp2d , jblok , kblok , nxhyd , nxyd ) c wrapper function for 3 parallel real sine/sine transforms c for the magnetic field with dirichlet or electric field with neumann c boundary conditions implicit none integer isign , ntpose , mixup , indx , indy , kstrt , nxvh , nyv integer kxp2 , kyp , kypd , kxp2d , jblok , kblok , nxhyd , nxyd real f , g , bs , br , ttp complex sctd dimension f ( 3 , 2 * nxvh , kypd , kblok ), g ( 3 , nyv , kxp2d , jblok ) dimension bs ( 3 , kxp2 + 1 , kyp + 1 , kblok ), br ( 3 , kxp2 + 1 , kyp + 1 , jblok ) dimension mixup ( nxhyd ), sctd ( nxyd ) c local data integer nx , ny , kxpi , kypi real tf double precision dtime data kxpi , kypi / 1 , 1 / c calculate range of indices nx = 2 ** indx ny = 2 ** indy c inverse fourier transform if ( isign . lt . 0 ) then c perform x sine-cosine transform call PFSCCT2R3X ( f , isign , mixup , sctd , indx , indy , kstrt , kyp , kypi , kyp 1 , nxvh , kypd , kblok , nxhyd , nxyd ) c transpose f array to g call PWTIMERA ( - 1 , ttp , dtime ) call PR3TPOSE ( f , g , bs , br , nx , ny , kstrt , 2 * nxvh , nyv , kxp2 , kyp , kxp2d , k 1 ypd , jblok , kblok ) call PWTIMERA ( 1 , ttp , dtime ) c perform y cosine-sine transform call PFCSCT2R3Y ( g , isign , mixup , sctd , indx , indy , kstrt , kxp2 , kxpi , kx 1 p2 , nyv , kxp2d , jblok , nxhyd , nxyd ) c transpose g array to f if ( ntpose . eq . 0 ) then call PWTIMERA ( - 1 , tf , dtime ) call PR3TPOSE ( g , f , br , bs , ny , nx , kstrt , nyv , 2 * nxvh , kyp , kxp2 , kypd 1 , kxp2d , kblok , jblok ) call PWTIMERA ( 1 , tf , dtime ) endif c forward fourier transform else if ( isign . gt . 0 ) then c transpose f array to g if ( ntpose . eq . 0 ) then call PWTIMERA ( - 1 , tf , dtime ) call PR3TPOSE ( f , g , bs , br , nx , ny , kstrt , 2 * nxvh , nyv , kxp2 , kyp , kxp2 1 d , kypd , jblok , kblok ) call PWTIMERA ( 1 , tf , dtime ) endif c perform y cosine-sine transform call PFCSCT2R3Y ( g , isign , mixup , sctd , indx , indy , kstrt , kxp2 , kxpi , kx 1 p2 , nyv , kxp2d , jblok , nxhyd , nxyd ) c transpose g array to f call PWTIMERA ( - 1 , ttp , dtime ) call PR3TPOSE ( g , f , br , bs , ny , nx , kstrt , nyv , 2 * nxvh , kyp , kxp2 , kypd , kx 1 p2d , kblok , jblok ) call PWTIMERA ( 1 , ttp , dtime ) c perform x sine-cosine transform call PFSCCT2R3X ( f , isign , mixup , sctd , indx , indy , kstrt , kyp , kypi , kyp 1 , nxvh , kypd , kblok , nxhyd , nxyd ) endif if ( ntpose . eq . 0 ) ttp = ttp + tf return end c----------------------------------------------------------------------- subroutine PFCSST2R3X ( f , isign , mixup , sctd , indx , indy , kstrt , kyp , kypi , 1 kypp , nxvh , kypd , kblok , nxhyd , nxyd ) c this subroutine performs the x part of 2 two dimensional fast real c sine and cosine transforms and their inverses, for a subset of y, c using real arithmetic, for data which is distributed in blocks c algorithm is described in Numerical Recipies in Fortran, Second Ed., c by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, c [Cambridge Univ. Press, 1992], p. 508. c for isign = (-1,1), input: all, output: f c approximate flop count: N*(5*log2(N) + 18)/nvp c where N = (nx/2)*ny c indx/indy = exponent which determines length in x/y direction, c where nx=2**indx, ny=2**indy c if isign = -1, inverse sine-cosine transforms are performed c f(1,n,k,i) = (1/nx*ny)*(.5*f(1,1,k,i) + ((-1)**n)*f(1,nx+1,k,i) c              + sum(f(1,j,k,i)*cos(pi*n*j/nx))) c f(2:3,n,k,i) = (1/nx*ny)*sum(f(2:3,j,k,i)*sin(pi*n*j/nx)) c if isign = 1, forward sine transforms are performed c f(1,j,k,i) = 2*(.5*f(1,1,k,i) + ((-1)**j)*f(1,n+1,k,i) c              + sum(f(1,n,k,i)*cos(pi*n*j/nx)) c f(2:3,j,k,i) = sum(f(2:3,n,k,i)*sin(pi*n*j/nx)) c mixup = array of bit reversed addresses c sctd = sine/cosine table c kstrt = starting data block number c kyp = number of data values per block in y c kypi = initial y index used c kypp = number of y indices used c nxvh = first dimension of f >= nx/2 + 1 c kypd = second dimension of f >= kyp + 1 c kblok = number of data blocks in y c nxhyd = maximum of (nx/2,ny) c nxyd = maximum of (nx,ny) c written by viktor k. decyk, ucla implicit none integer isign , mixup , indx , indy , kstrt , kyp , kypi , kypp integer nxvh , kypd , kblok , nxhyd , nxyd real f complex sctd dimension f ( 3 , 2 * nxvh , kypd , kblok ) dimension mixup ( nxhyd ), sctd ( nxyd ) c local data integer indx1 , indx1y , nx , nxh , nxhh , nx3 , ny , nxy , nxhy , ks , kypt integer i , j , k , l , m , km , kmr , nrx , j1 , j2 , ns , ns2 , k1 , k2 , kyps integer jj real at1 , at2 , at3 , t2 , t3 , t4 , t5 , t6 , ani , sum1 , sum2 , sum3 complex t1 indx1 = indx - 1 indx1y = max0 ( indx1 , indy ) nx = 2 ** indx nxh = nx / 2 nxhh = nx / 4 nx3 = nx + 3 ny = 2 ** indy nxy = max0 ( nx , ny ) nxhy = 2 ** indx1y ks = kstrt - 2 kyps = kypi + kypp - 1 if ( kstrt . gt . ny ) return if ( isign . eq . 0 ) return c create auxiliary array in x kmr = nxy / nx kypt = kyps do 30 l = 1 , kblok if (( kyps + kyp * ( l + ks )). eq . ny ) kypt = kyps + 1 do 20 k = kypi , kypt sum1 = . 5 * ( f ( 1 , 1 , k , l ) - f ( 1 , nx + 1 , k , l )) do 10 j = 2 , nxh j1 = 1 + kmr * ( j - 1 ) at3 = - aimag ( sctd ( j1 )) at2 = f ( 1 , nx + 2 - j , k , l ) at1 = f ( 1 , j , k , l ) + at2 at2 = f ( 1 , j , k , l ) - at2 sum1 = sum1 + real ( sctd ( j1 )) * at2 at2 = at3 * at2 at1 = . 5 * at1 f ( 1 , j , k , l ) = at1 - at2 f ( 1 , nx + 2 - j , k , l ) = at1 + at2 at2 = f ( 2 , nx + 2 - j , k , l ) at1 = f ( 2 , j , k , l ) + at2 at2 = f ( 2 , j , k , l ) - at2 at1 = at3 * at1 at2 = . 5 * at2 f ( 2 , j , k , l ) = at1 + at2 f ( 2 , nx + 2 - j , k , l ) = at1 - at2 at2 = f ( 3 , nx + 2 - j , k , l ) at1 = f ( 3 , j , k , l ) + at2 at2 = f ( 3 , j , k , l ) - at2 at1 = at3 * at1 at2 = . 5 * at2 f ( 3 , j , k , l ) = at1 + at2 f ( 3 , nx + 2 - j , k , l ) = at1 - at2 10 continue f ( 1 , 1 , k , l ) = . 5 * ( f ( 1 , 1 , k , l ) + f ( 1 , nx + 1 , k , l )) f ( 1 , nx + 1 , k , l ) = sum1 f ( 2 , 1 , k , l ) = 0.0 f ( 2 , nxh + 1 , k , l ) = 2.0 * f ( 2 , nxh + 1 , k , l ) f ( 3 , 1 , k , l ) = 0.0 f ( 3 , nxh + 1 , k , l ) = 2.0 * f ( 3 , nxh + 1 , k , l ) 20 continue 30 continue c bit-reverse array elements in x nrx = nxhy / nxh kypt = kyps do 70 l = 1 , kblok if (( kyps + kyp * ( l + ks )). eq . ny ) kypt = kyps + 1 do 60 j = 1 , nxh j1 = ( mixup ( j ) - 1 ) / nrx + 1 if ( j . ge . j1 ) go to 60 do 50 k = kypi , kypt do 40 jj = 1 , 3 t2 = f ( jj , 2 * j1 - 1 , k , l ) t3 = f ( jj , 2 * j1 , k , l ) f ( jj , 2 * j1 - 1 , k , l ) = f ( jj , 2 * j - 1 , k , l ) f ( jj , 2 * j1 , k , l ) = f ( jj , 2 * j , k , l ) f ( jj , 2 * j - 1 , k , l ) = t2 f ( jj , 2 * j , k , l ) = t3 40 continue 50 continue 60 continue 70 continue c first transform in x nrx = nxy / nxh do 130 m = 1 , indx1 ns = 2 ** ( m - 1 ) ns2 = ns + ns km = nxhh / ns kmr = 2 * km * nrx kypt = kyps do 120 l = 1 , kblok if (( kyps + kyp * ( l + ks )). eq . ny ) kypt = kyps + 1 do 110 k = 1 , km k1 = ns2 * ( k - 1 ) k2 = k1 + ns do 100 j = 1 , ns j1 = j + k1 j2 = j + k2 t1 = sctd ( 1 + kmr * ( j - 1 )) do 90 i = kypi , kypt do 80 jj = 1 , 3 t2 = real ( t1 ) * f ( jj , 2 * j2 - 1 , i , l ) - aimag ( t1 ) * f ( jj , 2 * j2 , i , l ) t3 = aimag ( t1 ) * f ( jj , 2 * j2 - 1 , i , l ) + real ( t1 ) * f ( jj , 2 * j2 , i , l ) f ( jj , 2 * j2 - 1 , i , l ) = f ( jj , 2 * j1 - 1 , i , l ) - t2 f ( jj , 2 * j2 , i , l ) = f ( jj , 2 * j1 , i , l ) - t3 f ( jj , 2 * j1 - 1 , i , l ) = f ( jj , 2 * j1 - 1 , i , l ) + t2 f ( jj , 2 * j1 , i , l ) = f ( jj , 2 * j1 , i , l ) + t3 80 continue 90 continue 100 continue 110 continue 120 continue 130 continue c unscramble coefficients and normalize c inverse fourier transform if ( isign . lt . 0 ) then kmr = nxy / nxh ani = 1. / float ( 2 * nx * ny ) kypt = kyps do 190 l = 1 , kblok if (( kyps + kyp * ( l + ks )). eq . ny ) kypt = kyps + 1 do 160 j = 2 , nxhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( j - 1 ))), - real ( sctd ( 1 + kmr * ( j - 1 )))) do 150 k = kypi , kypt do 140 jj = 1 , 3 t4 = f ( jj , nx3 - 2 * j , k , l ) t5 = - f ( jj , nx3 - 2 * j + 1 , k , l ) t2 = f ( jj , 2 * j - 1 , k , l ) + t4 t3 = f ( jj , 2 * j , k , l ) + t5 t6 = f ( jj , 2 * j - 1 , k , l ) - t4 t5 = f ( jj , 2 * j , k , l ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) f ( jj , 2 * j - 1 , k , l ) = ani * ( t2 + t4 ) f ( jj , 2 * j , k , l ) = ani * ( t3 + t5 ) f ( jj , nx3 - 2 * j , k , l ) = ani * ( t2 - t4 ) f ( jj , nx3 - 2 * j + 1 , k , l ) = ani * ( t5 - t3 ) 140 continue 150 continue 160 continue ani = 2. * ani do 180 k = kypi , kypt do 170 jj = 1 , 3 f ( jj , nxh + 1 , k , l ) = ani * f ( jj , nxh + 1 , k , l ) f ( jj , nxh + 2 , k , l ) = - ani * f ( jj , nxh + 2 , k , l ) t2 = ani * ( f ( jj , 1 , k , l ) + f ( jj , 2 , k , l )) f ( jj , 2 , k , l ) = ani * ( f ( jj , 1 , k , l ) - f ( jj , 2 , k , l )) f ( jj , 1 , k , l ) = t2 f ( jj , nx + 1 , k , l ) = ani * f ( jj , nx + 1 , k , l ) 170 continue 180 continue 190 continue c forward fourier transform else if ( isign . gt . 0 ) then kmr = nxy / nxh kypt = kyps do 250 l = 1 , kblok if (( kyps + kyp * ( l + ks )). eq . ny ) kypt = kyps + 1 do 220 j = 2 , nxhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( j - 1 ))), - real ( sctd ( 1 + kmr * ( j - 1 )))) do 210 k = kypi , kypt do 200 jj = 1 , 3 t4 = f ( jj , nx3 - 2 * j , k , l ) t5 = - f ( jj , nx3 - 2 * j + 1 , k , l ) t2 = f ( jj , 2 * j - 1 , k , l ) + t4 t3 = f ( jj , 2 * j , k , l ) + t5 t6 = f ( jj , 2 * j - 1 , k , l ) - t4 t5 = f ( jj , 2 * j , k , l ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) f ( jj , 2 * j - 1 , k , l ) = t2 + t4 f ( jj , 2 * j , k , l ) = t3 + t5 f ( jj , nx3 - 2 * j , k , l ) = t2 - t4 f ( jj , nx3 - 2 * j + 1 , k , l ) = t5 - t3 200 continue 210 continue 220 continue do 240 k = kypi , kypt do 230 jj = 1 , 3 f ( jj , nxh + 1 , k , l ) = 2.0 * f ( jj , nxh + 1 , k , l ) f ( jj , nxh + 2 , k , l ) = - 2.0 * f ( jj , nxh + 2 , k , l ) t2 = 2.0 * ( f ( jj , 1 , k , l ) + f ( jj , 2 , k , l )) f ( jj , 2 , k , l ) = 2.0 * ( f ( jj , 1 , k , l ) - f ( jj , 2 , k , l )) f ( jj , 1 , k , l ) = t2 f ( jj , nx + 1 , k , l ) = 2.0 * f ( jj , nx + 1 , k , l ) 230 continue 240 continue 250 continue endif c perform recursion for cosine-sine transform kypt = kyps do 280 l = 1 , kblok if (( kyps + kyp * ( l + ks )). eq . ny ) kypt = kyps + 1 do 270 k = kypi , kypt sum1 = f ( 1 , nx + 1 , k , l ) f ( 1 , nx + 1 , k , l ) = f ( 1 , 2 , k , l ) f ( 1 , 2 , k , l ) = sum1 sum2 = . 5 * f ( 2 , 1 , k , l ) f ( 2 , 1 , k , l ) = 0.0 f ( 2 , 2 , k , l ) = sum2 sum3 = . 5 * f ( 3 , 1 , k , l ) f ( 3 , 1 , k , l ) = 0.0 f ( 3 , 2 , k , l ) = sum3 do 260 j = 2 , nxh sum1 = sum1 - f ( 1 , 2 * j , k , l ) f ( 1 , 2 * j , k , l ) = sum1 sum2 = sum2 + f ( 2 , 2 * j - 1 , k , l ) f ( 2 , 2 * j - 1 , k , l ) = - f ( 2 , 2 * j , k , l ) f ( 2 , 2 * j , k , l ) = sum2 sum3 = sum3 + f ( 3 , 2 * j - 1 , k , l ) f ( 3 , 2 * j - 1 , k , l ) = - f ( 3 , 2 * j , k , l ) f ( 3 , 2 * j , k , l ) = sum3 260 continue f ( 2 , nx + 1 , k , l ) = 0.0 f ( 3 , nx + 1 , k , l ) = 0.0 270 continue 280 continue return end c----------------------------------------------------------------------- subroutine PFSCCT2R3X ( f , isign , mixup , sctd , indx , indy , kstrt , kyp , kypi , 1 kypp , nxvh , kypd , kblok , nxhyd , nxyd ) c this subroutine performs the x part of 3 two dimensional fast real c sine and cosine transforms and their inverses, for a subset of y, c using real arithmetic, for data which is distributed in blocks c algorithm is described in Numerical Recipies in Fortran, Second Ed., c by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, c [Cambridge Univ. Press, 1992], p. 508. c for isign = (-1,1), input: all, output: f c approximate flop count: N*(5*log2(N) + 18)/nvp c where N = (nx/2)*ny c indx/indy = exponent which determines length in x/y direction, c where nx=2**indx, ny=2**indy c if isign = -1, inverse sine-cosine transforms are performed c f(1,n,k,i) = (1/nx*ny)*sum(f(1,j,k,i)*sin(pi*n*j/nx)) c f(2:3,n,k,i) = (1/nx*ny)*(.5*f(2:3,1,k,i) + ((-1)**n)*f(2:3,nx+1,k,i) c              + sum(f(2:3,j,k,i)*cos(pi*n*j/nx))) c if isign = 1, forward sine transforms are performed c f(1,j,k,i) = sum(f(1,n,k,i)*sin(pi*n*j/nx)) c f(2:3,j,k,i) = 2*(.5*f(2:3,1,k,i) + ((-1)**j)*f(2:3,n+1,k,i) c              + sum(f(2:3,n,k,i)*cos(pi*n*j/nx)) c mixup = array of bit reversed addresses c sctd = sine/cosine table c kstrt = starting data block number c kyp = number of data values per block in y c kypi = initial y index used c kypp = number of y indices used c nxvh = first dimension of f >= nx/2 + 1 c kypd = second dimension of f >= kyp + 1 c kblok = number of data blocks in y c nxhyd = maximum of (nx/2,ny) c nxyd = maximum of (nx,ny) c written by viktor k. decyk, ucla implicit none integer isign , mixup , indx , indy , kstrt , kyp , kypi , kypp integer nxvh , kypd , kblok , nxhyd , nxyd real f complex sctd dimension f ( 3 , 2 * nxvh , kypd , kblok ) dimension mixup ( nxhyd ), sctd ( nxyd ) c local data integer indx1 , indx1y , nx , nxh , nxhh , nx3 , ny , nxy , nxhy , ks , kypt integer i , j , k , l , m , km , kmr , nrx , j1 , j2 , ns , ns2 , k1 , k2 , kyps integer jj real at1 , at2 , at3 , t2 , t3 , t4 , t5 , t6 , ani , sum1 , sum2 , sum3 complex t1 indx1 = indx - 1 indx1y = max0 ( indx1 , indy ) nx = 2 ** indx nxh = nx / 2 nxhh = nx / 4 nx3 = nx + 3 ny = 2 ** indy nxy = max0 ( nx , ny ) nxhy = 2 ** indx1y ks = kstrt - 2 kyps = kypi + kypp - 1 if ( kstrt . gt . ny ) return if ( isign . eq . 0 ) return c create auxiliary array in x kmr = nxy / nx kypt = kyps do 30 l = 1 , kblok if (( kyps + kyp * ( l + ks )). eq . ny ) kypt = kyps + 1 do 20 k = kypi , kypt sum1 = . 5 * ( f ( 2 , 1 , k , l ) - f ( 2 , nx + 1 , k , l )) sum2 = . 5 * ( f ( 3 , 1 , k , l ) - f ( 3 , nx + 1 , k , l )) do 10 j = 2 , nxh j1 = 1 + kmr * ( j - 1 ) at3 = - aimag ( sctd ( j1 )) at2 = f ( 1 , nx + 2 - j , k , l ) at1 = f ( 1 , j , k , l ) + at2 at2 = f ( 1 , j , k , l ) - at2 at1 = at3 * at1 at2 = . 5 * at2 f ( 1 , j , k , l ) = at1 + at2 f ( 1 , nx + 2 - j , k , l ) = at1 - at2 at2 = f ( 2 , nx + 2 - j , k , l ) at1 = f ( 2 , j , k , l ) + at2 at2 = f ( 2 , j , k , l ) - at2 sum1 = sum1 + real ( sctd ( j1 )) * at2 at2 = at3 * at2 at1 = . 5 * at1 f ( 2 , j , k , l ) = at1 - at2 f ( 2 , nx + 2 - j , k , l ) = at1 + at2 at2 = f ( 3 , nx + 2 - j , k , l ) at1 = f ( 3 , j , k , l ) + at2 at2 = f ( 3 , j , k , l ) - at2 sum2 = sum2 + real ( sctd ( j1 )) * at2 at2 = at3 * at2 at1 = . 5 * at1 f ( 3 , j , k , l ) = at1 - at2 f ( 3 , nx + 2 - j , k , l ) = at1 + at2 10 continue f ( 1 , 1 , k , l ) = 0.0 f ( 1 , nxh + 1 , k , l ) = 2.0 * f ( 1 , nxh + 1 , k , l ) f ( 2 , 1 , k , l ) = . 5 * ( f ( 2 , 1 , k , l ) + f ( 2 , nx + 1 , k , l )) f ( 2 , nx + 1 , k , l ) = sum1 f ( 3 , 1 , k , l ) = . 5 * ( f ( 3 , 1 , k , l ) + f ( 3 , nx + 1 , k , l )) f ( 3 , nx + 1 , k , l ) = sum2 20 continue 30 continue c bit-reverse array elements in x nrx = nxhy / nxh kypt = kyps do 70 l = 1 , kblok if (( kyps + kyp * ( l + ks )). eq . ny ) kypt = kyps + 1 do 60 j = 1 , nxh j1 = ( mixup ( j ) - 1 ) / nrx + 1 if ( j . ge . j1 ) go to 60 do 50 k = kypi , kypt do 40 jj = 1 , 3 t2 = f ( jj , 2 * j1 - 1 , k , l ) t3 = f ( jj , 2 * j1 , k , l ) f ( jj , 2 * j1 - 1 , k , l ) = f ( jj , 2 * j - 1 , k , l ) f ( jj , 2 * j1 , k , l ) = f ( jj , 2 * j , k , l ) f ( jj , 2 * j - 1 , k , l ) = t2 f ( jj , 2 * j , k , l ) = t3 40 continue 50 continue 60 continue 70 continue c first transform in x nrx = nxy / nxh do 130 m = 1 , indx1 ns = 2 ** ( m - 1 ) ns2 = ns + ns km = nxhh / ns kmr = 2 * km * nrx kypt = kyps do 120 l = 1 , kblok if (( kyps + kyp * ( l + ks )). eq . ny ) kypt = kyps + 1 do 110 k = 1 , km k1 = ns2 * ( k - 1 ) k2 = k1 + ns do 100 j = 1 , ns j1 = j + k1 j2 = j + k2 t1 = sctd ( 1 + kmr * ( j - 1 )) do 90 i = kypi , kypt do 80 jj = 1 , 3 t2 = real ( t1 ) * f ( jj , 2 * j2 - 1 , i , l ) - aimag ( t1 ) * f ( jj , 2 * j2 , i , l ) t3 = aimag ( t1 ) * f ( jj , 2 * j2 - 1 , i , l ) + real ( t1 ) * f ( jj , 2 * j2 , i , l ) f ( jj , 2 * j2 - 1 , i , l ) = f ( jj , 2 * j1 - 1 , i , l ) - t2 f ( jj , 2 * j2 , i , l ) = f ( jj , 2 * j1 , i , l ) - t3 f ( jj , 2 * j1 - 1 , i , l ) = f ( jj , 2 * j1 - 1 , i , l ) + t2 f ( jj , 2 * j1 , i , l ) = f ( jj , 2 * j1 , i , l ) + t3 80 continue 90 continue 100 continue 110 continue 120 continue 130 continue c unscramble coefficients and normalize c inverse fourier transform if ( isign . lt . 0 ) then kmr = nxy / nxh ani = 1. / float ( 2 * nx * ny ) kypt = kyps do 190 l = 1 , kblok if (( kyps + kyp * ( l + ks )). eq . ny ) kypt = kyps + 1 do 160 j = 2 , nxhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( j - 1 ))), - real ( sctd ( 1 + kmr * ( j - 1 )))) do 150 k = kypi , kypt do 140 jj = 1 , 3 t4 = f ( jj , nx3 - 2 * j , k , l ) t5 = - f ( jj , nx3 - 2 * j + 1 , k , l ) t2 = f ( jj , 2 * j - 1 , k , l ) + t4 t3 = f ( jj , 2 * j , k , l ) + t5 t6 = f ( jj , 2 * j - 1 , k , l ) - t4 t5 = f ( jj , 2 * j , k , l ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) f ( jj , 2 * j - 1 , k , l ) = ani * ( t2 + t4 ) f ( jj , 2 * j , k , l ) = ani * ( t3 + t5 ) f ( jj , nx3 - 2 * j , k , l ) = ani * ( t2 - t4 ) f ( jj , nx3 - 2 * j + 1 , k , l ) = ani * ( t5 - t3 ) 140 continue 150 continue 160 continue ani = 2. * ani do 180 k = kypi , kypt do 170 jj = 1 , 3 f ( jj , nxh + 1 , k , l ) = ani * f ( jj , nxh + 1 , k , l ) f ( jj , nxh + 2 , k , l ) = - ani * f ( jj , nxh + 2 , k , l ) t2 = ani * ( f ( jj , 1 , k , l ) + f ( jj , 2 , k , l )) f ( jj , 2 , k , l ) = ani * ( f ( jj , 1 , k , l ) - f ( jj , 2 , k , l )) f ( jj , 1 , k , l ) = t2 f ( jj , nx + 1 , k , l ) = ani * f ( jj , nx + 1 , k , l ) 170 continue 180 continue 190 continue c forward fourier transform else if ( isign . gt . 0 ) then kmr = nxy / nxh kypt = kyps do 250 l = 1 , kblok if (( kyps + kyp * ( l + ks )). eq . ny ) kypt = kyps + 1 do 220 j = 2 , nxhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( j - 1 ))), - real ( sctd ( 1 + kmr * ( j - 1 )))) do 210 k = kypi , kypt do 200 jj = 1 , 3 t4 = f ( jj , nx3 - 2 * j , k , l ) t5 = - f ( jj , nx3 - 2 * j + 1 , k , l ) t2 = f ( jj , 2 * j - 1 , k , l ) + t4 t3 = f ( jj , 2 * j , k , l ) + t5 t6 = f ( jj , 2 * j - 1 , k , l ) - t4 t5 = f ( jj , 2 * j , k , l ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) f ( jj , 2 * j - 1 , k , l ) = t2 + t4 f ( jj , 2 * j , k , l ) = t3 + t5 f ( jj , nx3 - 2 * j , k , l ) = t2 - t4 f ( jj , nx3 - 2 * j + 1 , k , l ) = t5 - t3 200 continue 210 continue 220 continue do 240 k = kypi , kypt do 230 jj = 1 , 3 f ( jj , nxh + 1 , k , l ) = 2.0 * f ( jj , nxh + 1 , k , l ) f ( jj , nxh + 2 , k , l ) = - 2.0 * f ( jj , nxh + 2 , k , l ) t2 = 2.0 * ( f ( jj , 1 , k , l ) + f ( jj , 2 , k , l )) f ( jj , 2 , k , l ) = 2.0 * ( f ( jj , 1 , k , l ) - f ( jj , 2 , k , l )) f ( jj , 1 , k , l ) = t2 f ( jj , nx + 1 , k , l ) = 2.0 * f ( jj , nx + 1 , k , l ) 230 continue 240 continue 250 continue endif c perform recursion for cosine-sine transform kypt = kyps do 280 l = 1 , kblok if (( kyps + kyp * ( l + ks )). eq . ny ) kypt = kyps + 1 do 270 k = kypi , kypt sum1 = . 5 * f ( 1 , 1 , k , l ) f ( 1 , 1 , k , l ) = 0.0 f ( 1 , 2 , k , l ) = sum1 sum2 = f ( 2 , nx + 1 , k , l ) f ( 2 , nx + 1 , k , l ) = f ( 2 , 2 , k , l ) f ( 2 , 2 , k , l ) = sum2 sum3 = f ( 3 , nx + 1 , k , l ) f ( 3 , nx + 1 , k , l ) = f ( 3 , 2 , k , l ) f ( 3 , 2 , k , l ) = sum3 do 260 j = 2 , nxh sum1 = sum1 + f ( 1 , 2 * j - 1 , k , l ) f ( 1 , 2 * j - 1 , k , l ) = - f ( 1 , 2 * j , k , l ) f ( 1 , 2 * j , k , l ) = sum1 sum2 = sum2 - f ( 2 , 2 * j , k , l ) f ( 2 , 2 * j , k , l ) = sum2 sum3 = sum3 - f ( 3 , 2 * j , k , l ) f ( 3 , 2 * j , k , l ) = sum3 260 continue f ( 1 , nx + 1 , k , l ) = 0.0 270 continue 280 continue return end c----------------------------------------------------------------------- subroutine PFSCST2R3Y ( g , isign , mixup , sctd , indx , indy , kstrt , kxp , kxpi , 1 kxpp , nyv , kxpd , jblok , nxhyd , nxyd ) c this subroutine performs the y part of 3 two dimensional fast real c sine and cosine transforms and their inverses, for a subset of x, c using real arithmetic, for data which is distributed in blocks c algorithm is described in Numerical Recipies in Fortran, Second Ed., c by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, c [Cambridge Univ. Press, 1992], p. 508. c for isign = (-1,1), input: all, output: f c approximate flop count: N*(5*log2(N) + 18)/nvp c where N = (nx/2)*ny c indx/indy = exponent which determines length in x/y direction, c where nx=2**indx, ny=2**indy c if isign = -1, inverse sine-cosine transform are performed c g(1,m,n,i) = sum(g(1,k,n,i)*sin(pi*m*k/ny)) c g(2,m,n,i) = (.5*g(2,1,n,i) + ((-1)**m)*g(2,ny+1,n,i) c              + sum(g(2,k,n,i)*cos(pi*m*k/ny)) c g(3,m,n,i) = sum(g(3,k,n,i)*sin(pi*m*k/ny)) c if isign = 1, a forward sine-cosine transforms are performed c g(1,k,n,i) = sum(g(1,m,n,i)*sin(pi*m*k/ny)) c g(2,k,n,i) = 2*(.5*g(2,1,n,i) + ((-1)**m)*g(2,ny+1,n,i) c              + sum(g(2,m,n,i)*cos(pi*m*k/ny)) c g(3,k,n,i) = sum(g(3,m,n,i)*sin(pi*m*k/ny)) c mixup = array of bit reversed addresses c sctd = sine/cosine table c kstrt = starting data block number c kxp = number of data values per block in x c kxpi = initial x index used c kxpp = number of x indices used c nyv = first dimension of g >= ny + 1 c kxpd = second dimension of g >= kxp + 1 c jblok = number of data blocks in x c nxhyd = maximum of (nx/2,ny) c nxyd = maximum of (nx,ny) c written by viktor k. decyk, ucla implicit none integer isign , mixup , indx , indy , kstrt , kxp , kxpi , kxpp integer nyv , kxpd , jblok , nxhyd , nxyd real g complex sctd dimension g ( 3 , nyv , kxpd , jblok ) dimension mixup ( nxhyd ), sctd ( nxyd ) c local data integer indx1 , indy1 , indx1y , nx , ny , nyh , nyhh , ny3 , nxy , nxhy integer i , j , k , l , m , ks , km , kmr , nry , j1 , j2 , ns , ns2 , k1 , k2 integer kxps , kxpt , jj real at1 , at2 , at3 , t2 , t3 , t4 , t5 , t6 , ani , sum1 , sum2 , sum3 complex t1 indx1 = indx - 1 indy1 = indy - 1 indx1y = max0 ( indx1 , indy ) nx = 2 ** indx ny = 2 ** indy nyh = ny / 2 nyhh = ny / 4 ny3 = ny + 3 nxy = max0 ( nx , ny ) nxhy = 2 ** indx1y ks = kstrt - 2 kxps = kxpi + kxpp - 1 if ( kstrt . gt . nx ) return if ( isign . eq . 0 ) return c create auxiliary array in y kmr = nxy / ny kxpt = kxps do 30 l = 1 , jblok if (( kxps + kxp * ( l + ks )). eq . nx ) kxpt = kxps + 1 do 20 j = kxpi , kxpt sum1 = . 5 * ( g ( 2 , 1 , j , l ) - g ( 2 , ny + 1 , j , l )) do 10 k = 2 , nyh k1 = 1 + kmr * ( k - 1 ) at3 = - aimag ( sctd ( k1 )) at2 = g ( 1 , ny + 2 - k , j , l ) at1 = g ( 1 , k , j , l ) + at2 at2 = g ( 1 , k , j , l ) - at2 at1 = at3 * at1 at2 = . 5 * at2 g ( 1 , k , j , l ) = at1 + at2 g ( 1 , ny + 2 - k , j , l ) = at1 - at2 at2 = g ( 2 , ny + 2 - k , j , l ) at1 = g ( 2 , k , j , l ) + at2 at2 = g ( 2 , k , j , l ) - at2 sum1 = sum1 + real ( sctd ( k1 )) * at2 at2 = at3 * at2 at1 = . 5 * at1 g ( 2 , k , j , l ) = at1 - at2 g ( 2 , ny + 2 - k , j , l ) = at1 + at2 at2 = g ( 3 , ny + 2 - k , j , l ) at1 = g ( 3 , k , j , l ) + at2 at2 = g ( 3 , k , j , l ) - at2 at1 = at3 * at1 at2 = . 5 * at2 g ( 3 , k , j , l ) = at1 + at2 g ( 3 , ny + 2 - k , j , l ) = at1 - at2 10 continue g ( 1 , 1 , j , l ) = 0.0 g ( 1 , nyh + 1 , j , l ) = 2.0 * g ( 1 , nyh + 1 , j , l ) g ( 2 , 1 , j , l ) = . 5 * ( g ( 2 , 1 , j , l ) + g ( 2 , ny + 1 , j , l )) g ( 2 , ny + 1 , j , l ) = sum1 g ( 3 , 1 , j , l ) = 0.0 g ( 3 , nyh + 1 , j , l ) = 2.0 * g ( 3 , nyh + 1 , j , l ) 20 continue 30 continue c bit-reverse array elements in y nry = nxhy / nyh kxpt = kxps do 70 l = 1 , jblok if (( kxps + kxp * ( l + ks )). eq . nx ) kxpt = kxps + 1 do 60 k = 1 , nyh k1 = ( mixup ( k ) - 1 ) / nry + 1 if ( k . ge . k1 ) go to 60 do 50 j = kxpi , kxpt do 40 jj = 1 , 3 t2 = g ( jj , 2 * k1 - 1 , j , l ) t3 = g ( jj , 2 * k1 , j , l ) g ( jj , 2 * k1 - 1 , j , l ) = g ( jj , 2 * k - 1 , j , l ) g ( jj , 2 * k1 , j , l ) = g ( jj , 2 * k , j , l ) g ( jj , 2 * k - 1 , j , l ) = t2 g ( jj , 2 * k , j , l ) = t3 40 continue 50 continue 60 continue 70 continue c first transform in y nry = nxy / nyh do 130 m = 1 , indy1 ns = 2 ** ( m - 1 ) ns2 = ns + ns km = nyhh / ns kmr = 2 * km * nry kxpt = kxps do 120 l = 1 , jblok if (( kxps + kxp * ( l + ks )). eq . nx ) kxpt = kxps + 1 do 110 k = 1 , km k1 = ns2 * ( k - 1 ) k2 = k1 + ns do 100 j = 1 , ns j1 = j + k1 j2 = j + k2 t1 = sctd ( 1 + kmr * ( j - 1 )) do 90 i = kxpi , kxpt do 80 jj = 1 , 3 t2 = real ( t1 ) * g ( jj , 2 * j2 - 1 , i , l ) - aimag ( t1 ) * g ( jj , 2 * j2 , i , l ) t3 = aimag ( t1 ) * g ( jj , 2 * j2 - 1 , i , l ) + real ( t1 ) * g ( jj , 2 * j2 , i , l ) g ( jj , 2 * j2 - 1 , i , l ) = g ( jj , 2 * j1 - 1 , i , l ) - t2 g ( jj , 2 * j2 , i , l ) = g ( jj , 2 * j1 , i , l ) - t3 g ( jj , 2 * j1 - 1 , i , l ) = g ( jj , 2 * j1 - 1 , i , l ) + t2 g ( jj , 2 * j1 , i , l ) = g ( jj , 2 * j1 , i , l ) + t3 80 continue 90 continue 100 continue 110 continue 120 continue 130 continue c unscramble coefficients and normalize c inverse fourier transform if ( isign . lt . 0 ) then kmr = nxy / nyh ani = 0.5 kxpt = kxps do 190 l = 1 , jblok if (( kxps + kxp * ( l + ks )). eq . nx ) kxpt = kxps + 1 do 160 k = 2 , nyhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( k - 1 ))), - real ( sctd ( 1 + kmr * ( k - 1 )))) do 150 j = kxpi , kxpt do 140 jj = 1 , 3 t4 = g ( jj , ny3 - 2 * k , j , l ) t5 = - g ( jj , ny3 - 2 * k + 1 , j , l ) t2 = g ( jj , 2 * k - 1 , j , l ) + t4 t3 = g ( jj , 2 * k , j , l ) + t5 t6 = g ( jj , 2 * k - 1 , j , l ) - t4 t5 = g ( jj , 2 * k , j , l ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) g ( jj , 2 * k - 1 , j , l ) = ani * ( t2 + t4 ) g ( jj , 2 * k , j , l ) = ani * ( t3 + t5 ) g ( jj , ny3 - 2 * k , j , l ) = ani * ( t2 - t4 ) g ( jj , ny3 - 2 * k + 1 , j , l ) = ani * ( t5 - t3 ) 140 continue 150 continue 160 continue do 180 j = kxpi , kxpt do 170 jj = 1 , 3 g ( jj , nyh + 1 , j , l ) = g ( jj , nyh + 1 , j , l ) g ( jj , nyh + 2 , j , l ) = - g ( jj , nyh + 2 , j , l ) t2 = g ( jj , 1 , j , l ) + g ( jj , 2 , j , l ) g ( jj , 2 , j , l ) = g ( jj , 1 , j , l ) - g ( jj , 2 , j , l ) g ( jj , 1 , j , l ) = t2 g ( jj , ny + 1 , j , l ) = g ( jj , ny + 1 , j , l ) 170 continue 180 continue 190 continue c forward fourier transform else if ( isign . gt . 0 ) then kmr = nxy / nyh kxpt = kxps do 250 l = 1 , jblok if (( kxps + kxp * ( l + ks )). eq . nx ) kxpt = kxps + 1 do 220 k = 2 , nyhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( k - 1 ))), - real ( sctd ( 1 + kmr * ( k - 1 )))) do 210 j = kxpi , kxpt do 200 jj = 1 , 3 t4 = g ( jj , ny3 - 2 * k , j , l ) t5 = - g ( jj , ny3 - 2 * k + 1 , j , l ) t2 = g ( jj , 2 * k - 1 , j , l ) + t4 t3 = g ( jj , 2 * k , j , l ) + t5 t6 = g ( jj , 2 * k - 1 , j , l ) - t4 t5 = g ( jj , 2 * k , j , l ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) g ( jj , 2 * k - 1 , j , l ) = t2 + t4 g ( jj , 2 * k , j , l ) = t3 + t5 g ( jj , ny3 - 2 * k , j , l ) = t2 - t4 g ( jj , ny3 - 2 * k + 1 , j , l ) = t5 - t3 200 continue 210 continue 220 continue do 240 j = kxpi , kxpt do 230 jj = 1 , 3 g ( jj , nyh + 1 , j , l ) = 2.0 * g ( jj , nyh + 1 , j , l ) g ( jj , nyh + 2 , j , l ) = - 2.0 * g ( jj , nyh + 2 , j , l ) t2 = 2.0 * ( g ( jj , 1 , j , l ) + g ( jj , 2 , j , l )) g ( jj , 2 , j , l ) = 2.0 * ( g ( jj , 1 , j , l ) - g ( jj , 2 , j , l )) g ( jj , 1 , j , l ) = t2 g ( jj , ny + 1 , j , l ) = 2.0 * g ( jj , ny + 1 , j , l ) 230 continue 240 continue 250 continue endif c perform recursion for sine-cosine transform kxpt = kxps do 280 l = 1 , jblok if (( kxps + kxp * ( l + ks )). eq . nx ) kxpt = kxps + 1 do 270 j = kxpi , kxpt sum1 = . 5 * g ( 1 , 1 , j , l ) g ( 1 , 1 , j , l ) = 0.0 g ( 1 , 2 , j , l ) = sum1 sum2 = g ( 2 , ny + 1 , j , l ) g ( 2 , ny + 1 , j , l ) = g ( 2 , 2 , j , l ) g ( 2 , 2 , j , l ) = sum2 sum3 = . 5 * g ( 3 , 1 , j , l ) g ( 3 , 1 , j , l ) = 0.0 g ( 3 , 2 , j , l ) = sum3 do 260 k = 2 , nyh sum1 = sum1 + g ( 1 , 2 * k - 1 , j , l ) g ( 1 , 2 * k - 1 , j , l ) = - g ( 1 , 2 * k , j , l ) g ( 1 , 2 * k , j , l ) = sum1 sum2 = sum2 - g ( 2 , 2 * k , j , l ) g ( 2 , 2 * k , j , l ) = sum2 sum3 = sum3 + g ( 3 , 2 * k - 1 , j , l ) g ( 3 , 2 * k - 1 , j , l ) = - g ( 3 , 2 * k , j , l ) g ( 3 , 2 * k , j , l ) = sum3 260 continue g ( 1 , ny + 1 , j , l ) = 0.0 g ( 3 , ny + 1 , j , l ) = 0.0 270 continue 280 continue return end c----------------------------------------------------------------------- subroutine PFCSCT2R3Y ( g , isign , mixup , sctd , indx , indy , kstrt , kxp , kxpi , 1 kxpp , nyv , kxpd , jblok , nxhyd , nxyd ) c this subroutine performs the y part of 3 two dimensional fast real c sine and cosine transforms and their inverses, for a subset of x, c using real arithmetic, for data which is distributed in blocks c algorithm is described in Numerical Recipies in Fortran, Second Ed., c by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, c [Cambridge Univ. Press, 1992], p. 508. c for isign = (-1,1), input: all, output: f c approximate flop count: N*(5*log2(N) + 18)/nvp c where N = (nx/2)*ny c indx/indy = exponent which determines length in x/y direction, c where nx=2**indx, ny=2**indy c if isign = -1, inverse sine-cosine transform are performed c g(1,m,n,i) = (.5*g(1,1,n,i) + ((-1)**m)*g(1,ny+1,n,i) c              + sum(g(1,k,n,i)*cos(pi*m*k/ny)) c g(2,m,n,i) = sum(g(2,k,n,i)*sin(pi*m*k/ny)) c g(3,m,n,i) = (.5*g(3,1,n,i) + ((-1)**m)*g(3,ny+1,n,i) c              + sum(g(3,k,n,i)*cos(pi*m*k/ny)) c if isign = 1, a forward sine-cosine transforms are performed c g(1,k,n,i) = 2*(.5*g(1,1,n,i) + ((-1)**m)*g(1,ny+1,n,i) c              + sum(g(1,m,n,i)*cos(pi*m*k/ny)) c g(2,k,n,i) = sum(g(2,m,n,i)*sin(pi*m*k/ny)) c g(3,k,n,i) = 2*(.5*g(3,1,n,i) + ((-1)**m)*g(3,ny+1,n,i) c              + sum(g(3,m,n,i)*cos(pi*m*k/ny)) c mixup = array of bit reversed addresses c sctd = sine/cosine table c kstrt = starting data block number c kxp = number of data values per block in x c kxpi = initial x index used c kxpp = number of x indices used c nyv = first dimension of g >= ny + 1 c kxpd = second dimension of g >= kxp + 1 c jblok = number of data blocks in x c nxhyd = maximum of (nx/2,ny) c nxyd = maximum of (nx,ny) c written by viktor k. decyk, ucla implicit none integer isign , mixup , indx , indy , kstrt , kxp , kxpi , kxpp integer nyv , kxpd , jblok , nxhyd , nxyd real g complex sctd dimension g ( 3 , nyv , kxpd , jblok ) dimension mixup ( nxhyd ), sctd ( nxyd ) c local data integer indx1 , indy1 , indx1y , nx , ny , nyh , nyhh , ny3 , nxy , nxhy integer i , j , k , l , m , ks , km , kmr , nry , j1 , j2 , ns , ns2 , k1 , k2 integer kxps , kxpt , jj real at1 , at2 , at3 , t2 , t3 , t4 , t5 , t6 , ani , sum1 , sum2 , sum3 complex t1 indx1 = indx - 1 indy1 = indy - 1 indx1y = max0 ( indx1 , indy ) nx = 2 ** indx ny = 2 ** indy nyh = ny / 2 nyhh = ny / 4 ny3 = ny + 3 nxy = max0 ( nx , ny ) nxhy = 2 ** indx1y ks = kstrt - 2 kxps = kxpi + kxpp - 1 if ( kstrt . gt . nx ) return if ( isign . eq . 0 ) return c create auxiliary array in y kmr = nxy / ny kxpt = kxps do 30 l = 1 , jblok if (( kxps + kxp * ( l + ks )). eq . nx ) kxpt = kxps + 1 do 20 j = kxpi , kxpt sum1 = . 5 * ( g ( 1 , 1 , j , l ) - g ( 1 , ny + 1 , j , l )) sum2 = . 5 * ( g ( 3 , 1 , j , l ) - g ( 3 , ny + 1 , j , l )) do 10 k = 2 , nyh k1 = 1 + kmr * ( k - 1 ) at3 = - aimag ( sctd ( k1 )) at2 = g ( 1 , ny + 2 - k , j , l ) at1 = g ( 1 , k , j , l ) + at2 at2 = g ( 1 , k , j , l ) - at2 sum1 = sum1 + real ( sctd ( k1 )) * at2 at2 = at3 * at2 at1 = . 5 * at1 g ( 1 , k , j , l ) = at1 - at2 g ( 1 , ny + 2 - k , j , l ) = at1 + at2 at2 = g ( 2 , ny + 2 - k , j , l ) at1 = g ( 2 , k , j , l ) + at2 at2 = g ( 2 , k , j , l ) - at2 at1 = at3 * at1 at2 = . 5 * at2 g ( 2 , k , j , l ) = at1 + at2 g ( 2 , ny + 2 - k , j , l ) = at1 - at2 at2 = g ( 3 , ny + 2 - k , j , l ) at1 = g ( 3 , k , j , l ) + at2 at2 = g ( 3 , k , j , l ) - at2 sum2 = sum2 + real ( sctd ( k1 )) * at2 at2 = at3 * at2 at1 = . 5 * at1 g ( 3 , k , j , l ) = at1 - at2 g ( 3 , ny + 2 - k , j , l ) = at1 + at2 10 continue g ( 1 , 1 , j , l ) = . 5 * ( g ( 1 , 1 , j , l ) + g ( 1 , ny + 1 , j , l )) g ( 1 , ny + 1 , j , l ) = sum1 g ( 2 , 1 , j , l ) = 0.0 g ( 2 , nyh + 1 , j , l ) = 2.0 * g ( 2 , nyh + 1 , j , l ) g ( 3 , 1 , j , l ) = . 5 * ( g ( 3 , 1 , j , l ) + g ( 3 , ny + 1 , j , l )) g ( 3 , ny + 1 , j , l ) = sum2 20 continue 30 continue c bit-reverse array elements in y nry = nxhy / nyh kxpt = kxps do 70 l = 1 , jblok if (( kxps + kxp * ( l + ks )). eq . nx ) kxpt = kxps + 1 do 60 k = 1 , nyh k1 = ( mixup ( k ) - 1 ) / nry + 1 if ( k . ge . k1 ) go to 60 do 50 j = kxpi , kxpt do 40 jj = 1 , 3 t2 = g ( jj , 2 * k1 - 1 , j , l ) t3 = g ( jj , 2 * k1 , j , l ) g ( jj , 2 * k1 - 1 , j , l ) = g ( jj , 2 * k - 1 , j , l ) g ( jj , 2 * k1 , j , l ) = g ( jj , 2 * k , j , l ) g ( jj , 2 * k - 1 , j , l ) = t2 g ( jj , 2 * k , j , l ) = t3 40 continue 50 continue 60 continue 70 continue c first transform in y nry = nxy / nyh do 130 m = 1 , indy1 ns = 2 ** ( m - 1 ) ns2 = ns + ns km = nyhh / ns kmr = 2 * km * nry kxpt = kxps do 120 l = 1 , jblok if (( kxps + kxp * ( l + ks )). eq . nx ) kxpt = kxps + 1 do 110 k = 1 , km k1 = ns2 * ( k - 1 ) k2 = k1 + ns do 100 j = 1 , ns j1 = j + k1 j2 = j + k2 t1 = sctd ( 1 + kmr * ( j - 1 )) do 90 i = kxpi , kxpt do 80 jj = 1 , 3 t2 = real ( t1 ) * g ( jj , 2 * j2 - 1 , i , l ) - aimag ( t1 ) * g ( jj , 2 * j2 , i , l ) t3 = aimag ( t1 ) * g ( jj , 2 * j2 - 1 , i , l ) + real ( t1 ) * g ( jj , 2 * j2 , i , l ) g ( jj , 2 * j2 - 1 , i , l ) = g ( jj , 2 * j1 - 1 , i , l ) - t2 g ( jj , 2 * j2 , i , l ) = g ( jj , 2 * j1 , i , l ) - t3 g ( jj , 2 * j1 - 1 , i , l ) = g ( jj , 2 * j1 - 1 , i , l ) + t2 g ( jj , 2 * j1 , i , l ) = g ( jj , 2 * j1 , i , l ) + t3 80 continue 90 continue 100 continue 110 continue 120 continue 130 continue c unscramble coefficients and normalize c inverse fourier transform if ( isign . lt . 0 ) then kmr = nxy / nyh ani = 0.5 kxpt = kxps do 190 l = 1 , jblok if (( kxps + kxp * ( l + ks )). eq . nx ) kxpt = kxps + 1 do 160 k = 2 , nyhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( k - 1 ))), - real ( sctd ( 1 + kmr * ( k - 1 )))) do 150 j = kxpi , kxpt do 140 jj = 1 , 3 t4 = g ( jj , ny3 - 2 * k , j , l ) t5 = - g ( jj , ny3 - 2 * k + 1 , j , l ) t2 = g ( jj , 2 * k - 1 , j , l ) + t4 t3 = g ( jj , 2 * k , j , l ) + t5 t6 = g ( jj , 2 * k - 1 , j , l ) - t4 t5 = g ( jj , 2 * k , j , l ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) g ( jj , 2 * k - 1 , j , l ) = ani * ( t2 + t4 ) g ( jj , 2 * k , j , l ) = ani * ( t3 + t5 ) g ( jj , ny3 - 2 * k , j , l ) = ani * ( t2 - t4 ) g ( jj , ny3 - 2 * k + 1 , j , l ) = ani * ( t5 - t3 ) 140 continue 150 continue 160 continue do 180 j = kxpi , kxpt do 170 jj = 1 , 3 g ( jj , nyh + 1 , j , l ) = g ( jj , nyh + 1 , j , l ) g ( jj , nyh + 2 , j , l ) = - g ( jj , nyh + 2 , j , l ) t2 = g ( jj , 1 , j , l ) + g ( jj , 2 , j , l ) g ( jj , 2 , j , l ) = g ( jj , 1 , j , l ) - g ( jj , 2 , j , l ) g ( jj , 1 , j , l ) = t2 g ( jj , ny + 1 , j , l ) = g ( jj , ny + 1 , j , l ) 170 continue 180 continue 190 continue c forward fourier transform else if ( isign . gt . 0 ) then kmr = nxy / nyh kxpt = kxps do 250 l = 1 , jblok if (( kxps + kxp * ( l + ks )). eq . nx ) kxpt = kxps + 1 do 220 k = 2 , nyhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( k - 1 ))), - real ( sctd ( 1 + kmr * ( k - 1 )))) do 210 j = kxpi , kxpt do 200 jj = 1 , 3 t4 = g ( jj , ny3 - 2 * k , j , l ) t5 = - g ( jj , ny3 - 2 * k + 1 , j , l ) t2 = g ( jj , 2 * k - 1 , j , l ) + t4 t3 = g ( jj , 2 * k , j , l ) + t5 t6 = g ( jj , 2 * k - 1 , j , l ) - t4 t5 = g ( jj , 2 * k , j , l ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) g ( jj , 2 * k - 1 , j , l ) = t2 + t4 g ( jj , 2 * k , j , l ) = t3 + t5 g ( jj , ny3 - 2 * k , j , l ) = t2 - t4 g ( jj , ny3 - 2 * k + 1 , j , l ) = t5 - t3 200 continue 210 continue 220 continue do 240 j = kxpi , kxpt do 230 jj = 1 , 3 g ( jj , nyh + 1 , j , l ) = 2.0 * g ( jj , nyh + 1 , j , l ) g ( jj , nyh + 2 , j , l ) = - 2.0 * g ( jj , nyh + 2 , j , l ) t2 = 2.0 * ( g ( jj , 1 , j , l ) + g ( jj , 2 , j , l )) g ( jj , 2 , j , l ) = 2.0 * ( g ( jj , 1 , j , l ) - g ( jj , 2 , j , l )) g ( jj , 1 , j , l ) = t2 g ( jj , ny + 1 , j , l ) = 2.0 * g ( jj , ny + 1 , j , l ) 230 continue 240 continue 250 continue endif c perform recursion for sine-cosine transform kxpt = kxps do 280 l = 1 , jblok if (( kxps + kxp * ( l + ks )). eq . nx ) kxpt = kxps + 1 do 270 j = kxpi , kxpt sum1 = g ( 1 , ny + 1 , j , l ) g ( 1 , ny + 1 , j , l ) = g ( 1 , 2 , j , l ) g ( 1 , 2 , j , l ) = sum1 sum2 = . 5 * g ( 2 , 1 , j , l ) g ( 2 , 1 , j , l ) = 0.0 g ( 2 , 2 , j , l ) = sum2 sum3 = g ( 3 , ny + 1 , j , l ) g ( 3 , ny + 1 , j , l ) = g ( 3 , 2 , j , l ) g ( 3 , 2 , j , l ) = sum3 do 260 k = 2 , nyh sum1 = sum1 - g ( 1 , 2 * k , j , l ) g ( 1 , 2 * k , j , l ) = sum1 sum2 = sum2 + g ( 2 , 2 * k - 1 , j , l ) g ( 2 , 2 * k - 1 , j , l ) = - g ( 2 , 2 * k , j , l ) g ( 2 , 2 * k , j , l ) = sum2 sum3 = sum3 - g ( 3 , 2 * k , j , l ) g ( 3 , 2 * k , j , l ) = sum3 260 continue g ( 2 , ny + 1 , j , l ) = 0.0 270 continue 280 continue return end c----------------------------------------------------------------------- subroutine PFSSCT2R3Y ( g , isign , mixup , sctd , indx , indy , kstrt , kxp , kxpi , 1 kxpp , nyv , kxpd , jblok , nxhyd , nxyd ) c this subroutine performs the y part of 3 two dimensional fast real c sine and cosine transforms and their inverses, for a subset of x, c using real arithmetic, for data which is distributed in blocks c algorithm is described in Numerical Recipies in Fortran, Second Ed., c by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, c [Cambridge Univ. Press, 1992], p. 508. c for isign = (-1,1), input: all, output: f c approximate flop count: N*(5*log2(N) + 18)/nvp c where N = (nx/2)*ny c indx/indy = exponent which determines length in x/y direction, c where nx=2**indx, ny=2**indy c if isign = -1, inverse sine-cosine transform are performed c g(1,m,n,i) = (.5*g(1,1,n,i) + ((-1)**m)*g(1,ny+1,n,i) c              + sum(g(1,k,n,i)*cos(pi*m*k/ny)) c g(2,m,n,i) = sum(g(2,k,n,i)*sin(pi*m*k/ny)) c g(3,m,n,i) = (.5*g(3,1,n,i) + ((-1)**m)*g(3,ny+1,n,i) c              + sum(g(3,k,n,i)*cos(pi*m*k/ny)) c if isign = 1, a forward sine-cosine transforms are performed c g(1,k,n,i) = 2*(.5*g(1,1,n,i) + ((-1)**m)*g(1,ny+1,n,i) c              + sum(g(1,m,n,i)*cos(pi*m*k/ny)) c g(2,k,n,i) = sum(g(2,m,n,i)*sin(pi*m*k/ny)) c g(3,k,n,i) = 2*(.5*g(3,1,n,i) + ((-1)**m)*g(3,ny+1,n,i) c              + sum(g(3,m,n,i)*cos(pi*m*k/ny)) c mixup = array of bit reversed addresses c sctd = sine/cosine table c kstrt = starting data block number c kxp = number of data values per block in x c kxpi = initial x index used c kxpp = number of x indices used c nyv = first dimension of g >= ny + 1 c kxpd = second dimension of g >= kxp + 1 c jblok = number of data blocks in x c nxhyd = maximum of (nx/2,ny) c nxyd = maximum of (nx,ny) c written by viktor k. decyk, ucla implicit none integer isign , mixup , indx , indy , kstrt , kxp , kxpi , kxpp integer nyv , kxpd , jblok , nxhyd , nxyd real g complex sctd dimension g ( 3 , nyv , kxpd , jblok ) dimension mixup ( nxhyd ), sctd ( nxyd ) c local data integer indx1 , indy1 , indx1y , nx , ny , nyh , nyhh , ny3 , nxy , nxhy integer i , j , k , l , m , ks , km , kmr , nry , j1 , j2 , ns , ns2 , k1 , k2 integer kxps , kxpt , jj real at1 , at2 , at3 , t2 , t3 , t4 , t5 , t6 , ani , sum1 , sum2 , sum3 complex t1 indx1 = indx - 1 indy1 = indy - 1 indx1y = max0 ( indx1 , indy ) nx = 2 ** indx ny = 2 ** indy nyh = ny / 2 nyhh = ny / 4 ny3 = ny + 3 nxy = max0 ( nx , ny ) nxhy = 2 ** indx1y ks = kstrt - 2 kxps = kxpi + kxpp - 1 if ( kstrt . gt . nx ) return if ( isign . eq . 0 ) return c create auxiliary array in y kmr = nxy / ny kxpt = kxps do 30 l = 1 , jblok if (( kxps + kxp * ( l + ks )). eq . nx ) kxpt = kxps + 1 do 20 j = kxpi , kxpt sum2 = . 5 * ( g ( 3 , 1 , j , l ) - g ( 3 , ny + 1 , j , l )) do 10 k = 2 , nyh k1 = 1 + kmr * ( k - 1 ) at3 = - aimag ( sctd ( k1 )) at2 = g ( 1 , ny + 2 - k , j , l ) at1 = g ( 1 , k , j , l ) + at2 at2 = g ( 1 , k , j , l ) - at2 at1 = at3 * at1 at2 = . 5 * at2 g ( 1 , k , j , l ) = at1 + at2 g ( 1 , ny + 2 - k , j , l ) = at1 - at2 at2 = g ( 2 , ny + 2 - k , j , l ) at1 = g ( 2 , k , j , l ) + at2 at2 = g ( 2 , k , j , l ) - at2 at1 = at3 * at1 at2 = . 5 * at2 g ( 2 , k , j , l ) = at1 + at2 g ( 2 , ny + 2 - k , j , l ) = at1 - at2 at2 = g ( 3 , ny + 2 - k , j , l ) at1 = g ( 3 , k , j , l ) + at2 at2 = g ( 3 , k , j , l ) - at2 sum2 = sum2 + real ( sctd ( k1 )) * at2 at2 = at3 * at2 at1 = . 5 * at1 g ( 3 , k , j , l ) = at1 - at2 g ( 3 , ny + 2 - k , j , l ) = at1 + at2 10 continue g ( 1 , 1 , j , l ) = 0.0 g ( 1 , nyh + 1 , j , l ) = 2.0 * g ( 1 , nyh + 1 , j , l ) g ( 2 , 1 , j , l ) = 0.0 g ( 2 , nyh + 1 , j , l ) = 2.0 * g ( 2 , nyh + 1 , j , l ) g ( 3 , 1 , j , l ) = . 5 * ( g ( 3 , 1 , j , l ) + g ( 3 , ny + 1 , j , l )) g ( 3 , ny + 1 , j , l ) = sum2 20 continue 30 continue c bit-reverse array elements in y nry = nxhy / nyh kxpt = kxps do 70 l = 1 , jblok if (( kxps + kxp * ( l + ks )). eq . nx ) kxpt = kxps + 1 do 60 k = 1 , nyh k1 = ( mixup ( k ) - 1 ) / nry + 1 if ( k . ge . k1 ) go to 60 do 50 j = kxpi , kxpt do 40 jj = 1 , 3 t2 = g ( jj , 2 * k1 - 1 , j , l ) t3 = g ( jj , 2 * k1 , j , l ) g ( jj , 2 * k1 - 1 , j , l ) = g ( jj , 2 * k - 1 , j , l ) g ( jj , 2 * k1 , j , l ) = g ( jj , 2 * k , j , l ) g ( jj , 2 * k - 1 , j , l ) = t2 g ( jj , 2 * k , j , l ) = t3 40 continue 50 continue 60 continue 70 continue c first transform in y nry = nxy / nyh do 130 m = 1 , indy1 ns = 2 ** ( m - 1 ) ns2 = ns + ns km = nyhh / ns kmr = 2 * km * nry kxpt = kxps do 120 l = 1 , jblok if (( kxps + kxp * ( l + ks )). eq . nx ) kxpt = kxps + 1 do 110 k = 1 , km k1 = ns2 * ( k - 1 ) k2 = k1 + ns do 100 j = 1 , ns j1 = j + k1 j2 = j + k2 t1 = sctd ( 1 + kmr * ( j - 1 )) do 90 i = kxpi , kxpt do 80 jj = 1 , 3 t2 = real ( t1 ) * g ( jj , 2 * j2 - 1 , i , l ) - aimag ( t1 ) * g ( jj , 2 * j2 , i , l ) t3 = aimag ( t1 ) * g ( jj , 2 * j2 - 1 , i , l ) + real ( t1 ) * g ( jj , 2 * j2 , i , l ) g ( jj , 2 * j2 - 1 , i , l ) = g ( jj , 2 * j1 - 1 , i , l ) - t2 g ( jj , 2 * j2 , i , l ) = g ( jj , 2 * j1 , i , l ) - t3 g ( jj , 2 * j1 - 1 , i , l ) = g ( jj , 2 * j1 - 1 , i , l ) + t2 g ( jj , 2 * j1 , i , l ) = g ( jj , 2 * j1 , i , l ) + t3 80 continue 90 continue 100 continue 110 continue 120 continue 130 continue c unscramble coefficients and normalize c inverse fourier transform if ( isign . lt . 0 ) then kmr = nxy / nyh ani = 0.5 kxpt = kxps do 190 l = 1 , jblok if (( kxps + kxp * ( l + ks )). eq . nx ) kxpt = kxps + 1 do 160 k = 2 , nyhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( k - 1 ))), - real ( sctd ( 1 + kmr * ( k - 1 )))) do 150 j = kxpi , kxpt do 140 jj = 1 , 3 t4 = g ( jj , ny3 - 2 * k , j , l ) t5 = - g ( jj , ny3 - 2 * k + 1 , j , l ) t2 = g ( jj , 2 * k - 1 , j , l ) + t4 t3 = g ( jj , 2 * k , j , l ) + t5 t6 = g ( jj , 2 * k - 1 , j , l ) - t4 t5 = g ( jj , 2 * k , j , l ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) g ( jj , 2 * k - 1 , j , l ) = ani * ( t2 + t4 ) g ( jj , 2 * k , j , l ) = ani * ( t3 + t5 ) g ( jj , ny3 - 2 * k , j , l ) = ani * ( t2 - t4 ) g ( jj , ny3 - 2 * k + 1 , j , l ) = ani * ( t5 - t3 ) 140 continue 150 continue 160 continue do 180 j = kxpi , kxpt do 170 jj = 1 , 3 g ( jj , nyh + 1 , j , l ) = g ( jj , nyh + 1 , j , l ) g ( jj , nyh + 2 , j , l ) = - g ( jj , nyh + 2 , j , l ) t2 = g ( jj , 1 , j , l ) + g ( jj , 2 , j , l ) g ( jj , 2 , j , l ) = g ( jj , 1 , j , l ) - g ( jj , 2 , j , l ) g ( jj , 1 , j , l ) = t2 g ( jj , ny + 1 , j , l ) = g ( jj , ny + 1 , j , l ) 170 continue 180 continue 190 continue c forward fourier transform else if ( isign . gt . 0 ) then kmr = nxy / nyh kxpt = kxps do 250 l = 1 , jblok if (( kxps + kxp * ( l + ks )). eq . nx ) kxpt = kxps + 1 do 220 k = 2 , nyhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( k - 1 ))), - real ( sctd ( 1 + kmr * ( k - 1 )))) do 210 j = kxpi , kxpt do 200 jj = 1 , 3 t4 = g ( jj , ny3 - 2 * k , j , l ) t5 = - g ( jj , ny3 - 2 * k + 1 , j , l ) t2 = g ( jj , 2 * k - 1 , j , l ) + t4 t3 = g ( jj , 2 * k , j , l ) + t5 t6 = g ( jj , 2 * k - 1 , j , l ) - t4 t5 = g ( jj , 2 * k , j , l ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) g ( jj , 2 * k - 1 , j , l ) = t2 + t4 g ( jj , 2 * k , j , l ) = t3 + t5 g ( jj , ny3 - 2 * k , j , l ) = t2 - t4 g ( jj , ny3 - 2 * k + 1 , j , l ) = t5 - t3 200 continue 210 continue 220 continue do 240 j = kxpi , kxpt do 230 jj = 1 , 3 g ( jj , nyh + 1 , j , l ) = 2.0 * g ( jj , nyh + 1 , j , l ) g ( jj , nyh + 2 , j , l ) = - 2.0 * g ( jj , nyh + 2 , j , l ) t2 = 2.0 * ( g ( jj , 1 , j , l ) + g ( jj , 2 , j , l )) g ( jj , 2 , j , l ) = 2.0 * ( g ( jj , 1 , j , l ) - g ( jj , 2 , j , l )) g ( jj , 1 , j , l ) = t2 g ( jj , ny + 1 , j , l ) = 2.0 * g ( jj , ny + 1 , j , l ) 230 continue 240 continue 250 continue endif c perform recursion for sine-cosine transform kxpt = kxps do 280 l = 1 , jblok if (( kxps + kxp * ( l + ks )). eq . nx ) kxpt = kxps + 1 do 270 j = kxpi , kxpt sum1 = . 5 * g ( 1 , 1 , j , l ) g ( 1 , 1 , j , l ) = 0.0 g ( 1 , 2 , j , l ) = sum1 sum2 = . 5 * g ( 2 , 1 , j , l ) g ( 2 , 1 , j , l ) = 0.0 g ( 2 , 2 , j , l ) = sum2 sum3 = g ( 3 , ny + 1 , j , l ) g ( 3 , ny + 1 , j , l ) = g ( 3 , 2 , j , l ) g ( 3 , 2 , j , l ) = sum3 do 260 k = 2 , nyh sum1 = sum1 + g ( 1 , 2 * k - 1 , j , l ) g ( 1 , 2 * k - 1 , j , l ) = - g ( 1 , 2 * k , j , l ) g ( 1 , 2 * k , j , l ) = sum1 sum2 = sum2 + g ( 2 , 2 * k - 1 , j , l ) g ( 2 , 2 * k - 1 , j , l ) = - g ( 2 , 2 * k , j , l ) g ( 2 , 2 * k , j , l ) = sum2 sum3 = sum3 - g ( 3 , 2 * k , j , l ) g ( 3 , 2 * k , j , l ) = sum3 260 continue g ( 1 , ny + 1 , j , l ) = 0.0 g ( 2 , ny + 1 , j , l ) = 0.0 270 continue 280 continue return end c----------------------------------------------------------------------- subroutine PFSSCT2R3X ( f , isign , mixup , sctd , indx , indy , kstrt , kyp , kypi , 1 kypp , nxvh , kypd , kblok , nxhyd , nxyd ) c this subroutine performs the x part of 3 two dimensional fast real c sine and cosine transforms and their inverses, for a subset of y, c using real arithmetic, for data which is distributed in blocks c algorithm is described in Numerical Recipies in Fortran, Second Ed., c by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, c [Cambridge Univ. Press, 1992], p. 508. c for isign = (-1,1), input: all, output: f c approximate flop count: N*(5*log2(N) + 18)/nvp c where N = (nx/2)*ny c indx/indy = exponent which determines length in x/y direction, c where nx=2**indx, ny=2**indy c if isign = -1, inverse sine-cosine transforms are performed c f(1,n,k,i) = (1/nx*ny)*sum(f(1,j,k,i)*sin(pi*n*j/nx)) c f(2:3,n,k,i) = (1/nx*ny)*(.5*f(2:3,1,k,i) + ((-1)**n)*f(2:3,nx+1,k,i) c              + sum(f(2:3,j,k,i)*cos(pi*n*j/nx))) c if isign = 1, forward sine transforms are performed c f(1,j,k,i) = sum(f(1,n,k,i)*sin(pi*n*j/nx)) c f(2:3,j,k,i) = 2*(.5*f(2:3,1,k,i) + ((-1)**j)*f(2:3,n+1,k,i) c              + sum(f(2:3,n,k,i)*cos(pi*n*j/nx)) c mixup = array of bit reversed addresses c sctd = sine/cosine table c kstrt = starting data block number c kyp = number of data values per block in y c kypi = initial y index used c kypp = number of y indices used c nxvh = first dimension of f >= nx/2 + 1 c kypd = second dimension of f >= kyp + 1 c kblok = number of data blocks in y c nxhyd = maximum of (nx/2,ny) c nxyd = maximum of (nx,ny) c written by viktor k. decyk, ucla implicit none integer isign , mixup , indx , indy , kstrt , kyp , kypi , kypp integer nxvh , kypd , kblok , nxhyd , nxyd real f complex sctd dimension f ( 3 , 2 * nxvh , kypd , kblok ) dimension mixup ( nxhyd ), sctd ( nxyd ) c local data integer indx1 , indx1y , nx , nxh , nxhh , nx3 , ny , nxy , nxhy , ks , kypt integer i , j , k , l , m , km , kmr , nrx , j1 , j2 , ns , ns2 , k1 , k2 , kyps integer jj real at1 , at2 , at3 , t2 , t3 , t4 , t5 , t6 , ani , sum1 , sum2 , sum3 complex t1 indx1 = indx - 1 indx1y = max0 ( indx1 , indy ) nx = 2 ** indx nxh = nx / 2 nxhh = nx / 4 nx3 = nx + 3 ny = 2 ** indy nxy = max0 ( nx , ny ) nxhy = 2 ** indx1y ks = kstrt - 2 kyps = kypi + kypp - 1 if ( kstrt . gt . ny ) return if ( isign . eq . 0 ) return c create auxiliary array in x kmr = nxy / nx kypt = kyps do 30 l = 1 , kblok if (( kyps + kyp * ( l + ks )). eq . ny ) kypt = kyps + 1 do 20 k = kypi , kypt sum2 = . 5 * ( f ( 3 , 1 , k , l ) - f ( 3 , nx + 1 , k , l )) do 10 j = 2 , nxh j1 = 1 + kmr * ( j - 1 ) at3 = - aimag ( sctd ( j1 )) at2 = f ( 1 , nx + 2 - j , k , l ) at1 = f ( 1 , j , k , l ) + at2 at2 = f ( 1 , j , k , l ) - at2 at1 = at3 * at1 at2 = . 5 * at2 f ( 1 , j , k , l ) = at1 + at2 f ( 1 , nx + 2 - j , k , l ) = at1 - at2 at2 = f ( 2 , nx + 2 - j , k , l ) at1 = f ( 2 , j , k , l ) + at2 at2 = f ( 2 , j , k , l ) - at2 at1 = at3 * at1 at2 = . 5 * at2 f ( 2 , j , k , l ) = at1 + at2 f ( 2 , nx + 2 - j , k , l ) = at1 - at2 at2 = f ( 3 , nx + 2 - j , k , l ) at1 = f ( 3 , j , k , l ) + at2 at2 = f ( 3 , j , k , l ) - at2 sum2 = sum2 + real ( sctd ( j1 )) * at2 at2 = at3 * at2 at1 = . 5 * at1 f ( 3 , j , k , l ) = at1 - at2 f ( 3 , nx + 2 - j , k , l ) = at1 + at2 10 continue f ( 1 , 1 , k , l ) = 0.0 f ( 1 , nxh + 1 , k , l ) = 2.0 * f ( 1 , nxh + 1 , k , l ) f ( 2 , 1 , k , l ) = 0.0 f ( 2 , nxh + 1 , k , l ) = 2.0 * f ( 2 , nxh + 1 , k , l ) f ( 3 , 1 , k , l ) = . 5 * ( f ( 3 , 1 , k , l ) + f ( 3 , nx + 1 , k , l )) f ( 3 , nx + 1 , k , l ) = sum2 20 continue 30 continue c bit-reverse array elements in x nrx = nxhy / nxh kypt = kyps do 70 l = 1 , kblok if (( kyps + kyp * ( l + ks )). eq . ny ) kypt = kyps + 1 do 60 j = 1 , nxh j1 = ( mixup ( j ) - 1 ) / nrx + 1 if ( j . ge . j1 ) go to 60 do 50 k = kypi , kypt do 40 jj = 1 , 3 t2 = f ( jj , 2 * j1 - 1 , k , l ) t3 = f ( jj , 2 * j1 , k , l ) f ( jj , 2 * j1 - 1 , k , l ) = f ( jj , 2 * j - 1 , k , l ) f ( jj , 2 * j1 , k , l ) = f ( jj , 2 * j , k , l ) f ( jj , 2 * j - 1 , k , l ) = t2 f ( jj , 2 * j , k , l ) = t3 40 continue 50 continue 60 continue 70 continue c first transform in x nrx = nxy / nxh do 130 m = 1 , indx1 ns = 2 ** ( m - 1 ) ns2 = ns + ns km = nxhh / ns kmr = 2 * km * nrx kypt = kyps do 120 l = 1 , kblok if (( kyps + kyp * ( l + ks )). eq . ny ) kypt = kyps + 1 do 110 k = 1 , km k1 = ns2 * ( k - 1 ) k2 = k1 + ns do 100 j = 1 , ns j1 = j + k1 j2 = j + k2 t1 = sctd ( 1 + kmr * ( j - 1 )) do 90 i = kypi , kypt do 80 jj = 1 , 3 t2 = real ( t1 ) * f ( jj , 2 * j2 - 1 , i , l ) - aimag ( t1 ) * f ( jj , 2 * j2 , i , l ) t3 = aimag ( t1 ) * f ( jj , 2 * j2 - 1 , i , l ) + real ( t1 ) * f ( jj , 2 * j2 , i , l ) f ( jj , 2 * j2 - 1 , i , l ) = f ( jj , 2 * j1 - 1 , i , l ) - t2 f ( jj , 2 * j2 , i , l ) = f ( jj , 2 * j1 , i , l ) - t3 f ( jj , 2 * j1 - 1 , i , l ) = f ( jj , 2 * j1 - 1 , i , l ) + t2 f ( jj , 2 * j1 , i , l ) = f ( jj , 2 * j1 , i , l ) + t3 80 continue 90 continue 100 continue 110 continue 120 continue 130 continue c unscramble coefficients and normalize c inverse fourier transform if ( isign . lt . 0 ) then kmr = nxy / nxh ani = 1. / float ( 2 * nx * ny ) kypt = kyps do 190 l = 1 , kblok if (( kyps + kyp * ( l + ks )). eq . ny ) kypt = kyps + 1 do 160 j = 2 , nxhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( j - 1 ))), - real ( sctd ( 1 + kmr * ( j - 1 )))) do 150 k = kypi , kypt do 140 jj = 1 , 3 t4 = f ( jj , nx3 - 2 * j , k , l ) t5 = - f ( jj , nx3 - 2 * j + 1 , k , l ) t2 = f ( jj , 2 * j - 1 , k , l ) + t4 t3 = f ( jj , 2 * j , k , l ) + t5 t6 = f ( jj , 2 * j - 1 , k , l ) - t4 t5 = f ( jj , 2 * j , k , l ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) f ( jj , 2 * j - 1 , k , l ) = ani * ( t2 + t4 ) f ( jj , 2 * j , k , l ) = ani * ( t3 + t5 ) f ( jj , nx3 - 2 * j , k , l ) = ani * ( t2 - t4 ) f ( jj , nx3 - 2 * j + 1 , k , l ) = ani * ( t5 - t3 ) 140 continue 150 continue 160 continue ani = 2. * ani do 180 k = kypi , kypt do 170 jj = 1 , 3 f ( jj , nxh + 1 , k , l ) = ani * f ( jj , nxh + 1 , k , l ) f ( jj , nxh + 2 , k , l ) = - ani * f ( jj , nxh + 2 , k , l ) t2 = ani * ( f ( jj , 1 , k , l ) + f ( jj , 2 , k , l )) f ( jj , 2 , k , l ) = ani * ( f ( jj , 1 , k , l ) - f ( jj , 2 , k , l )) f ( jj , 1 , k , l ) = t2 f ( jj , nx + 1 , k , l ) = ani * f ( jj , nx + 1 , k , l ) 170 continue 180 continue 190 continue c forward fourier transform else if ( isign . gt . 0 ) then kmr = nxy / nxh kypt = kyps do 250 l = 1 , kblok if (( kyps + kyp * ( l + ks )). eq . ny ) kypt = kyps + 1 do 220 j = 2 , nxhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( j - 1 ))), - real ( sctd ( 1 + kmr * ( j - 1 )))) do 210 k = kypi , kypt do 200 jj = 1 , 3 t4 = f ( jj , nx3 - 2 * j , k , l ) t5 = - f ( jj , nx3 - 2 * j + 1 , k , l ) t2 = f ( jj , 2 * j - 1 , k , l ) + t4 t3 = f ( jj , 2 * j , k , l ) + t5 t6 = f ( jj , 2 * j - 1 , k , l ) - t4 t5 = f ( jj , 2 * j , k , l ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) f ( jj , 2 * j - 1 , k , l ) = t2 + t4 f ( jj , 2 * j , k , l ) = t3 + t5 f ( jj , nx3 - 2 * j , k , l ) = t2 - t4 f ( jj , nx3 - 2 * j + 1 , k , l ) = t5 - t3 200 continue 210 continue 220 continue do 240 k = kypi , kypt do 230 jj = 1 , 3 f ( jj , nxh + 1 , k , l ) = 2.0 * f ( jj , nxh + 1 , k , l ) f ( jj , nxh + 2 , k , l ) = - 2.0 * f ( jj , nxh + 2 , k , l ) t2 = 2.0 * ( f ( jj , 1 , k , l ) + f ( jj , 2 , k , l )) f ( jj , 2 , k , l ) = 2.0 * ( f ( jj , 1 , k , l ) - f ( jj , 2 , k , l )) f ( jj , 1 , k , l ) = t2 f ( jj , nx + 1 , k , l ) = 2.0 * f ( jj , nx + 1 , k , l ) 230 continue 240 continue 250 continue endif c perform recursion for cosine-sine transform kypt = kyps do 280 l = 1 , kblok if (( kyps + kyp * ( l + ks )). eq . ny ) kypt = kyps + 1 do 270 k = kypi , kypt sum1 = . 5 * f ( 1 , 1 , k , l ) f ( 1 , 1 , k , l ) = 0.0 f ( 1 , 2 , k , l ) = sum1 sum2 = . 5 * f ( 2 , 1 , k , l ) f ( 2 , 1 , k , l ) = 0.0 f ( 2 , 2 , k , l ) = sum2 sum3 = f ( 3 , nx + 1 , k , l ) f ( 3 , nx + 1 , k , l ) = f ( 3 , 2 , k , l ) f ( 3 , 2 , k , l ) = sum3 do 260 j = 2 , nxh sum1 = sum1 + f ( 1 , 2 * j - 1 , k , l ) f ( 1 , 2 * j - 1 , k , l ) = - f ( 1 , 2 * j , k , l ) f ( 1 , 2 * j , k , l ) = sum1 sum2 = sum2 + f ( 2 , 2 * j - 1 , k , l ) f ( 2 , 2 * j - 1 , k , l ) = - f ( 2 , 2 * j , k , l ) f ( 2 , 2 * j , k , l ) = sum2 sum3 = sum3 - f ( 3 , 2 * j , k , l ) f ( 3 , 2 * j , k , l ) = sum3 260 continue f ( 1 , nx + 1 , k , l ) = 0.0 f ( 2 , nx + 1 , k , l ) = 0.0 270 continue 280 continue return end c----------------------------------------------------------------------- subroutine WPFS3T2R3 ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp , indx , in 1 dy , kstrt , nxvh , nyv , kxp2 , kyp , kypd , kxp2d , jblok , kblok , nxhyd , nxyd ) c wrapper function for 3 parallel real sine/sine transforms c for the electric field with dirichlet or magnetic field with neumann c boundary conditions implicit none integer isign , ntpose , mixup , indx , indy , kstrt , nxvh , nyv integer kxp2 , kyp , kypd , kxp2d , jblok , kblok , nxhyd , nxyd real f , g , bs , br , ttp complex sctd dimension f ( 3 , 2 * nxvh , kypd , kblok ), g ( 3 , nyv , kxp2d , jblok ) dimension bs ( 3 , kxp2 + 1 , kyp + 1 , kblok ), br ( 3 , kxp2 + 1 , kyp + 1 , jblok ) dimension mixup ( nxhyd ), sctd ( nxyd ) c local data integer nx , ny , kxpi , kypi real tf double precision dtime data kxpi , kypi / 1 , 1 / c calculate range of indices nx = 2 ** indx ny = 2 ** indy c inverse fourier transform if ( isign . lt . 0 ) then c perform x cosine-sine transform call PFSSCT2R3X ( f , isign , mixup , sctd , indx , indy , kstrt , kyp , kypi , kyp 1 , nxvh , kypd , kblok , nxhyd , nxyd ) c transpose f array to g call PWTIMERA ( - 1 , ttp , dtime ) call PR3TPOSE ( f , g , bs , br , nx , ny , kstrt , 2 * nxvh , nyv , kxp2 , kyp , kxp2d , k 1 ypd , jblok , kblok ) call PWTIMERA ( 1 , ttp , dtime ) c perform y sine-cosine transform call PFSSCT2R3Y ( g , isign , mixup , sctd , indx , indy , kstrt , kxp2 , kxpi , kx 1 p2 , nyv , kxp2d , jblok , nxhyd , nxyd ) c transpose g array to f if ( ntpose . eq . 0 ) then call PWTIMERA ( - 1 , tf , dtime ) call PR3TPOSE ( g , f , br , bs , ny , nx , kstrt , nyv , 2 * nxvh , kyp , kxp2 , kypd 1 , kxp2d , kblok , jblok ) call PWTIMERA ( 1 , tf , dtime ) endif c forward fourier transform else if ( isign . gt . 0 ) then c transpose f array to g if ( ntpose . eq . 0 ) then call PWTIMERA ( - 1 , tf , dtime ) call PR3TPOSE ( f , g , bs , br , nx , ny , kstrt , 2 * nxvh , nyv , kxp2 , kyp , kxp2 1 d , kypd , jblok , kblok ) call PWTIMERA ( 1 , tf , dtime ) endif c perform y sine-cosine transform call PFSSCT2R3Y ( g , isign , mixup , sctd , indx , indy , kstrt , kxp2 , kxpi , kx 1 p2 , nyv , kxp2d , jblok , nxhyd , nxyd ) c transpose g array to f call PWTIMERA ( - 1 , ttp , dtime ) call PR3TPOSE ( g , f , br , bs , ny , nx , kstrt , nyv , 2 * nxvh , kyp , kxp2 , kypd , kx 1 p2d , kblok , jblok ) call PWTIMERA ( 1 , ttp , dtime ) c perform x cosine-sine transform call PFSSCT2R3X ( f , isign , mixup , sctd , indx , indy , kstrt , kyp , kypi , kyp 1 , nxvh , kypd , kblok , nxhyd , nxyd ) endif if ( ntpose . eq . 0 ) ttp = ttp + tf return end c----------------------------------------------------------------------- subroutine PRTPOSE ( f , g , s , t , nx , ny , kstrt , nxv , nyv , kxp , kyp , kxpd , kypd , j 1 blok , kblok ) c this subroutine performs a transpose of a matrix f, distributed in y, c to a matrix g, distributed in x, that is, c g(k+kyp*(m-1),j,l) = f(j+kxp*(l-1),k,m), where c 1 <= j <= kxp, 1 <= k <= kyp, 1 <= l <= nx/kxp, 1 <= m <= ny/kyp c and where indices l and m can be distributed across processors. c includes an extra guard cell for last row and column c this subroutine sends and receives one message at a time, either c synchronously or asynchronously. it uses a minimum of system resources c f = real input array c g = real output array c s, t = real scratch arrays c nx/ny = number of points in x/y c kstrt = starting data block number c nxv = first dimension of f >= nx+1 c nyv = first dimension of g >= ny+1 c kypd = second dimension of f >= kyp+1 c kxpd = second dimension of g >= kxp+1 c kxp/kyp = number of data values per block in x/y c jblok/kblok = number of data blocks in x/y implicit none integer nx , ny , kstrt , nxv , nyv , kxp , kyp , kxpd , kypd integer jblok , kblok real f , g , s , t dimension f ( nxv , kypd , kblok ), g ( nyv , kxpd , jblok ) dimension s ( kxp + 1 , kyp + 1 , kblok ), t ( kxp + 1 , kyp + 1 , jblok ) c common block for parallel processing integer nproc , lgrp , lstat , mreal , mint , mcplx , mdouble , lworld c lstat = length of status array parameter ( lstat = 10 ) c lgrp = current communicator c mreal = default datatype for reals common / PPARMS / nproc , lgrp , mreal , mint , mcplx , mdouble , lworld c local data integer ks , kxb , kyb , kxp1 , kyp1 , kxpt , kypt integer jkblok , kxym , mtr , ntr , mntr integer l , i , joff , koff , k , j integer ir0 , is0 , ii , ir , is , ierr , msid , istatus dimension istatus ( lstat ) ks = kstrt - 2 kxb = nx / kxp kyb = ny / kyp c set constants to receive extra guard cells kxp1 = kxp + 1 kyp1 = kyp + 1 kxpt = kxp if ( kstrt . eq . kxb ) kxpt = kxp1 c this segment is used for shared memory computers c     if (kstrt.gt.nx) return c     kypt = kyp c     do 40 l = 1, jblok c     joff = kxp*(l + ks) c     if ((l+ks).eq.(kxb-1)) kxpt = kxp1 c     do 30 i = 1, kyb c     koff = kyp*(i - 1) c     if (i.eq.kyb) kypt = kyp1 c     do 20 k = 1, kypt c     do 10 j = 1, kxpt c     g(k+koff,j,l) = f(j+joff,k,i) c  10 continue c  20 continue c  30 continue c  40 continue c this segment is used for mpi computers jkblok = max0 ( jblok , kblok ) kxym = min0 ( kxb , kyb ) mtr = kyb / kxym ntr = kxb / kxym mntr = max0 ( mtr , ntr ) do 70 l = 1 , jkblok do 60 i = 1 , kxym ir0 = iand ( kxym - 1 , ieor ( l + ks , i - 1 )) + 1 is0 = ir0 do 50 ii = 1 , mntr c post receive if (( kstrt . le . nx ). and .( ii . le . mtr )) then ir = ir0 + kxym * ( ii - 1 ) kypt = kyp if ( ir . eq . kyb ) kypt = kyp1 call MPI_IRECV ( t ( 1 , 1 , l ), kxp1 * kyp1 , mreal , ir - 1 , ir + kxym + 1 , lgrp , msi 1 d , ierr ) endif c send data if (( kstrt . le . ny ). and .( ii . le . ntr )) then is = is0 + kxym * ( ii - 1 ) joff = kxp * ( is - 1 ) do 20 k = 1 , kyp1 do 10 j = 1 , kxp1 s ( j , k , l ) = f ( j + joff , k , l ) 10 continue 20 continue call MPI_SEND ( s ( 1 , 1 , l ), kxp1 * kyp1 , mreal , is - 1 , l + ks + kxym + 2 , lgrp , ie 1 rr ) endif c receive data if (( kstrt . le . nx ). and .( ii . le . mtr )) then koff = kyp * ( ir - 1 ) call MPI_WAIT ( msid , istatus , ierr ) do 40 k = 1 , kypt do 30 j = 1 , kxpt g ( k + koff , j , l ) = t ( j , k , l ) 30 continue 40 continue endif 50 continue 60 continue 70 continue return end c----------------------------------------------------------------------- subroutine PR2TPOSE ( f , g , s , t , nx , ny , kstrt , nxv , nyv , kxp , kyp , kxpd , kypd , 1 jblok , kblok ) c this subroutine performs a transpose of a matrix f, distributed in y, c to a matrix g, distributed in x, that is, c g(1:2,k+kyp*(m-1),j,l) = f(1:2,j+kxp*(l-1),k,m), where c 1 <= j <= kxp, 1 <= k <= kyp, 1 <= l <= nx/kxp, 1 <= m <= ny/kyp c and where indices l and m can be distributed across processors. c includes an extra guard cell for last row and column c this subroutine sends and receives one message at a time, either c synchronously or asynchronously. it uses a minimum of system resources c f = real input array c g = real output array c s, t = real scratch arrays c nx/ny = number of points in x/y c kstrt = starting data block number c nxv = first dimension of f >= nx+1 c nyv = first dimension of g >= ny+1 c kypd = second dimension of f >= kyp+1 c kxpd = second dimension of g >= kxp+1 c kxp/kyp = number of data values per block in x/y c jblok/kblok = number of data blocks in x/y implicit none integer nx , ny , kstrt , nxv , nyv , kxp , kyp , kxpd , kypd integer jblok , kblok real f , g , s , t dimension f ( 2 , nxv , kypd , kblok ), g ( 2 , nyv , kxpd , jblok ) dimension s ( 2 , kxp + 1 , kyp + 1 , kblok ), t ( 2 , kxp + 1 , kyp + 1 , jblok ) c common block for parallel processing integer nproc , lgrp , lstat , mreal , mint , mcplx , mdouble , lworld c lstat = length of status array parameter ( lstat = 10 ) c lgrp = current communicator c mreal = default datatype for reals common / PPARMS / nproc , lgrp , mreal , mint , mcplx , mdouble , lworld c local data integer ks , kxb , kyb , kxp1 , kyp1 , kxpt , kypt integer jkblok , kxym , mtr , ntr , mntr integer l , i , joff , koff , k , j integer ir0 , is0 , ii , ir , is , ierr , msid , istatus dimension istatus ( lstat ) ks = kstrt - 2 kxb = nx / kxp kyb = ny / kyp c set constants to receive extra guard cells kxp1 = kxp + 1 kyp1 = kyp + 1 kxpt = kxp if ( kstrt . eq . kxb ) kxpt = kxp1 c this segment is used for shared memory computers c     if (kstrt.gt.nx) return c     kypt = kyp c     do 40 l = 1, jblok c     joff = kxp*(l + ks) c     if ((l+ks).eq.(kxb-1)) kxpt = kxp1 c     do 30 i = 1, kyb c     koff = kyp*(i - 1) c     if (i.eq.kyb) kypt = kyp1 c     do 20 k = 1, kypt c     do 10 j = 1, kxpt c     g(1,k+koff,j,l) = f(1,j+joff,k,i) c     g(2,k+koff,j,l) = f(2,j+joff,k,i) c  10 continue c  20 continue c  30 continue c  40 continue c this segment is used for mpi computers jkblok = max0 ( jblok , kblok ) kxym = min0 ( kxb , kyb ) mtr = kyb / kxym ntr = kxb / kxym mntr = max0 ( mtr , ntr ) do 70 l = 1 , jkblok do 60 i = 1 , kxym ir0 = iand ( kxym - 1 , ieor ( l + ks , i - 1 )) + 1 is0 = ir0 do 50 ii = 1 , mntr c post receive if (( kstrt . le . nx ). and .( ii . le . mtr )) then ir = ir0 + kxym * ( ii - 1 ) kypt = kyp if ( ir . eq . kyb ) kypt = kyp1 call MPI_IRECV ( t ( 1 , 1 , 1 , l ), 2 * kxp1 * kyp1 , mreal , ir - 1 , ir + kxym + 1 , lgrp 1 , msid , ierr ) endif c send data if (( kstrt . le . ny ). and .( ii . le . ntr )) then is = is0 + kxym * ( ii - 1 ) joff = kxp * ( is - 1 ) do 20 k = 1 , kyp1 do 10 j = 1 , kxp1 s ( 1 , j , k , l ) = f ( 1 , j + joff , k , l ) s ( 2 , j , k , l ) = f ( 2 , j + joff , k , l ) 10 continue 20 continue call MPI_SEND ( s ( 1 , 1 , 1 , l ), 2 * kxp1 * kyp1 , mreal , is - 1 , l + ks + kxym + 2 , lgr 1 p , ierr ) endif c receive data if (( kstrt . le . nx ). and .( ii . le . mtr )) then koff = kyp * ( ir - 1 ) call MPI_WAIT ( msid , istatus , ierr ) do 40 k = 1 , kypt do 30 j = 1 , kxpt g ( 1 , k + koff , j , l ) = t ( 1 , j , k , l ) g ( 2 , k + koff , j , l ) = t ( 2 , j , k , l ) 30 continue 40 continue endif 50 continue 60 continue 70 continue return end c----------------------------------------------------------------------- subroutine PR3TPOSE ( f , g , s , t , nx , ny , kstrt , nxv , nyv , kxp , kyp , kxpd , kypd , 1 jblok , kblok ) c this subroutine performs a transpose of a matrix f, distributed in y, c to a matrix g, distributed in x, that is, c g(1:3,k+kyp*(m-1),j,l) = f(1:3,j+kxp*(l-1),k,m), where c 1 <= j <= kxp, 1 <= k <= kyp, 1 <= l <= nx/kxp, 1 <= m <= ny/kyp c and where indices l and m can be distributed across processors. c includes an extra guard cell for last row and column c this subroutine sends and receives one message at a time, either c synchronously or asynchronously. it uses a minimum of system resources c f = real input array c g = real output array c s, t = real scratch arrays c nx/ny = number of points in x/y c kstrt = starting data block number c nxv = first dimension of f >= nx+1 c nyv = first dimension of g >= ny+1 c kypd = second dimension of f >= kyp+1 c kxpd = second dimension of g >= kxp+1 c kxp/kyp = number of data values per block in x/y c jblok/kblok = number of data blocks in x/y implicit none integer nx , ny , kstrt , nxv , nyv , kxp , kyp , kxpd , kypd integer jblok , kblok real f , g , s , t dimension f ( 3 , nxv , kypd , kblok ), g ( 3 , nyv , kxpd , jblok ) dimension s ( 3 , kxp + 1 , kyp + 1 , kblok ), t ( 3 , kxp + 1 , kyp + 1 , jblok ) c common block for parallel processing integer nproc , lgrp , lstat , mreal , mint , mcplx , mdouble , lworld c lstat = length of status array parameter ( lstat = 10 ) c lgrp = current communicator c mreal = default datatype for reals common / PPARMS / nproc , lgrp , mreal , mint , mcplx , mdouble , lworld c local data integer ks , kxb , kyb , kxp1 , kyp1 , kxpt , kypt integer jkblok , kxym , mtr , ntr , mntr integer l , i , joff , koff , k , j integer ir0 , is0 , ii , ir , is , ierr , msid , istatus dimension istatus ( lstat ) ks = kstrt - 2 kxb = nx / kxp kyb = ny / kyp c set constants to receive extra guard cells kxp1 = kxp + 1 kyp1 = kyp + 1 kxpt = kxp if ( kstrt . eq . kxb ) kxpt = kxp1 c this segment is used for shared memory computers c     if (kstrt.gt.nx) return c     kypt = kyp c     do 40 l = 1, jblok c     joff = kxp*(l + ks) c     if ((l+ks).eq.(kxb-1)) kxpt = kxp1 c     do 30 i = 1, kyb c     koff = kyp*(i - 1) c     if (i.eq.kyb) kypt = kyp1 c     do 20 k = 1, kypt c     do 10 j = 1, kxpt c     g(1,k+koff,j,l) = f(1,j+joff,k,i) c     g(2,k+koff,j,l) = f(2,j+joff,k,i) c     g(3,k+koff,j,l) = f(3,j+joff,k,i) c  10 continue c  20 continue c  30 continue c  40 continue c this segment is used for mpi computers jkblok = max0 ( jblok , kblok ) kxym = min0 ( kxb , kyb ) mtr = kyb / kxym ntr = kxb / kxym mntr = max0 ( mtr , ntr ) do 70 l = 1 , jkblok do 60 i = 1 , kxym ir0 = iand ( kxym - 1 , ieor ( l + ks , i - 1 )) + 1 is0 = ir0 do 50 ii = 1 , mntr c post receive if (( kstrt . le . nx ). and .( ii . le . mtr )) then ir = ir0 + kxym * ( ii - 1 ) kypt = kyp if ( ir . eq . kyb ) kypt = kyp1 call MPI_IRECV ( t ( 1 , 1 , 1 , l ), 3 * kxp1 * kyp1 , mreal , ir - 1 , ir + kxym + 1 , lgrp 1 , msid , ierr ) endif c send data if (( kstrt . le . ny ). and .( ii . le . ntr )) then is = is0 + kxym * ( ii - 1 ) joff = kxp * ( is - 1 ) do 20 k = 1 , kyp1 do 10 j = 1 , kxp1 s ( 1 , j , k , l ) = f ( 1 , j + joff , k , l ) s ( 2 , j , k , l ) = f ( 2 , j + joff , k , l ) s ( 3 , j , k , l ) = f ( 3 , j + joff , k , l ) 10 continue 20 continue call MPI_SEND ( s ( 1 , 1 , 1 , l ), 3 * kxp1 * kyp1 , mreal , is - 1 , l + ks + kxym + 2 , lgr 1 p , ierr ) endif c receive data if (( kstrt . le . nx ). and .( ii . le . mtr )) then koff = kyp * ( ir - 1 ) call MPI_WAIT ( msid , istatus , ierr ) do 40 k = 1 , kypt do 30 j = 1 , kxpt g ( 1 , k + koff , j , l ) = t ( 1 , j , k , l ) g ( 2 , k + koff , j , l ) = t ( 2 , j , k , l ) g ( 3 , k + koff , j , l ) = t ( 3 , j , k , l ) 30 continue 40 continue endif 50 continue 60 continue 70 continue return end c----------------------------------------------------------------------- subroutine PWTIMERA ( icntrl , time , dtime ) c this subroutine performs local wall clock timing c input: icntrl, dtime c icntrl = (-1,0,1) = (initialize,ignore,read) clock c clock should be initialized before it is read! c time = elapsed time in seconds c dtime = current time c written for mpi implicit none integer icntrl real time double precision dtime c local data double precision jclock double precision MPI_WTIME external MPI_WTIME c initialize clock if ( icntrl . eq .( - 1 )) then dtime = MPI_WTIME () c read clock and write time difference from last clock initialization else if ( icntrl . eq . 1 ) then jclock = dtime dtime = MPI_WTIME () time = real ( dtime - jclock ) endif return end c----------------------------------------------------------------------- subroutine PDIVFD2 ( f , df , nx , ny , kstrt , ndim , nyv , kxp2 , j2blok ) c this subroutine calculates the divergence in fourier space c with dirichlet boundary conditions (zero potential) c intended for calculating the charge density from the electric field c input: all except df, output: df c approximate flop count is: 6*nxc*nyc c where nxc = (nx/2-1)/nvp, nyc = ny - 1, and nvp = number of procs c the divergence is calculated using the equation: c df(kx,ky) = sqrt(-1)*(kx*fx(kx,ky)+ky*fy(kx,ky)) c where kx = 2pi*j/nx, ky = 2pi*k/ny, and j,k = fourier mode numbers, c except for df(kx=pi) = df(ky=pi) = df(kx=0,ky=0) = 0. c nx/ny = system length in x/y direction c ndim = number of field arrays, must be >= 2 c kstrt = starting data block number c nyv = first dimension of field arrays, must be >= ny+1 c kxp2 = number of data values per block c j2blok = number of data blocks real f , df dimension f ( ndim , nyv , kxp2 + 1 , j2blok ), df ( nyv , kxp2 + 1 , j2blok ) if ( ndim . lt . 2 ) return ks = kstrt - 2 ny1 = ny + 1 dnx = 6.28318530717959 / float ( nx + nx ) dny = 6.28318530717959 / float ( ny + ny ) c calculate the divergence if ( kstrt . gt . nx ) return do 50 l = 1 , j2blok c mode numbers 0 < kx < nx and 0 < ky < ny joff = kxp2 * ( l + ks ) - 1 do 20 j = 1 , kxp2 dkx = dnx * float ( j + joff ) if (( j + joff ). gt . 0 ) then do 10 k = 2 , ny dky = dny * float ( k - 1 ) df ( k , j , l ) = - ( dkx * f ( 1 , k , j , l ) + dky * f ( 2 , k , j , l )) 10 continue endif c mode numbers ky = 0, ny df ( 1 , j , l ) = 0. df ( ny + 1 , j , l ) = 0. 20 continue c mode numbers kx = 0, nx if (( l + ks ). eq . 0 ) then do 30 k = 2 , ny df ( k , 1 , l ) = 0. 30 continue endif do 40 k = 1 , ny1 df ( k , kxp2 + 1 , l ) = 0. 40 continue 50 continue return end c----------------------------------------------------------------------- subroutine PGRADFD2 ( df , f , nx , ny , kstrt , ndim , nyv , kxp2 , j2blok ) c this subroutine calculates the gradient in fourier space c with dirichlet boundary conditions (zero potential) c intended for calculating the electric field from the potential c input: all except f, output: f c approximate flop count is: 4*nxc*nyc c where nxc = (nx/2-1)/nvp, nyc = ny - 1, and nvp = number of procs c the gradient is calculated using the equations: c fx(kx,ky) = sqrt(-1)*kx*df(kx,ky) c fy(kx,ky) = sqrt(-1)*ky*df(kx,ky) c where kx = 2pi*j/nx, ky = 2pi*k/ny, and j,k = fourier mode numbers, c except for fx(kx=pi) = fy(kx=pi) = 0, fx(ky=pi) = fy(ky=pi) = 0, c and fx(kx=0,ky=0) = fy(kx=0,ky=0) = 0. c nx/ny = system length in x/y direction c ndim = number of field arrays, must be >= 2 c kstrt = starting data block number c nyv = first dimension of field arrays, must be >= ny+1 c kxp2 = number of data values per block c j2blok = number of data blocks real df , f dimension df ( nyv , kxp2 + 1 , j2blok ), f ( ndim , nyv , kxp2 + 1 , j2blok ) ks = kstrt - 2 ny1 = ny + 1 dnx = 6.28318530717959 / float ( nx + nx ) dny = 6.28318530717959 / float ( ny + ny ) c calculate the gradient if ( kstrt . gt . nx ) return do 50 l = 1 , j2blok c mode numbers 0 < kx < nx and 0 < ky < ny joff = kxp2 * ( l + ks ) - 1 do 20 j = 1 , kxp2 dkx = dnx * float ( j + joff ) if (( j + joff ). gt . 0 ) then do 10 k = 2 , ny dky = dny * float ( k - 1 ) f ( 1 , k , j , l ) = dkx * df ( k , j , l ) f ( 2 , k , j , l ) = dky * df ( k , j , l ) 10 continue endif c mode numbers ky = 0, ny f ( 1 , 1 , j , l ) = 0. f ( 2 , 1 , j , l ) = 0. f ( 1 , ny + 1 , j , l ) = 0. f ( 2 , ny + 1 , j , l ) = 0. 20 continue c mode numbers kx = 0, nx if (( l + ks ). eq . 0 ) then do 30 k = 2 , ny f ( 1 , k , 1 , l ) = 0. f ( 2 , k , 1 , l ) = 0. 30 continue endif do 40 k = 1 , ny1 f ( 1 , k , kxp2 + 1 , l ) = 0. f ( 2 , k , kxp2 + 1 , l ) = 0. 40 continue 50 continue return end c----------------------------------------------------------------------- subroutine PCURLFD22 ( f , g , nx , ny , kstrt , nyv , kxp2 , j2blok ) c this subroutine calculates the curl in fourier space c with dirichlet boundary conditions (zero potential) c intended for calculating the magnetic field from the vector potential c input: all except g, output: g c approximate flop count is: 32*nxc*nyc c where nxc = (nx/2-1)/nvp, nyc = ny - 1, and nvp = number of procs c the curl is calculated using the equations: c g(kx,ky) = sqrt(-1)*(kx*fy(kx,ky)-ky*fx(kx,ky)) c where kx = 2pi*j/nx, ky = 2pi*k/ny, and j,k = fourier mode numbers, c nx/ny = system length in x/y direction c kstrt = starting data block number c nyv = first dimension of field arrays, must be >= ny+1 c kxp2 = number of data values per block c j2blok = number of data blocks real f , g dimension f ( 2 , nyv , kxp2 + 1 , j2blok ), g ( nyv , kxp2 + 1 , j2blok ) ks = kstrt - 2 ny1 = ny + 1 dnx = 6.28318530717959 / float ( nx + nx ) dny = 6.28318530717959 / float ( ny + ny ) c calculate the curl if ( kstrt . gt . nx ) return do 50 l = 1 , j2blok c mode numbers 0 < kx < nx and 0 < ky < ny joff = kxp2 * ( l + ks ) - 1 do 20 j = 1 , kxp2 dkx = dnx * float ( j + joff ) if (( j + joff ). gt . 0 ) then do 10 k = 2 , ny dky = dny * float ( k - 1 ) g ( k , j , l ) = dkx * f ( 2 , k , j , l ) - dky * f ( 1 , k , j , l ) 10 continue c mode numbers ky = 0, ny g ( 1 , j , l ) = dkx * f ( 2 , 1 , j , l ) endif g ( ny + 1 , j , l ) = 0. 20 continue c mode numbers kx = 0, nx if (( l + ks ). eq . 0 ) then do 30 k = 2 , ny dky = dny * float ( k - 1 ) g ( k , 1 , l ) = - dky * f ( 1 , k , 1 , l ) 30 continue g ( 1 , 1 , l ) = 0. endif do 40 k = 1 , ny1 g ( k , kxp2 + 1 , l ) = 0. 40 continue 50 continue return end c----------------------------------------------------------------------- subroutine PCURLFD2 ( f , g , nx , ny , kstrt , nyv , kxp2 , j2blok ) c this subroutine calculates the curl in fourier space c with dirichlet boundary conditions (zero potential) c intended for calculating the magnetic field from the vector potential c input: all except g, output: g c approximate flop count is: 8*nxc*nyc c where nxc = (nx/2-1)/nvp, nyc = ny - 1, and nvp = number of procs c the curl is calculated using the equations: c gx(kx,ky) = sqrt(-1)*ky*fz(kx,ky) c gy(kx,ky) = -sqrt(-1)*kx*fz(kx,ky) c gz(kx,ky) = sqrt(-1)*(kx*fy(kx,ky)-ky*fx(kx,ky)) c where kx = 2pi*j/nx, ky = 2pi*k/ny, and j,k = fourier mode numbers, c except for gx(kx=pi) = gy(kx=pi) = 0, gx(ky=pi) = gy(ky=pi) = 0, c and gx(kx=0,ky=0) = gy(kx=0,ky=0) = 0. c nx/ny = system length in x/y direction c kstrt = starting data block number c nyv = first dimension of field arrays, must be >= ny+1 c kxp2 = number of data values per block c j2blok = number of data blocks real f , g dimension f ( 3 , nyv , kxp2 + 1 , j2blok ), g ( 3 , nyv , kxp2 + 1 , j2blok ) ks = kstrt - 2 ny1 = ny + 1 dnx = 6.28318530717959 / float ( nx + nx ) dny = 6.28318530717959 / float ( ny + ny ) c calculate the curl if ( kstrt . gt . nx ) return do 50 l = 1 , j2blok c mode numbers 0 < kx < nx and 0 < ky < ny joff = kxp2 * ( l + ks ) - 1 do 20 j = 1 , kxp2 dkx = dnx * float ( j + joff ) if (( j + joff ). gt . 0 ) then do 10 k = 2 , ny dky = dny * float ( k - 1 ) g ( 1 , k , j , l ) = dky * f ( 3 , k , j , l ) g ( 2 , k , j , l ) = - dkx * f ( 3 , k , j , l ) g ( 3 , k , j , l ) = dkx * f ( 2 , k , j , l ) - dky * f ( 1 , k , j , l ) 10 continue c mode numbers ky = 0, ny g ( 1 , 1 , j , l ) = 0. g ( 2 , 1 , j , l ) = 0. g ( 3 , 1 , j , l ) = dkx * f ( 2 , 1 , j , l ) endif g ( 1 , ny + 1 , j , l ) = 0. g ( 2 , ny + 1 , j , l ) = 0. g ( 3 , ny + 1 , j , l ) = 0. 20 continue c mode numbers kx = 0, nx if (( l + ks ). eq . 0 ) then do 30 k = 2 , ny dky = dny * float ( k - 1 ) g ( 1 , k , 1 , l ) = 0. g ( 2 , k , 1 , l ) = 0. g ( 3 , k , 1 , l ) = - dky * f ( 1 , k , 1 , l ) 30 continue g ( 1 , 1 , 1 , l ) = 0. g ( 2 , 1 , 1 , l ) = 0. g ( 3 , 1 , 1 , l ) = 0. endif do 40 k = 1 , ny1 g ( 1 , k , kxp2 + 1 , l ) = 0. g ( 2 , k , kxp2 + 1 , l ) = 0. g ( 3 , k , kxp2 + 1 , l ) = 0. 40 continue 50 continue return end c----------------------------------------------------------------------- subroutine WPPFSST2RM ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp , indx , & & indy , kstrt , nvp , nxvh , nyv , kxp2 , kyp , kypd , kxp2d , nxhyd , nxyd ) ! wrapper function for parallel real sine/sine transform implicit none integer isign , ntpose , indx , indy , kstrt , nvp , nxvh , nyv integer kxp2 , kyp , kypd , kxp2d , nxhyd , nxyd , mixup real f , g , bs , br , ttp complex sctd dimension f ( 2 * nxvh , kypd ), g ( nyv , kxp2d ) dimension bs ( kxp2 + 1 , kyp + 1 ), br ( kxp2 + 1 , kyp + 1 ) dimension mixup ( nxhyd ), sctd ( nxyd ) ! local data integer nx , ny , kxpi , kypi , ks , kxp2p , kypp , kxb2 , kyb real tf double precision dtime data kxpi , kypi / 1 , 1 / ! calculate range of indices nx = 2 ** indx ny = 2 ** indy ! ks = processor id ks = kstrt - 1 ! kxp2p = actual size used in x direction kxp2p = min ( kxp2 , max ( 0 , nx - kxp2 * ks )) ! kypp = actual size used in y direction kypp = min ( kyp , max ( 0 , ny - kyp * ks )) ! kxb2 = minimum number of processors needed in x direction kxb2 = ( nx - 1 ) / kxp2 + 1 ! kyb = minimum number of processors needed in y direction kyb = ( ny - 1 ) / kyp + 1 ! add extra word for last processor in x if ( ks == ( kxb2 - 1 )) kxp2p = kxp2p + 1 ! add extra word for last processor in y if ( ks == ( kyb - 1 )) kypp = kypp + 1 ! inverse fourier transform if ( isign . lt . 0 ) then ! perform x sine transform call PPFST2RMXX ( f , isign , mixup , sctd , indx , indy , kstrt , kypi , kypp , & & nxvh , kypd , nxhyd , nxyd ) ! transpose f array to g call PWTIMERA ( - 1 , ttp , dtime ) call PPRTPOSE ( f , g , bs , br , nx , ny , kxp2 , kyp , kstrt , nvp , 2 * nxvh , nyv , & & kxp2d , kypd ) call PWTIMERA ( 1 , ttp , dtime ) ! perform y sine transform call PPFST2RMXY ( g , isign , mixup , sctd , indx , indy , kstrt , kxpi , kxp2p , & & nyv , kxp2d , nxhyd , nxyd ) ! transpose g array to f if ( ntpose . eq . 0 ) then call PWTIMERA ( - 1 , tf , dtime ) call PPRTPOSE ( g , f , br , bs , ny , nx , kyp , kxp2 , kstrt , nvp , nyv , 2 * nxvh , & & kypd , kxp2d ) call PWTIMERA ( 1 , tf , dtime ) endif ! forward fourier transform else if ( isign . gt . 0 ) then ! transpose f array to g if ( ntpose . eq . 0 ) then call PWTIMERA ( - 1 , tf , dtime ) call PPRTPOSE ( f , g , bs , br , nx , ny , kxp2 , kyp , kstrt , nvp , 2 * nxvh , nyv , & & kxp2d , kypd ) call PWTIMERA ( 1 , tf , dtime ) endif ! perform y sine transform call PPFST2RMXY ( g , isign , mixup , sctd , indx , indy , kstrt , kxpi , kxp2p , & & nyv , kxp2d , nxhyd , nxyd ) ! transpose g array to f call PWTIMERA ( - 1 , ttp , dtime ) call PPRTPOSE ( g , f , br , bs , ny , nx , kyp , kxp2 , kstrt , nvp , nyv , 2 * nxvh , & & kypd , kxp2d ) call PWTIMERA ( 1 , ttp , dtime ) ! perform x sine transform call PPFST2RMXX ( f , isign , mixup , sctd , indx , indy , kstrt , kypi , kypp , & & nxvh , kypd , nxhyd , nxyd ) endif if ( ntpose . eq . 0 ) ttp = ttp + tf return end !----------------------------------------------------------------------- subroutine WPPFSCT2RM ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp , indx , & & indy , kstrt , nvp , nxvh , nyv , kxp2 , kyp , kypd , kxp2d , nxhyd , nxyd ) ! wrapper function for parallel real sine/cosine transform implicit none integer isign , ntpose , indx , indy , kstrt , nvp , nxvh , nyv integer kxp2 , kyp , kypd , kxp2d , nxhyd , nxyd , mixup real f , g , bs , br , ttp complex sctd dimension f ( 2 * nxvh , kypd ), g ( nyv , kxp2d ) dimension bs ( kxp2 + 1 , kyp + 1 ), br ( kxp2 + 1 , kyp + 1 ) dimension mixup ( nxhyd ), sctd ( nxyd ) ! local data integer nx , ny , kxpi , kypi , ks , kxp2p , kypp , kxb2 , kyb real tf double precision dtime data kxpi , kypi / 1 , 1 / ! calculate range of indices nx = 2 ** indx ny = 2 ** indy ! ks = processor id ks = kstrt - 1 ! kxp2p = actual size used in x direction kxp2p = min ( kxp2 , max ( 0 , nx - kxp2 * ks )) ! kypp = actual size used in y direction kypp = min ( kyp , max ( 0 , ny - kyp * ks )) ! kxb2 = minimum number of processors needed in x direction kxb2 = ( nx - 1 ) / kxp2 + 1 ! kyb = minimum number of processors needed in y direction kyb = ( ny - 1 ) / kyp + 1 ! add extra word for last processor in x if ( ks == ( kxb2 - 1 )) kxp2p = kxp2p + 1 ! add extra word for last processor in y if ( ks == ( kyb - 1 )) kypp = kypp + 1 ! inverse fourier transform if ( isign . lt . 0 ) then ! perform x sine transform call PPFST2RMXX ( f , isign , mixup , sctd , indx , indy , kstrt , kypi , kypp , & & nxvh , kypd , nxhyd , nxyd ) ! transpose f array to g call PWTIMERA ( - 1 , ttp , dtime ) call PPRTPOSE ( f , g , bs , br , nx , ny , kxp2 , kyp , kstrt , nvp , 2 * nxvh , nyv , & & kxp2d , kypd ) call PWTIMERA ( 1 , ttp , dtime ) ! perform y cosine transform call PPFCT2RMXY ( g , isign , mixup , sctd , indx , indy , kstrt , kxpi , kxp2p , & & nyv , kxp2d , nxhyd , nxyd ) ! transpose g array to f if ( ntpose . eq . 0 ) then call PWTIMERA ( - 1 , tf , dtime ) call PPRTPOSE ( g , f , br , bs , ny , nx , kyp , kxp2 , kstrt , nvp , nyv , 2 * nxvh , & & kypd , kxp2d ) call PWTIMERA ( 1 , tf , dtime ) endif ! forward fourier transform else if ( isign . gt . 0 ) then ! transpose f array to g if ( ntpose . eq . 0 ) then call PWTIMERA ( - 1 , tf , dtime ) call PPRTPOSE ( f , g , bs , br , nx , ny , kxp2 , kyp , kstrt , nvp , 2 * nxvh , nyv , & & kxp2d , kypd ) call PWTIMERA ( 1 , tf , dtime ) endif ! perform y cosine transform call PPFCT2RMXY ( g , isign , mixup , sctd , indx , indy , kstrt , kxpi , kxp2p , & & nyv , kxp2d , nxhyd , nxyd ) ! transpose g array to f call PWTIMERA ( - 1 , ttp , dtime ) call PPRTPOSE ( g , f , br , bs , ny , nx , kyp , kxp2 , kstrt , nvp , nyv , 2 * nxvh , & & kypd , kxp2d ) call PWTIMERA ( 1 , ttp , dtime ) ! perform x sine transform call PPFST2RMXX ( f , isign , mixup , sctd , indx , indy , kstrt , kypi , kypp , & & nxvh , kypd , nxhyd , nxyd ) endif if ( ntpose . eq . 0 ) ttp = ttp + tf return end !----------------------------------------------------------------------- subroutine WPPFCST2RM ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp , indx , & & indy , kstrt , nvp , nxvh , nyv , kxp2 , kyp , kypd , kxp2d , nxhyd , nxyd ) ! wrapper function for parallel real cosine/sine transform implicit none integer isign , ntpose , indx , indy , kstrt , nvp , nxvh , nyv integer kxp2 , kyp , kypd , kxp2d , nxhyd , nxyd , mixup real f , g , bs , br , ttp complex sctd dimension f ( 2 * nxvh , kypd ), g ( nyv , kxp2d ) dimension bs ( kxp2 + 1 , kyp + 1 ), br ( kxp2 + 1 , kyp + 1 ) dimension mixup ( nxhyd ), sctd ( nxyd ) ! local data integer nx , ny , kxpi , kypi , ks , kxp2p , kypp , kxb2 , kyb real tf double precision dtime data kxpi , kypi / 1 , 1 / ! calculate range of indices nx = 2 ** indx ny = 2 ** indy ! ks = processor id ks = kstrt - 1 ! kxp2p = actual size used in x direction kxp2p = min ( kxp2 , max ( 0 , nx - kxp2 * ks )) ! kypp = actual size used in y direction kypp = min ( kyp , max ( 0 , ny - kyp * ks )) ! kxb2 = minimum number of processors needed in x direction kxb2 = ( nx - 1 ) / kxp2 + 1 ! kyb = minimum number of processors needed in y direction kyb = ( ny - 1 ) / kyp + 1 ! add extra word for last processor in x if ( ks == ( kxb2 - 1 )) kxp2p = kxp2p + 1 ! add extra word for last processor in y if ( ks == ( kyb - 1 )) kypp = kypp + 1 ! inverse fourier transform if ( isign . lt . 0 ) then ! perform x cosine transform call PPFCT2RMXX ( f , isign , mixup , sctd , indx , indy , kstrt , kypi , kypp , & & nxvh , kypd , nxhyd , nxyd ) ! transpose f array to g call PWTIMERA ( - 1 , ttp , dtime ) call PPRTPOSE ( f , g , bs , br , nx , ny , kxp2 , kyp , kstrt , nvp , 2 * nxvh , nyv , & & kxp2d , kypd ) call PWTIMERA ( 1 , ttp , dtime ) ! perform y sine transform call PPFST2RMXY ( g , isign , mixup , sctd , indx , indy , kstrt , kxpi , kxp2p , & & nyv , kxp2d , nxhyd , nxyd ) ! transpose g array to f if ( ntpose . eq . 0 ) then call PWTIMERA ( - 1 , tf , dtime ) call PPRTPOSE ( g , f , br , bs , ny , nx , kyp , kxp2 , kstrt , nvp , nyv , 2 * nxvh , & & kypd , kxp2d ) call PWTIMERA ( 1 , tf , dtime ) endif ! forward fourier transform else if ( isign . gt . 0 ) then ! transpose f array to g if ( ntpose . eq . 0 ) then call PWTIMERA ( - 1 , tf , dtime ) call PPRTPOSE ( f , g , bs , br , nx , ny , kxp2 , kyp , kstrt , nvp , 2 * nxvh , nyv , & & kxp2d , kypd ) call PWTIMERA ( 1 , tf , dtime ) endif ! perform y sine transform call PPFST2RMXY ( g , isign , mixup , sctd , indx , indy , kstrt , kxpi , kxp2p , & & nyv , kxp2d , nxhyd , nxyd ) ! transpose g array to f call PWTIMERA ( - 1 , ttp , dtime ) call PPRTPOSE ( g , f , br , bs , ny , nx , kyp , kxp2 , kstrt , nvp , nyv , 2 * nxvh , & & kypd , kxp2d ) call PWTIMERA ( 1 , ttp , dtime ) ! perform x cosine transform call PPFCT2RMXX ( f , isign , mixup , sctd , indx , indy , kstrt , kypi , kypp , & & nxvh , kypd , nxhyd , nxyd ) endif if ( ntpose . eq . 0 ) ttp = ttp + tf return end !----------------------------------------------------------------------- subroutine WPPFCCT2RM ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp , indx , & & indy , kstrt , nvp , nxvh , nyv , kxp2 , kyp , kypd , kxp2d , nxhyd , nxyd ) ! wrapper function for parallel real cosine/cosine transform implicit none integer isign , ntpose , indx , indy , kstrt , nvp , nxvh , nyv integer kxp2 , kyp , kypd , kxp2d , nxhyd , nxyd , mixup real f , g , bs , br , ttp complex sctd dimension f ( 2 * nxvh , kypd ), g ( nyv , kxp2d ) dimension bs ( kxp2 + 1 , kyp + 1 ), br ( kxp2 + 1 , kyp + 1 ) dimension mixup ( nxhyd ), sctd ( nxyd ) ! local data integer nx , ny , kxpi , kypi , ks , kxp2p , kypp , kxb2 , kyb real tf double precision dtime data kxpi , kypi / 1 , 1 / ! calculate range of indices nx = 2 ** indx ny = 2 ** indy ! ks = processor id ks = kstrt - 1 ! kxp2p = actual size used in x direction kxp2p = min ( kxp2 , max ( 0 , nx - kxp2 * ks )) ! kypp = actual size used in y direction kypp = min ( kyp , max ( 0 , ny - kyp * ks )) ! kxb2 = minimum number of processors needed in x direction kxb2 = ( nx - 1 ) / kxp2 + 1 ! kyb = minimum number of processors needed in y direction kyb = ( ny - 1 ) / kyp + 1 ! add extra word for last processor in x if ( ks == ( kxb2 - 1 )) kxp2p = kxp2p + 1 ! add extra word for last processor in y if ( ks == ( kyb - 1 )) kypp = kypp + 1 ! inverse fourier transform if ( isign . lt . 0 ) then ! perform x cosine transform call PPFCT2RMXX ( f , isign , mixup , sctd , indx , indy , kstrt , kypi , kypp , & & nxvh , kypd , nxhyd , nxyd ) ! transpose f array to g call PWTIMERA ( - 1 , ttp , dtime ) call PPRTPOSE ( f , g , bs , br , nx , ny , kxp2 , kyp , kstrt , nvp , 2 * nxvh , nyv , & & kxp2d , kypd ) call PWTIMERA ( 1 , ttp , dtime ) ! perform y cosine transform call PPFCT2RMXY ( g , isign , mixup , sctd , indx , indy , kstrt , kxpi , kxp2p , & & nyv , kxp2d , nxhyd , nxyd ) ! transpose g array to f if ( ntpose . eq . 0 ) then call PWTIMERA ( - 1 , tf , dtime ) call PPRTPOSE ( g , f , br , bs , ny , nx , kyp , kxp2 , kstrt , nvp , nyv , 2 * nxvh , & & kypd , kxp2d ) call PWTIMERA ( 1 , tf , dtime ) endif ! forward fourier transform else if ( isign . gt . 0 ) then ! transpose f array to g if ( ntpose . eq . 0 ) then call PWTIMERA ( - 1 , tf , dtime ) call PPRTPOSE ( f , g , bs , br , nx , ny , kxp2 , kyp , kstrt , nvp , 2 * nxvh , nyv , & & kxp2d , kypd ) call PWTIMERA ( 1 , tf , dtime ) endif ! perform y cosine transform call PPFCT2RMXY ( g , isign , mixup , sctd , indx , indy , kstrt , kxpi , kxp2p , & & nyv , kxp2d , nxhyd , nxyd ) ! transpose g array to f call PWTIMERA ( - 1 , ttp , dtime ) call PPRTPOSE ( g , f , br , bs , ny , nx , kyp , kxp2 , kstrt , nvp , nyv , 2 * nxvh , & & kypd , kxp2d ) call PWTIMERA ( 1 , ttp , dtime ) ! perform x cosine transform call PPFCT2RMXX ( f , isign , mixup , sctd , indx , indy , kstrt , kypi , kypp , & & nxvh , kypd , nxhyd , nxyd ) endif if ( ntpose . eq . 0 ) ttp = ttp + tf return end !----------------------------------------------------------------------- subroutine PPFST2RMXX ( f , isign , mixup , sctd , indx , indy , kstrt , kypi , kypp & & , nxvh , kypd , nxhyd , nxyd ) ! this subroutine performs the x part of a two dimensional fast real ! sine transform and its inverse, for a subset of y, ! using real arithmetic, with OpenMP, ! for data which is distributed in blocks ! algorithm is described in Numerical Recipies in Fortran, Second Ed., ! by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, ! [Cambridge Univ. Press, 1992], p. 508. ! for isign = (-1,1), input: all, output: f ! approximate flop count: N*(5*log2(N) + 18)/nvp ! where N = (nx/2)*ny ! indx/indy = exponent which determines length in x/y direction, ! where nx=2**indx, ny=2**indy ! if isign = -1, an inverse sine transform is performed ! f(n,k) = (1/nx*ny)*sum(f(j,k)*sin(pi*n*j/nx)) ! if isign = 1, a forward sine transform is performed ! f(j,k) = sum(f(n,k)*sin(pi*n*j/nx)) ! mixup = array of bit reversed addresses ! sctd = sine/cosine table ! kstrt = starting data block number ! kypi = initial y index used ! kypp = number of y indices used ! nxvh = first dimension of f >= nx/2 + 1 ! kypd = second dimension of f >= kyp + 1 ! nxhyd = maximum of (nx/2,ny) ! nxyd = maximum of (nx,ny) ! written by viktor k. decyk, ucla implicit none integer isign , indx , indy , kstrt , kypi , kypp , nxvh , kypd integer nxhyd , nxyd , mixup real f complex sctd dimension f ( 2 * nxvh , kypd ) dimension mixup ( nxhyd ), sctd ( nxyd ) ! local data integer indx1 , indx1y , nx , nxh , nxhh , nx3 , ny , nxy , nxhy , ks integer i , j , k , m , km , kmr , nrx , j1 , j2 , ns , ns2 , k1 , k2 , kyps integer nrxb real at1 , at2 , t2 , t3 , t4 , t5 , t6 , ani complex t1 double precision sum1 indx1 = indx - 1 indx1y = max0 ( indx1 , indy ) nx = 2 ** indx nxh = nx / 2 nxhh = nx / 4 nx3 = nx + 3 ny = 2 ** indy nxy = max0 ( nx , ny ) nxhy = 2 ** indx1y ks = kstrt - 1 kyps = kypi + kypp - 1 if ( kstrt . gt . ny ) return if ( isign . eq . 0 ) return ani = 0.5 / ( real ( nx ) * real ( ny )) nrxb = nxhy / nxh nrx = nxy / nxh !$OMP PARALLEL DO !$OMP& PRIVATE(i,j,k,m,ns,ns2,km,kmr,k1,k2,j1,j2,at1,at2,t2,t3,t4,t5,t6, !$OMP& t1,sum1) do 90 i = kypi , kyps ! create auxiliary array in x kmr = nxy / nx do 10 j = 2 , nxh j1 = 1 + kmr * ( j - 1 ) at2 = f ( nx + 2 - j , i ) at1 = f ( j , i ) + at2 at2 = f ( j , i ) - at2 at1 = - aimag ( sctd ( j1 )) * at1 at2 = 0.5 * at2 f ( j , i ) = at1 + at2 f ( nx + 2 - j , i ) = at1 - at2 10 continue f ( 1 , i ) = 0.0 f ( nxh + 1 , i ) = 2.0 * f ( nxh + 1 , i ) ! bit-reverse array elements in x do 20 j = 1 , nxh j1 = ( mixup ( j ) - 1 ) / nrxb + 1 if ( j . lt . j1 ) then t2 = f ( 2 * j1 - 1 , i ) t3 = f ( 2 * j1 , i ) f ( 2 * j1 - 1 , i ) = f ( 2 * j - 1 , i ) f ( 2 * j1 , i ) = f ( 2 * j , i ) f ( 2 * j - 1 , i ) = t2 f ( 2 * j , i ) = t3 endif 20 continue ! then transform in x do 50 m = 1 , indx1 ns = 2 ** ( m - 1 ) ns2 = ns + ns km = nxhh / ns kmr = 2 * km * nrx do 40 k = 1 , km k1 = ns2 * ( k - 1 ) k2 = k1 + ns do 30 j = 1 , ns j1 = j + k1 j2 = j + k2 t1 = sctd ( 1 + kmr * ( j - 1 )) t2 = real ( t1 ) * f ( 2 * j2 - 1 , i ) - aimag ( t1 ) * f ( 2 * j2 , i ) t3 = aimag ( t1 ) * f ( 2 * j2 - 1 , i ) + real ( t1 ) * f ( 2 * j2 , i ) f ( 2 * j2 - 1 , i ) = f ( 2 * j1 - 1 , i ) - t2 f ( 2 * j2 , i ) = f ( 2 * j1 , i ) - t3 f ( 2 * j1 - 1 , i ) = f ( 2 * j1 - 1 , i ) + t2 f ( 2 * j1 , i ) = f ( 2 * j1 , i ) + t3 30 continue 40 continue 50 continue ! unscramble coefficients and normalize ! inverse fourier transform if ( isign . lt . 0 ) then kmr = nxy / nxh do 60 j = 2 , nxhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( j - 1 ))), - real ( sctd ( 1 + kmr * ( j - 1 )))) t4 = f ( nx3 - 2 * j , i ) t5 = - f ( nx3 - 2 * j + 1 , i ) t2 = f ( 2 * j - 1 , i ) + t4 t3 = f ( 2 * j , i ) + t5 t6 = f ( 2 * j - 1 , i ) - t4 t5 = f ( 2 * j , i ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) f ( 2 * j - 1 , i ) = ani * ( t2 + t4 ) f ( 2 * j , i ) = ani * ( t3 + t5 ) f ( nx3 - 2 * j , i ) = ani * ( t2 - t4 ) f ( nx3 - 2 * j + 1 , i ) = ani * ( t5 - t3 ) 60 continue f ( nxh + 1 , i ) = 2.0 * ani * f ( nxh + 1 , i ) f ( nxh + 2 , i ) = - 2.0 * ani * f ( nxh + 2 , i ) t2 = 2.0 * ani * ( f ( 1 , i ) + f ( 2 , i )) f ( 2 , i ) = 2.0 * ani * ( f ( 1 , i ) - f ( 2 , i )) f ( 1 , i ) = t2 f ( nx + 1 , i ) = 2.0 * ani * f ( nx + 1 , i ) ! forward fourier transform else if ( isign . gt . 0 ) then kmr = nxy / nxh do 70 j = 2 , nxhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( j - 1 ))), - real ( sctd ( 1 + kmr * ( j - 1 )))) t4 = f ( nx3 - 2 * j , i ) t5 = - f ( nx3 - 2 * j + 1 , i ) t2 = f ( 2 * j - 1 , i ) + t4 t3 = f ( 2 * j , i ) + t5 t6 = f ( 2 * j - 1 , i ) - t4 t5 = f ( 2 * j , i ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) f ( 2 * j - 1 , i ) = t2 + t4 f ( 2 * j , i ) = t3 + t5 f ( nx3 - 2 * j , i ) = t2 - t4 f ( nx3 - 2 * j + 1 , i ) = t5 - t3 70 continue f ( nxh + 1 , i ) = 2.0 * f ( nxh + 1 , i ) f ( nxh + 2 , i ) = - 2.0 * f ( nxh + 2 , i ) t2 = 2.0 * ( f ( 1 , i ) + f ( 2 , i )) f ( 2 , i ) = 2.0 * ( f ( 1 , i ) - f ( 2 , i )) f ( 1 , i ) = t2 f ( nx + 1 , i ) = 2.0 * f ( nx + 1 , i ) endif ! perform recursion for sine transform sum1 = 0.5 * f ( 1 , i ) f ( 1 , i ) = 0.0 f ( 2 , i ) = sum1 do 80 j = 2 , nxh sum1 = sum1 + f ( 2 * j - 1 , i ) f ( 2 * j - 1 , i ) = - f ( 2 * j , i ) f ( 2 * j , i ) = sum1 80 continue f ( nx + 1 , i ) = 0.0 90 continue !$OMP END PARALLEL DO return end !----------------------------------------------------------------------- subroutine PPFCT2RMXX ( f , isign , mixup , sctd , indx , indy , kstrt , kypi , kypp & & , nxvh , kypd , nxhyd , nxyd ) ! this subroutine performs the x part of a two dimensional fast real ! cosine transform and its inverse, for a subset of y, ! using real arithmetic, with OpenMP, ! for data which is distributed in blocks ! algorithm is described in Numerical Recipies in Fortran, Second Ed., ! by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, ! [Cambridge Univ. Press, 1992], p. 508. ! for isign = (-1,1), input: all, output: f ! approximate flop count: N*(5*log2(N) + 18)/nvp ! where N = (nx/2)*ny ! indx/indy = exponent which determines length in x/y direction, ! where nx=2**indx, ny=2**indy ! if isign = -1, an inverse cosine transform is performed ! f(n,k) = (1/nx*ny)*(.5*f(1,k) + ((-1)**n)*f(nx+1,k) !            + sum(f(j,k)*cos(pi*n*j/nx))) ! if isign = 1, a forward cosine transform is performed ! f(j,k) = 2*(.5*f(1,k) + ((-1)**j)*f(n+1,k) + sum(f(n,k)* !            cos(pi*n*j/nx)) ! mixup = array of bit reversed addresses ! sctd = sine/cosine table ! kstrt = starting data block number ! kypi = initial y index used ! kypp = number of y indices used ! nxvh = first dimension of f >= nx/2 + 1 ! kypd = second dimension of f >= kyp+1 ! nxhyd = maximum of (nx/2,ny) ! nxyd = maximum of (nx,ny) ! written by viktor k. decyk, ucla implicit none integer isign , indx , indy , kstrt , kypi , kypp , nxvh , kypd integer nxhyd , nxyd , mixup real f complex sctd dimension f ( 2 * nxvh , kypd ) dimension mixup ( nxhyd ), sctd ( nxyd ) ! local data integer indx1 , indx1y , nx , nxh , nxhh , nx3 , ny , nxy , nxhy , ks integer i , j , k , m , km , kmr , nrx , j1 , j2 , ns , ns2 , k1 , k2 , kyps integer nrxb real at1 , at2 , t2 , t3 , t4 , t5 , t6 , ani double precision sum1 complex t1 indx1 = indx - 1 indx1y = max0 ( indx1 , indy ) nx = 2 ** indx nxh = nx / 2 nxhh = nx / 4 nx3 = nx + 3 ny = 2 ** indy nxy = max0 ( nx , ny ) nxhy = 2 ** indx1y ks = kstrt - 1 kyps = kypi + kypp - 1 if ( kstrt . gt . ny ) return if ( isign . eq . 0 ) return ani = 0.5 / ( real ( nx ) * real ( ny )) nrxb = nxhy / nxh nrx = nxy / nxh !$OMP PARALLEL DO !$OMP& PRIVATE(i,j,k,m,ns,ns2,km,kmr,k1,k2,j1,j2,at1,at2,t2,t3,t4,t5,t6, !$OMP& t1,sum1) do 90 i = kypi , kyps ! create auxiliary array in x kmr = nxy / nx sum1 = 0.5 * ( f ( 1 , i ) - f ( nx + 1 , i )) do 10 j = 2 , nxh j1 = 1 + kmr * ( j - 1 ) at2 = f ( nx + 2 - j , i ) at1 = f ( j , i ) + at2 at2 = f ( j , i ) - at2 sum1 = sum1 + real ( sctd ( j1 )) * at2 at2 = - aimag ( sctd ( j1 )) * at2 at1 = 0.5 * at1 f ( j , i ) = at1 - at2 f ( nx + 2 - j , i ) = at1 + at2 10 continue f ( 1 , i ) = 0.5 * ( f ( 1 , i ) + f ( nx + 1 , i )) f ( nx + 1 , i ) = sum1 ! bit-reverse array elements in x do 20 j = 1 , nxh j1 = ( mixup ( j ) - 1 ) / nrxb + 1 if ( j . lt . j1 ) then t2 = f ( 2 * j1 - 1 , i ) t3 = f ( 2 * j1 , i ) f ( 2 * j1 - 1 , i ) = f ( 2 * j - 1 , i ) f ( 2 * j1 , i ) = f ( 2 * j , i ) f ( 2 * j - 1 , i ) = t2 f ( 2 * j , i ) = t3 endif 20 continue ! then transform in x do 50 m = 1 , indx1 ns = 2 ** ( m - 1 ) ns2 = ns + ns km = nxhh / ns kmr = 2 * km * nrx do 40 k = 1 , km k1 = ns2 * ( k - 1 ) k2 = k1 + ns do 30 j = 1 , ns j1 = j + k1 j2 = j + k2 t1 = sctd ( 1 + kmr * ( j - 1 )) t2 = real ( t1 ) * f ( 2 * j2 - 1 , i ) - aimag ( t1 ) * f ( 2 * j2 , i ) t3 = aimag ( t1 ) * f ( 2 * j2 - 1 , i ) + real ( t1 ) * f ( 2 * j2 , i ) f ( 2 * j2 - 1 , i ) = f ( 2 * j1 - 1 , i ) - t2 f ( 2 * j2 , i ) = f ( 2 * j1 , i ) - t3 f ( 2 * j1 - 1 , i ) = f ( 2 * j1 - 1 , i ) + t2 f ( 2 * j1 , i ) = f ( 2 * j1 , i ) + t3 30 continue 40 continue 50 continue ! unscramble coefficients and normalize ! inverse fourier transform if ( isign . lt . 0 ) then kmr = nxy / nxh do 60 j = 2 , nxhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( j - 1 ))), - real ( sctd ( 1 + kmr * ( j - 1 )))) t4 = f ( nx3 - 2 * j , i ) t5 = - f ( nx3 - 2 * j + 1 , i ) t2 = f ( 2 * j - 1 , i ) + t4 t3 = f ( 2 * j , i ) + t5 t6 = f ( 2 * j - 1 , i ) - t4 t5 = f ( 2 * j , i ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) f ( 2 * j - 1 , i ) = ani * ( t2 + t4 ) f ( 2 * j , i ) = ani * ( t3 + t5 ) f ( nx3 - 2 * j , i ) = ani * ( t2 - t4 ) f ( nx3 - 2 * j + 1 , i ) = ani * ( t5 - t3 ) 60 continue f ( nxh + 1 , i ) = 2.0 * ani * f ( nxh + 1 , i ) f ( nxh + 2 , i ) = - 2.0 * ani * f ( nxh + 2 , i ) t2 = 2.0 * ani * ( f ( 1 , i ) + f ( 2 , i )) f ( 2 , i ) = 2.0 * ani * ( f ( 1 , i ) - f ( 2 , i )) f ( 1 , i ) = t2 f ( nx + 1 , i ) = 2.0 * ani * f ( nx + 1 , i ) ! forward fourier transform else if ( isign . gt . 0 ) then kmr = nxy / nxh do 70 j = 2 , nxhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( j - 1 ))), - real ( sctd ( 1 + kmr * ( j - 1 )))) t4 = f ( nx3 - 2 * j , i ) t5 = - f ( nx3 - 2 * j + 1 , i ) t2 = f ( 2 * j - 1 , i ) + t4 t3 = f ( 2 * j , i ) + t5 t6 = f ( 2 * j - 1 , i ) - t4 t5 = f ( 2 * j , i ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) f ( 2 * j - 1 , i ) = t2 + t4 f ( 2 * j , i ) = t3 + t5 f ( nx3 - 2 * j , i ) = t2 - t4 f ( nx3 - 2 * j + 1 , i ) = t5 - t3 70 continue f ( nxh + 1 , i ) = 2.0 * f ( nxh + 1 , i ) f ( nxh + 2 , i ) = - 2.0 * f ( nxh + 2 , i ) t2 = 2.0 * ( f ( 1 , i ) + f ( 2 , i )) f ( 2 , i ) = 2.0 * ( f ( 1 , i ) - f ( 2 , i )) f ( 1 , i ) = t2 f ( nx + 1 , i ) = 2.0 * f ( nx + 1 , i ) endif ! perform recursion for cosine transform sum1 = f ( nx + 1 , i ) f ( nx + 1 , i ) = f ( 2 , i ) f ( 2 , i ) = sum1 do 80 j = 2 , nxh sum1 = sum1 - f ( 2 * j , i ) f ( 2 * j , i ) = sum1 80 continue 90 continue !$OMP END PARALLEL DO return end !----------------------------------------------------------------------- subroutine PPFST2RMXY ( g , isign , mixup , sctd , indx , indy , kstrt , kxpi , kxpp & & , nyv , kxpd , nxhyd , nxyd ) ! this subroutine performs the y part of a two dimensional fast real ! sine transform and its inverse, for a subset of x, ! using real arithmetic, with OpenMP, ! for data which is distributed in blocks ! algorithm is described in Numerical Recipies in Fortran, Second Ed., ! by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, ! [Cambridge Univ. Press, 1992], p. 508. ! for isign = (-1,1), input: all, output: f ! approximate flop count: N*(5*log2(N) + 18)/nvp ! where N = (nx/2)*ny ! indx/indy = exponent which determines length in x/y direction, ! where nx=2**indx, ny=2**indy ! if isign = -1, an inverse sine transform is performed ! g(m,n) = sum(g(k,n)*sin(pi*m*k/ny)) ! if isign = 1, a forward sine transform is performed ! g(k,n) = sum(g(m,n)*sin(pi*m*k/ny)) ! mixup = array of bit reversed addresses ! sctd = sine/cosine table ! kstrt = starting data block number ! kxpi = initial x index used ! kxpp = number of x indices used ! nyv = first dimension of g >= ny + 1 ! kxpd = second dimension of g >= kxp + 1 ! nxhyd = maximum of (nx/2,ny) ! nxyd = maximum of (nx,ny) ! written by viktor k. decyk, ucla implicit none integer isign , indx , indy , kstrt , kxpi , kxpp , nyv , kxpd integer nxhyd , nxyd , mixup real g complex sctd dimension g ( nyv , kxpd ) dimension mixup ( nxhyd ), sctd ( nxyd ) ! local data integer indx1 , indy1 , indx1y , nx , ny , nyh , nyhh , ny3 , nxy , nxhy integer i , j , k , m , ks , km , kmr , nry , j1 , j2 , ns , ns2 , k1 , k2 integer kxps , nryb real at1 , at2 , t2 , t3 , t4 , t5 , t6 complex t1 double precision sum1 indx1 = indx - 1 indy1 = indy - 1 indx1y = max0 ( indx1 , indy ) nx = 2 ** indx ny = 2 ** indy nyh = ny / 2 nyhh = ny / 4 ny3 = ny + 3 nxy = max0 ( nx , ny ) nxhy = 2 ** indx1y ks = kstrt - 1 kxps = kxpi + kxpp - 1 if ( kstrt . gt . nx ) return if ( isign . eq . 0 ) return nryb = nxhy / nyh nry = nxy / nyh !$OMP PARALLEL DO !$OMP& PRIVATE(i,j,k,m,ns,ns2,km,kmr,k1,k2,j1,j2,at1,at2,t2,t3,t4,t5,t6, !$OMP& t1,sum1) do 90 i = kxpi , kxps ! create auxiliary array in y kmr = nxy / ny do 10 k = 2 , nyh k1 = 1 + kmr * ( k - 1 ) at2 = g ( ny + 2 - k , i ) at1 = g ( k , i ) + at2 at2 = g ( k , i ) - at2 at1 = - aimag ( sctd ( k1 )) * at1 at2 = 0.5 * at2 g ( k , i ) = at1 + at2 g ( ny + 2 - k , i ) = at1 - at2 10 continue g ( 1 , i ) = 0.0 g ( nyh + 1 , i ) = 2.0 * g ( nyh + 1 , i ) ! bit-reverse array elements in y do 20 k = 1 , nyh k1 = ( mixup ( k ) - 1 ) / nryb + 1 if ( k . lt . k1 ) then t2 = g ( 2 * k1 - 1 , i ) t3 = g ( 2 * k1 , i ) g ( 2 * k1 - 1 , i ) = g ( 2 * k - 1 , i ) g ( 2 * k1 , i ) = g ( 2 * k , i ) g ( 2 * k - 1 , i ) = t2 g ( 2 * k , i ) = t3 endif 20 continue ! then transform in y do 50 m = 1 , indy1 ns = 2 ** ( m - 1 ) ns2 = ns + ns km = nyhh / ns kmr = 2 * km * nry do 40 k = 1 , km k1 = ns2 * ( k - 1 ) k2 = k1 + ns do 30 j = 1 , ns j1 = j + k1 j2 = j + k2 t1 = sctd ( 1 + kmr * ( j - 1 )) t2 = real ( t1 ) * g ( 2 * j2 - 1 , i ) - aimag ( t1 ) * g ( 2 * j2 , i ) t3 = aimag ( t1 ) * g ( 2 * j2 - 1 , i ) + real ( t1 ) * g ( 2 * j2 , i ) g ( 2 * j2 - 1 , i ) = g ( 2 * j1 - 1 , i ) - t2 g ( 2 * j2 , i ) = g ( 2 * j1 , i ) - t3 g ( 2 * j1 - 1 , i ) = g ( 2 * j1 - 1 , i ) + t2 g ( 2 * j1 , i ) = g ( 2 * j1 , i ) + t3 30 continue 40 continue 50 continue ! unscramble coefficients and normalize ! inverse fourier transform if ( isign . lt . 0 ) then kmr = nxy / nyh do 60 k = 2 , nyhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( k - 1 ))), - real ( sctd ( 1 + kmr * ( k - 1 )))) t4 = g ( ny3 - 2 * k , i ) t5 = - g ( ny3 - 2 * k + 1 , i ) t2 = g ( 2 * k - 1 , i ) + t4 t3 = g ( 2 * k , i ) + t5 t6 = g ( 2 * k - 1 , i ) - t4 t5 = g ( 2 * k , i ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) g ( 2 * k - 1 , i ) = 0.5 * ( t2 + t4 ) g ( 2 * k , i ) = 0.5 * ( t3 + t5 ) g ( ny3 - 2 * k , i ) = 0.5 * ( t2 - t4 ) g ( ny3 - 2 * k + 1 , i ) = 0.5 * ( t5 - t3 ) 60 continue g ( nyh + 1 , i ) = g ( nyh + 1 , i ) g ( nyh + 2 , i ) = - g ( nyh + 2 , i ) t2 = g ( 1 , i ) + g ( 2 , i ) g ( 2 , i ) = g ( 1 , i ) - g ( 2 , i ) g ( 1 , i ) = t2 g ( ny + 1 , i ) = g ( ny + 1 , i ) ! forward fourier transform else if ( isign . gt . 0 ) then kmr = nxy / nyh do 70 k = 2 , nyhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( k - 1 ))), - real ( sctd ( 1 + kmr * ( k - 1 )))) t4 = g ( ny3 - 2 * k , i ) t5 = - g ( ny3 - 2 * k + 1 , i ) t2 = g ( 2 * k - 1 , i ) + t4 t3 = g ( 2 * k , i ) + t5 t6 = g ( 2 * k - 1 , i ) - t4 t5 = g ( 2 * k , i ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) g ( 2 * k - 1 , i ) = t2 + t4 g ( 2 * k , i ) = t3 + t5 g ( ny3 - 2 * k , i ) = t2 - t4 g ( ny3 - 2 * k + 1 , i ) = t5 - t3 70 continue g ( nyh + 1 , i ) = 2.0 * g ( nyh + 1 , i ) g ( nyh + 2 , i ) = - 2.0 * g ( nyh + 2 , i ) t2 = 2.0 * ( g ( 1 , i ) + g ( 2 , i )) g ( 2 , i ) = 2.0 * ( g ( 1 , i ) - g ( 2 , i )) g ( 1 , i ) = t2 g ( ny + 1 , i ) = 2.0 * g ( ny + 1 , i ) endif ! perform recursion for sine transform sum1 = 0.5 * g ( 1 , i ) g ( 1 , i ) = 0.0 g ( 2 , i ) = sum1 do 80 k = 2 , nyh sum1 = sum1 + g ( 2 * k - 1 , i ) g ( 2 * k - 1 , i ) = - g ( 2 * k , i ) g ( 2 * k , i ) = sum1 80 continue g ( ny + 1 , i ) = 0.0 90 continue !$OMP END PARALLEL DO return end !----------------------------------------------------------------------- subroutine PPFCT2RMXY ( g , isign , mixup , sctd , indx , indy , kstrt , kxpi , kxpp & & , nyv , kxpd , nxhyd , nxyd ) ! this subroutine performs the y part of a two dimensional fast real ! cosine transform and its inverse, for a subset of x, ! using real arithmetic, with OpenMP, ! for data which is distributed in blocks ! algorithm is described in Numerical Recipies in Fortran, Second Ed., ! by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, ! [Cambridge Univ. Press, 1992], p. 508. ! for isign = (-1,1), input: all, output: f ! approximate flop count: N*(5*log2(N) + 18)/nvp ! where N = (nx/2)*ny ! indx/indy = exponent which determines length in x/y direction, ! where nx=2**indx, ny=2**indy ! if isign = -1, an inverse cosine transform is performed ! g(m,n) = (.5*g(1,n) + ((-1)**m)*g(ny+1,n) !            + sum(g(k,n)*cos(pi*m*k/ny)) ! if isign = 1, a forward cosine transform is performed ! g(k,n) = 2*(.5*g(1,n) + ((-1)**m)*g(ny+1,n) + sum(g(m,n)* !            cos(pi*m*k/ny)) ! mixup = array of bit reversed addresses ! sctd = sine/cosine table ! kstrt = starting data block number ! kxpi = initial x index used ! kxpp = number of x indices used ! nyv = first dimension of g >= ny + 1 ! kxpd = second dimension of g >= kxp + 1 ! nxhyd = maximum of (nx/2,ny) ! nxyd = maximum of (nx,ny) ! written by viktor k. decyk, ucla implicit none integer isign , indx , indy , kstrt , kxpi , kxpp , nyv , kxpd integer nxhyd , nxyd , mixup real g complex sctd dimension g ( nyv , kxpd ) dimension mixup ( nxhyd ), sctd ( nxyd ) ! local data integer indx1 , indy1 , indx1y , nx , ny , nyh , nyhh , ny3 , nxy , nxhy integer i , j , k , m , ks , km , kmr , nry , j1 , j2 , ns , ns2 , k1 , k2 integer kxps , nryb real at1 , at2 , t2 , t3 , t4 , t5 , t6 complex t1 double precision sum1 indx1 = indx - 1 indy1 = indy - 1 indx1y = max0 ( indx1 , indy ) nx = 2 ** indx ny = 2 ** indy nyh = ny / 2 nyhh = ny / 4 ny3 = ny + 3 nxy = max0 ( nx , ny ) nxhy = 2 ** indx1y ks = kstrt - 1 kxps = kxpi + kxpp - 1 if ( kstrt . gt . nx ) return if ( isign . eq . 0 ) return nryb = nxhy / nyh nry = nxy / nyh !$OMP PARALLEL DO !$OMP& PRIVATE(i,j,k,m,ns,ns2,km,kmr,k1,k2,j1,j2,at1,at2,t2,t3,t4,t5,t6, !$OMP& t1,sum1) do 90 i = kxpi , kxps ! create auxiliary array in y kmr = nxy / ny sum1 = 0.5 * ( g ( 1 , i ) - g ( ny + 1 , i )) do 10 k = 2 , nyh k1 = 1 + kmr * ( k - 1 ) at2 = g ( ny + 2 - k , i ) at1 = g ( k , i ) + at2 at2 = g ( k , i ) - at2 sum1 = sum1 + real ( sctd ( k1 )) * at2 at2 = - aimag ( sctd ( k1 )) * at2 at1 = 0.5 * at1 g ( k , i ) = at1 - at2 g ( ny + 2 - k , i ) = at1 + at2 10 continue g ( 1 , i ) = 0.5 * ( g ( 1 , i ) + g ( ny + 1 , i )) g ( ny + 1 , i ) = sum1 ! bit-reverse array elements in y do 20 k = 1 , nyh k1 = ( mixup ( k ) - 1 ) / nryb + 1 if ( k . lt . k1 ) then t2 = g ( 2 * k1 - 1 , i ) t3 = g ( 2 * k1 , i ) g ( 2 * k1 - 1 , i ) = g ( 2 * k - 1 , i ) g ( 2 * k1 , i ) = g ( 2 * k , i ) g ( 2 * k - 1 , i ) = t2 g ( 2 * k , i ) = t3 endif 20 continue ! then transform in y do 50 m = 1 , indy1 ns = 2 ** ( m - 1 ) ns2 = ns + ns km = nyhh / ns kmr = 2 * km * nry do 40 k = 1 , km k1 = ns2 * ( k - 1 ) k2 = k1 + ns do 30 j = 1 , ns j1 = j + k1 j2 = j + k2 t1 = sctd ( 1 + kmr * ( j - 1 )) t2 = real ( t1 ) * g ( 2 * j2 - 1 , i ) - aimag ( t1 ) * g ( 2 * j2 , i ) t3 = aimag ( t1 ) * g ( 2 * j2 - 1 , i ) + real ( t1 ) * g ( 2 * j2 , i ) g ( 2 * j2 - 1 , i ) = g ( 2 * j1 - 1 , i ) - t2 g ( 2 * j2 , i ) = g ( 2 * j1 , i ) - t3 g ( 2 * j1 - 1 , i ) = g ( 2 * j1 - 1 , i ) + t2 g ( 2 * j1 , i ) = g ( 2 * j1 , i ) + t3 30 continue 40 continue 50 continue ! unscramble coefficients and normalize ! inverse fourier transform if ( isign . lt . 0 ) then kmr = nxy / nyh do 60 k = 2 , nyhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( k - 1 ))), - real ( sctd ( 1 + kmr * ( k - 1 )))) t4 = g ( ny3 - 2 * k , i ) t5 = - g ( ny3 - 2 * k + 1 , i ) t2 = g ( 2 * k - 1 , i ) + t4 t3 = g ( 2 * k , i ) + t5 t6 = g ( 2 * k - 1 , i ) - t4 t5 = g ( 2 * k , i ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) g ( 2 * k - 1 , i ) = 0.5 * ( t2 + t4 ) g ( 2 * k , i ) = 0.5 * ( t3 + t5 ) g ( ny3 - 2 * k , i ) = 0.5 * ( t2 - t4 ) g ( ny3 - 2 * k + 1 , i ) = 0.5 * ( t5 - t3 ) 60 continue g ( nyh + 1 , i ) = g ( nyh + 1 , i ) g ( nyh + 2 , i ) = - g ( nyh + 2 , i ) t2 = g ( 1 , i ) + g ( 2 , i ) g ( 2 , i ) = g ( 1 , i ) - g ( 2 , i ) g ( 1 , i ) = t2 g ( ny + 1 , i ) = g ( ny + 1 , i ) ! forward fourier transform else if ( isign . gt . 0 ) then kmr = nxy / nyh do 70 k = 2 , nyhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( k - 1 ))), - real ( sctd ( 1 + kmr * ( k - 1 )))) t4 = g ( ny3 - 2 * k , i ) t5 = - g ( ny3 - 2 * k + 1 , i ) t2 = g ( 2 * k - 1 , i ) + t4 t3 = g ( 2 * k , i ) + t5 t6 = g ( 2 * k - 1 , i ) - t4 t5 = g ( 2 * k , i ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) g ( 2 * k - 1 , i ) = t2 + t4 g ( 2 * k , i ) = t3 + t5 g ( ny3 - 2 * k , i ) = t2 - t4 g ( ny3 - 2 * k + 1 , i ) = t5 - t3 70 continue g ( nyh + 1 , i ) = 2.0 * g ( nyh + 1 , i ) g ( nyh + 2 , i ) = - 2.0 * g ( nyh + 2 , i ) t2 = 2.0 * ( g ( 1 , i ) + g ( 2 , i )) g ( 2 , i ) = 2.0 * ( g ( 1 , i ) - g ( 2 , i )) g ( 1 , i ) = t2 g ( ny + 1 , i ) = 2.0 * g ( ny + 1 , i ) endif ! perform recursion for cosine transform sum1 = g ( ny + 1 , i ) g ( ny + 1 , i ) = g ( 2 , i ) g ( 2 , i ) = sum1 do 80 k = 2 , nyh sum1 = sum1 - g ( 2 * k , i ) g ( 2 * k , i ) = sum1 80 continue 90 continue !$OMP END PARALLEL DO return end !----------------------------------------------------------------------- subroutine WPPFCST2RM2 ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp , indx , & & indy , kstrt , nvp , nxvh , nyv , kxp2 , kyp , kypd , kxp2d , nxhyd , nxyd ) ! wrapper function for 2 parallel real cosine/sine transforms ! for the electric field with dirichlet or magnetic field with neumann ! boundary conditions ! x component has a cosine/sine transform in x and y, respectively ! y component has a sine/cosine transform in x and y, respectively implicit none integer isign , ntpose , indx , indy , kstrt , nvp , nxvh , nyv integer kxp2 , kyp , kypd , kxp2d , nxhyd , nxyd , mixup real f , g , bs , br , ttp complex sctd dimension f ( 2 , 2 * nxvh , kypd ), g ( 2 , nyv , kxp2d ) dimension bs ( 2 , kxp2 + 1 , kyp + 1 ), br ( 2 , kxp2 + 1 , kyp + 1 ) dimension mixup ( nxhyd ), sctd ( nxyd ) ! local data integer nx , ny , kxpi , kypi , ks , kxp2p , kypp , kxb2 , kyb real tf double precision dtime data kxpi , kypi / 1 , 1 / ! calculate range of indices nx = 2 ** indx ny = 2 ** indy ! ks = processor id ks = kstrt - 1 ! kxp2p = actual size used in x direction kxp2p = min ( kxp2 , max ( 0 , nx - kxp2 * ks )) ! kypp = actual size used in y direction kypp = min ( kyp , max ( 0 , ny - kyp * ks )) ! kxb2 = minimum number of processors needed in x direction kxb2 = ( nx - 1 ) / kxp2 + 1 ! kyb = minimum number of processors needed in y direction kyb = ( ny - 1 ) / kyp + 1 ! add extra word for last processor in x if ( ks == ( kxb2 - 1 )) kxp2p = kxp2p + 1 ! add extra word for last processor in y if ( ks == ( kyb - 1 )) kypp = kypp + 1 ! inverse fourier transform if ( isign . lt . 0 ) then ! perform x cosine-sine transform call PPFCST2RM2X ( f , isign , mixup , sctd , indx , indy , kstrt , kypi , kypp , & & nxvh , kypd , nxhyd , nxyd ) ! transpose f array to g call PWTIMERA ( - 1 , ttp , dtime ) call PPRNTPOSE ( f , g , bs , br , nx , ny , kxp2 , kyp , kstrt , nvp , 2 , 2 * nxvh , nyv , & & kxp2d , kypd ) call PWTIMERA ( 1 , ttp , dtime ) ! perform y sine-cosine transform call PPFSCT2RM2Y ( g , isign , mixup , sctd , indx , indy , kstrt , kxpi , kxp2p , & & nyv , kxp2d , nxhyd , nxyd ) ! transpose g array to f if ( ntpose . eq . 0 ) then call PWTIMERA ( - 1 , tf , dtime ) call PPRNTPOSE ( g , f , br , bs , ny , nx , kyp , kxp2 , kstrt , nvp , 2 , nyv , & & 2 * nxvh , kypd , kxp2d ) call PWTIMERA ( 1 , tf , dtime ) endif ! forward fourier transform else if ( isign . gt . 0 ) then ! transpose f array to g if ( ntpose . eq . 0 ) then call PWTIMERA ( - 1 , tf , dtime ) call PPRNTPOSE ( f , g , bs , br , nx , ny , kxp2 , kyp , kstrt , nvp , 2 , 2 * nxvh , & & nyv , kxp2d , kypd ) call PWTIMERA ( 1 , tf , dtime ) endif ! perform y sine-cosine transform call PPFSCT2RM2Y ( g , isign , mixup , sctd , indx , indy , kstrt , kxpi , kxp2p , & & nyv , kxp2d , nxhyd , nxyd ) ! transpose g array to f call PWTIMERA ( - 1 , ttp , dtime ) call PPRNTPOSE ( g , f , br , bs , ny , nx , kyp , kxp2 , kstrt , nvp , 2 , nyv , 2 * nxvh , & & kypd , kxp2d ) call PWTIMERA ( 1 , ttp , dtime ) ! perform x cosine-sine transform call PPFCST2RM2X ( f , isign , mixup , sctd , indx , indy , kstrt , kypi , kypp , & & nxvh , kypd , nxhyd , nxyd ) endif if ( ntpose . eq . 0 ) ttp = ttp + tf return end !----------------------------------------------------------------------- subroutine WPPFSCT2RM2 ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp , indx , & & indy , kstrt , nvp , nxvh , nyv , kxp2 , kyp , kypd , kxp2d , nxhyd , nxyd ) ! wrapper function for 2 parallel real sine/cosine transforms ! for the magnetic field with dirichlet or electric field with neumann ! boundary conditions ! x component has a sine/cosine transform in x and y, respectively ! y component has a cosine/sine transform in x and y, respectively implicit none integer isign , ntpose , indx , indy , kstrt , nvp , nxvh , nyv integer kxp2 , kyp , kypd , kxp2d , nxhyd , nxyd , mixup real f , g , bs , br , ttp complex sctd dimension f ( 2 , 2 * nxvh , kypd ), g ( 2 , nyv , kxp2d ) dimension bs ( 2 , kxp2 + 1 , kyp + 1 ), br ( 2 , kxp2 + 1 , kyp + 1 ) dimension mixup ( nxhyd ), sctd ( nxyd ) ! local data integer nx , ny , kxpi , kypi , ks , kxp2p , kypp , kxb2 , kyb real tf double precision dtime data kxpi , kypi / 1 , 1 / ! calculate range of indices nx = 2 ** indx ny = 2 ** indy ! ks = processor id ks = kstrt - 1 ! kxp2p = actual size used in x direction kxp2p = min ( kxp2 , max ( 0 , nx - kxp2 * ks )) ! kypp = actual size used in y direction kypp = min ( kyp , max ( 0 , ny - kyp * ks )) ! kxb2 = minimum number of processors needed in x direction kxb2 = ( nx - 1 ) / kxp2 + 1 ! kyb = minimum number of processors needed in y direction kyb = ( ny - 1 ) / kyp + 1 ! add extra word for last processor in x if ( ks == ( kxb2 - 1 )) kxp2p = kxp2p + 1 ! add extra word for last processor in y if ( ks == ( kyb - 1 )) kypp = kypp + 1 ! inverse fourier transform if ( isign . lt . 0 ) then ! perform x sine-cosine transform call PPFSCT2RM2X ( f , isign , mixup , sctd , indx , indy , kstrt , kypi , kypp , & & nxvh , kypd , nxhyd , nxyd ) ! transpose f array to g call PWTIMERA ( - 1 , ttp , dtime ) call PPRNTPOSE ( f , g , bs , br , nx , ny , kxp2 , kyp , kstrt , nvp , 2 , 2 * nxvh , nyv , & & kxp2d , kypd ) call PWTIMERA ( 1 , ttp , dtime ) ! perform y cosine-sine transform call PPFCST2RM2Y ( g , isign , mixup , sctd , indx , indy , kstrt , kxpi , kxp2p , & & nyv , kxp2d , nxhyd , nxyd ) ! transpose g array to f if ( ntpose . eq . 0 ) then call PWTIMERA ( - 1 , tf , dtime ) call PPRNTPOSE ( g , f , br , bs , ny , nx , kyp , kxp2 , kstrt , nvp , 2 , nyv , & & 2 * nxvh , kypd , kxp2d ) call PWTIMERA ( 1 , tf , dtime ) endif ! forward fourier transform else if ( isign . gt . 0 ) then ! transpose f array to g if ( ntpose . eq . 0 ) then call PWTIMERA ( - 1 , tf , dtime ) call PPRNTPOSE ( f , g , bs , br , nx , ny , kxp2 , kyp , kstrt , nvp , 2 , 2 * nxvh , & & nyv , kxp2d , kypd ) call PWTIMERA ( 1 , tf , dtime ) endif ! perform y cosine-sine transform call PPFCST2RM2Y ( g , isign , mixup , sctd , indx , indy , kstrt , kxpi , kxp2p , & & nyv , kxp2d , nxhyd , nxyd ) ! transpose g array to f call PWTIMERA ( - 1 , ttp , dtime ) call PPRNTPOSE ( g , f , br , bs , ny , nx , kyp , kxp2 , kstrt , nvp , 2 , nyv , 2 * nxvh , & & kypd , kxp2d ) call PWTIMERA ( 1 , ttp , dtime ) ! perform x sine-cosine transform call PPFSCT2RM2X ( f , isign , mixup , sctd , indx , indy , kstrt , kypi , kypp , & & nxvh , kypd , nxhyd , nxyd ) endif if ( ntpose . eq . 0 ) ttp = ttp + tf return end !----------------------------------------------------------------------- subroutine PPFCST2RM2X ( f , isign , mixup , sctd , indx , indy , kstrt , kypi , & & kypp , nxvh , kypd , nxhyd , nxyd ) ! this subroutine performs the x part of 2 two dimensional fast real ! sine and cosine transforms and their inverses, for a subset of y, ! using real arithmetic, with OpenMP, ! for data which is distributed in blocks ! x component has a cosine transform, y component a sine transform ! algorithm is described in Numerical Recipies in Fortran, Second Ed., ! by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, ! [Cambridge Univ. Press, 1992], p. 508. ! for isign = (-1,1), input: all, output: f ! approximate flop count: N*(5*log2(N) + 18)/nvp ! where N = (nx/2)*ny ! indx/indy = exponent which determines length in x/y direction, ! where nx=2**indx, ny=2**indy ! if isign = -1, inverse cosine-sine transforms are performed ! f(1,n,k) = (1/nx*ny)*(.5*f(1,1,k) + ((-1)**n)*f(1,nx+1,k) !              + sum(f(1,j,k)*cos(pi*n*j/nx))) ! f(2,n,k) = (1/nx*ny)*sum(f(2,j,k)*sin(pi*n*j/nx)) ! if isign = 1, forward cosine-sine transforms are performed ! f(1,j,k) = 2*(.5*f(1,1,k) + ((-1)**j)*f(1,n+1,k) !              + sum(f(1,n,k)*cos(pi*n*j/nx)) ! f(2,j,k) = sum(f(2,n,k)*sin(pi*n*j/nx)) ! mixup = array of bit reversed addresses ! sctd = sine/cosine table ! kstrt = starting data block number ! kypi = initial y index used ! kypp = number of y indices used ! nxvh = second dimension of f >= nx/2 + 1 ! kypd = third dimension of f >= kyp + 1 ! nxhyd = maximum of (nx/2,ny) ! nxyd = maximum of (nx,ny) ! written by viktor k. decyk, ucla implicit none integer isign , indx , indy , kstrt , kypi , kypp integer nxvh , kypd , nxhyd , nxyd , mixup real f complex sctd dimension f ( 2 , 2 * nxvh , kypd ) dimension mixup ( nxhyd ), sctd ( nxyd ) ! local data integer indx1 , indx1y , nx , nxh , nxhh , nx3 , ny , nxy , nxhy , ks integer i , j , k , m , km , kmr , nrx , j1 , j2 , ns , ns2 , k1 , k2 , kyps integer nrxb , jj real at1 , at2 , at3 , t2 , t3 , t4 , t5 , t6 , ani complex t1 double precision sum1 , sum2 indx1 = indx - 1 indx1y = max0 ( indx1 , indy ) nx = 2 ** indx nxh = nx / 2 nxhh = nx / 4 nx3 = nx + 3 ny = 2 ** indy nxy = max0 ( nx , ny ) nxhy = 2 ** indx1y ks = kstrt - 1 kyps = kypi + kypp - 1 if ( kstrt . gt . ny ) return if ( isign . eq . 0 ) return ani = 0.5 / ( real ( nx ) * real ( ny )) nrxb = nxhy / nxh nrx = nxy / nxh !$OMP PARALLEL DO !$OMP& PRIVATE(i,j,k,m,jj,ns,ns2,km,kmr,k1,k2,j1,j2,at1,at2,at3,t2,t3,t4 !$OMP& ,t5,t6,t1,sum1,sum2) do 150 i = kypi , kyps ! create auxiliary array in x kmr = nxy / nx sum1 = 0.5 * ( f ( 1 , 1 , i ) - f ( 1 , nx + 1 , i )) do 10 j = 2 , nxh j1 = 1 + kmr * ( j - 1 ) at3 = - aimag ( sctd ( j1 )) at2 = f ( 1 , nx + 2 - j , i ) at1 = f ( 1 , j , i ) + at2 at2 = f ( 1 , j , i ) - at2 sum1 = sum1 + real ( sctd ( j1 )) * at2 at2 = at3 * at2 at1 = 0.5 * at1 f ( 1 , j , i ) = at1 - at2 f ( 1 , nx + 2 - j , i ) = at1 + at2 at2 = f ( 2 , nx + 2 - j , i ) at1 = f ( 2 , j , i ) + at2 at2 = f ( 2 , j , i ) - at2 at1 = at3 * at1 at2 = 0.5 * at2 f ( 2 , j , i ) = at1 + at2 f ( 2 , nx + 2 - j , i ) = at1 - at2 10 continue f ( 1 , 1 , i ) = 0.5 * ( f ( 1 , 1 , i ) + f ( 1 , nx + 1 , i )) f ( 1 , nx + 1 , i ) = sum1 f ( 2 , 1 , i ) = 0.0 f ( 2 , nxh + 1 , i ) = 2.0 * f ( 2 , nxh + 1 , i ) ! bit-reverse array elements in x do 30 j = 1 , nxh j1 = ( mixup ( j ) - 1 ) / nrxb + 1 if ( j . lt . j1 ) then do 20 jj = 1 , 2 t2 = f ( jj , 2 * j1 - 1 , i ) t3 = f ( jj , 2 * j1 , i ) f ( jj , 2 * j1 - 1 , i ) = f ( jj , 2 * j - 1 , i ) f ( jj , 2 * j1 , i ) = f ( jj , 2 * j , i ) f ( jj , 2 * j - 1 , i ) = t2 f ( jj , 2 * j , i ) = t3 20 continue endif 30 continue ! then transform in x do 70 m = 1 , indx1 ns = 2 ** ( m - 1 ) ns2 = ns + ns km = nxhh / ns kmr = 2 * km * nrx do 60 k = 1 , km k1 = ns2 * ( k - 1 ) k2 = k1 + ns do 50 j = 1 , ns j1 = j + k1 j2 = j + k2 t1 = sctd ( 1 + kmr * ( j - 1 )) do 40 jj = 1 , 2 t2 = real ( t1 ) * f ( jj , 2 * j2 - 1 , i ) - aimag ( t1 ) * f ( jj , 2 * j2 , i ) t3 = aimag ( t1 ) * f ( jj , 2 * j2 - 1 , i ) + real ( t1 ) * f ( jj , 2 * j2 , i ) f ( jj , 2 * j2 - 1 , i ) = f ( jj , 2 * j1 - 1 , i ) - t2 f ( jj , 2 * j2 , i ) = f ( jj , 2 * j1 , i ) - t3 f ( jj , 2 * j1 - 1 , i ) = f ( jj , 2 * j1 - 1 , i ) + t2 f ( jj , 2 * j1 , i ) = f ( jj , 2 * j1 , i ) + t3 40 continue 50 continue 60 continue 70 continue ! unscramble coefficients and normalize ! inverse fourier transform if ( isign . lt . 0 ) then kmr = nxy / nxh do 90 j = 2 , nxhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( j - 1 ))), - real ( sctd ( 1 + kmr * ( j - 1 )))) do 80 jj = 1 , 2 t4 = f ( jj , nx3 - 2 * j , i ) t5 = - f ( jj , nx3 - 2 * j + 1 , i ) t2 = f ( jj , 2 * j - 1 , i ) + t4 t3 = f ( jj , 2 * j , i ) + t5 t6 = f ( jj , 2 * j - 1 , i ) - t4 t5 = f ( jj , 2 * j , i ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) f ( jj , 2 * j - 1 , i ) = ani * ( t2 + t4 ) f ( jj , 2 * j , i ) = ani * ( t3 + t5 ) f ( jj , nx3 - 2 * j , i ) = ani * ( t2 - t4 ) f ( jj , nx3 - 2 * j + 1 , i ) = ani * ( t5 - t3 ) 80 continue 90 continue do 100 jj = 1 , 2 f ( jj , nxh + 1 , i ) = 2.0 * ani * f ( jj , nxh + 1 , i ) f ( jj , nxh + 2 , i ) = - 2.0 * ani * f ( jj , nxh + 2 , i ) t2 = 2.0 * ani * ( f ( jj , 1 , i ) + f ( jj , 2 , i )) f ( jj , 2 , i ) = 2.0 * ani * ( f ( jj , 1 , i ) - f ( jj , 2 , i )) f ( jj , 1 , i ) = t2 f ( jj , nx + 1 , i ) = 2.0 * ani * f ( jj , nx + 1 , i ) 100 continue ! forward fourier transform else if ( isign . gt . 0 ) then kmr = nxy / nxh do 120 j = 2 , nxhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( j - 1 ))), - real ( sctd ( 1 + kmr * ( j - 1 )))) do 110 jj = 1 , 2 t4 = f ( jj , nx3 - 2 * j , i ) t5 = - f ( jj , nx3 - 2 * j + 1 , i ) t2 = f ( jj , 2 * j - 1 , i ) + t4 t3 = f ( jj , 2 * j , i ) + t5 t6 = f ( jj , 2 * j - 1 , i ) - t4 t5 = f ( jj , 2 * j , i ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) f ( jj , 2 * j - 1 , i ) = t2 + t4 f ( jj , 2 * j , i ) = t3 + t5 f ( jj , nx3 - 2 * j , i ) = t2 - t4 f ( jj , nx3 - 2 * j + 1 , i ) = t5 - t3 110 continue 120 continue do 130 jj = 1 , 2 f ( jj , nxh + 1 , i ) = 2.0 * f ( jj , nxh + 1 , i ) f ( jj , nxh + 2 , i ) = - 2.0 * f ( jj , nxh + 2 , i ) t2 = 2.0 * ( f ( jj , 1 , i ) + f ( jj , 2 , i )) f ( jj , 2 , i ) = 2.0 * ( f ( jj , 1 , i ) - f ( jj , 2 , i )) f ( jj , 1 , i ) = t2 f ( jj , nx + 1 , i ) = 2.0 * f ( jj , nx + 1 , i ) 130 continue endif ! perform recursion for cosine-sine transform sum1 = f ( 1 , nx + 1 , i ) f ( 1 , nx + 1 , i ) = f ( 1 , 2 , i ) f ( 1 , 2 , i ) = sum1 sum2 = 0.5 * f ( 2 , 1 , i ) f ( 2 , 1 , i ) = 0.0 f ( 2 , 2 , i ) = sum2 do 140 j = 2 , nxh sum1 = sum1 - f ( 1 , 2 * j , i ) f ( 1 , 2 * j , i ) = sum1 sum2 = sum2 + f ( 2 , 2 * j - 1 , i ) f ( 2 , 2 * j - 1 , i ) = - f ( 2 , 2 * j , i ) f ( 2 , 2 * j , i ) = sum2 140 continue f ( 2 , nx + 1 , i ) = 0.0 150 continue !$OMP END PARALLEL DO return end !----------------------------------------------------------------------- subroutine PPFSCT2RM2X ( f , isign , mixup , sctd , indx , indy , kstrt , kypi , & & kypp , nxvh , kypd , nxhyd , nxyd ) ! this subroutine performs the x part of 2 two dimensional fast real ! sine and cosine transforms and their inverses, for a subset of y, ! using real arithmetic, with OpenMP, ! for data which is distributed in blocks ! x component has a sine transform, y component a cosine transform ! algorithm is described in Numerical Recipies in Fortran, Second Ed., ! by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, ! [Cambridge Univ. Press, 1992], p. 508. ! for isign = (-1,1), input: all, output: f ! approximate flop count: N*(5*log2(N) + 18)/nvp ! where N = (nx/2)*ny ! indx/indy = exponent which determines length in x/y direction, ! where nx=2**indx, ny=2**indy ! if isign = -1, inverse sine-cosine transforms are performed ! f(1,n,k) = (1/nx*ny)*sum(f(1,j,k)*sin(pi*n*j/nx)) ! f(2,n,k) = (1/nx*ny)*(.5*f(2,1,k) + ((-1)**n)*f(2,nx+1,k) !              + sum(f(2,j,k)*cos(pi*n*j/nx))) ! if isign = 1, forward sine-cosine transforms are performed ! f(1,j,k) = sum(f(1,n,k)*sin(pi*n*j/nx)) ! f(2,j,k) = 2*(.5*f(2,1,k) + ((-1)**j)*f(2,n+1,k) !              + sum(f(2,n,k)*cos(pi*n*j/nx)) ! mixup = array of bit reversed addresses ! sctd = sine/cosine table ! kstrt = starting data block number ! kypi = initial y index used ! kypp = number of y indices used ! nxvh = second dimension of f >= nx/2 + 1 ! kypd = third dimension of f >= kyp + 1 ! nxhyd = maximum of (nx/2,ny) ! nxyd = maximum of (nx,ny) ! written by viktor k. decyk, ucla implicit none integer isign , indx , indy , kstrt , kypi , kypp integer nxvh , kypd , nxhyd , nxyd , mixup real f complex sctd dimension f ( 2 , 2 * nxvh , kypd ) dimension mixup ( nxhyd ), sctd ( nxyd ) ! local data integer indx1 , indx1y , nx , nxh , nxhh , nx3 , ny , nxy , nxhy , ks integer i , j , k , m , km , kmr , nrx , j1 , j2 , ns , ns2 , k1 , k2 , kyps integer nrxb , jj real at1 , at2 , at3 , t2 , t3 , t4 , t5 , t6 , ani complex t1 double precision sum1 , sum2 indx1 = indx - 1 indx1y = max0 ( indx1 , indy ) nx = 2 ** indx nxh = nx / 2 nxhh = nx / 4 nx3 = nx + 3 ny = 2 ** indy nxy = max0 ( nx , ny ) nxhy = 2 ** indx1y ks = kstrt - 1 kyps = kypi + kypp - 1 if ( kstrt . gt . ny ) return if ( isign . eq . 0 ) return ani = 0.5 / ( real ( nx ) * real ( ny )) nrxb = nxhy / nxh nrx = nxy / nxh !$OMP PARALLEL DO !$OMP& PRIVATE(i,j,k,m,jj,ns,ns2,km,kmr,k1,k2,j1,j2,at1,at2,at3,t2,t3,t4 !$OMP& ,t5,t6,t1,sum1,sum2) do 150 i = kypi , kyps ! create auxiliary array in x kmr = nxy / nx sum1 = 0.5 * ( f ( 2 , 1 , i ) - f ( 2 , nx + 1 , i )) do 10 j = 2 , nxh j1 = 1 + kmr * ( j - 1 ) at3 = - aimag ( sctd ( j1 )) at2 = f ( 1 , nx + 2 - j , i ) at1 = f ( 1 , j , i ) + at2 at2 = f ( 1 , j , i ) - at2 at1 = at3 * at1 at2 = 0.5 * at2 f ( 1 , j , i ) = at1 + at2 f ( 1 , nx + 2 - j , i ) = at1 - at2 at2 = f ( 2 , nx + 2 - j , i ) at1 = f ( 2 , j , i ) + at2 at2 = f ( 2 , j , i ) - at2 sum1 = sum1 + real ( sctd ( j1 )) * at2 at2 = at3 * at2 at1 = 0.5 * at1 f ( 2 , j , i ) = at1 - at2 f ( 2 , nx + 2 - j , i ) = at1 + at2 10 continue f ( 1 , 1 , i ) = 0.0 f ( 1 , nxh + 1 , i ) = 2.0 * f ( 1 , nxh + 1 , i ) f ( 2 , 1 , i ) = 0.5 * ( f ( 2 , 1 , i ) + f ( 2 , nx + 1 , i )) f ( 2 , nx + 1 , i ) = sum1 ! bit-reverse array elements in x do 30 j = 1 , nxh j1 = ( mixup ( j ) - 1 ) / nrxb + 1 if ( j . lt . j1 ) then do 20 jj = 1 , 2 t2 = f ( jj , 2 * j1 - 1 , i ) t3 = f ( jj , 2 * j1 , i ) f ( jj , 2 * j1 - 1 , i ) = f ( jj , 2 * j - 1 , i ) f ( jj , 2 * j1 , i ) = f ( jj , 2 * j , i ) f ( jj , 2 * j - 1 , i ) = t2 f ( jj , 2 * j , i ) = t3 20 continue endif 30 continue ! then transform in x do 70 m = 1 , indx1 ns = 2 ** ( m - 1 ) ns2 = ns + ns km = nxhh / ns kmr = 2 * km * nrx do 60 k = 1 , km k1 = ns2 * ( k - 1 ) k2 = k1 + ns do 50 j = 1 , ns j1 = j + k1 j2 = j + k2 t1 = sctd ( 1 + kmr * ( j - 1 )) do 40 jj = 1 , 2 t2 = real ( t1 ) * f ( jj , 2 * j2 - 1 , i ) - aimag ( t1 ) * f ( jj , 2 * j2 , i ) t3 = aimag ( t1 ) * f ( jj , 2 * j2 - 1 , i ) + real ( t1 ) * f ( jj , 2 * j2 , i ) f ( jj , 2 * j2 - 1 , i ) = f ( jj , 2 * j1 - 1 , i ) - t2 f ( jj , 2 * j2 , i ) = f ( jj , 2 * j1 , i ) - t3 f ( jj , 2 * j1 - 1 , i ) = f ( jj , 2 * j1 - 1 , i ) + t2 f ( jj , 2 * j1 , i ) = f ( jj , 2 * j1 , i ) + t3 40 continue 50 continue 60 continue 70 continue ! unscramble coefficients and normalize ! inverse fourier transform if ( isign . lt . 0 ) then kmr = nxy / nxh do 90 j = 2 , nxhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( j - 1 ))), - real ( sctd ( 1 + kmr * ( j - 1 )))) do 80 jj = 1 , 2 t4 = f ( jj , nx3 - 2 * j , i ) t5 = - f ( jj , nx3 - 2 * j + 1 , i ) t2 = f ( jj , 2 * j - 1 , i ) + t4 t3 = f ( jj , 2 * j , i ) + t5 t6 = f ( jj , 2 * j - 1 , i ) - t4 t5 = f ( jj , 2 * j , i ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) f ( jj , 2 * j - 1 , i ) = ani * ( t2 + t4 ) f ( jj , 2 * j , i ) = ani * ( t3 + t5 ) f ( jj , nx3 - 2 * j , i ) = ani * ( t2 - t4 ) f ( jj , nx3 - 2 * j + 1 , i ) = ani * ( t5 - t3 ) 80 continue 90 continue do 100 jj = 1 , 2 f ( jj , nxh + 1 , i ) = 2.0 * ani * f ( jj , nxh + 1 , i ) f ( jj , nxh + 2 , i ) = - 2.0 * ani * f ( jj , nxh + 2 , i ) t2 = 2.0 * ani * ( f ( jj , 1 , i ) + f ( jj , 2 , i )) f ( jj , 2 , i ) = 2.0 * ani * ( f ( jj , 1 , i ) - f ( jj , 2 , i )) f ( jj , 1 , i ) = t2 f ( jj , nx + 1 , i ) = 2.0 * ani * f ( jj , nx + 1 , i ) 100 continue ! forward fourier transform else if ( isign . gt . 0 ) then kmr = nxy / nxh do 120 j = 2 , nxhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( j - 1 ))), - real ( sctd ( 1 + kmr * ( j - 1 )))) do 110 jj = 1 , 2 t4 = f ( jj , nx3 - 2 * j , i ) t5 = - f ( jj , nx3 - 2 * j + 1 , i ) t2 = f ( jj , 2 * j - 1 , i ) + t4 t3 = f ( jj , 2 * j , i ) + t5 t6 = f ( jj , 2 * j - 1 , i ) - t4 t5 = f ( jj , 2 * j , i ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) f ( jj , 2 * j - 1 , i ) = t2 + t4 f ( jj , 2 * j , i ) = t3 + t5 f ( jj , nx3 - 2 * j , i ) = t2 - t4 f ( jj , nx3 - 2 * j + 1 , i ) = t5 - t3 110 continue 120 continue do 130 jj = 1 , 2 f ( jj , nxh + 1 , i ) = 2.0 * f ( jj , nxh + 1 , i ) f ( jj , nxh + 2 , i ) = - 2.0 * f ( jj , nxh + 2 , i ) t2 = 2.0 * ( f ( jj , 1 , i ) + f ( jj , 2 , i )) f ( jj , 2 , i ) = 2.0 * ( f ( jj , 1 , i ) - f ( jj , 2 , i )) f ( jj , 1 , i ) = t2 f ( jj , nx + 1 , i ) = 2.0 * f ( jj , nx + 1 , i ) 130 continue endif ! perform recursion for cosine-sine transform sum1 = 0.5 * f ( 1 , 1 , i ) f ( 1 , 1 , i ) = 0.0 f ( 1 , 2 , i ) = sum1 sum2 = f ( 2 , nx + 1 , i ) f ( 2 , nx + 1 , i ) = f ( 2 , 2 , i ) f ( 2 , 2 , i ) = sum2 do 140 j = 2 , nxh sum1 = sum1 + f ( 1 , 2 * j - 1 , i ) f ( 1 , 2 * j - 1 , i ) = - f ( 1 , 2 * j , i ) f ( 1 , 2 * j , i ) = sum1 sum2 = sum2 - f ( 2 , 2 * j , i ) f ( 2 , 2 * j , i ) = sum2 140 continue f ( 1 , nx + 1 , i ) = 0.0 150 continue !$OMP END PARALLEL DO return end !----------------------------------------------------------------------- subroutine PPFSCT2RM2Y ( g , isign , mixup , sctd , indx , indy , kstrt , kxpi , & & kxpp , nyv , kxpd , nxhyd , nxyd ) ! this subroutine performs the y part of 2 two dimensional fast real ! sine and cosine transforms and their inverses, for a subset of x, ! using real arithmetic, with OpenMP, ! for data which is distributed in blocks ! x component has a sine transform, y component a cosine transform ! algorithm is described in Numerical Recipies in Fortran, Second Ed., ! by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, ! [Cambridge Univ. Press, 1992], p. 508. ! for isign = (-1,1), input: all, output: f ! approximate flop count: N*(5*log2(N) + 18)/nvp ! where N = (nx/2)*ny ! indx/indy = exponent which determines length in x/y direction, ! where nx=2**indx, ny=2**indy ! if isign = -1, inverse sine-cosine transform are performed ! g(1,m,n) = sum(g(1,k,n)*sin(pi*m*k/ny)) ! g(2,m,n) = (.5*g(2,1,n) + ((-1)**m)*g(2,ny+1,n) !              + sum(g(2,k,n)*cos(pi*m*k/ny)) ! if isign = 1, a forward sine-cosine transforms are performed ! g(1,k,n) = sum(g(1,m,n)*sin(pi*m*k/ny)) ! g(2,k,n) = 2*(.5*g(2,1,n) + ((-1)**m)*g(2,ny+1,n) !              + sum(g(2,m,n)*cos(pi*m*k/ny)) ! mixup = array of bit reversed addresses ! sctd = sine/cosine table ! kstrt = starting data block number ! kxpi = initial x index used ! kxpp = number of x indices used ! nyv = second dimension of g >= ny + 1 ! kxpd = third dimension of g >= kxp + 1 ! nxhyd = maximum of (nx/2,ny) ! nxyd = maximum of (nx,ny) ! written by viktor k. decyk, ucla implicit none integer isign , indx , indy , kstrt , kxpi , kxpp integer nyv , kxpd , nxhyd , nxyd , mixup real g complex sctd dimension g ( 2 , nyv , kxpd ) dimension mixup ( nxhyd ), sctd ( nxyd ) ! local data integer indx1 , indy1 , indx1y , nx , ny , nyh , nyhh , ny3 , nxy , nxhy integer i , j , k , m , ks , km , kmr , nry , j1 , j2 , ns , ns2 , k1 , k2 integer kxps , nryb , jj real at1 , at2 , at3 , t2 , t3 , t4 , t5 , t6 complex t1 double precision sum1 , sum2 indx1 = indx - 1 indy1 = indy - 1 indx1y = max0 ( indx1 , indy ) nx = 2 ** indx ny = 2 ** indy nyh = ny / 2 nyhh = ny / 4 ny3 = ny + 3 nxy = max0 ( nx , ny ) nxhy = 2 ** indx1y ks = kstrt - 1 kxps = kxpi + kxpp - 1 if ( kstrt . gt . nx ) return if ( isign . eq . 0 ) return nryb = nxhy / nyh nry = nxy / nyh !$OMP PARALLEL DO !$OMP& PRIVATE(i,j,k,m,jj,ns,ns2,km,kmr,k1,k2,j1,j2,at1,at2,at3,t2,t3,t4 !$OMP& ,t5,t6,t1,sum1,sum2) do 150 i = kxpi , kxps ! create auxiliary array in y kmr = nxy / ny sum1 = 0.5 * ( g ( 2 , 1 , i ) - g ( 2 , ny + 1 , i )) do 10 k = 2 , nyh k1 = 1 + kmr * ( k - 1 ) at3 = - aimag ( sctd ( k1 )) at2 = g ( 1 , ny + 2 - k , i ) at1 = g ( 1 , k , i ) + at2 at2 = g ( 1 , k , i ) - at2 at1 = at3 * at1 at2 = 0.5 * at2 g ( 1 , k , i ) = at1 + at2 g ( 1 , ny + 2 - k , i ) = at1 - at2 at2 = g ( 2 , ny + 2 - k , i ) at1 = g ( 2 , k , i ) + at2 at2 = g ( 2 , k , i ) - at2 sum1 = sum1 + real ( sctd ( k1 )) * at2 at2 = at3 * at2 at1 = 0.5 * at1 g ( 2 , k , i ) = at1 - at2 g ( 2 , ny + 2 - k , i ) = at1 + at2 10 continue g ( 1 , 1 , i ) = 0.0 g ( 1 , nyh + 1 , i ) = 2.0 * g ( 1 , nyh + 1 , i ) g ( 2 , 1 , i ) = 0.5 * ( g ( 2 , 1 , i ) + g ( 2 , ny + 1 , i )) g ( 2 , ny + 1 , i ) = sum1 ! bit-reverse array elements in y do 30 k = 1 , nyh k1 = ( mixup ( k ) - 1 ) / nryb + 1 if ( k . lt . k1 ) then do 20 jj = 1 , 2 t2 = g ( jj , 2 * k1 - 1 , i ) t3 = g ( jj , 2 * k1 , i ) g ( jj , 2 * k1 - 1 , i ) = g ( jj , 2 * k - 1 , i ) g ( jj , 2 * k1 , i ) = g ( jj , 2 * k , i ) g ( jj , 2 * k - 1 , i ) = t2 g ( jj , 2 * k , i ) = t3 20 continue endif 30 continue ! then transform in y do 70 m = 1 , indy1 ns = 2 ** ( m - 1 ) ns2 = ns + ns km = nyhh / ns kmr = 2 * km * nry do 60 k = 1 , km k1 = ns2 * ( k - 1 ) k2 = k1 + ns do 50 j = 1 , ns j1 = j + k1 j2 = j + k2 t1 = sctd ( 1 + kmr * ( j - 1 )) do 40 jj = 1 , 2 t2 = real ( t1 ) * g ( jj , 2 * j2 - 1 , i ) - aimag ( t1 ) * g ( jj , 2 * j2 , i ) t3 = aimag ( t1 ) * g ( jj , 2 * j2 - 1 , i ) + real ( t1 ) * g ( jj , 2 * j2 , i ) g ( jj , 2 * j2 - 1 , i ) = g ( jj , 2 * j1 - 1 , i ) - t2 g ( jj , 2 * j2 , i ) = g ( jj , 2 * j1 , i ) - t3 g ( jj , 2 * j1 - 1 , i ) = g ( jj , 2 * j1 - 1 , i ) + t2 g ( jj , 2 * j1 , i ) = g ( jj , 2 * j1 , i ) + t3 40 continue 50 continue 60 continue 70 continue ! unscramble coefficients and normalize ! inverse fourier transform if ( isign . lt . 0 ) then kmr = nxy / nyh do 90 k = 2 , nyhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( k - 1 ))), - real ( sctd ( 1 + kmr * ( k - 1 )))) do 80 jj = 1 , 2 t4 = g ( jj , ny3 - 2 * k , i ) t5 = - g ( jj , ny3 - 2 * k + 1 , i ) t2 = g ( jj , 2 * k - 1 , i ) + t4 t3 = g ( jj , 2 * k , i ) + t5 t6 = g ( jj , 2 * k - 1 , i ) - t4 t5 = g ( jj , 2 * k , i ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) g ( jj , 2 * k - 1 , i ) = 0.5 * ( t2 + t4 ) g ( jj , 2 * k , i ) = 0.5 * ( t3 + t5 ) g ( jj , ny3 - 2 * k , i ) = 0.5 * ( t2 - t4 ) g ( jj , ny3 - 2 * k + 1 , i ) = 0.5 * ( t5 - t3 ) 80 continue 90 continue do 100 jj = 1 , 2 g ( jj , nyh + 1 , i ) = g ( jj , nyh + 1 , i ) g ( jj , nyh + 2 , i ) = - g ( jj , nyh + 2 , i ) t2 = g ( jj , 1 , i ) + g ( jj , 2 , i ) g ( jj , 2 , i ) = g ( jj , 1 , i ) - g ( jj , 2 , i ) g ( jj , 1 , i ) = t2 g ( jj , ny + 1 , i ) = g ( jj , ny + 1 , i ) 100 continue ! forward fourier transform else if ( isign . gt . 0 ) then kmr = nxy / nyh do 120 k = 2 , nyhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( k - 1 ))), - real ( sctd ( 1 + kmr * ( k - 1 )))) do 110 jj = 1 , 2 t4 = g ( jj , ny3 - 2 * k , i ) t5 = - g ( jj , ny3 - 2 * k + 1 , i ) t2 = g ( jj , 2 * k - 1 , i ) + t4 t3 = g ( jj , 2 * k , i ) + t5 t6 = g ( jj , 2 * k - 1 , i ) - t4 t5 = g ( jj , 2 * k , i ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) g ( jj , 2 * k - 1 , i ) = t2 + t4 g ( jj , 2 * k , i ) = t3 + t5 g ( jj , ny3 - 2 * k , i ) = t2 - t4 g ( jj , ny3 - 2 * k + 1 , i ) = t5 - t3 110 continue 120 continue do 130 jj = 1 , 2 g ( jj , nyh + 1 , i ) = 2.0 * g ( jj , nyh + 1 , i ) g ( jj , nyh + 2 , i ) = - 2.0 * g ( jj , nyh + 2 , i ) t2 = 2.0 * ( g ( jj , 1 , i ) + g ( jj , 2 , i )) g ( jj , 2 , i ) = 2.0 * ( g ( jj , 1 , i ) - g ( jj , 2 , i )) g ( jj , 1 , i ) = t2 g ( jj , ny + 1 , i ) = 2.0 * g ( jj , ny + 1 , i ) 130 continue endif ! perform recursion for sine-cosine transform sum1 = 0.5 * g ( 1 , 1 , i ) g ( 1 , 1 , i ) = 0.0 g ( 1 , 2 , i ) = sum1 sum2 = g ( 2 , ny + 1 , i ) g ( 2 , ny + 1 , i ) = g ( 2 , 2 , i ) g ( 2 , 2 , i ) = sum2 do 140 k = 2 , nyh sum1 = sum1 + g ( 1 , 2 * k - 1 , i ) g ( 1 , 2 * k - 1 , i ) = - g ( 1 , 2 * k , i ) g ( 1 , 2 * k , i ) = sum1 sum2 = sum2 - g ( 2 , 2 * k , i ) g ( 2 , 2 * k , i ) = sum2 140 continue g ( 1 , ny + 1 , i ) = 0.0 150 continue !$OMP END PARALLEL DO return end !----------------------------------------------------------------------- subroutine PPFCST2RM2Y ( g , isign , mixup , sctd , indx , indy , kstrt , kxpi , & & kxpp , nyv , kxpd , nxhyd , nxyd ) ! this subroutine performs the y part of 2 two dimensional fast real ! sine and cosine transforms and their inverses, for a subset of x, ! using real arithmetic, with OpenMP, ! for data which is distributed in blocks ! x component has a cosine transform, y component a sine transform ! algorithm is described in Numerical Recipies in Fortran, Second Ed., ! by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, ! [Cambridge Univ. Press, 1992], p. 508. ! for isign = (-1,1), input: all, output: f ! approximate flop count: N*(5*log2(N) + 18)/nvp ! where N = (nx/2)*ny ! indx/indy = exponent which determines length in x/y direction, ! where nx=2**indx, ny=2**indy ! if isign = -1, inverse cosine-sine transform are performed ! g(1,m,n) = (.5*g(1,1,n) + ((-1)**m)*g(1,ny+1,n) !              + sum(g(1,k,n)*cos(pi*m*k/ny)) ! g(2,m,n) = sum(g(2,k,n)*sin(pi*m*k/ny)) ! if isign = 1, a forward cosine-sine transforms are performed ! g(1,k,n) = 2*(.5*g(1,1,n) + ((-1)**m)*g(1,ny+1,n) !              + sum(g(1,m,n)*cos(pi*m*k/ny)) ! g(2,k,n) = sum(g(2,m,n)*sin(pi*m*k/ny)) ! mixup = array of bit reversed addresses ! sctd = sine/cosine table ! kstrt = starting data block number ! kxpi = initial x index used ! kxpp = number of x indices used ! nyv = second dimension of g >= ny + 1 ! kxpd = third dimension of g >= kxp + 1 ! nxhyd = maximum of (nx/2,ny) ! nxyd = maximum of (nx,ny) ! written by viktor k. decyk, ucla implicit none integer isign , indx , indy , kstrt , kxpi , kxpp integer nyv , kxpd , nxhyd , nxyd , mixup real g complex sctd dimension g ( 2 , nyv , kxpd ) dimension mixup ( nxhyd ), sctd ( nxyd ) ! local data integer indx1 , indy1 , indx1y , nx , ny , nyh , nyhh , ny3 , nxy , nxhy integer i , j , k , m , ks , km , kmr , nry , j1 , j2 , ns , ns2 , k1 , k2 integer kxps , nryb , jj real at1 , at2 , at3 , t2 , t3 , t4 , t5 , t6 complex t1 double precision sum1 , sum2 indx1 = indx - 1 indy1 = indy - 1 indx1y = max0 ( indx1 , indy ) nx = 2 ** indx ny = 2 ** indy nyh = ny / 2 nyhh = ny / 4 ny3 = ny + 3 nxy = max0 ( nx , ny ) nxhy = 2 ** indx1y ks = kstrt - 1 kxps = kxpi + kxpp - 1 if ( kstrt . gt . nx ) return if ( isign . eq . 0 ) return nryb = nxhy / nyh nry = nxy / nyh !$OMP PARALLEL DO !$OMP& PRIVATE(i,j,k,m,jj,ns,ns2,km,kmr,k1,k2,j1,j2,at1,at2,at3,t2,t3,t4 !$OMP& ,t5,t6,t1,sum1,sum2) do 150 i = kxpi , kxps ! create auxiliary array in y kmr = nxy / ny sum1 = 0.5 * ( g ( 1 , 1 , i ) - g ( 1 , ny + 1 , i )) do 10 k = 2 , nyh k1 = 1 + kmr * ( k - 1 ) at3 = - aimag ( sctd ( k1 )) at2 = g ( 1 , ny + 2 - k , i ) at1 = g ( 1 , k , i ) + at2 at2 = g ( 1 , k , i ) - at2 sum1 = sum1 + real ( sctd ( k1 )) * at2 at2 = at3 * at2 at1 = 0.5 * at1 g ( 1 , k , i ) = at1 - at2 g ( 1 , ny + 2 - k , i ) = at1 + at2 at2 = g ( 2 , ny + 2 - k , i ) at1 = g ( 2 , k , i ) + at2 at2 = g ( 2 , k , i ) - at2 at1 = at3 * at1 at2 = 0.5 * at2 g ( 2 , k , i ) = at1 + at2 g ( 2 , ny + 2 - k , i ) = at1 - at2 10 continue g ( 1 , 1 , i ) = 0.5 * ( g ( 1 , 1 , i ) + g ( 1 , ny + 1 , i )) g ( 1 , ny + 1 , i ) = sum1 g ( 2 , 1 , i ) = 0.0 g ( 2 , nyh + 1 , i ) = 2.0 * g ( 2 , nyh + 1 , i ) ! bit-reverse array elements in y do 30 k = 1 , nyh k1 = ( mixup ( k ) - 1 ) / nryb + 1 if ( k . lt . k1 ) then do 20 jj = 1 , 2 t2 = g ( jj , 2 * k1 - 1 , i ) t3 = g ( jj , 2 * k1 , i ) g ( jj , 2 * k1 - 1 , i ) = g ( jj , 2 * k - 1 , i ) g ( jj , 2 * k1 , i ) = g ( jj , 2 * k , i ) g ( jj , 2 * k - 1 , i ) = t2 g ( jj , 2 * k , i ) = t3 20 continue endif 30 continue ! then transform in y do 70 m = 1 , indy1 ns = 2 ** ( m - 1 ) ns2 = ns + ns km = nyhh / ns kmr = 2 * km * nry do 60 k = 1 , km k1 = ns2 * ( k - 1 ) k2 = k1 + ns do 50 j = 1 , ns j1 = j + k1 j2 = j + k2 t1 = sctd ( 1 + kmr * ( j - 1 )) do 40 jj = 1 , 2 t2 = real ( t1 ) * g ( jj , 2 * j2 - 1 , i ) - aimag ( t1 ) * g ( jj , 2 * j2 , i ) t3 = aimag ( t1 ) * g ( jj , 2 * j2 - 1 , i ) + real ( t1 ) * g ( jj , 2 * j2 , i ) g ( jj , 2 * j2 - 1 , i ) = g ( jj , 2 * j1 - 1 , i ) - t2 g ( jj , 2 * j2 , i ) = g ( jj , 2 * j1 , i ) - t3 g ( jj , 2 * j1 - 1 , i ) = g ( jj , 2 * j1 - 1 , i ) + t2 g ( jj , 2 * j1 , i ) = g ( jj , 2 * j1 , i ) + t3 40 continue 50 continue 60 continue 70 continue ! unscramble coefficients and normalize ! inverse fourier transform if ( isign . lt . 0 ) then kmr = nxy / nyh do 90 k = 2 , nyhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( k - 1 ))), - real ( sctd ( 1 + kmr * ( k - 1 )))) do 80 jj = 1 , 2 t4 = g ( jj , ny3 - 2 * k , i ) t5 = - g ( jj , ny3 - 2 * k + 1 , i ) t2 = g ( jj , 2 * k - 1 , i ) + t4 t3 = g ( jj , 2 * k , i ) + t5 t6 = g ( jj , 2 * k - 1 , i ) - t4 t5 = g ( jj , 2 * k , i ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) g ( jj , 2 * k - 1 , i ) = 0.5 * ( t2 + t4 ) g ( jj , 2 * k , i ) = 0.5 * ( t3 + t5 ) g ( jj , ny3 - 2 * k , i ) = 0.5 * ( t2 - t4 ) g ( jj , ny3 - 2 * k + 1 , i ) = 0.5 * ( t5 - t3 ) 80 continue 90 continue do 100 jj = 1 , 2 g ( jj , nyh + 1 , i ) = g ( jj , nyh + 1 , i ) g ( jj , nyh + 2 , i ) = - g ( jj , nyh + 2 , i ) t2 = g ( jj , 1 , i ) + g ( jj , 2 , i ) g ( jj , 2 , i ) = g ( jj , 1 , i ) - g ( jj , 2 , i ) g ( jj , 1 , i ) = t2 g ( jj , ny + 1 , i ) = g ( jj , ny + 1 , i ) 100 continue ! forward fourier transform else if ( isign . gt . 0 ) then kmr = nxy / nyh do 120 k = 2 , nyhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( k - 1 ))), - real ( sctd ( 1 + kmr * ( k - 1 )))) do 110 jj = 1 , 2 t4 = g ( jj , ny3 - 2 * k , i ) t5 = - g ( jj , ny3 - 2 * k + 1 , i ) t2 = g ( jj , 2 * k - 1 , i ) + t4 t3 = g ( jj , 2 * k , i ) + t5 t6 = g ( jj , 2 * k - 1 , i ) - t4 t5 = g ( jj , 2 * k , i ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) g ( jj , 2 * k - 1 , i ) = t2 + t4 g ( jj , 2 * k , i ) = t3 + t5 g ( jj , ny3 - 2 * k , i ) = t2 - t4 g ( jj , ny3 - 2 * k + 1 , i ) = t5 - t3 110 continue 120 continue do 130 jj = 1 , 2 g ( jj , nyh + 1 , i ) = 2.0 * g ( jj , nyh + 1 , i ) g ( jj , nyh + 2 , i ) = - 2.0 * g ( jj , nyh + 2 , i ) t2 = 2.0 * ( g ( jj , 1 , i ) + g ( jj , 2 , i )) g ( jj , 2 , i ) = 2.0 * ( g ( jj , 1 , i ) - g ( jj , 2 , i )) g ( jj , 1 , i ) = t2 g ( jj , ny + 1 , i ) = 2.0 * g ( jj , ny + 1 , i ) 130 continue endif ! perform recursion for sine-cosine transform sum1 = g ( 1 , ny + 1 , i ) g ( 1 , ny + 1 , i ) = g ( 1 , 2 , i ) g ( 1 , 2 , i ) = sum1 sum2 = 0.5 * g ( 2 , 1 , i ) g ( 2 , 1 , i ) = 0.0 g ( 2 , 2 , i ) = sum2 do 140 k = 2 , nyh sum1 = sum1 - g ( 1 , 2 * k , i ) g ( 1 , 2 * k , i ) = sum1 sum2 = sum2 + g ( 2 , 2 * k - 1 , i ) g ( 2 , 2 * k - 1 , i ) = - g ( 2 , 2 * k , i ) g ( 2 , 2 * k , i ) = sum2 140 continue g ( 2 , ny + 1 , i ) = 0.0 150 continue !$OMP END PARALLEL DO return end !----------------------------------------------------------------------- subroutine WPPFCST2RM3 ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp , indx , & & indy , kstrt , nvp , nxvh , nyv , kxp2 , kyp , kypd , kxp2d , nxhyd , nxyd ) ! wrapper function for 3 parallel real cosine/sine transforms ! for the electric field with dirichlet or magnetic field with neumann ! boundary conditions ! x component has a cosine/sine transform in x and y, respectively ! y/z component has a sine/cosine transform in x and y, respectively implicit none integer isign , ntpose , mixup , indx , indy , kstrt , nvp , nxvh , nyv integer kxp2 , kyp , kypd , kxp2d , nxhyd , nxyd real f , g , bs , br , ttp complex sctd dimension f ( 3 , 2 * nxvh , kypd ), g ( 3 , nyv , kxp2d ) dimension bs ( 3 , kxp2 + 1 , kyp + 1 ), br ( 3 , kxp2 + 1 , kyp + 1 ) dimension mixup ( nxhyd ), sctd ( nxyd ) ! local data integer nx , ny , kxpi , kypi , ks , kxp2p , kypp , kxb2 , kyb real tf double precision dtime data kxpi , kypi / 1 , 1 / ! calculate range of indices nx = 2 ** indx ny = 2 ** indy ! ks = processor id ks = kstrt - 1 ! kxp2p = actual size used in x direction kxp2p = min ( kxp2 , max ( 0 , nx - kxp2 * ks )) ! kypp = actual size used in y direction kypp = min ( kyp , max ( 0 , ny - kyp * ks )) ! kxb2 = minimum number of processors needed in x direction kxb2 = ( nx - 1 ) / kxp2 + 1 ! kyb = minimum number of processors needed in y direction kyb = ( ny - 1 ) / kyp + 1 ! add extra word for last processor in x if ( ks == ( kxb2 - 1 )) kxp2p = kxp2p + 1 ! add extra word for last processor in y if ( ks == ( kyb - 1 )) kypp = kypp + 1 ! inverse fourier transform if ( isign . lt . 0 ) then ! perform x cosine-sine-sine transform call PPFCSST2RM3X ( f , isign , mixup , sctd , indx , indy , kstrt , kypi , kypp , & & nxvh , kypd , nxhyd , nxyd ) ! transpose f array to g call PWTIMERA ( - 1 , ttp , dtime ) call PPRNTPOSE ( f , g , bs , br , nx , ny , kxp2 , kyp , kstrt , nvp , 3 , 2 * nxvh , nyv , & & kxp2d , kypd ) call PWTIMERA ( 1 , ttp , dtime ) ! perform y sine-cosine-sine transform call PPFSCST2RM3Y ( g , isign , mixup , sctd , indx , indy , kstrt , kxpi , kxp2p & & , nyv , kxp2d , nxhyd , nxyd ) ! transpose g array to f if ( ntpose . eq . 0 ) then call PWTIMERA ( - 1 , tf , dtime ) call PPRNTPOSE ( g , f , br , bs , ny , nx , kyp , kxp2 , kstrt , nvp , 3 , nyv , & & 2 * nxvh , kypd , kxp2d ) call PWTIMERA ( 1 , tf , dtime ) endif ! forward fourier transform else if ( isign . gt . 0 ) then ! transpose f array to g if ( ntpose . eq . 0 ) then call PWTIMERA ( - 1 , tf , dtime ) call PPRNTPOSE ( f , g , bs , br , nx , ny , kxp2 , kyp , kstrt , nvp , 3 , 2 * nxvh , & & nyv , kxp2d , kypd ) call PWTIMERA ( 1 , tf , dtime ) endif ! perform y sine-cosine-sine transform call PPFSCST2RM3Y ( g , isign , mixup , sctd , indx , indy , kstrt , kxpi , kxp2p & & , nyv , kxp2d , nxhyd , nxyd ) ! transpose g array to f call PWTIMERA ( - 1 , ttp , dtime ) call PPRNTPOSE ( g , f , br , bs , ny , nx , kyp , kxp2 , kstrt , nvp , 3 , nyv , 2 * nxvh , & & kypd , kxp2d ) call PWTIMERA ( 1 , ttp , dtime ) ! perform x cosine-sine-sine transform call PPFCSST2RM3X ( f , isign , mixup , sctd , indx , indy , kstrt , kypi , kypp , & & nxvh , kypd , nxhyd , nxyd ) endif if ( ntpose . eq . 0 ) ttp = ttp + tf return end !----------------------------------------------------------------------- subroutine WPPFSCT2RM3 ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp , indx , & & indy , kstrt , nvp , nxvh , nyv , kxp2 , kyp , kypd , kxp2d , nxhyd , nxyd ) ! wrapper function for 3 parallel real sine/cosine transforms ! for the magnetic field with dirichlet or electric field with neumann ! boundary conditions ! x component has a sine/cosine transform in x and y, respectively ! y component has a cosine/sine transform in x and y, respectively ! z component has a cosine/cosine transform in x and y, respectively implicit none integer isign , ntpose , mixup , indx , indy , kstrt , nvp , nxvh , nyv integer kxp2 , kyp , kypd , kxp2d , nxhyd , nxyd real f , g , bs , br , ttp complex sctd dimension f ( 3 , 2 * nxvh , kypd ), g ( 3 , nyv , kxp2d ) dimension bs ( 3 , kxp2 + 1 , kyp + 1 ), br ( 3 , kxp2 + 1 , kyp + 1 ) dimension mixup ( nxhyd ), sctd ( nxyd ) ! local data integer nx , ny , kxpi , kypi , ks , kxp2p , kypp , kxb2 , kyb real tf double precision dtime data kxpi , kypi / 1 , 1 / ! calculate range of indices nx = 2 ** indx ny = 2 ** indy ! ks = processor id ks = kstrt - 1 ! kxp2p = actual size used in x direction kxp2p = min ( kxp2 , max ( 0 , nx - kxp2 * ks )) ! kypp = actual size used in y direction kypp = min ( kyp , max ( 0 , ny - kyp * ks )) ! kxb2 = minimum number of processors needed in x direction kxb2 = ( nx - 1 ) / kxp2 + 1 ! kyb = minimum number of processors needed in y direction kyb = ( ny - 1 ) / kyp + 1 ! add extra word for last processor in x if ( ks == ( kxb2 - 1 )) kxp2p = kxp2p + 1 ! add extra word for last processor in y if ( ks == ( kyb - 1 )) kypp = kypp + 1 ! inverse fourier transform if ( isign . lt . 0 ) then ! perform x sine-cosine-cosine transform call PPFSCCT2RM3X ( f , isign , mixup , sctd , indx , indy , kstrt , kypi , kypp , & & nxvh , kypd , nxhyd , nxyd ) ! transpose f array to g call PWTIMERA ( - 1 , ttp , dtime ) call PPRNTPOSE ( f , g , bs , br , nx , ny , kxp2 , kyp , kstrt , nvp , 3 , 2 * nxvh , nyv , & & kxp2d , kypd ) call PWTIMERA ( 1 , ttp , dtime ) ! perform y cosine-sine-cosine transform call PPFCSCT2RM3Y ( g , isign , mixup , sctd , indx , indy , kstrt , kxpi , kxp2p & & , nyv , kxp2d , nxhyd , nxyd ) ! transpose g array to f if ( ntpose . eq . 0 ) then call PWTIMERA ( - 1 , tf , dtime ) call PPRNTPOSE ( g , f , br , bs , ny , nx , kyp , kxp2 , kstrt , nvp , 3 , nyv , & & 2 * nxvh , kypd , kxp2d ) call PWTIMERA ( 1 , tf , dtime ) endif ! forward fourier transform else if ( isign . gt . 0 ) then ! transpose f array to g if ( ntpose . eq . 0 ) then call PWTIMERA ( - 1 , tf , dtime ) call PPRNTPOSE ( f , g , bs , br , nx , ny , kxp2 , kyp , kstrt , nvp , 3 , 2 * nxvh , & & nyv , kxp2d , kypd ) call PWTIMERA ( 1 , tf , dtime ) endif ! perform y cosine-sine-cosine transform call PPFCSCT2RM3Y ( g , isign , mixup , sctd , indx , indy , kstrt , kxpi , kxp2p & & , nyv , kxp2d , nxhyd , nxyd ) ! transpose g array to f call PWTIMERA ( - 1 , ttp , dtime ) call PPRNTPOSE ( g , f , br , bs , ny , nx , kyp , kxp2 , kstrt , nvp , 3 , nyv , 2 * nxvh , & & kypd , kxp2d ) call PWTIMERA ( 1 , ttp , dtime ) ! perform x sine-cosine-cosine transform call PPFSCCT2RM3X ( f , isign , mixup , sctd , indx , indy , kstrt , kypi , kypp , & & nxvh , kypd , nxhyd , nxyd ) endif if ( ntpose . eq . 0 ) ttp = ttp + tf return end !----------------------------------------------------------------------- subroutine PPFCSST2RM3X ( f , isign , mixup , sctd , indx , indy , kstrt , kypi , & & kypp , nxvh , kypd , nxhyd , nxyd ) ! this subroutine performs the x part of 3 two dimensional fast real ! sine and cosine transforms and their inverses, for a subset of y, ! using real arithmetic, with OpenMP, ! for data which is distributed in blocks ! x component has a cosine transform, y/z component a sine transform ! algorithm is described in Numerical Recipies in Fortran, Second Ed., ! by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, ! [Cambridge Univ. Press, 1992], p. 508. ! for isign = (-1,1), input: all, output: f ! approximate flop count: N*(5*log2(N) + 18)/nvp ! where N = (nx/2)*ny ! indx/indy = exponent which determines length in x/y direction, ! where nx=2**indx, ny=2**indy ! if isign = -1, inverse cosine-sine-sine transforms are performed ! f(1,n,k) = (1/nx*ny)*(.5*f(1,1,k) + ((-1)**n)*f(1,nx+1,k) !              + sum(f(1,j,k)*cos(pi*n*j/nx))) ! f(2:3,n,k) = (1/nx*ny)*sum(f(2:3,j,k)*sin(pi*n*j/nx)) ! if isign = 1, forward cosine-sine-sine transforms are performed ! f(1,j,k) = 2*(.5*f(1,1,k) + ((-1)**j)*f(1,n+1,k) !              + sum(f(1,n,k)*cos(pi*n*j/nx)) ! f(2:3,j,k) = sum(f(2:3,n,k)*sin(pi*n*j/nx)) ! mixup = array of bit reversed addresses ! sctd = sine/cosine table ! kstrt = starting data block number ! kypi = initial y index used ! kypp = number of y indices used ! nxvh = first dimension of f >= nx/2 + 1 ! kypd = second dimension of f >= kyp + 1 ! nxhyd = maximum of (nx/2,ny) ! nxyd = maximum of (nx,ny) ! written by viktor k. decyk, ucla implicit none integer isign , indx , indy , kstrt , kypi , kypp integer nxvh , kypd , nxhyd , nxyd , mixup real f complex sctd dimension f ( 3 , 2 * nxvh , kypd ) dimension mixup ( nxhyd ), sctd ( nxyd ) ! local data integer indx1 , indx1y , nx , nxh , nxhh , nx3 , ny , nxy , nxhy , ks integer i , j , k , m , km , kmr , nrx , j1 , j2 , ns , ns2 , k1 , k2 , kyps integer nrxb , jj real at1 , at2 , at3 , t2 , t3 , t4 , t5 , t6 , ani complex t1 double precision sum1 , sum2 , sum3 indx1 = indx - 1 indx1y = max0 ( indx1 , indy ) nx = 2 ** indx nxh = nx / 2 nxhh = nx / 4 nx3 = nx + 3 ny = 2 ** indy nxy = max0 ( nx , ny ) nxhy = 2 ** indx1y ks = kstrt - 1 kyps = kypi + kypp - 1 if ( kstrt . gt . ny ) return if ( isign . eq . 0 ) return ani = 0.5 / ( real ( nx ) * real ( ny )) nrxb = nxhy / nxh nrx = nxy / nxh !$OMP PARALLEL DO !$OMP& PRIVATE(i,j,k,m,jj,ns,ns2,km,kmr,k1,k2,j1,j2,at1,at2,at3,t2,t3,t4 !$OMP& ,t5,t6,t1,sum1,sum2,sum3) do 150 i = kypi , kyps ! create auxiliary array in x kmr = nxy / nx sum1 = 0.5 * ( f ( 1 , 1 , i ) - f ( 1 , nx + 1 , i )) do 10 j = 2 , nxh j1 = 1 + kmr * ( j - 1 ) at3 = - aimag ( sctd ( j1 )) at2 = f ( 1 , nx + 2 - j , i ) at1 = f ( 1 , j , i ) + at2 at2 = f ( 1 , j , i ) - at2 sum1 = sum1 + real ( sctd ( j1 )) * at2 at2 = at3 * at2 at1 = 0.5 * at1 f ( 1 , j , i ) = at1 - at2 f ( 1 , nx + 2 - j , i ) = at1 + at2 at2 = f ( 2 , nx + 2 - j , i ) at1 = f ( 2 , j , i ) + at2 at2 = f ( 2 , j , i ) - at2 at1 = at3 * at1 at2 = 0.5 * at2 f ( 2 , j , i ) = at1 + at2 f ( 2 , nx + 2 - j , i ) = at1 - at2 at2 = f ( 3 , nx + 2 - j , i ) at1 = f ( 3 , j , i ) + at2 at2 = f ( 3 , j , i ) - at2 at1 = at3 * at1 at2 = 0.5 * at2 f ( 3 , j , i ) = at1 + at2 f ( 3 , nx + 2 - j , i ) = at1 - at2 10 continue f ( 1 , 1 , i ) = 0.5 * ( f ( 1 , 1 , i ) + f ( 1 , nx + 1 , i )) f ( 1 , nx + 1 , i ) = sum1 f ( 2 , 1 , i ) = 0.0 f ( 2 , nxh + 1 , i ) = 2.0 * f ( 2 , nxh + 1 , i ) f ( 3 , 1 , i ) = 0.0 f ( 3 , nxh + 1 , i ) = 2.0 * f ( 3 , nxh + 1 , i ) ! bit-reverse array elements in x do 30 j = 1 , nxh j1 = ( mixup ( j ) - 1 ) / nrxb + 1 if ( j . lt . j1 ) then do 20 jj = 1 , 3 t2 = f ( jj , 2 * j1 - 1 , i ) t3 = f ( jj , 2 * j1 , i ) f ( jj , 2 * j1 - 1 , i ) = f ( jj , 2 * j - 1 , i ) f ( jj , 2 * j1 , i ) = f ( jj , 2 * j , i ) f ( jj , 2 * j - 1 , i ) = t2 f ( jj , 2 * j , i ) = t3 20 continue endif 30 continue ! then transform in x do 70 m = 1 , indx1 ns = 2 ** ( m - 1 ) ns2 = ns + ns km = nxhh / ns kmr = 2 * km * nrx do 60 k = 1 , km k1 = ns2 * ( k - 1 ) k2 = k1 + ns do 50 j = 1 , ns j1 = j + k1 j2 = j + k2 t1 = sctd ( 1 + kmr * ( j - 1 )) do 40 jj = 1 , 3 t2 = real ( t1 ) * f ( jj , 2 * j2 - 1 , i ) - aimag ( t1 ) * f ( jj , 2 * j2 , i ) t3 = aimag ( t1 ) * f ( jj , 2 * j2 - 1 , i ) + real ( t1 ) * f ( jj , 2 * j2 , i ) f ( jj , 2 * j2 - 1 , i ) = f ( jj , 2 * j1 - 1 , i ) - t2 f ( jj , 2 * j2 , i ) = f ( jj , 2 * j1 , i ) - t3 f ( jj , 2 * j1 - 1 , i ) = f ( jj , 2 * j1 - 1 , i ) + t2 f ( jj , 2 * j1 , i ) = f ( jj , 2 * j1 , i ) + t3 40 continue 50 continue 60 continue 70 continue ! unscramble coefficients and normalize ! inverse fourier transform if ( isign . lt . 0 ) then kmr = nxy / nxh do 90 j = 2 , nxhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( j - 1 ))), - real ( sctd ( 1 + kmr * ( j - 1 )))) do 80 jj = 1 , 3 t4 = f ( jj , nx3 - 2 * j , i ) t5 = - f ( jj , nx3 - 2 * j + 1 , i ) t2 = f ( jj , 2 * j - 1 , i ) + t4 t3 = f ( jj , 2 * j , i ) + t5 t6 = f ( jj , 2 * j - 1 , i ) - t4 t5 = f ( jj , 2 * j , i ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) f ( jj , 2 * j - 1 , i ) = ani * ( t2 + t4 ) f ( jj , 2 * j , i ) = ani * ( t3 + t5 ) f ( jj , nx3 - 2 * j , i ) = ani * ( t2 - t4 ) f ( jj , nx3 - 2 * j + 1 , i ) = ani * ( t5 - t3 ) 80 continue 90 continue do 100 jj = 1 , 3 f ( jj , nxh + 1 , i ) = 2.0 * ani * f ( jj , nxh + 1 , i ) f ( jj , nxh + 2 , i ) = - 2.0 * ani * f ( jj , nxh + 2 , i ) t2 = 2.0 * ani * ( f ( jj , 1 , i ) + f ( jj , 2 , i )) f ( jj , 2 , i ) = 2.0 * ani * ( f ( jj , 1 , i ) - f ( jj , 2 , i )) f ( jj , 1 , i ) = t2 f ( jj , nx + 1 , i ) = 2.0 * ani * f ( jj , nx + 1 , i ) 100 continue ! forward fourier transform else if ( isign . gt . 0 ) then kmr = nxy / nxh do 120 j = 2 , nxhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( j - 1 ))), - real ( sctd ( 1 + kmr * ( j - 1 )))) do 110 jj = 1 , 3 t4 = f ( jj , nx3 - 2 * j , i ) t5 = - f ( jj , nx3 - 2 * j + 1 , i ) t2 = f ( jj , 2 * j - 1 , i ) + t4 t3 = f ( jj , 2 * j , i ) + t5 t6 = f ( jj , 2 * j - 1 , i ) - t4 t5 = f ( jj , 2 * j , i ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) f ( jj , 2 * j - 1 , i ) = t2 + t4 f ( jj , 2 * j , i ) = t3 + t5 f ( jj , nx3 - 2 * j , i ) = t2 - t4 f ( jj , nx3 - 2 * j + 1 , i ) = t5 - t3 110 continue 120 continue do 130 jj = 1 , 3 f ( jj , nxh + 1 , i ) = 2.0 * f ( jj , nxh + 1 , i ) f ( jj , nxh + 2 , i ) = - 2.0 * f ( jj , nxh + 2 , i ) t2 = 2.0 * ( f ( jj , 1 , i ) + f ( jj , 2 , i )) f ( jj , 2 , i ) = 2.0 * ( f ( jj , 1 , i ) - f ( jj , 2 , i )) f ( jj , 1 , i ) = t2 f ( jj , nx + 1 , i ) = 2.0 * f ( jj , nx + 1 , i ) 130 continue endif ! perform recursion for cosine-sine transform sum1 = f ( 1 , nx + 1 , i ) f ( 1 , nx + 1 , i ) = f ( 1 , 2 , i ) f ( 1 , 2 , i ) = sum1 sum2 = 0.5 * f ( 2 , 1 , i ) f ( 2 , 1 , i ) = 0.0 f ( 2 , 2 , i ) = sum2 sum3 = 0.5 * f ( 3 , 1 , i ) f ( 3 , 1 , i ) = 0.0 f ( 3 , 2 , i ) = sum3 do 140 j = 2 , nxh sum1 = sum1 - f ( 1 , 2 * j , i ) f ( 1 , 2 * j , i ) = sum1 sum2 = sum2 + f ( 2 , 2 * j - 1 , i ) f ( 2 , 2 * j - 1 , i ) = - f ( 2 , 2 * j , i ) f ( 2 , 2 * j , i ) = sum2 sum3 = sum3 + f ( 3 , 2 * j - 1 , i ) f ( 3 , 2 * j - 1 , i ) = - f ( 3 , 2 * j , i ) f ( 3 , 2 * j , i ) = sum3 140 continue f ( 2 , nx + 1 , i ) = 0.0 f ( 3 , nx + 1 , i ) = 0.0 150 continue !$OMP END PARALLEL DO return end !----------------------------------------------------------------------- subroutine PPFSCCT2RM3X ( f , isign , mixup , sctd , indx , indy , kstrt , kypi , & & kypp , nxvh , kypd , nxhyd , nxyd ) ! this subroutine performs the x part of 3 two dimensional fast real ! sine and cosine transforms and their inverses, for a subset of y, ! using real arithmetic, with OpenMP, ! for data which is distributed in blocks ! x component has a sine transform, y/z component a cosine transform ! algorithm is described in Numerical Recipies in Fortran, Second Ed., ! by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, ! [Cambridge Univ. Press, 1992], p. 508. ! for isign = (-1,1), input: all, output: f ! approximate flop count: N*(5*log2(N) + 18)/nvp ! where N = (nx/2)*ny ! indx/indy = exponent which determines length in x/y direction, ! where nx=2**indx, ny=2**indy ! if isign = -1, inverse sine-cosine-cosine transforms are performed ! f(1,n,k) = (1/nx*ny)*sum(f(1,j,k)*sin(pi*n*j/nx)) ! f(2:3,n,k) = (1/nx*ny)*(.5*f(2:3,1,k) + ((-1)**n)*f(2:3,nx+1,k) !              + sum(f(2:3,j,k)*cos(pi*n*j/nx))) ! if isign = 1, forward sine-cosine-cosine transforms are performed ! f(1,j,k) = sum(f(1,n,k)*sin(pi*n*j/nx)) ! f(2:3,j,k) = 2*(.5*f(2:3,1,k) + ((-1)**j)*f(2:3,n+1,k) !              + sum(f(2:3,n,k)*cos(pi*n*j/nx)) ! mixup = array of bit reversed addresses ! sctd = sine/cosine table ! kstrt = starting data block number ! kypi = initial y index used ! kypp = number of y indices used ! nxvh = first dimension of f >= nx/2 + 1 ! kypd = second dimension of f >= kyp + 1 ! nxhyd = maximum of (nx/2,ny) ! nxyd = maximum of (nx,ny) ! written by viktor k. decyk, ucla implicit none integer isign , indx , indy , kstrt , kypi , kypp integer nxvh , kypd , nxhyd , nxyd , mixup real f complex sctd dimension f ( 3 , 2 * nxvh , kypd ) dimension mixup ( nxhyd ), sctd ( nxyd ) ! local data integer indx1 , indx1y , nx , nxh , nxhh , nx3 , ny , nxy , nxhy , ks integer i , j , k , m , km , kmr , nrx , j1 , j2 , ns , ns2 , k1 , k2 , kyps integer nrxb , jj real at1 , at2 , at3 , t2 , t3 , t4 , t5 , t6 , ani complex t1 double precision sum1 , sum2 , sum3 indx1 = indx - 1 indx1y = max0 ( indx1 , indy ) nx = 2 ** indx nxh = nx / 2 nxhh = nx / 4 nx3 = nx + 3 ny = 2 ** indy nxy = max0 ( nx , ny ) nxhy = 2 ** indx1y ks = kstrt - 1 kyps = kypi + kypp - 1 if ( kstrt . gt . ny ) return if ( isign . eq . 0 ) return ani = 0.5 / ( real ( nx ) * real ( ny )) nrxb = nxhy / nxh nrx = nxy / nxh !$OMP PARALLEL DO !$OMP& PRIVATE(i,j,k,m,jj,ns,ns2,km,kmr,k1,k2,j1,j2,at1,at2,at3,t2,t3,t4 !$OMP& ,t5,t6,t1,sum1,sum2,sum3) do 150 i = kypi , kyps ! create auxiliary array in x kmr = nxy / nx sum1 = 0.5 * ( f ( 2 , 1 , i ) - f ( 2 , nx + 1 , i )) sum2 = 0.5 * ( f ( 3 , 1 , i ) - f ( 3 , nx + 1 , i )) do 10 j = 2 , nxh j1 = 1 + kmr * ( j - 1 ) at3 = - aimag ( sctd ( j1 )) at2 = f ( 1 , nx + 2 - j , i ) at1 = f ( 1 , j , i ) + at2 at2 = f ( 1 , j , i ) - at2 at1 = at3 * at1 at2 = 0.5 * at2 f ( 1 , j , i ) = at1 + at2 f ( 1 , nx + 2 - j , i ) = at1 - at2 at2 = f ( 2 , nx + 2 - j , i ) at1 = f ( 2 , j , i ) + at2 at2 = f ( 2 , j , i ) - at2 sum1 = sum1 + real ( sctd ( j1 )) * at2 at2 = at3 * at2 at1 = 0.5 * at1 f ( 2 , j , i ) = at1 - at2 f ( 2 , nx + 2 - j , i ) = at1 + at2 at2 = f ( 3 , nx + 2 - j , i ) at1 = f ( 3 , j , i ) + at2 at2 = f ( 3 , j , i ) - at2 sum2 = sum2 + real ( sctd ( j1 )) * at2 at2 = at3 * at2 at1 = 0.5 * at1 f ( 3 , j , i ) = at1 - at2 f ( 3 , nx + 2 - j , i ) = at1 + at2 10 continue f ( 1 , 1 , i ) = 0.0 f ( 1 , nxh + 1 , i ) = 2.0 * f ( 1 , nxh + 1 , i ) f ( 2 , 1 , i ) = 0.5 * ( f ( 2 , 1 , i ) + f ( 2 , nx + 1 , i )) f ( 2 , nx + 1 , i ) = sum1 f ( 3 , 1 , i ) = 0.5 * ( f ( 3 , 1 , i ) + f ( 3 , nx + 1 , i )) f ( 3 , nx + 1 , i ) = sum2 ! bit-reverse array elements in x do 30 j = 1 , nxh j1 = ( mixup ( j ) - 1 ) / nrxb + 1 if ( j . lt . j1 ) then do 20 jj = 1 , 3 t2 = f ( jj , 2 * j1 - 1 , i ) t3 = f ( jj , 2 * j1 , i ) f ( jj , 2 * j1 - 1 , i ) = f ( jj , 2 * j - 1 , i ) f ( jj , 2 * j1 , i ) = f ( jj , 2 * j , i ) f ( jj , 2 * j - 1 , i ) = t2 f ( jj , 2 * j , i ) = t3 20 continue endif 30 continue ! then transform in x do 70 m = 1 , indx1 ns = 2 ** ( m - 1 ) ns2 = ns + ns km = nxhh / ns kmr = 2 * km * nrx do 60 k = 1 , km k1 = ns2 * ( k - 1 ) k2 = k1 + ns do 50 j = 1 , ns j1 = j + k1 j2 = j + k2 t1 = sctd ( 1 + kmr * ( j - 1 )) do 40 jj = 1 , 3 t2 = real ( t1 ) * f ( jj , 2 * j2 - 1 , i ) - aimag ( t1 ) * f ( jj , 2 * j2 , i ) t3 = aimag ( t1 ) * f ( jj , 2 * j2 - 1 , i ) + real ( t1 ) * f ( jj , 2 * j2 , i ) f ( jj , 2 * j2 - 1 , i ) = f ( jj , 2 * j1 - 1 , i ) - t2 f ( jj , 2 * j2 , i ) = f ( jj , 2 * j1 , i ) - t3 f ( jj , 2 * j1 - 1 , i ) = f ( jj , 2 * j1 - 1 , i ) + t2 f ( jj , 2 * j1 , i ) = f ( jj , 2 * j1 , i ) + t3 40 continue 50 continue 60 continue 70 continue ! unscramble coefficients and normalize ! inverse fourier transform if ( isign . lt . 0 ) then kmr = nxy / nxh do 90 j = 2 , nxhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( j - 1 ))), - real ( sctd ( 1 + kmr * ( j - 1 )))) do 80 jj = 1 , 3 t4 = f ( jj , nx3 - 2 * j , i ) t5 = - f ( jj , nx3 - 2 * j + 1 , i ) t2 = f ( jj , 2 * j - 1 , i ) + t4 t3 = f ( jj , 2 * j , i ) + t5 t6 = f ( jj , 2 * j - 1 , i ) - t4 t5 = f ( jj , 2 * j , i ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) f ( jj , 2 * j - 1 , i ) = ani * ( t2 + t4 ) f ( jj , 2 * j , i ) = ani * ( t3 + t5 ) f ( jj , nx3 - 2 * j , i ) = ani * ( t2 - t4 ) f ( jj , nx3 - 2 * j + 1 , i ) = ani * ( t5 - t3 ) 80 continue 90 continue do 100 jj = 1 , 3 f ( jj , nxh + 1 , i ) = 2.0 * ani * f ( jj , nxh + 1 , i ) f ( jj , nxh + 2 , i ) = - 2.0 * ani * f ( jj , nxh + 2 , i ) t2 = 2.0 * ani * ( f ( jj , 1 , i ) + f ( jj , 2 , i )) f ( jj , 2 , i ) = 2.0 * ani * ( f ( jj , 1 , i ) - f ( jj , 2 , i )) f ( jj , 1 , i ) = t2 f ( jj , nx + 1 , i ) = 2.0 * ani * f ( jj , nx + 1 , i ) 100 continue ! forward fourier transform else if ( isign . gt . 0 ) then kmr = nxy / nxh do 120 j = 2 , nxhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( j - 1 ))), - real ( sctd ( 1 + kmr * ( j - 1 )))) do 110 jj = 1 , 3 t4 = f ( jj , nx3 - 2 * j , i ) t5 = - f ( jj , nx3 - 2 * j + 1 , i ) t2 = f ( jj , 2 * j - 1 , i ) + t4 t3 = f ( jj , 2 * j , i ) + t5 t6 = f ( jj , 2 * j - 1 , i ) - t4 t5 = f ( jj , 2 * j , i ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) f ( jj , 2 * j - 1 , i ) = t2 + t4 f ( jj , 2 * j , i ) = t3 + t5 f ( jj , nx3 - 2 * j , i ) = t2 - t4 f ( jj , nx3 - 2 * j + 1 , i ) = t5 - t3 110 continue 120 continue do 130 jj = 1 , 3 f ( jj , nxh + 1 , i ) = 2.0 * f ( jj , nxh + 1 , i ) f ( jj , nxh + 2 , i ) = - 2.0 * f ( jj , nxh + 2 , i ) t2 = 2.0 * ( f ( jj , 1 , i ) + f ( jj , 2 , i )) f ( jj , 2 , i ) = 2.0 * ( f ( jj , 1 , i ) - f ( jj , 2 , i )) f ( jj , 1 , i ) = t2 f ( jj , nx + 1 , i ) = 2.0 * f ( jj , nx + 1 , i ) 130 continue endif ! perform recursion for cosine-sine transform sum1 = 0.5 * f ( 1 , 1 , i ) f ( 1 , 1 , i ) = 0.0 f ( 1 , 2 , i ) = sum1 sum2 = f ( 2 , nx + 1 , i ) f ( 2 , nx + 1 , i ) = f ( 2 , 2 , i ) f ( 2 , 2 , i ) = sum2 sum3 = f ( 3 , nx + 1 , i ) f ( 3 , nx + 1 , i ) = f ( 3 , 2 , i ) f ( 3 , 2 , i ) = sum3 do 140 j = 2 , nxh sum1 = sum1 + f ( 1 , 2 * j - 1 , i ) f ( 1 , 2 * j - 1 , i ) = - f ( 1 , 2 * j , i ) f ( 1 , 2 * j , i ) = sum1 sum2 = sum2 - f ( 2 , 2 * j , i ) f ( 2 , 2 * j , i ) = sum2 sum3 = sum3 - f ( 3 , 2 * j , i ) f ( 3 , 2 * j , i ) = sum3 140 continue f ( 1 , nx + 1 , i ) = 0.0 150 continue !$OMP END PARALLEL DO return end !----------------------------------------------------------------------- subroutine PPFSCST2RM3Y ( g , isign , mixup , sctd , indx , indy , kstrt , kxpi , & & kxpp , nyv , kxpd , nxhyd , nxyd ) ! this subroutine performs the y part of 3 two dimensional fast real ! sine and cosine transforms and their inverses, for a subset of x, ! using real arithmetic, with OpenMP, ! for data which is distributed in blocks ! x/z component has a sine transform, y component a cosine transform ! algorithm is described in Numerical Recipies in Fortran, Second Ed., ! by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, ! [Cambridge Univ. Press, 1992], p. 508. ! for isign = (-1,1), input: all, output: f ! approximate flop count: N*(5*log2(N) + 18)/nvp ! where N = (nx/2)*ny ! indx/indy = exponent which determines length in x/y direction, ! where nx=2**indx, ny=2**indy ! if isign = -1, inverse sine-cosine-sine transform are performed ! g(1,m,n) = sum(g(1,k,n)*sin(pi*m*k/ny)) ! g(2,m,n) = (.5*g(2,1,n) + ((-1)**m)*g(2,ny+1,n) !              + sum(g(2,k,n)*cos(pi*m*k/ny)) ! g(3,m,n) = sum(g(3,k,n)*sin(pi*m*k/ny)) ! if isign = 1, a forward sine-cosine-sine transforms are performed ! g(1,k,n) = sum(g(1,m,n)*sin(pi*m*k/ny)) ! g(2,k,n) = 2*(.5*g(2,1,n) + ((-1)**m)*g(2,ny+1,n) !              + sum(g(2,m,n)*cos(pi*m*k/ny)) ! g(3,k,n) = sum(g(3,m,n)*sin(pi*m*k/ny)) ! mixup = array of bit reversed addresses ! sctd = sine/cosine table ! kstrt = starting data block number ! kxpi = initial x index used ! kxpp = number of x indices used ! nyv = first dimension of g >= ny + 1 ! kxpd = second dimension of g >= kxp + 1 ! nxhyd = maximum of (nx/2,ny) ! nxyd = maximum of (nx,ny) ! written by viktor k. decyk, ucla implicit none integer isign , indx , indy , kstrt , kxpi , kxpp integer nyv , kxpd , nxhyd , nxyd , mixup real g complex sctd dimension g ( 3 , nyv , kxpd ) dimension mixup ( nxhyd ), sctd ( nxyd ) ! local data integer indx1 , indy1 , indx1y , nx , ny , nyh , nyhh , ny3 , nxy , nxhy integer i , j , k , m , ks , km , kmr , nry , j1 , j2 , ns , ns2 , k1 , k2 integer kxps , nryb , jj real at1 , at2 , at3 , t2 , t3 , t4 , t5 , t6 complex t1 double precision sum1 , sum2 , sum3 indx1 = indx - 1 indy1 = indy - 1 indx1y = max0 ( indx1 , indy ) nx = 2 ** indx ny = 2 ** indy nyh = ny / 2 nyhh = ny / 4 ny3 = ny + 3 nxy = max0 ( nx , ny ) nxhy = 2 ** indx1y ks = kstrt - 1 kxps = kxpi + kxpp - 1 if ( kstrt . gt . nx ) return if ( isign . eq . 0 ) return nryb = nxhy / nyh nry = nxy / nyh !$OMP PARALLEL DO !$OMP& PRIVATE(i,j,k,m,jj,ns,ns2,km,kmr,k1,k2,j1,j2,at1,at2,at3,t2,t3,t4 !$OMP& ,t5,t6,t1,sum1,sum2,sum3) do 150 i = kxpi , kxps ! create auxiliary array in y kmr = nxy / ny sum1 = 0.5 * ( g ( 2 , 1 , i ) - g ( 2 , ny + 1 , i )) do 10 k = 2 , nyh k1 = 1 + kmr * ( k - 1 ) at3 = - aimag ( sctd ( k1 )) at2 = g ( 1 , ny + 2 - k , i ) at1 = g ( 1 , k , i ) + at2 at2 = g ( 1 , k , i ) - at2 at1 = at3 * at1 at2 = 0.5 * at2 g ( 1 , k , i ) = at1 + at2 g ( 1 , ny + 2 - k , i ) = at1 - at2 at2 = g ( 2 , ny + 2 - k , i ) at1 = g ( 2 , k , i ) + at2 at2 = g ( 2 , k , i ) - at2 sum1 = sum1 + real ( sctd ( k1 )) * at2 at2 = at3 * at2 at1 = 0.5 * at1 g ( 2 , k , i ) = at1 - at2 g ( 2 , ny + 2 - k , i ) = at1 + at2 at2 = g ( 3 , ny + 2 - k , i ) at1 = g ( 3 , k , i ) + at2 at2 = g ( 3 , k , i ) - at2 at1 = at3 * at1 at2 = 0.5 * at2 g ( 3 , k , i ) = at1 + at2 g ( 3 , ny + 2 - k , i ) = at1 - at2 10 continue g ( 1 , 1 , i ) = 0.0 g ( 1 , nyh + 1 , i ) = 2.0 * g ( 1 , nyh + 1 , i ) g ( 2 , 1 , i ) = 0.5 * ( g ( 2 , 1 , i ) + g ( 2 , ny + 1 , i )) g ( 2 , ny + 1 , i ) = sum1 g ( 3 , 1 , i ) = 0.0 g ( 3 , nyh + 1 , i ) = 2.0 * g ( 3 , nyh + 1 , i ) ! bit-reverse array elements in y do 30 k = 1 , nyh k1 = ( mixup ( k ) - 1 ) / nryb + 1 if ( k . lt . k1 ) then do 20 jj = 1 , 3 t2 = g ( jj , 2 * k1 - 1 , i ) t3 = g ( jj , 2 * k1 , i ) g ( jj , 2 * k1 - 1 , i ) = g ( jj , 2 * k - 1 , i ) g ( jj , 2 * k1 , i ) = g ( jj , 2 * k , i ) g ( jj , 2 * k - 1 , i ) = t2 g ( jj , 2 * k , i ) = t3 20 continue endif 30 continue ! then transform in y do 70 m = 1 , indy1 ns = 2 ** ( m - 1 ) ns2 = ns + ns km = nyhh / ns kmr = 2 * km * nry do 60 k = 1 , km k1 = ns2 * ( k - 1 ) k2 = k1 + ns do 50 j = 1 , ns j1 = j + k1 j2 = j + k2 t1 = sctd ( 1 + kmr * ( j - 1 )) do 40 jj = 1 , 3 t2 = real ( t1 ) * g ( jj , 2 * j2 - 1 , i ) - aimag ( t1 ) * g ( jj , 2 * j2 , i ) t3 = aimag ( t1 ) * g ( jj , 2 * j2 - 1 , i ) + real ( t1 ) * g ( jj , 2 * j2 , i ) g ( jj , 2 * j2 - 1 , i ) = g ( jj , 2 * j1 - 1 , i ) - t2 g ( jj , 2 * j2 , i ) = g ( jj , 2 * j1 , i ) - t3 g ( jj , 2 * j1 - 1 , i ) = g ( jj , 2 * j1 - 1 , i ) + t2 g ( jj , 2 * j1 , i ) = g ( jj , 2 * j1 , i ) + t3 40 continue 50 continue 60 continue 70 continue ! unscramble coefficients and normalize ! inverse fourier transform if ( isign . lt . 0 ) then kmr = nxy / nyh do 90 k = 2 , nyhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( k - 1 ))), - real ( sctd ( 1 + kmr * ( k - 1 )))) do 80 jj = 1 , 3 t4 = g ( jj , ny3 - 2 * k , i ) t5 = - g ( jj , ny3 - 2 * k + 1 , i ) t2 = g ( jj , 2 * k - 1 , i ) + t4 t3 = g ( jj , 2 * k , i ) + t5 t6 = g ( jj , 2 * k - 1 , i ) - t4 t5 = g ( jj , 2 * k , i ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) g ( jj , 2 * k - 1 , i ) = 0.5 * ( t2 + t4 ) g ( jj , 2 * k , i ) = 0.5 * ( t3 + t5 ) g ( jj , ny3 - 2 * k , i ) = 0.5 * ( t2 - t4 ) g ( jj , ny3 - 2 * k + 1 , i ) = 0.5 * ( t5 - t3 ) 80 continue 90 continue do 100 jj = 1 , 3 g ( jj , nyh + 1 , i ) = g ( jj , nyh + 1 , i ) g ( jj , nyh + 2 , i ) = - g ( jj , nyh + 2 , i ) t2 = g ( jj , 1 , i ) + g ( jj , 2 , i ) g ( jj , 2 , i ) = g ( jj , 1 , i ) - g ( jj , 2 , i ) g ( jj , 1 , i ) = t2 g ( jj , ny + 1 , i ) = g ( jj , ny + 1 , i ) 100 continue ! forward fourier transform else if ( isign . gt . 0 ) then kmr = nxy / nyh do 120 k = 2 , nyhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( k - 1 ))), - real ( sctd ( 1 + kmr * ( k - 1 )))) do 110 jj = 1 , 3 t4 = g ( jj , ny3 - 2 * k , i ) t5 = - g ( jj , ny3 - 2 * k + 1 , i ) t2 = g ( jj , 2 * k - 1 , i ) + t4 t3 = g ( jj , 2 * k , i ) + t5 t6 = g ( jj , 2 * k - 1 , i ) - t4 t5 = g ( jj , 2 * k , i ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) g ( jj , 2 * k - 1 , i ) = t2 + t4 g ( jj , 2 * k , i ) = t3 + t5 g ( jj , ny3 - 2 * k , i ) = t2 - t4 g ( jj , ny3 - 2 * k + 1 , i ) = t5 - t3 110 continue 120 continue do 130 jj = 1 , 3 g ( jj , nyh + 1 , i ) = 2.0 * g ( jj , nyh + 1 , i ) g ( jj , nyh + 2 , i ) = - 2.0 * g ( jj , nyh + 2 , i ) t2 = 2.0 * ( g ( jj , 1 , i ) + g ( jj , 2 , i )) g ( jj , 2 , i ) = 2.0 * ( g ( jj , 1 , i ) - g ( jj , 2 , i )) g ( jj , 1 , i ) = t2 g ( jj , ny + 1 , i ) = 2.0 * g ( jj , ny + 1 , i ) 130 continue endif ! perform recursion for sine-cosine transform sum1 = 0.5 * g ( 1 , 1 , i ) g ( 1 , 1 , i ) = 0.0 g ( 1 , 2 , i ) = sum1 sum2 = g ( 2 , ny + 1 , i ) g ( 2 , ny + 1 , i ) = g ( 2 , 2 , i ) g ( 2 , 2 , i ) = sum2 sum3 = 0.5 * g ( 3 , 1 , i ) g ( 3 , 1 , i ) = 0.0 g ( 3 , 2 , i ) = sum3 do 140 k = 2 , nyh sum1 = sum1 + g ( 1 , 2 * k - 1 , i ) g ( 1 , 2 * k - 1 , i ) = - g ( 1 , 2 * k , i ) g ( 1 , 2 * k , i ) = sum1 sum2 = sum2 - g ( 2 , 2 * k , i ) g ( 2 , 2 * k , i ) = sum2 sum3 = sum3 + g ( 3 , 2 * k - 1 , i ) g ( 3 , 2 * k - 1 , i ) = - g ( 3 , 2 * k , i ) g ( 3 , 2 * k , i ) = sum3 140 continue g ( 1 , ny + 1 , i ) = 0.0 g ( 3 , ny + 1 , i ) = 0.0 150 continue !$OMP END PARALLEL DO return end !----------------------------------------------------------------------- subroutine PPFCSCT2RM3Y ( g , isign , mixup , sctd , indx , indy , kstrt , kxpi , & & kxpp , nyv , kxpd , nxhyd , nxyd ) ! this subroutine performs the y part of 3 two dimensional fast real ! sine and cosine transforms and their inverses, for a subset of x, ! using real arithmetic, with OpenMP, ! for data which is distributed in blocks ! x/z component has a cosine transform, y component a sine transform ! algorithm is described in Numerical Recipies in Fortran, Second Ed., ! by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, ! [Cambridge Univ. Press, 1992], p. 508. ! for isign = (-1,1), input: all, output: f ! approximate flop count: N*(5*log2(N) + 18)/nvp ! where N = (nx/2)*ny ! indx/indy = exponent which determines length in x/y direction, ! where nx=2**indx, ny=2**indy ! if isign = -1, inverse cosine-sine-cosine transform are performed ! g(1,m,n) = (.5*g(1,1,n) + ((-1)**m)*g(1,ny+1,n) !              + sum(g(1,k,n)*cos(pi*m*k/ny)) ! g(2,m,n) = sum(g(2,k,n)*sin(pi*m*k/ny)) ! g(3,m,n) = (.5*g(3,1,n) + ((-1)**m)*g(3,ny+1,n) !              + sum(g(3,k,n)*cos(pi*m*k/ny)) ! if isign = 1, a forward cosine-sine-cosine transforms are performed ! g(1,k,n) = 2*(.5*g(1,1,n) + ((-1)**m)*g(1,ny+1,n) !              + sum(g(1,m,n)*cos(pi*m*k/ny)) ! g(2,k,n) = sum(g(2,m,n)*sin(pi*m*k/ny)) ! g(3,k,n) = 2*(.5*g(3,1,n) + ((-1)**m)*g(3,ny+1,n) !              + sum(g(3,m,n)*cos(pi*m*k/ny)) ! mixup = array of bit reversed addresses ! sctd = sine/cosine table ! kstrt = starting data block number ! kxpi = initial x index used ! kxpp = number of x indices used ! nyv = first dimension of g >= ny + 1 ! kxpd = second dimension of g >= kxp + 1 ! nxhyd = maximum of (nx/2,ny) ! nxyd = maximum of (nx,ny) ! written by viktor k. decyk, ucla implicit none integer isign , indx , indy , kstrt , kxpi , kxpp integer nyv , kxpd , nxhyd , nxyd , mixup real g complex sctd dimension g ( 3 , nyv , kxpd ) dimension mixup ( nxhyd ), sctd ( nxyd ) ! local data integer indx1 , indy1 , indx1y , nx , ny , nyh , nyhh , ny3 , nxy , nxhy integer i , j , k , m , ks , km , kmr , nry , j1 , j2 , ns , ns2 , k1 , k2 integer kxps , nryb , jj real at1 , at2 , at3 , t2 , t3 , t4 , t5 , t6 complex t1 double precision sum1 , sum2 , sum3 indx1 = indx - 1 indy1 = indy - 1 indx1y = max0 ( indx1 , indy ) nx = 2 ** indx ny = 2 ** indy nyh = ny / 2 nyhh = ny / 4 ny3 = ny + 3 nxy = max0 ( nx , ny ) nxhy = 2 ** indx1y ks = kstrt - 1 kxps = kxpi + kxpp - 1 if ( kstrt . gt . nx ) return if ( isign . eq . 0 ) return nryb = nxhy / nyh nry = nxy / nyh !$OMP PARALLEL DO !$OMP& PRIVATE(i,j,k,m,jj,ns,ns2,km,kmr,k1,k2,j1,j2,at1,at2,at3,t2,t3,t4 !$OMP& ,t5,t6,t1,sum1,sum2,sum3) do 150 i = kxpi , kxps ! create auxiliary array in y kmr = nxy / ny sum1 = 0.5 * ( g ( 1 , 1 , i ) - g ( 1 , ny + 1 , i )) sum2 = 0.5 * ( g ( 3 , 1 , i ) - g ( 3 , ny + 1 , i )) do 10 k = 2 , nyh k1 = 1 + kmr * ( k - 1 ) at3 = - aimag ( sctd ( k1 )) at2 = g ( 1 , ny + 2 - k , i ) at1 = g ( 1 , k , i ) + at2 at2 = g ( 1 , k , i ) - at2 sum1 = sum1 + real ( sctd ( k1 )) * at2 at2 = at3 * at2 at1 = 0.5 * at1 g ( 1 , k , i ) = at1 - at2 g ( 1 , ny + 2 - k , i ) = at1 + at2 at2 = g ( 2 , ny + 2 - k , i ) at1 = g ( 2 , k , i ) + at2 at2 = g ( 2 , k , i ) - at2 at1 = at3 * at1 at2 = 0.5 * at2 g ( 2 , k , i ) = at1 + at2 g ( 2 , ny + 2 - k , i ) = at1 - at2 at2 = g ( 3 , ny + 2 - k , i ) at1 = g ( 3 , k , i ) + at2 at2 = g ( 3 , k , i ) - at2 sum2 = sum2 + real ( sctd ( k1 )) * at2 at2 = at3 * at2 at1 = 0.5 * at1 g ( 3 , k , i ) = at1 - at2 g ( 3 , ny + 2 - k , i ) = at1 + at2 10 continue g ( 1 , 1 , i ) = 0.5 * ( g ( 1 , 1 , i ) + g ( 1 , ny + 1 , i )) g ( 1 , ny + 1 , i ) = sum1 g ( 2 , 1 , i ) = 0.0 g ( 2 , nyh + 1 , i ) = 2.0 * g ( 2 , nyh + 1 , i ) g ( 3 , 1 , i ) = 0.5 * ( g ( 3 , 1 , i ) + g ( 3 , ny + 1 , i )) g ( 3 , ny + 1 , i ) = sum2 ! bit-reverse array elements in y do 30 k = 1 , nyh k1 = ( mixup ( k ) - 1 ) / nryb + 1 if ( k . lt . k1 ) then do 20 jj = 1 , 3 t2 = g ( jj , 2 * k1 - 1 , i ) t3 = g ( jj , 2 * k1 , i ) g ( jj , 2 * k1 - 1 , i ) = g ( jj , 2 * k - 1 , i ) g ( jj , 2 * k1 , i ) = g ( jj , 2 * k , i ) g ( jj , 2 * k - 1 , i ) = t2 g ( jj , 2 * k , i ) = t3 20 continue endif 30 continue ! then transform in y do 70 m = 1 , indy1 ns = 2 ** ( m - 1 ) ns2 = ns + ns km = nyhh / ns kmr = 2 * km * nry do 60 k = 1 , km k1 = ns2 * ( k - 1 ) k2 = k1 + ns do 50 j = 1 , ns j1 = j + k1 j2 = j + k2 t1 = sctd ( 1 + kmr * ( j - 1 )) do 40 jj = 1 , 3 t2 = real ( t1 ) * g ( jj , 2 * j2 - 1 , i ) - aimag ( t1 ) * g ( jj , 2 * j2 , i ) t3 = aimag ( t1 ) * g ( jj , 2 * j2 - 1 , i ) + real ( t1 ) * g ( jj , 2 * j2 , i ) g ( jj , 2 * j2 - 1 , i ) = g ( jj , 2 * j1 - 1 , i ) - t2 g ( jj , 2 * j2 , i ) = g ( jj , 2 * j1 , i ) - t3 g ( jj , 2 * j1 - 1 , i ) = g ( jj , 2 * j1 - 1 , i ) + t2 g ( jj , 2 * j1 , i ) = g ( jj , 2 * j1 , i ) + t3 40 continue 50 continue 60 continue 70 continue ! unscramble coefficients and normalize ! inverse fourier transform if ( isign . lt . 0 ) then kmr = nxy / nyh do 90 k = 2 , nyhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( k - 1 ))), - real ( sctd ( 1 + kmr * ( k - 1 )))) do 80 jj = 1 , 3 t4 = g ( jj , ny3 - 2 * k , i ) t5 = - g ( jj , ny3 - 2 * k + 1 , i ) t2 = g ( jj , 2 * k - 1 , i ) + t4 t3 = g ( jj , 2 * k , i ) + t5 t6 = g ( jj , 2 * k - 1 , i ) - t4 t5 = g ( jj , 2 * k , i ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) g ( jj , 2 * k - 1 , i ) = 0.5 * ( t2 + t4 ) g ( jj , 2 * k , i ) = 0.5 * ( t3 + t5 ) g ( jj , ny3 - 2 * k , i ) = 0.5 * ( t2 - t4 ) g ( jj , ny3 - 2 * k + 1 , i ) = 0.5 * ( t5 - t3 ) 80 continue 90 continue do 100 jj = 1 , 3 g ( jj , nyh + 1 , i ) = g ( jj , nyh + 1 , i ) g ( jj , nyh + 2 , i ) = - g ( jj , nyh + 2 , i ) t2 = g ( jj , 1 , i ) + g ( jj , 2 , i ) g ( jj , 2 , i ) = g ( jj , 1 , i ) - g ( jj , 2 , i ) g ( jj , 1 , i ) = t2 g ( jj , ny + 1 , i ) = g ( jj , ny + 1 , i ) 100 continue ! forward fourier transform else if ( isign . gt . 0 ) then kmr = nxy / nyh do 120 k = 2 , nyhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( k - 1 ))), - real ( sctd ( 1 + kmr * ( k - 1 )))) do 110 jj = 1 , 3 t4 = g ( jj , ny3 - 2 * k , i ) t5 = - g ( jj , ny3 - 2 * k + 1 , i ) t2 = g ( jj , 2 * k - 1 , i ) + t4 t3 = g ( jj , 2 * k , i ) + t5 t6 = g ( jj , 2 * k - 1 , i ) - t4 t5 = g ( jj , 2 * k , i ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) g ( jj , 2 * k - 1 , i ) = t2 + t4 g ( jj , 2 * k , i ) = t3 + t5 g ( jj , ny3 - 2 * k , i ) = t2 - t4 g ( jj , ny3 - 2 * k + 1 , i ) = t5 - t3 110 continue 120 continue do 130 jj = 1 , 3 g ( jj , nyh + 1 , i ) = 2.0 * g ( jj , nyh + 1 , i ) g ( jj , nyh + 2 , i ) = - 2.0 * g ( jj , nyh + 2 , i ) t2 = 2.0 * ( g ( jj , 1 , i ) + g ( jj , 2 , i )) g ( jj , 2 , i ) = 2.0 * ( g ( jj , 1 , i ) - g ( jj , 2 , i )) g ( jj , 1 , i ) = t2 g ( jj , ny + 1 , i ) = 2.0 * g ( jj , ny + 1 , i ) 130 continue endif ! perform recursion for sine-cosine transform sum1 = g ( 1 , ny + 1 , i ) g ( 1 , ny + 1 , i ) = g ( 1 , 2 , i ) g ( 1 , 2 , i ) = sum1 sum2 = 0.5 * g ( 2 , 1 , i ) g ( 2 , 1 , i ) = 0.0 g ( 2 , 2 , i ) = sum2 sum3 = g ( 3 , ny + 1 , i ) g ( 3 , ny + 1 , i ) = g ( 3 , 2 , i ) g ( 3 , 2 , i ) = sum3 do 140 k = 2 , nyh sum1 = sum1 - g ( 1 , 2 * k , i ) g ( 1 , 2 * k , i ) = sum1 sum2 = sum2 + g ( 2 , 2 * k - 1 , i ) g ( 2 , 2 * k - 1 , i ) = - g ( 2 , 2 * k , i ) g ( 2 , 2 * k , i ) = sum2 sum3 = sum3 - g ( 3 , 2 * k , i ) g ( 3 , 2 * k , i ) = sum3 140 continue g ( 2 , ny + 1 , i ) = 0.0 150 continue !$OMP END PARALLEL DO return end !----------------------------------------------------------------------- subroutine WPPFSCT2RM4 ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp , indx , & & indy , kstrt , nvp , nxvh , nyv , kxp2 , kyp , kypd , kxp2d , nxhyd , nxyd ) ! wrapper function for 4 parallel real sine/cosine transforms ! for the momentum flux with dirichlet boundary conditions ! x component has a sine/sine transform in x and y, respectively ! y component has a cosine/cosine transform in x and y, respectively ! z component has a cosine/sine transform in x and y, respectively ! w component has a sine/cosine transform in x and y, respectively implicit none integer isign , ntpose , mixup , indx , indy , kstrt , nvp , nxvh , nyv integer kxp2 , kyp , kypd , kxp2d , nxhyd , nxyd real f , g , bs , br , ttp complex sctd dimension f ( 4 , 2 * nxvh , kypd ), g ( 4 , nyv , kxp2d ) dimension bs ( 4 , kxp2 + 1 , kyp + 1 ), br ( 4 , kxp2 + 1 , kyp + 1 ) dimension mixup ( nxhyd ), sctd ( nxyd ) ! local data integer nx , ny , kxpi , kypi , ks , kxp2p , kypp , kxb2 , kyb real tf double precision dtime data kxpi , kypi / 1 , 1 / ! calculate range of indices nx = 2 ** indx ny = 2 ** indy ! ks = processor id ks = kstrt - 1 ! kxp2p = actual size used in x direction kxp2p = min ( kxp2 , max ( 0 , nx - kxp2 * ks )) ! kypp = actual size used in y direction kypp = min ( kyp , max ( 0 , ny - kyp * ks )) ! kxb2 = minimum number of processors needed in x direction kxb2 = ( nx - 1 ) / kxp2 + 1 ! kyb = minimum number of processors needed in y direction kyb = ( ny - 1 ) / kyp + 1 ! add extra word for last processor in x if ( ks == ( kxb2 - 1 )) kxp2p = kxp2p + 1 ! add extra word for last processor in y if ( ks == ( kyb - 1 )) kypp = kypp + 1 ! inverse fourier transform if ( isign . lt . 0 ) then ! perform x sine-cosine-cosine-sine transform call PPFSCCST2RM4X ( f , isign , mixup , sctd , indx , indy , kstrt , kypi , kypp & & , nxvh , kypd , nxhyd , nxyd ) ! transpose f array to g call PWTIMERA ( - 1 , ttp , dtime ) call PPRNTPOSE ( f , g , bs , br , nx , ny , kxp2 , kyp , kstrt , nvp , 4 , 2 * nxvh , nyv , & & kxp2d , kypd ) call PWTIMERA ( 1 , ttp , dtime ) ! perform y sine-cosine-sine-cosine transform call PPFSCSCT2RM4Y ( g , isign , mixup , sctd , indx , indy , kstrt , kxpi , & & kxp2p , nyv , kxp2d , nxhyd , nxyd ) ! transpose g array to f if ( ntpose . eq . 0 ) then call PWTIMERA ( - 1 , tf , dtime ) call PPRNTPOSE ( g , f , br , bs , ny , nx , kyp , kxp2 , kstrt , nvp , 4 , nyv , & & 2 * nxvh , kypd , kxp2d ) call PWTIMERA ( 1 , tf , dtime ) endif ! forward fourier transform else if ( isign . gt . 0 ) then ! transpose f array to g if ( ntpose . eq . 0 ) then call PWTIMERA ( - 1 , tf , dtime ) call PPRNTPOSE ( f , g , bs , br , nx , ny , kxp2 , kyp , kstrt , nvp , 4 , 2 * nxvh , & & nyv , kxp2d , kypd ) call PWTIMERA ( 1 , tf , dtime ) endif ! perform y sine-cosine-sine-cosine transform call PPFSCSCT2RM4Y ( g , isign , mixup , sctd , indx , indy , kstrt , kxpi , & & kxp2p , nyv , kxp2d , nxhyd , nxyd ) ! transpose g array to f call PWTIMERA ( - 1 , ttp , dtime ) call PPRNTPOSE ( g , f , br , bs , ny , nx , kyp , kxp2 , kstrt , nvp , 4 , nyv , 2 * nxvh , & & kypd , kxp2d ) call PWTIMERA ( 1 , ttp , dtime ) ! perform y sine-cosine-sine-cosine transform call PPFSCCST2RM4X ( f , isign , mixup , sctd , indx , indy , kstrt , kypi , kypp & & , nxvh , kypd , nxhyd , nxyd ) endif if ( ntpose . eq . 0 ) ttp = ttp + tf return end !----------------------------------------------------------------------- subroutine PPFSCCST2RM4X ( f , isign , mixup , sctd , indx , indy , kstrt , kypi , & & kypp , nxvh , kypd , nxhyd , nxyd ) ! this subroutine performs the x part of 4 two dimensional fast real ! sine and cosine transforms and their inverses, for a subset of y, ! using real arithmetic, with OpenMP, ! for data which is distributed in blocks ! x/w component has a sine transform, y/z component a cosine transform ! algorithm is described in Numerical Recipies in Fortran, Second Ed., ! by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, ! [Cambridge Univ. Press, 1992], p. 508. ! for isign = (-1,1), input: all, output: f ! approximate flop count: N*(5*log2(N) + 18)/nvp ! where N = (nx/2)*ny ! indx/indy = exponent which determines length in x/y direction, ! where nx=2**indx, ny=2**indy ! if isign = -1, inverse sine-cosine-cosine-sine transforms are ! performed ! f(1,n,k) = (1/nx*ny)*sum(f(1,j,k)*sin(pi*n*j/nx)) ! f(2:3,n,k) = (1/nx*ny)*(.5*f(2:3,1,k) + ((-1)**n)*f(2:3,nx+1,k) !              + sum(f(2:3,j,k)*cos(pi*n*j/nx))) ! f(4,n,k) = (1/nx*ny)*sum(f(4,j,k)*sin(pi*n*j/nx)) ! if isign = 1, forward sine-cosine-cosine-sine transforms are performed ! f(1,j,k) = sum(f(1,n,k)*sin(pi*n*j/nx)) ! f(2:3,j,k) = 2*(.5*f(2:3,1,k) + ((-1)**j)*f(2:3,n+1,k) !              + sum(f(2:3,n,k)*cos(pi*n*j/nx)) ! f(4,j,k) = sum(f(4,n,k)*sin(pi*n*j/nx)) ! mixup = array of bit reversed addresses ! sctd = sine/cosine table ! kstrt = starting data block number ! kypi = initial y index used ! kypp = number of y indices used ! nxvh = first dimension of f >= nx/2 + 1 ! kypd = second dimension of f >= kyp + 1 ! nxhyd = maximum of (nx/2,ny) ! nxyd = maximum of (nx,ny) ! written by viktor k. decyk, ucla implicit none integer isign , indx , indy , kstrt , kypi , kypp integer nxvh , kypd , nxhyd , nxyd , mixup real f complex sctd dimension f ( 4 , 2 * nxvh , kypd ) dimension mixup ( nxhyd ), sctd ( nxyd ) ! local data integer indx1 , indx1y , nx , nxh , nxhh , nx3 , ny , nxy , nxhy , ks integer i , j , k , m , km , kmr , nrx , j1 , j2 , ns , ns2 , k1 , k2 , kyps integer nrxb , jj real at1 , at2 , at3 , t2 , t3 , t4 , t5 , t6 , ani complex t1 double precision sum1 , sum2 , sum3 , sum4 indx1 = indx - 1 indx1y = max0 ( indx1 , indy ) nx = 2 ** indx nxh = nx / 2 nxhh = nx / 4 nx3 = nx + 3 ny = 2 ** indy nxy = max0 ( nx , ny ) nxhy = 2 ** indx1y ks = kstrt - 1 kyps = kypi + kypp - 1 if ( kstrt . gt . ny ) return if ( isign . eq . 0 ) return ani = 0.5 / ( real ( nx ) * real ( ny )) nrxb = nxhy / nxh nrx = nxy / nxh !$OMP PARALLEL DO !$OMP& PRIVATE(i,j,k,m,jj,ns,ns2,km,kmr,k1,k2,j1,j2,at1,at2,at3,t2,t3,t4 !$OMP& ,t5,t6,t1,sum1,sum2,sum3,sum4) do 150 i = kypi , kyps ! create auxiliary array in x kmr = nxy / nx sum2 = 0.5 * ( f ( 2 , 1 , i ) - f ( 2 , nx + 1 , i )) sum3 = 0.5 * ( f ( 3 , 1 , i ) - f ( 3 , nx + 1 , i )) do 10 j = 2 , nxh j1 = 1 + kmr * ( j - 1 ) at3 = - aimag ( sctd ( j1 )) at2 = f ( 1 , nx + 2 - j , i ) at1 = f ( 1 , j , i ) + at2 at2 = f ( 1 , j , i ) - at2 at1 = at3 * at1 at2 = 0.5 * at2 f ( 1 , j , i ) = at1 + at2 f ( 1 , nx + 2 - j , i ) = at1 - at2 at2 = f ( 2 , nx + 2 - j , i ) at1 = f ( 2 , j , i ) + at2 at2 = f ( 2 , j , i ) - at2 sum2 = sum2 + real ( sctd ( j1 )) * at2 at2 = at3 * at2 at1 = 0.5 * at1 f ( 2 , j , i ) = at1 - at2 f ( 2 , nx + 2 - j , i ) = at1 + at2 at2 = f ( 3 , nx + 2 - j , i ) at1 = f ( 3 , j , i ) + at2 at2 = f ( 3 , j , i ) - at2 sum3 = sum3 + real ( sctd ( j1 )) * at2 at2 = at3 * at2 at1 = 0.5 * at1 f ( 3 , j , i ) = at1 - at2 f ( 3 , nx + 2 - j , i ) = at1 + at2 at2 = f ( 4 , nx + 2 - j , i ) at1 = f ( 4 , j , i ) + at2 at2 = f ( 4 , j , i ) - at2 at1 = at3 * at1 at2 = 0.5 * at2 f ( 4 , j , i ) = at1 + at2 f ( 4 , nx + 2 - j , i ) = at1 - at2 10 continue f ( 1 , 1 , i ) = 0.0 f ( 1 , nxh + 1 , i ) = 2.0 * f ( 1 , nxh + 1 , i ) f ( 2 , 1 , i ) = 0.5 * ( f ( 2 , 1 , i ) + f ( 2 , nx + 1 , i )) f ( 2 , nx + 1 , i ) = sum2 f ( 3 , 1 , i ) = 0.5 * ( f ( 3 , 1 , i ) + f ( 3 , nx + 1 , i )) f ( 3 , nx + 1 , i ) = sum3 f ( 4 , 1 , i ) = 0.0 f ( 4 , nxh + 1 , i ) = 2.0 * f ( 4 , nxh + 1 , i ) ! bit-reverse array elements in x do 30 j = 1 , nxh j1 = ( mixup ( j ) - 1 ) / nrxb + 1 if ( j . lt . j1 ) then do 20 jj = 1 , 4 t2 = f ( jj , 2 * j1 - 1 , i ) t3 = f ( jj , 2 * j1 , i ) f ( jj , 2 * j1 - 1 , i ) = f ( jj , 2 * j - 1 , i ) f ( jj , 2 * j1 , i ) = f ( jj , 2 * j , i ) f ( jj , 2 * j - 1 , i ) = t2 f ( jj , 2 * j , i ) = t3 20 continue endif 30 continue ! then transform in x do 70 m = 1 , indx1 ns = 2 ** ( m - 1 ) ns2 = ns + ns km = nxhh / ns kmr = 2 * km * nrx do 60 k = 1 , km k1 = ns2 * ( k - 1 ) k2 = k1 + ns do 50 j = 1 , ns j1 = j + k1 j2 = j + k2 t1 = sctd ( 1 + kmr * ( j - 1 )) do 40 jj = 1 , 4 t2 = real ( t1 ) * f ( jj , 2 * j2 - 1 , i ) - aimag ( t1 ) * f ( jj , 2 * j2 , i ) t3 = aimag ( t1 ) * f ( jj , 2 * j2 - 1 , i ) + real ( t1 ) * f ( jj , 2 * j2 , i ) f ( jj , 2 * j2 - 1 , i ) = f ( jj , 2 * j1 - 1 , i ) - t2 f ( jj , 2 * j2 , i ) = f ( jj , 2 * j1 , i ) - t3 f ( jj , 2 * j1 - 1 , i ) = f ( jj , 2 * j1 - 1 , i ) + t2 f ( jj , 2 * j1 , i ) = f ( jj , 2 * j1 , i ) + t3 40 continue 50 continue 60 continue 70 continue ! unscramble coefficients and normalize ! inverse fourier transform if ( isign . lt . 0 ) then kmr = nxy / nxh do 90 j = 2 , nxhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( j - 1 ))), - real ( sctd ( 1 + kmr * ( j - 1 )))) do 80 jj = 1 , 4 t4 = f ( jj , nx3 - 2 * j , i ) t5 = - f ( jj , nx3 - 2 * j + 1 , i ) t2 = f ( jj , 2 * j - 1 , i ) + t4 t3 = f ( jj , 2 * j , i ) + t5 t6 = f ( jj , 2 * j - 1 , i ) - t4 t5 = f ( jj , 2 * j , i ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) f ( jj , 2 * j - 1 , i ) = ani * ( t2 + t4 ) f ( jj , 2 * j , i ) = ani * ( t3 + t5 ) f ( jj , nx3 - 2 * j , i ) = ani * ( t2 - t4 ) f ( jj , nx3 - 2 * j + 1 , i ) = ani * ( t5 - t3 ) 80 continue 90 continue do 100 jj = 1 , 4 f ( jj , nxh + 1 , i ) = 2.0 * ani * f ( jj , nxh + 1 , i ) f ( jj , nxh + 2 , i ) = - 2.0 * ani * f ( jj , nxh + 2 , i ) t2 = 2.0 * ani * ( f ( jj , 1 , i ) + f ( jj , 2 , i )) f ( jj , 2 , i ) = 2.0 * ani * ( f ( jj , 1 , i ) - f ( jj , 2 , i )) f ( jj , 1 , i ) = t2 f ( jj , nx + 1 , i ) = 2.0 * ani * f ( jj , nx + 1 , i ) 100 continue ! forward fourier transform else if ( isign . gt . 0 ) then kmr = nxy / nxh do 120 j = 2 , nxhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( j - 1 ))), - real ( sctd ( 1 + kmr * ( j - 1 )))) do 110 jj = 1 , 4 t4 = f ( jj , nx3 - 2 * j , i ) t5 = - f ( jj , nx3 - 2 * j + 1 , i ) t2 = f ( jj , 2 * j - 1 , i ) + t4 t3 = f ( jj , 2 * j , i ) + t5 t6 = f ( jj , 2 * j - 1 , i ) - t4 t5 = f ( jj , 2 * j , i ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) f ( jj , 2 * j - 1 , i ) = t2 + t4 f ( jj , 2 * j , i ) = t3 + t5 f ( jj , nx3 - 2 * j , i ) = t2 - t4 f ( jj , nx3 - 2 * j + 1 , i ) = t5 - t3 110 continue 120 continue do 130 jj = 1 , 4 f ( jj , nxh + 1 , i ) = 2.0 * f ( jj , nxh + 1 , i ) f ( jj , nxh + 2 , i ) = - 2.0 * f ( jj , nxh + 2 , i ) t2 = 2.0 * ( f ( jj , 1 , i ) + f ( jj , 2 , i )) f ( jj , 2 , i ) = 2.0 * ( f ( jj , 1 , i ) - f ( jj , 2 , i )) f ( jj , 1 , i ) = t2 f ( jj , nx + 1 , i ) = 2.0 * f ( jj , nx + 1 , i ) 130 continue endif ! perform recursion for cosine-sine transform sum1 = 0.5 * f ( 1 , 1 , i ) f ( 1 , 1 , i ) = 0.0 f ( 1 , 2 , i ) = sum1 sum2 = f ( 2 , nx + 1 , i ) f ( 2 , nx + 1 , i ) = f ( 2 , 2 , i ) f ( 2 , 2 , i ) = sum2 sum3 = f ( 3 , nx + 1 , i ) f ( 3 , nx + 1 , i ) = f ( 3 , 2 , i ) f ( 3 , 2 , i ) = sum3 sum4 = 0.5 * f ( 4 , 1 , i ) f ( 4 , 1 , i ) = 0.0 f ( 4 , 2 , i ) = sum4 do 140 j = 2 , nxh sum1 = sum1 + f ( 1 , 2 * j - 1 , i ) f ( 1 , 2 * j - 1 , i ) = - f ( 1 , 2 * j , i ) f ( 1 , 2 * j , i ) = sum1 sum2 = sum2 - f ( 2 , 2 * j , i ) f ( 2 , 2 * j , i ) = sum2 sum3 = sum3 - f ( 3 , 2 * j , i ) f ( 3 , 2 * j , i ) = sum3 sum4 = sum4 + f ( 4 , 2 * j - 1 , i ) f ( 4 , 2 * j - 1 , i ) = - f ( 4 , 2 * j , i ) f ( 4 , 2 * j , i ) = sum4 140 continue f ( 1 , nx + 1 , i ) = 0.0 f ( 4 , nx + 1 , i ) = 0.0 150 continue !$OMP END PARALLEL DO return end !----------------------------------------------------------------------- subroutine PPFSCSCT2RM4Y ( g , isign , mixup , sctd , indx , indy , kstrt , kxpi , & & kxpp , nyv , kxpd , nxhyd , nxyd ) ! this subroutine performs the y part of 4 two dimensional fast real ! sine and cosine transforms and their inverses, for a subset of x, ! using real arithmetic, with OpenMP, ! for data which is distributed in blocks ! x/z component has a sine transform, y/w component a cosine transform ! algorithm is described in Numerical Recipies in Fortran, Second Ed., ! by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, ! [Cambridge Univ. Press, 1992], p. 508. ! for isign = (-1,1), input: all, output: f ! approximate flop count: N*(5*log2(N) + 18)/nvp ! where N = (nx/2)*ny ! indx/indy = exponent which determines length in x/y direction, ! where nx=2**indx, ny=2**indy ! if isign = -1, inverse sine-cosine-sine-cosine transform are performed ! g(1,m,n) = sum(g(1,k,n)*sin(pi*m*k/ny)) ! g(2,m,n) = (.5*g(2,1,n) + ((-1)**m)*g(2,ny+1,n) !              + sum(g(2,k,n)*cos(pi*m*k/ny)) ! g(3,m,n) = sum(g(3,k,n)*sin(pi*m*k/ny)) ! g(4,m,n) = (.5*g(4,1,n) + ((-1)**m)*g(4,ny+1,n) !              + sum(g(4,k,n)*cos(pi*m*k/ny)) ! if isign = 1, forward sine-cosine-sine-cosine transform are performed ! g(1,k,n) = sum(g(1,m,n)*sin(pi*m*k/ny)) ! g(2,k,n) = 2*(.5*g(2,1,n) + ((-1)**m)*g(2,ny+1,n) !              + sum(g(2,m,n)*cos(pi*m*k/ny)) ! g(3,k,n) = sum(g(3,m,n)*sin(pi*m*k/ny)) ! g(4,k,n) = 2*(.5*g(4,1,n) + ((-1)**m)*g(4,ny+1,n) !              + sum(g(4,m,n)*cos(pi*m*k/ny)) ! mixup = array of bit reversed addresses ! sctd = sine/cosine table ! kstrt = starting data block number ! kxpi = initial x index used ! kxpp = number of x indices used ! nyv = first dimension of g >= ny + 1 ! kxpd = second dimension of g >= kxp + 1 ! nxhyd = maximum of (nx/2,ny) ! nxyd = maximum of (nx,ny) ! written by viktor k. decyk, ucla implicit none integer isign , indx , indy , kstrt , kxpi , kxpp integer nyv , kxpd , nxhyd , nxyd , mixup real g complex sctd dimension g ( 4 , nyv , kxpd ) dimension mixup ( nxhyd ), sctd ( nxyd ) ! local data integer indx1 , indy1 , indx1y , nx , ny , nyh , nyhh , ny3 , nxy , nxhy integer i , j , k , m , ks , km , kmr , nry , j1 , j2 , ns , ns2 , k1 , k2 integer kxps , nryb , jj real at1 , at2 , at3 , t2 , t3 , t4 , t5 , t6 complex t1 double precision sum1 , sum2 , sum3 , sum4 indx1 = indx - 1 indy1 = indy - 1 indx1y = max0 ( indx1 , indy ) nx = 2 ** indx ny = 2 ** indy nyh = ny / 2 nyhh = ny / 4 ny3 = ny + 3 nxy = max0 ( nx , ny ) nxhy = 2 ** indx1y ks = kstrt - 1 kxps = kxpi + kxpp - 1 if ( kstrt . gt . nx ) return if ( isign . eq . 0 ) return nryb = nxhy / nyh nry = nxy / nyh !$OMP PARALLEL DO !$OMP& PRIVATE(i,j,k,m,jj,ns,ns2,km,kmr,k1,k2,j1,j2,at1,at2,at3,t2,t3,t4 !$OMP& ,t5,t6,t1,sum1,sum2,sum3,sum4) do 150 i = kxpi , kxps ! create auxiliary array in y kmr = nxy / ny sum2 = 0.5 * ( g ( 2 , 1 , i ) - g ( 2 , ny + 1 , i )) sum4 = 0.5 * ( g ( 4 , 1 , i ) - g ( 4 , ny + 1 , i )) do 10 k = 2 , nyh k1 = 1 + kmr * ( k - 1 ) at3 = - aimag ( sctd ( k1 )) at2 = g ( 1 , ny + 2 - k , i ) at1 = g ( 1 , k , i ) + at2 at2 = g ( 1 , k , i ) - at2 at1 = at3 * at1 at2 = 0.5 * at2 g ( 1 , k , i ) = at1 + at2 g ( 1 , ny + 2 - k , i ) = at1 - at2 at2 = g ( 2 , ny + 2 - k , i ) at1 = g ( 2 , k , i ) + at2 at2 = g ( 2 , k , i ) - at2 sum2 = sum2 + real ( sctd ( k1 )) * at2 at2 = at3 * at2 at1 = 0.5 * at1 g ( 2 , k , i ) = at1 - at2 g ( 2 , ny + 2 - k , i ) = at1 + at2 at2 = g ( 3 , ny + 2 - k , i ) at1 = g ( 3 , k , i ) + at2 at2 = g ( 3 , k , i ) - at2 at1 = at3 * at1 at2 = 0.5 * at2 g ( 3 , k , i ) = at1 + at2 g ( 3 , ny + 2 - k , i ) = at1 - at2 at2 = g ( 4 , ny + 2 - k , i ) at1 = g ( 4 , k , i ) + at2 at2 = g ( 4 , k , i ) - at2 sum4 = sum4 + real ( sctd ( k1 )) * at2 at2 = at3 * at2 at1 = 0.5 * at1 g ( 4 , k , i ) = at1 - at2 g ( 4 , ny + 2 - k , i ) = at1 + at2 10 continue g ( 1 , 1 , i ) = 0.0 g ( 1 , nyh + 1 , i ) = 2.0 * g ( 1 , nyh + 1 , i ) g ( 2 , 1 , i ) = 0.5 * ( g ( 2 , 1 , i ) + g ( 2 , ny + 1 , i )) g ( 2 , ny + 1 , i ) = sum2 g ( 3 , 1 , i ) = 0.0 g ( 3 , nyh + 1 , i ) = 2.0 * g ( 3 , nyh + 1 , i ) g ( 4 , 1 , i ) = 0.5 * ( g ( 4 , 1 , i ) + g ( 4 , ny + 1 , i )) g ( 4 , ny + 1 , i ) = sum4 ! bit-reverse array elements in y do 30 k = 1 , nyh k1 = ( mixup ( k ) - 1 ) / nryb + 1 if ( k . lt . k1 ) then do 20 jj = 1 , 4 t2 = g ( jj , 2 * k1 - 1 , i ) t3 = g ( jj , 2 * k1 , i ) g ( jj , 2 * k1 - 1 , i ) = g ( jj , 2 * k - 1 , i ) g ( jj , 2 * k1 , i ) = g ( jj , 2 * k , i ) g ( jj , 2 * k - 1 , i ) = t2 g ( jj , 2 * k , i ) = t3 20 continue endif 30 continue ! then transform in y do 70 m = 1 , indy1 ns = 2 ** ( m - 1 ) ns2 = ns + ns km = nyhh / ns kmr = 2 * km * nry do 60 k = 1 , km k1 = ns2 * ( k - 1 ) k2 = k1 + ns do 50 j = 1 , ns j1 = j + k1 j2 = j + k2 t1 = sctd ( 1 + kmr * ( j - 1 )) do 40 jj = 1 , 4 t2 = real ( t1 ) * g ( jj , 2 * j2 - 1 , i ) - aimag ( t1 ) * g ( jj , 2 * j2 , i ) t3 = aimag ( t1 ) * g ( jj , 2 * j2 - 1 , i ) + real ( t1 ) * g ( jj , 2 * j2 , i ) g ( jj , 2 * j2 - 1 , i ) = g ( jj , 2 * j1 - 1 , i ) - t2 g ( jj , 2 * j2 , i ) = g ( jj , 2 * j1 , i ) - t3 g ( jj , 2 * j1 - 1 , i ) = g ( jj , 2 * j1 - 1 , i ) + t2 g ( jj , 2 * j1 , i ) = g ( jj , 2 * j1 , i ) + t3 40 continue 50 continue 60 continue 70 continue ! unscramble coefficients and normalize ! inverse fourier transform if ( isign . lt . 0 ) then kmr = nxy / nyh do 90 k = 2 , nyhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( k - 1 ))), - real ( sctd ( 1 + kmr * ( k - 1 )))) do 80 jj = 1 , 4 t4 = g ( jj , ny3 - 2 * k , i ) t5 = - g ( jj , ny3 - 2 * k + 1 , i ) t2 = g ( jj , 2 * k - 1 , i ) + t4 t3 = g ( jj , 2 * k , i ) + t5 t6 = g ( jj , 2 * k - 1 , i ) - t4 t5 = g ( jj , 2 * k , i ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) g ( jj , 2 * k - 1 , i ) = 0.5 * ( t2 + t4 ) g ( jj , 2 * k , i ) = 0.5 * ( t3 + t5 ) g ( jj , ny3 - 2 * k , i ) = 0.5 * ( t2 - t4 ) g ( jj , ny3 - 2 * k + 1 , i ) = 0.5 * ( t5 - t3 ) 80 continue 90 continue do 100 jj = 1 , 4 g ( jj , nyh + 1 , i ) = g ( jj , nyh + 1 , i ) g ( jj , nyh + 2 , i ) = - g ( jj , nyh + 2 , i ) t2 = g ( jj , 1 , i ) + g ( jj , 2 , i ) g ( jj , 2 , i ) = g ( jj , 1 , i ) - g ( jj , 2 , i ) g ( jj , 1 , i ) = t2 g ( jj , ny + 1 , i ) = g ( jj , ny + 1 , i ) 100 continue ! forward fourier transform else if ( isign . gt . 0 ) then kmr = nxy / nyh do 120 k = 2 , nyhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( k - 1 ))), - real ( sctd ( 1 + kmr * ( k - 1 )))) do 110 jj = 1 , 4 t4 = g ( jj , ny3 - 2 * k , i ) t5 = - g ( jj , ny3 - 2 * k + 1 , i ) t2 = g ( jj , 2 * k - 1 , i ) + t4 t3 = g ( jj , 2 * k , i ) + t5 t6 = g ( jj , 2 * k - 1 , i ) - t4 t5 = g ( jj , 2 * k , i ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) g ( jj , 2 * k - 1 , i ) = t2 + t4 g ( jj , 2 * k , i ) = t3 + t5 g ( jj , ny3 - 2 * k , i ) = t2 - t4 g ( jj , ny3 - 2 * k + 1 , i ) = t5 - t3 110 continue 120 continue do 130 jj = 1 , 4 g ( jj , nyh + 1 , i ) = 2.0 * g ( jj , nyh + 1 , i ) g ( jj , nyh + 2 , i ) = - 2.0 * g ( jj , nyh + 2 , i ) t2 = 2.0 * ( g ( jj , 1 , i ) + g ( jj , 2 , i )) g ( jj , 2 , i ) = 2.0 * ( g ( jj , 1 , i ) - g ( jj , 2 , i )) g ( jj , 1 , i ) = t2 g ( jj , ny + 1 , i ) = 2.0 * g ( jj , ny + 1 , i ) 130 continue endif ! perform recursion for sine-cosine transform sum1 = 0.5 * g ( 1 , 1 , i ) g ( 1 , 1 , i ) = 0.0 g ( 1 , 2 , i ) = sum1 sum2 = g ( 2 , ny + 1 , i ) g ( 2 , ny + 1 , i ) = g ( 2 , 2 , i ) g ( 2 , 2 , i ) = sum2 sum3 = 0.5 * g ( 3 , 1 , i ) g ( 3 , 1 , i ) = 0.0 g ( 3 , 2 , i ) = sum3 sum4 = g ( 4 , ny + 1 , i ) g ( 4 , ny + 1 , i ) = g ( 4 , 2 , i ) g ( 4 , 2 , i ) = sum4 do 140 k = 2 , nyh sum1 = sum1 + g ( 1 , 2 * k - 1 , i ) g ( 1 , 2 * k - 1 , i ) = - g ( 1 , 2 * k , i ) g ( 1 , 2 * k , i ) = sum1 sum2 = sum2 - g ( 2 , 2 * k , i ) g ( 2 , 2 * k , i ) = sum2 sum3 = sum3 + g ( 3 , 2 * k - 1 , i ) g ( 3 , 2 * k - 1 , i ) = - g ( 3 , 2 * k , i ) g ( 3 , 2 * k , i ) = sum3 sum4 = sum4 - g ( 4 , 2 * k , i ) g ( 4 , 2 * k , i ) = sum4 140 continue g ( 1 , ny + 1 , i ) = 0.0 g ( 3 , ny + 1 , i ) = 0.0 150 continue !$OMP END PARALLEL DO return end !----------------------------------------------------------------------- subroutine WPPFSCT2RM22 ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp , indx & & , indy , kstrt , nvp , nxvh , nyv , kxp2 , kyp , kypd , kxp2d , nxhyd , nxyd ) ! wrapper function for 2 parallel real sine/cosine transforms ! for the momentum flux with dirichlet boundary conditions ! x component has a sine/sine transform in x and y, respectively ! y component has a cosine/cosine transform in x and y, respectively implicit none integer isign , ntpose , mixup , indx , indy , kstrt , nvp , nxvh , nyv integer kxp2 , kyp , kypd , kxp2d , nxhyd , nxyd real f , g , bs , br , ttp complex sctd dimension f ( 2 , 2 * nxvh , kypd ), g ( 2 , nyv , kxp2d ) dimension bs ( 2 , kxp2 + 1 , kyp + 1 ), br ( 2 , kxp2 + 1 , kyp + 1 ) dimension mixup ( nxhyd ), sctd ( nxyd ) ! local data integer nx , ny , kxpi , kypi , ks , kxp2p , kypp , kxb2 , kyb real tf double precision dtime data kxpi , kypi / 1 , 1 / ! calculate range of indices nx = 2 ** indx ny = 2 ** indy ! ks = processor id ks = kstrt - 1 ! kxp2p = actual size used in x direction kxp2p = min ( kxp2 , max ( 0 , nx - kxp2 * ks )) ! kypp = actual size used in y direction kypp = min ( kyp , max ( 0 , ny - kyp * ks )) ! kxb2 = minimum number of processors needed in x direction kxb2 = ( nx - 1 ) / kxp2 + 1 ! kyb = minimum number of processors needed in y direction kyb = ( ny - 1 ) / kyp + 1 ! add extra word for last processor in x if ( ks == ( kxb2 - 1 )) kxp2p = kxp2p + 1 ! add extra word for last processor in y if ( ks == ( kyb - 1 )) kypp = kypp + 1 ! inverse fourier transform if ( isign . lt . 0 ) then ! perform x sine-cosine transform call PPFSCCST2RM22X ( f , isign , mixup , sctd , indx , indy , kstrt , kypi , & & kypp , nxvh , kypd , nxhyd , nxyd ) ! transpose f array to g call PWTIMERA ( - 1 , ttp , dtime ) call PPRNTPOSE ( f , g , bs , br , nx , ny , kxp2 , kyp , kstrt , nvp , 2 , 2 * nxvh , nyv , & & kxp2d , kypd ) call PWTIMERA ( 1 , ttp , dtime ) ! perform y sine-cosine transform call PPFSCSCT2RM22Y ( g , isign , mixup , sctd , indx , indy , kstrt , kxpi , & & kxp2p , nyv , kxp2d , nxhyd , nxyd ) ! transpose g array to f if ( ntpose . eq . 0 ) then call PWTIMERA ( - 1 , tf , dtime ) call PPRNTPOSE ( g , f , br , bs , ny , nx , kyp , kxp2 , kstrt , nvp , 2 , nyv , & & 2 * nxvh , kypd , kxp2d ) call PWTIMERA ( 1 , tf , dtime ) endif ! forward fourier transform else if ( isign . gt . 0 ) then ! transpose f array to g if ( ntpose . eq . 0 ) then call PWTIMERA ( - 1 , tf , dtime ) call PPRNTPOSE ( f , g , bs , br , nx , ny , kxp2 , kyp , kstrt , nvp , 2 , 2 * nxvh , & & nyv , kxp2d , kypd ) call PWTIMERA ( 1 , tf , dtime ) endif ! perform y cosine-sine transform call PPFSCSCT2RM22Y ( g , isign , mixup , sctd , indx , indy , kstrt , kxpi , & & kxp2p , nyv , kxp2d , nxhyd , nxyd ) ! transpose g array to f call PWTIMERA ( - 1 , ttp , dtime ) call PPRNTPOSE ( g , f , br , bs , ny , nx , kyp , kxp2 , kstrt , nvp , 2 , nyv , 2 * nxvh , & & kypd , kxp2d ) call PWTIMERA ( 1 , ttp , dtime ) ! perform y sine-cosine transform call PPFSCCST2RM22X ( f , isign , mixup , sctd , indx , indy , kstrt , kypi , & & kypp , nxvh , kypd , nxhyd , nxyd ) endif if ( ntpose . eq . 0 ) ttp = ttp + tf return end !----------------------------------------------------------------------- subroutine PPFSCCST2RM22X ( f , isign , mixup , sctd , indx , indy , kstrt , kypi , & & kypp , nxvh , kypd , nxhyd , nxyd ) ! this subroutine performs the x part of 2 two dimensional fast real ! sine and cosine transforms and their inverses, for a subset of y, ! using real arithmetic, with OpenMP, ! for data which is distributed in blocks ! x component has a sine transform, y component a cosine transform ! algorithm is described in Numerical Recipies in Fortran, Second Ed., ! by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, ! [Cambridge Univ. Press, 1992], p. 508. ! for isign = (-1,1), input: all, output: f ! approximate flop count: N*(5*log2(N) + 18)/nvp ! where N = (nx/2)*ny ! indx/indy = exponent which determines length in x/y direction, ! where nx=2**indx, ny=2**indy ! if isign = -1, inverse sine-cosine transforms are ! performed ! f(1,n,k) = (1/nx*ny)*sum(f(1,j,k)*sin(pi*n*j/nx)) ! f(2,n,k) = (1/nx*ny)*(.5*f(2,1,k) + ((-1)**n)*f(2,nx+1,k) !              + sum(f(2,j,k)*cos(pi*n*j/nx))) ! if isign = 1, forward sine-cosine transforms are performed ! f(1,j,k) = sum(f(1,n,k)*sin(pi*n*j/nx)) ! f(2,j,k) = 2*(.5*f(2,1,k) + ((-1)**j)*f(2,n+1,k) !              + sum(f(2:3,n,k)*cos(pi*n*j/nx)) ! mixup = array of bit reversed addresses ! sctd = sine/cosine table ! kstrt = starting data block number ! kypi = initial y index used ! kypp = number of y indices used ! nxvh = first dimension of f >= nx/2 + 1 ! kypd = second dimension of f >= kyp + 1 ! nxhyd = maximum of (nx/2,ny) ! nxyd = maximum of (nx,ny) ! written by viktor k. decyk, ucla implicit none integer isign , indx , indy , kstrt , kypi , kypp integer nxvh , kypd , nxhyd , nxyd , mixup real f complex sctd dimension f ( 2 , 2 * nxvh , kypd ) dimension mixup ( nxhyd ), sctd ( nxyd ) ! local data integer indx1 , indx1y , nx , nxh , nxhh , nx3 , ny , nxy , nxhy , ks integer i , j , k , m , km , kmr , nrx , j1 , j2 , ns , ns2 , k1 , k2 , kyps integer nrxb , jj real at1 , at2 , at3 , t2 , t3 , t4 , t5 , t6 , ani complex t1 double precision sum1 , sum2 indx1 = indx - 1 indx1y = max0 ( indx1 , indy ) nx = 2 ** indx nxh = nx / 2 nxhh = nx / 4 nx3 = nx + 3 ny = 2 ** indy nxy = max0 ( nx , ny ) nxhy = 2 ** indx1y ks = kstrt - 1 kyps = kypi + kypp - 1 if ( kstrt . gt . ny ) return if ( isign . eq . 0 ) return ani = 0.5 / ( real ( nx ) * real ( ny )) nrxb = nxhy / nxh nrx = nxy / nxh !$OMP PARALLEL DO !$OMP& PRIVATE(i,j,k,m,jj,ns,ns2,km,kmr,k1,k2,j1,j2,at1,at2,at3,t2,t3,t4 !$OMP& ,t5,t6,t1,sum1,sum2) do 150 i = kypi , kyps ! create auxiliary array in x kmr = nxy / nx sum2 = 0.5 * ( f ( 2 , 1 , i ) - f ( 2 , nx + 1 , i )) do 10 j = 2 , nxh j1 = 1 + kmr * ( j - 1 ) at3 = - aimag ( sctd ( j1 )) at2 = f ( 1 , nx + 2 - j , i ) at1 = f ( 1 , j , i ) + at2 at2 = f ( 1 , j , i ) - at2 at1 = at3 * at1 at2 = 0.5 * at2 f ( 1 , j , i ) = at1 + at2 f ( 1 , nx + 2 - j , i ) = at1 - at2 at2 = f ( 2 , nx + 2 - j , i ) at1 = f ( 2 , j , i ) + at2 at2 = f ( 2 , j , i ) - at2 sum2 = sum2 + real ( sctd ( j1 )) * at2 at2 = at3 * at2 at1 = 0.5 * at1 f ( 2 , j , i ) = at1 - at2 f ( 2 , nx + 2 - j , i ) = at1 + at2 10 continue f ( 1 , 1 , i ) = 0.0 f ( 1 , nxh + 1 , i ) = 2.0 * f ( 1 , nxh + 1 , i ) f ( 2 , 1 , i ) = 0.5 * ( f ( 2 , 1 , i ) + f ( 2 , nx + 1 , i )) f ( 2 , nx + 1 , i ) = sum2 ! bit-reverse array elements in x do 30 j = 1 , nxh j1 = ( mixup ( j ) - 1 ) / nrxb + 1 if ( j . lt . j1 ) then do 20 jj = 1 , 2 t2 = f ( jj , 2 * j1 - 1 , i ) t3 = f ( jj , 2 * j1 , i ) f ( jj , 2 * j1 - 1 , i ) = f ( jj , 2 * j - 1 , i ) f ( jj , 2 * j1 , i ) = f ( jj , 2 * j , i ) f ( jj , 2 * j - 1 , i ) = t2 f ( jj , 2 * j , i ) = t3 20 continue endif 30 continue ! then transform in x do 70 m = 1 , indx1 ns = 2 ** ( m - 1 ) ns2 = ns + ns km = nxhh / ns kmr = 2 * km * nrx do 60 k = 1 , km k1 = ns2 * ( k - 1 ) k2 = k1 + ns do 50 j = 1 , ns j1 = j + k1 j2 = j + k2 t1 = sctd ( 1 + kmr * ( j - 1 )) do 40 jj = 1 , 2 t2 = real ( t1 ) * f ( jj , 2 * j2 - 1 , i ) - aimag ( t1 ) * f ( jj , 2 * j2 , i ) t3 = aimag ( t1 ) * f ( jj , 2 * j2 - 1 , i ) + real ( t1 ) * f ( jj , 2 * j2 , i ) f ( jj , 2 * j2 - 1 , i ) = f ( jj , 2 * j1 - 1 , i ) - t2 f ( jj , 2 * j2 , i ) = f ( jj , 2 * j1 , i ) - t3 f ( jj , 2 * j1 - 1 , i ) = f ( jj , 2 * j1 - 1 , i ) + t2 f ( jj , 2 * j1 , i ) = f ( jj , 2 * j1 , i ) + t3 40 continue 50 continue 60 continue 70 continue ! unscramble coefficients and normalize ! inverse fourier transform if ( isign . lt . 0 ) then kmr = nxy / nxh do 90 j = 2 , nxhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( j - 1 ))), - real ( sctd ( 1 + kmr * ( j - 1 )))) do 80 jj = 1 , 2 t4 = f ( jj , nx3 - 2 * j , i ) t5 = - f ( jj , nx3 - 2 * j + 1 , i ) t2 = f ( jj , 2 * j - 1 , i ) + t4 t3 = f ( jj , 2 * j , i ) + t5 t6 = f ( jj , 2 * j - 1 , i ) - t4 t5 = f ( jj , 2 * j , i ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) f ( jj , 2 * j - 1 , i ) = ani * ( t2 + t4 ) f ( jj , 2 * j , i ) = ani * ( t3 + t5 ) f ( jj , nx3 - 2 * j , i ) = ani * ( t2 - t4 ) f ( jj , nx3 - 2 * j + 1 , i ) = ani * ( t5 - t3 ) 80 continue 90 continue do 100 jj = 1 , 2 f ( jj , nxh + 1 , i ) = 2.0 * ani * f ( jj , nxh + 1 , i ) f ( jj , nxh + 2 , i ) = - 2.0 * ani * f ( jj , nxh + 2 , i ) t2 = 2.0 * ani * ( f ( jj , 1 , i ) + f ( jj , 2 , i )) f ( jj , 2 , i ) = 2.0 * ani * ( f ( jj , 1 , i ) - f ( jj , 2 , i )) f ( jj , 1 , i ) = t2 f ( jj , nx + 1 , i ) = 2.0 * ani * f ( jj , nx + 1 , i ) 100 continue ! forward fourier transform else if ( isign . gt . 0 ) then kmr = nxy / nxh do 120 j = 2 , nxhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( j - 1 ))), - real ( sctd ( 1 + kmr * ( j - 1 )))) do 110 jj = 1 , 2 t4 = f ( jj , nx3 - 2 * j , i ) t5 = - f ( jj , nx3 - 2 * j + 1 , i ) t2 = f ( jj , 2 * j - 1 , i ) + t4 t3 = f ( jj , 2 * j , i ) + t5 t6 = f ( jj , 2 * j - 1 , i ) - t4 t5 = f ( jj , 2 * j , i ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) f ( jj , 2 * j - 1 , i ) = t2 + t4 f ( jj , 2 * j , i ) = t3 + t5 f ( jj , nx3 - 2 * j , i ) = t2 - t4 f ( jj , nx3 - 2 * j + 1 , i ) = t5 - t3 110 continue 120 continue do 130 jj = 1 , 2 f ( jj , nxh + 1 , i ) = 2.0 * f ( jj , nxh + 1 , i ) f ( jj , nxh + 2 , i ) = - 2.0 * f ( jj , nxh + 2 , i ) t2 = 2.0 * ( f ( jj , 1 , i ) + f ( jj , 2 , i )) f ( jj , 2 , i ) = 2.0 * ( f ( jj , 1 , i ) - f ( jj , 2 , i )) f ( jj , 1 , i ) = t2 f ( jj , nx + 1 , i ) = 2.0 * f ( jj , nx + 1 , i ) 130 continue endif ! perform recursion for cosine-sine transform sum1 = 0.5 * f ( 1 , 1 , i ) f ( 1 , 1 , i ) = 0.0 f ( 1 , 2 , i ) = sum1 sum2 = f ( 2 , nx + 1 , i ) f ( 2 , nx + 1 , i ) = f ( 2 , 2 , i ) f ( 2 , 2 , i ) = sum2 do 140 j = 2 , nxh sum1 = sum1 + f ( 1 , 2 * j - 1 , i ) f ( 1 , 2 * j - 1 , i ) = - f ( 1 , 2 * j , i ) f ( 1 , 2 * j , i ) = sum1 sum2 = sum2 - f ( 2 , 2 * j , i ) f ( 2 , 2 * j , i ) = sum2 140 continue f ( 1 , nx + 1 , i ) = 0.0 150 continue !$OMP END PARALLEL DO return end !----------------------------------------------------------------------- subroutine PPFSCSCT2RM22Y ( g , isign , mixup , sctd , indx , indy , kstrt , kxpi , & & kxpp , nyv , kxpd , nxhyd , nxyd ) ! this subroutine performs the y part of 2 two dimensional fast real ! sine and cosine transforms and their inverses, for a subset of x, ! using real arithmetic, with OpenMP, ! for data which is distributed in blocks ! x component has a sine transform, y component a cosine transform ! algorithm is described in Numerical Recipies in Fortran, Second Ed., ! by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, ! [Cambridge Univ. Press, 1992], p. 508. ! for isign = (-1,1), input: all, output: f ! approximate flop count: N*(5*log2(N) + 18)/nvp ! where N = (nx/2)*ny ! indx/indy = exponent which determines length in x/y direction, ! where nx=2**indx, ny=2**indy ! if isign = -1, inverse sine-cosine transform are performed ! g(1,m,n) = sum(g(1,k,n)*sin(pi*m*k/ny)) ! g(2,m,n) = (.5*g(2,1,n) + ((-1)**m)*g(2,ny+1,n) !              + sum(g(2,k,n)*cos(pi*m*k/ny)) ! if isign = 1, forward sine-cosine transform are performed ! g(1,k,n) = sum(g(1,m,n)*sin(pi*m*k/ny)) ! g(2,k,n) = 2*(.5*g(2,1,n) + ((-1)**m)*g(2,ny+1,n) !              + sum(g(2,m,n)*cos(pi*m*k/ny)) ! mixup = array of bit reversed addresses ! sctd = sine/cosine table ! kstrt = starting data block number ! kxpi = initial x index used ! kxpp = number of x indices used ! nyv = first dimension of g >= ny + 1 ! kxpd = second dimension of g >= kxp + 1 ! nxhyd = maximum of (nx/2,ny) ! nxyd = maximum of (nx,ny) ! written by viktor k. decyk, ucla implicit none integer isign , indx , indy , kstrt , kxpi , kxpp integer nyv , kxpd , nxhyd , nxyd , mixup real g complex sctd dimension g ( 2 , nyv , kxpd ) dimension mixup ( nxhyd ), sctd ( nxyd ) ! local data integer indx1 , indy1 , indx1y , nx , ny , nyh , nyhh , ny3 , nxy , nxhy integer i , j , k , m , ks , km , kmr , nry , j1 , j2 , ns , ns2 , k1 , k2 integer kxps , nryb , jj real at1 , at2 , at3 , t2 , t3 , t4 , t5 , t6 complex t1 double precision sum1 , sum2 indx1 = indx - 1 indy1 = indy - 1 indx1y = max0 ( indx1 , indy ) nx = 2 ** indx ny = 2 ** indy nyh = ny / 2 nyhh = ny / 4 ny3 = ny + 3 nxy = max0 ( nx , ny ) nxhy = 2 ** indx1y ks = kstrt - 1 kxps = kxpi + kxpp - 1 if ( kstrt . gt . nx ) return if ( isign . eq . 0 ) return nryb = nxhy / nyh nry = nxy / nyh !$OMP PARALLEL DO !$OMP& PRIVATE(i,j,k,m,jj,ns,ns2,km,kmr,k1,k2,j1,j2,at1,at2,at3,t2,t3,t4 !$OMP& ,t5,t6,t1,sum1,sum2) do 150 i = kxpi , kxps ! create auxiliary array in y kmr = nxy / ny sum2 = 0.5 * ( g ( 2 , 1 , i ) - g ( 2 , ny + 1 , i )) do 10 k = 2 , nyh k1 = 1 + kmr * ( k - 1 ) at3 = - aimag ( sctd ( k1 )) at2 = g ( 1 , ny + 2 - k , i ) at1 = g ( 1 , k , i ) + at2 at2 = g ( 1 , k , i ) - at2 at1 = at3 * at1 at2 = 0.5 * at2 g ( 1 , k , i ) = at1 + at2 g ( 1 , ny + 2 - k , i ) = at1 - at2 at2 = g ( 2 , ny + 2 - k , i ) at1 = g ( 2 , k , i ) + at2 at2 = g ( 2 , k , i ) - at2 sum2 = sum2 + real ( sctd ( k1 )) * at2 at2 = at3 * at2 at1 = 0.5 * at1 g ( 2 , k , i ) = at1 - at2 g ( 2 , ny + 2 - k , i ) = at1 + at2 10 continue g ( 1 , 1 , i ) = 0.0 g ( 1 , nyh + 1 , i ) = 2.0 * g ( 1 , nyh + 1 , i ) g ( 2 , 1 , i ) = 0.5 * ( g ( 2 , 1 , i ) + g ( 2 , ny + 1 , i )) g ( 2 , ny + 1 , i ) = sum2 ! bit-reverse array elements in y do 30 k = 1 , nyh k1 = ( mixup ( k ) - 1 ) / nryb + 1 if ( k . lt . k1 ) then do 20 jj = 1 , 2 t2 = g ( jj , 2 * k1 - 1 , i ) t3 = g ( jj , 2 * k1 , i ) g ( jj , 2 * k1 - 1 , i ) = g ( jj , 2 * k - 1 , i ) g ( jj , 2 * k1 , i ) = g ( jj , 2 * k , i ) g ( jj , 2 * k - 1 , i ) = t2 g ( jj , 2 * k , i ) = t3 20 continue endif 30 continue ! then transform in y do 70 m = 1 , indy1 ns = 2 ** ( m - 1 ) ns2 = ns + ns km = nyhh / ns kmr = 2 * km * nry do 60 k = 1 , km k1 = ns2 * ( k - 1 ) k2 = k1 + ns do 50 j = 1 , ns j1 = j + k1 j2 = j + k2 t1 = sctd ( 1 + kmr * ( j - 1 )) do 40 jj = 1 , 2 t2 = real ( t1 ) * g ( jj , 2 * j2 - 1 , i ) - aimag ( t1 ) * g ( jj , 2 * j2 , i ) t3 = aimag ( t1 ) * g ( jj , 2 * j2 - 1 , i ) + real ( t1 ) * g ( jj , 2 * j2 , i ) g ( jj , 2 * j2 - 1 , i ) = g ( jj , 2 * j1 - 1 , i ) - t2 g ( jj , 2 * j2 , i ) = g ( jj , 2 * j1 , i ) - t3 g ( jj , 2 * j1 - 1 , i ) = g ( jj , 2 * j1 - 1 , i ) + t2 g ( jj , 2 * j1 , i ) = g ( jj , 2 * j1 , i ) + t3 40 continue 50 continue 60 continue 70 continue ! unscramble coefficients and normalize ! inverse fourier transform if ( isign . lt . 0 ) then kmr = nxy / nyh do 90 k = 2 , nyhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( k - 1 ))), - real ( sctd ( 1 + kmr * ( k - 1 )))) do 80 jj = 1 , 2 t4 = g ( jj , ny3 - 2 * k , i ) t5 = - g ( jj , ny3 - 2 * k + 1 , i ) t2 = g ( jj , 2 * k - 1 , i ) + t4 t3 = g ( jj , 2 * k , i ) + t5 t6 = g ( jj , 2 * k - 1 , i ) - t4 t5 = g ( jj , 2 * k , i ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) g ( jj , 2 * k - 1 , i ) = 0.5 * ( t2 + t4 ) g ( jj , 2 * k , i ) = 0.5 * ( t3 + t5 ) g ( jj , ny3 - 2 * k , i ) = 0.5 * ( t2 - t4 ) g ( jj , ny3 - 2 * k + 1 , i ) = 0.5 * ( t5 - t3 ) 80 continue 90 continue do 100 jj = 1 , 2 g ( jj , nyh + 1 , i ) = g ( jj , nyh + 1 , i ) g ( jj , nyh + 2 , i ) = - g ( jj , nyh + 2 , i ) t2 = g ( jj , 1 , i ) + g ( jj , 2 , i ) g ( jj , 2 , i ) = g ( jj , 1 , i ) - g ( jj , 2 , i ) g ( jj , 1 , i ) = t2 g ( jj , ny + 1 , i ) = g ( jj , ny + 1 , i ) 100 continue ! forward fourier transform else if ( isign . gt . 0 ) then kmr = nxy / nyh do 120 k = 2 , nyhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( k - 1 ))), - real ( sctd ( 1 + kmr * ( k - 1 )))) do 110 jj = 1 , 2 t4 = g ( jj , ny3 - 2 * k , i ) t5 = - g ( jj , ny3 - 2 * k + 1 , i ) t2 = g ( jj , 2 * k - 1 , i ) + t4 t3 = g ( jj , 2 * k , i ) + t5 t6 = g ( jj , 2 * k - 1 , i ) - t4 t5 = g ( jj , 2 * k , i ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) g ( jj , 2 * k - 1 , i ) = t2 + t4 g ( jj , 2 * k , i ) = t3 + t5 g ( jj , ny3 - 2 * k , i ) = t2 - t4 g ( jj , ny3 - 2 * k + 1 , i ) = t5 - t3 110 continue 120 continue do 130 jj = 1 , 2 g ( jj , nyh + 1 , i ) = 2.0 * g ( jj , nyh + 1 , i ) g ( jj , nyh + 2 , i ) = - 2.0 * g ( jj , nyh + 2 , i ) t2 = 2.0 * ( g ( jj , 1 , i ) + g ( jj , 2 , i )) g ( jj , 2 , i ) = 2.0 * ( g ( jj , 1 , i ) - g ( jj , 2 , i )) g ( jj , 1 , i ) = t2 g ( jj , ny + 1 , i ) = 2.0 * g ( jj , ny + 1 , i ) 130 continue endif ! perform recursion for sine-cosine transform sum1 = 0.5 * g ( 1 , 1 , i ) g ( 1 , 1 , i ) = 0.0 g ( 1 , 2 , i ) = sum1 sum2 = g ( 2 , ny + 1 , i ) g ( 2 , ny + 1 , i ) = g ( 2 , 2 , i ) g ( 2 , 2 , i ) = sum2 do 140 k = 2 , nyh sum1 = sum1 + g ( 1 , 2 * k - 1 , i ) g ( 1 , 2 * k - 1 , i ) = - g ( 1 , 2 * k , i ) g ( 1 , 2 * k , i ) = sum1 sum2 = sum2 - g ( 2 , 2 * k , i ) g ( 2 , 2 * k , i ) = sum2 140 continue g ( 1 , ny + 1 , i ) = 0.0 150 continue !$OMP END PARALLEL DO return end !----------------------------------------------------------------------- subroutine WPPFSST2RM23 ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp , indx & & , indy , kstrt , nvp , nxvh , nyv , kxp2 , kyp , kypd , kxp2d , nxhyd , nxyd ) ! wrapper function for 3 parallel real sine transforms ! x/y component has a sine/sine transform in x and y, respectively ! z component has a cosine/cosine transform in x and y, respectively implicit none integer isign , ntpose , mixup , indx , indy , kstrt , nvp , nxvh , nyv integer kxp2 , kyp , kypd , kxp2d , nxhyd , nxyd real f , g , bs , br , ttp complex sctd dimension f ( 3 , 2 * nxvh , kypd ), g ( 3 , nyv , kxp2d ) dimension bs ( 3 , kxp2 + 1 , kyp + 1 ), br ( 3 , kxp2 + 1 , kyp + 1 ) dimension mixup ( nxhyd ), sctd ( nxyd ) ! local data integer nx , ny , kxpi , kypi , ks , kxp2p , kypp , kxb2 , kyb real tf double precision dtime data kxpi , kypi / 1 , 1 / ! calculate range of indices nx = 2 ** indx ny = 2 ** indy ! ks = processor id ks = kstrt - 1 ! kxp2p = actual size used in x direction kxp2p = min ( kxp2 , max ( 0 , nx - kxp2 * ks )) ! kypp = actual size used in y direction kypp = min ( kyp , max ( 0 , ny - kyp * ks )) ! kxb2 = minimum number of processors needed in x direction kxb2 = ( nx - 1 ) / kxp2 + 1 ! kyb = minimum number of processors needed in y direction kyb = ( ny - 1 ) / kyp + 1 ! add extra word for last processor in x if ( ks == ( kxb2 - 1 )) kxp2p = kxp2p + 1 ! add extra word for last processor in y if ( ks == ( kyb - 1 )) kypp = kypp + 1 ! inverse fourier transform if ( isign . lt . 0 ) then ! perform x sine transforms call PPFSSCT2RM23X ( f , isign , mixup , sctd , indx , indy , kstrt , kypi , kypp & & , nxvh , kypd , nxhyd , nxyd ) ! transpose f array to g call PWTIMERA ( - 1 , ttp , dtime ) call PPRNTPOSE ( f , g , bs , br , nx , ny , kxp2 , kyp , kstrt , nvp , 3 , 2 * nxvh , nyv , & & kxp2d , kypd ) call PWTIMERA ( 1 , ttp , dtime ) ! perform y sine transforms call PPFSSCT2RM23Y ( g , isign , mixup , sctd , indx , indy , kstrt , kxpi , & & kxp2p , nyv , kxp2d , nxhyd , nxyd ) ! transpose g array to f if ( ntpose . eq . 0 ) then call PWTIMERA ( - 1 , tf , dtime ) call PPRNTPOSE ( g , f , br , bs , ny , nx , kyp , kxp2 , kstrt , nvp , 3 , nyv , & & 2 * nxvh , kypd , kxp2d ) call PWTIMERA ( 1 , tf , dtime ) endif ! forward fourier transform else if ( isign . gt . 0 ) then ! transpose f array to g if ( ntpose . eq . 0 ) then call PWTIMERA ( - 1 , tf , dtime ) call PPRNTPOSE ( f , g , bs , br , nx , ny , kxp2 , kyp , kstrt , nvp , 3 , 2 * nxvh , & & nyv , kxp2d , kypd ) call PWTIMERA ( 1 , tf , dtime ) endif ! perform y sine transforms call PPFSSCT2RM23Y ( g , isign , mixup , sctd , indx , indy , kstrt , kxpi , & & kxp2p , nyv , kxp2d , nxhyd , nxyd ) ! transpose g array to f call PWTIMERA ( - 1 , ttp , dtime ) call PPRNTPOSE ( g , f , br , bs , ny , nx , kyp , kxp2 , kstrt , nvp , 3 , nyv , 2 * nxvh , & & kypd , kxp2d ) call PWTIMERA ( 1 , ttp , dtime ) ! perform x sine transforms call PPFSSCT2RM23X ( f , isign , mixup , sctd , indx , indy , kstrt , kypi , kypp & & , nxvh , kypd , nxhyd , nxyd ) endif if ( ntpose . eq . 0 ) ttp = ttp + tf return end !----------------------------------------------------------------------- subroutine PPFSSCT2RM23X ( f , isign , mixup , sctd , indx , indy , kstrt , kypi , & & kypp , nxvh , kypd , nxhyd , nxyd ) ! this subroutine performs the x part of 3 two dimensional fast real ! sine transforms and their inverses, for a subset of y, ! using real arithmetic, with OpenMP, ! for data which is distributed in blocks ! x/y component has a sine transform, z component a cosine transform ! algorithm is described in Numerical Recipies in Fortran, Second Ed., ! by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, ! [Cambridge Univ. Press, 1992], p. 508. ! for isign = (-1,1), input: all, output: f ! approximate flop count: N*(5*log2(N) + 18)/nvp ! where N = (nx/2)*ny ! indx/indy = exponent which determines length in x/y direction, ! where nx=2**indx, ny=2**indy ! if isign = -1, inverse sine-sine-cosine transforms are performed ! f(1:2,n,k) = (1/nx*ny)*sum(f(2:3,j,k)*sin(pi*n*j/nx)) ! f(3,n,k) = (1/nx*ny)*(.5*f(1,1,k) + ((-1)**n)*f(1,nx+1,k) !              + sum(f(1,j,k)*cos(pi*n*j/nx))) ! if isign = 1, forward sine-sine-cosine transforms are performed ! f(1:2,j,k) = sum(f(2:3,n,k)*sin(pi*n*j/nx)) ! f(3,j,k) = 2*(.5*f(1,1,k) + ((-1)**j)*f(1,n+1,k) !              + sum(f(1,n,k)*cos(pi*n*j/nx)) ! mixup = array of bit reversed addresses ! sctd = sine/cosine table ! kstrt = starting data block number ! kypi = initial y index used ! kypp = number of y indices used ! nxvh = first dimension of f >= nx/2 + 1 ! kypd = second dimension of f >= kyp + 1 ! nxhyd = maximum of (nx/2,ny) ! nxyd = maximum of (nx,ny) ! written by viktor k. decyk, ucla implicit none integer isign , indx , indy , kstrt , kypi , kypp integer nxvh , kypd , nxhyd , nxyd , mixup real f complex sctd dimension f ( 3 , 2 * nxvh , kypd ) dimension mixup ( nxhyd ), sctd ( nxyd ) ! local data integer indx1 , indx1y , nx , nxh , nxhh , nx3 , ny , nxy , nxhy , ks integer i , j , k , m , km , kmr , nrx , j1 , j2 , ns , ns2 , k1 , k2 , kyps integer nrxb , jj real at1 , at2 , at3 , t2 , t3 , t4 , t5 , t6 , ani complex t1 double precision sum1 , sum2 , sum3 indx1 = indx - 1 indx1y = max0 ( indx1 , indy ) nx = 2 ** indx nxh = nx / 2 nxhh = nx / 4 nx3 = nx + 3 ny = 2 ** indy nxy = max0 ( nx , ny ) nxhy = 2 ** indx1y ks = kstrt - 1 kyps = kypi + kypp - 1 if ( kstrt . gt . ny ) return if ( isign . eq . 0 ) return ani = 0.5 / ( real ( nx ) * real ( ny )) nrxb = nxhy / nxh nrx = nxy / nxh !$OMP PARALLEL DO !$OMP& PRIVATE(i,j,k,m,jj,ns,ns2,km,kmr,k1,k2,j1,j2,at1,at2,at3,t2,t3,t4 !$OMP& ,t5,t6,t1,sum1,sum2,sum3) do 150 i = kypi , kyps ! create auxiliary array in x kmr = nxy / nx sum3 = 0.5 * ( f ( 3 , 1 , i ) - f ( 3 , nx + 1 , i )) do 10 j = 2 , nxh j1 = 1 + kmr * ( j - 1 ) at3 = - aimag ( sctd ( j1 )) at2 = f ( 1 , nx + 2 - j , i ) at1 = f ( 1 , j , i ) + at2 at2 = f ( 1 , j , i ) - at2 at1 = at3 * at1 at2 = 0.5 * at2 f ( 1 , j , i ) = at1 + at2 f ( 1 , nx + 2 - j , i ) = at1 - at2 at2 = f ( 2 , nx + 2 - j , i ) at1 = f ( 2 , j , i ) + at2 at2 = f ( 2 , j , i ) - at2 at1 = at3 * at1 at2 = 0.5 * at2 f ( 2 , j , i ) = at1 + at2 f ( 2 , nx + 2 - j , i ) = at1 - at2 at2 = f ( 3 , nx + 2 - j , i ) at1 = f ( 3 , j , i ) + at2 at2 = f ( 3 , j , i ) - at2 sum3 = sum3 + real ( sctd ( j1 )) * at2 at2 = at3 * at2 at1 = 0.5 * at1 f ( 3 , j , i ) = at1 - at2 f ( 3 , nx + 2 - j , i ) = at1 + at2 10 continue f ( 1 , 1 , i ) = 0.0 f ( 1 , nxh + 1 , i ) = 2.0 * f ( 1 , nxh + 1 , i ) f ( 2 , 1 , i ) = 0.0 f ( 2 , nxh + 1 , i ) = 2.0 * f ( 2 , nxh + 1 , i ) f ( 3 , 1 , i ) = 0.5 * ( f ( 3 , 1 , i ) + f ( 3 , nx + 1 , i )) f ( 3 , nx + 1 , i ) = sum3 ! bit-reverse array elements in x do 30 j = 1 , nxh j1 = ( mixup ( j ) - 1 ) / nrxb + 1 if ( j . lt . j1 ) then do 20 jj = 1 , 3 t2 = f ( jj , 2 * j1 - 1 , i ) t3 = f ( jj , 2 * j1 , i ) f ( jj , 2 * j1 - 1 , i ) = f ( jj , 2 * j - 1 , i ) f ( jj , 2 * j1 , i ) = f ( jj , 2 * j , i ) f ( jj , 2 * j - 1 , i ) = t2 f ( jj , 2 * j , i ) = t3 20 continue endif 30 continue ! then transform in x do 70 m = 1 , indx1 ns = 2 ** ( m - 1 ) ns2 = ns + ns km = nxhh / ns kmr = 2 * km * nrx do 60 k = 1 , km k1 = ns2 * ( k - 1 ) k2 = k1 + ns do 50 j = 1 , ns j1 = j + k1 j2 = j + k2 t1 = sctd ( 1 + kmr * ( j - 1 )) do 40 jj = 1 , 3 t2 = real ( t1 ) * f ( jj , 2 * j2 - 1 , i ) - aimag ( t1 ) * f ( jj , 2 * j2 , i ) t3 = aimag ( t1 ) * f ( jj , 2 * j2 - 1 , i ) + real ( t1 ) * f ( jj , 2 * j2 , i ) f ( jj , 2 * j2 - 1 , i ) = f ( jj , 2 * j1 - 1 , i ) - t2 f ( jj , 2 * j2 , i ) = f ( jj , 2 * j1 , i ) - t3 f ( jj , 2 * j1 - 1 , i ) = f ( jj , 2 * j1 - 1 , i ) + t2 f ( jj , 2 * j1 , i ) = f ( jj , 2 * j1 , i ) + t3 40 continue 50 continue 60 continue 70 continue ! unscramble coefficients and normalize ! inverse fourier transform if ( isign . lt . 0 ) then kmr = nxy / nxh do 90 j = 2 , nxhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( j - 1 ))), - real ( sctd ( 1 + kmr * ( j - 1 )))) do 80 jj = 1 , 3 t4 = f ( jj , nx3 - 2 * j , i ) t5 = - f ( jj , nx3 - 2 * j + 1 , i ) t2 = f ( jj , 2 * j - 1 , i ) + t4 t3 = f ( jj , 2 * j , i ) + t5 t6 = f ( jj , 2 * j - 1 , i ) - t4 t5 = f ( jj , 2 * j , i ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) f ( jj , 2 * j - 1 , i ) = ani * ( t2 + t4 ) f ( jj , 2 * j , i ) = ani * ( t3 + t5 ) f ( jj , nx3 - 2 * j , i ) = ani * ( t2 - t4 ) f ( jj , nx3 - 2 * j + 1 , i ) = ani * ( t5 - t3 ) 80 continue 90 continue do 100 jj = 1 , 3 f ( jj , nxh + 1 , i ) = 2.0 * ani * f ( jj , nxh + 1 , i ) f ( jj , nxh + 2 , i ) = - 2.0 * ani * f ( jj , nxh + 2 , i ) t2 = 2.0 * ani * ( f ( jj , 1 , i ) + f ( jj , 2 , i )) f ( jj , 2 , i ) = 2.0 * ani * ( f ( jj , 1 , i ) - f ( jj , 2 , i )) f ( jj , 1 , i ) = t2 f ( jj , nx + 1 , i ) = 2.0 * ani * f ( jj , nx + 1 , i ) 100 continue ! forward fourier transform else if ( isign . gt . 0 ) then kmr = nxy / nxh do 120 j = 2 , nxhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( j - 1 ))), - real ( sctd ( 1 + kmr * ( j - 1 )))) do 110 jj = 1 , 3 t4 = f ( jj , nx3 - 2 * j , i ) t5 = - f ( jj , nx3 - 2 * j + 1 , i ) t2 = f ( jj , 2 * j - 1 , i ) + t4 t3 = f ( jj , 2 * j , i ) + t5 t6 = f ( jj , 2 * j - 1 , i ) - t4 t5 = f ( jj , 2 * j , i ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) f ( jj , 2 * j - 1 , i ) = t2 + t4 f ( jj , 2 * j , i ) = t3 + t5 f ( jj , nx3 - 2 * j , i ) = t2 - t4 f ( jj , nx3 - 2 * j + 1 , i ) = t5 - t3 110 continue 120 continue do 130 jj = 1 , 3 f ( jj , nxh + 1 , i ) = 2.0 * f ( jj , nxh + 1 , i ) f ( jj , nxh + 2 , i ) = - 2.0 * f ( jj , nxh + 2 , i ) t2 = 2.0 * ( f ( jj , 1 , i ) + f ( jj , 2 , i )) f ( jj , 2 , i ) = 2.0 * ( f ( jj , 1 , i ) - f ( jj , 2 , i )) f ( jj , 1 , i ) = t2 f ( jj , nx + 1 , i ) = 2.0 * f ( jj , nx + 1 , i ) 130 continue endif ! perform recursion for sine-sine transform sum1 = 0.5 * f ( 1 , 1 , i ) f ( 1 , 1 , i ) = 0.0 f ( 1 , 2 , i ) = sum1 sum2 = 0.5 * f ( 2 , 1 , i ) f ( 2 , 1 , i ) = 0.0 f ( 2 , 2 , i ) = sum2 sum3 = f ( 3 , nx + 1 , i ) f ( 3 , nx + 1 , i ) = f ( 3 , 2 , i ) f ( 3 , 2 , i ) = sum3 do 140 j = 2 , nxh sum1 = sum1 + f ( 1 , 2 * j - 1 , i ) f ( 1 , 2 * j - 1 , i ) = - f ( 1 , 2 * j , i ) f ( 1 , 2 * j , i ) = sum1 sum2 = sum2 + f ( 2 , 2 * j - 1 , i ) f ( 2 , 2 * j - 1 , i ) = - f ( 2 , 2 * j , i ) f ( 2 , 2 * j , i ) = sum2 sum3 = sum3 - f ( 3 , 2 * j , i ) f ( 3 , 2 * j , i ) = sum3 140 continue f ( 1 , nx + 1 , i ) = 0.0 f ( 2 , nx + 1 , i ) = 0.0 150 continue !$OMP END PARALLEL DO return end !----------------------------------------------------------------------- subroutine PPFSSCT2RM23Y ( g , isign , mixup , sctd , indx , indy , kstrt , kxpi , & & kxpp , nyv , kxpd , nxhyd , nxyd ) ! this subroutine performs the y part of 3 two dimensional fast real ! sine transforms and their inverses, for a subset of x, ! using real arithmetic, with OpenMP, ! for data which is distributed in blocks ! x/y component has a sine transform, z component a cosine transform ! algorithm is described in Numerical Recipies in Fortran, Second Ed., ! by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, ! [Cambridge Univ. Press, 1992], p. 508. ! for isign = (-1,1), input: all, output: f ! approximate flop count: N*(5*log2(N) + 18)/nvp ! where N = (nx/2)*ny ! indx/indy = exponent which determines length in x/y direction, ! where nx=2**indx, ny=2**indy ! if isign = -1, inverse sine-sine-cosine transform are performed ! g(1:2,m,n) = sum(g(1:2,k,n)*sin(pi*m*k/ny)) ! g(3,m,n) = (.5*g(3,1,n) + ((-1)**m)*g(3,ny+1,n) !              + sum(g(3,k,n)*cos(pi*m*k/ny)) ! if isign = 1, a forward sine-sine-cosine transforms are performed ! g(1:2,k,n) = sum(g(1:2,m,n)*sin(pi*m*k/ny)) ! g(3,k,n) = 2*(.5*g(3,1,n) + ((-1)**m)*g(3,ny+1,n) !              + sum(g(2,m,n)*cos(pi*m*k/ny)) ! mixup = array of bit reversed addresses ! sctd = sine/cosine table ! kstrt = starting data block number ! kxpi = initial x index used ! kxpp = number of x indices used ! nyv = first dimension of g >= ny + 1 ! kxpd = second dimension of g >= kxp + 1 ! nxhyd = maximum of (nx/2,ny) ! nxyd = maximum of (nx,ny) ! written by viktor k. decyk, ucla implicit none integer isign , indx , indy , kstrt , kxpi , kxpp integer nyv , kxpd , nxhyd , nxyd , mixup real g complex sctd dimension g ( 3 , nyv , kxpd ) dimension mixup ( nxhyd ), sctd ( nxyd ) ! local data integer indx1 , indy1 , indx1y , nx , ny , nyh , nyhh , ny3 , nxy , nxhy integer i , j , k , m , ks , km , kmr , nry , j1 , j2 , ns , ns2 , k1 , k2 integer kxps , nryb , jj real at1 , at2 , at3 , t2 , t3 , t4 , t5 , t6 complex t1 double precision sum1 , sum2 , sum3 indx1 = indx - 1 indy1 = indy - 1 indx1y = max0 ( indx1 , indy ) nx = 2 ** indx ny = 2 ** indy nyh = ny / 2 nyhh = ny / 4 ny3 = ny + 3 nxy = max0 ( nx , ny ) nxhy = 2 ** indx1y ks = kstrt - 1 kxps = kxpi + kxpp - 1 if ( kstrt . gt . nx ) return if ( isign . eq . 0 ) return nryb = nxhy / nyh nry = nxy / nyh !$OMP PARALLEL DO !$OMP& PRIVATE(i,j,k,m,jj,ns,ns2,km,kmr,k1,k2,j1,j2,at1,at2,at3,t2,t3,t4 !$OMP& ,t5,t6,t1,sum1,sum2,sum3) do 150 i = kxpi , kxps ! create auxiliary array in y kmr = nxy / ny sum3 = 0.5 * ( g ( 3 , 1 , i ) - g ( 3 , ny + 1 , i )) do 10 k = 2 , nyh k1 = 1 + kmr * ( k - 1 ) at3 = - aimag ( sctd ( k1 )) at2 = g ( 1 , ny + 2 - k , i ) at1 = g ( 1 , k , i ) + at2 at2 = g ( 1 , k , i ) - at2 at1 = at3 * at1 at2 = 0.5 * at2 g ( 1 , k , i ) = at1 + at2 g ( 1 , ny + 2 - k , i ) = at1 - at2 at2 = g ( 2 , ny + 2 - k , i ) at1 = g ( 2 , k , i ) + at2 at2 = g ( 2 , k , i ) - at2 at1 = at3 * at1 at2 = 0.5 * at2 g ( 2 , k , i ) = at1 + at2 g ( 2 , ny + 2 - k , i ) = at1 - at2 at2 = g ( 3 , ny + 2 - k , i ) at1 = g ( 3 , k , i ) + at2 at2 = g ( 3 , k , i ) - at2 sum3 = sum3 + real ( sctd ( k1 )) * at2 at2 = at3 * at2 at1 = 0.5 * at1 g ( 3 , k , i ) = at1 - at2 g ( 3 , ny + 2 - k , i ) = at1 + at2 10 continue g ( 1 , 1 , i ) = 0.0 g ( 1 , nyh + 1 , i ) = 2.0 * g ( 1 , nyh + 1 , i ) g ( 2 , 1 , i ) = 0.0 g ( 2 , nyh + 1 , i ) = 2.0 * g ( 2 , nyh + 1 , i ) g ( 3 , 1 , i ) = 0.5 * ( g ( 3 , 1 , i ) + g ( 3 , ny + 1 , i )) g ( 3 , ny + 1 , i ) = sum3 ! bit-reverse array elements in y do 30 k = 1 , nyh k1 = ( mixup ( k ) - 1 ) / nryb + 1 if ( k . lt . k1 ) then do 20 jj = 1 , 3 t2 = g ( jj , 2 * k1 - 1 , i ) t3 = g ( jj , 2 * k1 , i ) g ( jj , 2 * k1 - 1 , i ) = g ( jj , 2 * k - 1 , i ) g ( jj , 2 * k1 , i ) = g ( jj , 2 * k , i ) g ( jj , 2 * k - 1 , i ) = t2 g ( jj , 2 * k , i ) = t3 20 continue endif 30 continue ! then transform in y do 70 m = 1 , indy1 ns = 2 ** ( m - 1 ) ns2 = ns + ns km = nyhh / ns kmr = 2 * km * nry do 60 k = 1 , km k1 = ns2 * ( k - 1 ) k2 = k1 + ns do 50 j = 1 , ns j1 = j + k1 j2 = j + k2 t1 = sctd ( 1 + kmr * ( j - 1 )) do 40 jj = 1 , 3 t2 = real ( t1 ) * g ( jj , 2 * j2 - 1 , i ) - aimag ( t1 ) * g ( jj , 2 * j2 , i ) t3 = aimag ( t1 ) * g ( jj , 2 * j2 - 1 , i ) + real ( t1 ) * g ( jj , 2 * j2 , i ) g ( jj , 2 * j2 - 1 , i ) = g ( jj , 2 * j1 - 1 , i ) - t2 g ( jj , 2 * j2 , i ) = g ( jj , 2 * j1 , i ) - t3 g ( jj , 2 * j1 - 1 , i ) = g ( jj , 2 * j1 - 1 , i ) + t2 g ( jj , 2 * j1 , i ) = g ( jj , 2 * j1 , i ) + t3 40 continue 50 continue 60 continue 70 continue ! unscramble coefficients and normalize ! inverse fourier transform if ( isign . lt . 0 ) then kmr = nxy / nyh do 90 k = 2 , nyhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( k - 1 ))), - real ( sctd ( 1 + kmr * ( k - 1 )))) do 80 jj = 1 , 3 t4 = g ( jj , ny3 - 2 * k , i ) t5 = - g ( jj , ny3 - 2 * k + 1 , i ) t2 = g ( jj , 2 * k - 1 , i ) + t4 t3 = g ( jj , 2 * k , i ) + t5 t6 = g ( jj , 2 * k - 1 , i ) - t4 t5 = g ( jj , 2 * k , i ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) g ( jj , 2 * k - 1 , i ) = 0.5 * ( t2 + t4 ) g ( jj , 2 * k , i ) = 0.5 * ( t3 + t5 ) g ( jj , ny3 - 2 * k , i ) = 0.5 * ( t2 - t4 ) g ( jj , ny3 - 2 * k + 1 , i ) = 0.5 * ( t5 - t3 ) 80 continue 90 continue do 100 jj = 1 , 3 g ( jj , nyh + 1 , i ) = g ( jj , nyh + 1 , i ) g ( jj , nyh + 2 , i ) = - g ( jj , nyh + 2 , i ) t2 = g ( jj , 1 , i ) + g ( jj , 2 , i ) g ( jj , 2 , i ) = g ( jj , 1 , i ) - g ( jj , 2 , i ) g ( jj , 1 , i ) = t2 g ( jj , ny + 1 , i ) = g ( jj , ny + 1 , i ) 100 continue ! forward fourier transform else if ( isign . gt . 0 ) then kmr = nxy / nyh do 120 k = 2 , nyhh t1 = cmplx ( aimag ( sctd ( 1 + kmr * ( k - 1 ))), - real ( sctd ( 1 + kmr * ( k - 1 )))) do 110 jj = 1 , 3 t4 = g ( jj , ny3 - 2 * k , i ) t5 = - g ( jj , ny3 - 2 * k + 1 , i ) t2 = g ( jj , 2 * k - 1 , i ) + t4 t3 = g ( jj , 2 * k , i ) + t5 t6 = g ( jj , 2 * k - 1 , i ) - t4 t5 = g ( jj , 2 * k , i ) - t5 t4 = t6 * real ( t1 ) - t5 * aimag ( t1 ) t5 = t6 * aimag ( t1 ) + t5 * real ( t1 ) g ( jj , 2 * k - 1 , i ) = t2 + t4 g ( jj , 2 * k , i ) = t3 + t5 g ( jj , ny3 - 2 * k , i ) = t2 - t4 g ( jj , ny3 - 2 * k + 1 , i ) = t5 - t3 110 continue 120 continue do 130 jj = 1 , 3 g ( jj , nyh + 1 , i ) = 2.0 * g ( jj , nyh + 1 , i ) g ( jj , nyh + 2 , i ) = - 2.0 * g ( jj , nyh + 2 , i ) t2 = 2.0 * ( g ( jj , 1 , i ) + g ( jj , 2 , i )) g ( jj , 2 , i ) = 2.0 * ( g ( jj , 1 , i ) - g ( jj , 2 , i )) g ( jj , 1 , i ) = t2 g ( jj , ny + 1 , i ) = 2.0 * g ( jj , ny + 1 , i ) 130 continue endif ! perform recursion for sine-cosine transform sum1 = 0.5 * g ( 1 , 1 , i ) g ( 1 , 1 , i ) = 0.0 g ( 1 , 2 , i ) = sum1 sum2 = 0.5 * g ( 2 , 1 , i ) g ( 2 , 1 , i ) = 0.0 g ( 2 , 2 , i ) = sum2 sum3 = g ( 3 , ny + 1 , i ) g ( 3 , ny + 1 , i ) = g ( 3 , 2 , i ) g ( 3 , 2 , i ) = sum3 do 140 k = 2 , nyh sum1 = sum1 + g ( 1 , 2 * k - 1 , i ) g ( 1 , 2 * k - 1 , i ) = - g ( 1 , 2 * k , i ) g ( 1 , 2 * k , i ) = sum1 sum2 = sum2 + g ( 2 , 2 * k - 1 , i ) g ( 2 , 2 * k - 1 , i ) = - g ( 2 , 2 * k , i ) g ( 2 , 2 * k , i ) = sum2 sum3 = sum3 - g ( 3 , 2 * k , i ) g ( 3 , 2 * k , i ) = sum3 140 continue g ( 1 , ny + 1 , i ) = 0.0 g ( 2 , ny + 1 , i ) = 0.0 150 continue !$OMP END PARALLEL DO return end !----------------------------------------------------------------------- subroutine MPPDIVFD2 ( f , df , nx , ny , kstrt , ndim , nyv , kxp2 ) ! this subroutine calculates the divergence in fourier space ! with dirichlet boundary conditions (zero potential) ! using fast sine/cosine transforms for distributed data. ! intended for calculating the charge density from the electric field ! input: all except df, output: df ! approximate flop count is: 6*nx*ny ! the divergence is calculated using the equation: ! df(kx,ky) = -(kx*fx(kx,ky)+ky*fy(kx,ky)) ! where kx = pi*j/nx, ky = pi*k/ny, and j,k = fourier mode numbers, ! all for fourier mode (jj-1,k-1), where jj = j + kxp2*(kstrt - 1) ! modes nx and ny are zeroed out ! nx/ny = system length in x/y direction ! ndim = number of field arrays, must be >= 2 ! kstrt = starting data block number ! nyv = first dimension of field arrays, must be >= ny+1 ! kxp2 = number of data values per block implicit none integer nx , ny , kstrt , ndim , nyv , kxp2 real f , df dimension f ( ndim , nyv , kxp2 + 1 ), df ( nyv , kxp2 + 1 ) ! local data integer j , k , ks , ny1 , joff , kxp2s real dnx , dny , dkx , dky if ( ndim . lt . 2 ) return ks = kstrt - 1 ny1 = ny + 1 joff = kxp2 * ks kxp2s = min ( kxp2 , max ( 0 , nx - joff )) joff = joff - 1 dnx = 6.28318530717959 / real ( nx + nx ) dny = 6.28318530717959 / real ( ny + ny ) ! calculate the divergence if ( kstrt . gt . nx ) return ! mode numbers 0 < kx < nx and 0 < ky < ny !$OMP PARALLEL DO PRIVATE(j,k,dkx,dky) do 20 j = 1 , kxp2s dkx = dnx * real ( j + joff ) if (( j + joff ). gt . 0 ) then do 10 k = 2 , ny dky = dny * real ( k - 1 ) df ( k , j ) = - ( dkx * f ( 1 , k , j ) + dky * f ( 2 , k , j )) 10 continue endif ! mode numbers ky = 0, ny df ( 1 , j ) = 0.0 df ( ny + 1 , j ) = 0.0 20 continue !$OMP END PARALLEL DO ! mode numbers kx = 0, nx if ( ks . eq . 0 ) then do 30 k = 2 , ny df ( k , 1 ) = 0.0 30 continue endif do 40 k = 1 , ny1 df ( k , kxp2s + 1 ) = 0.0 40 continue return end !----------------------------------------------------------------------- subroutine MPPGRADFD2 ( df , f , nx , ny , kstrt , ndim , nyv , kxp2 ) ! this subroutine calculates the gradient in fourier space ! with dirichlet boundary conditions (zero potential) ! using fast sine/cosine transforms for distributed data. ! intended for calculating the electric field from the potential ! input: all except f, output: f ! approximate flop count is: 4*nx*ny ! the gradient is calculated using the equations: ! fx(kx,ky) = kx*df(kx,ky) ! fy(kx,ky) = ky*df(kx,ky) ! where kx = pi*j/nx, ky = pi*k/ny, and j,k = fourier mode numbers, ! all for fourier mode (jj-1,k-1), where jj = j + kxp2*(kstrt - 1) ! modes nx and ny are zeroed out ! nx/ny = system length in x/y direction ! ndim = number of field arrays, must be >= 2 ! kstrt = starting data block number ! nyv = first dimension of field arrays, must be >= ny+1 ! kxp2 = number of data values per block implicit none integer nx , ny , kstrt , ndim , nyv , kxp2 real df , f dimension df ( nyv , kxp2 + 1 ), f ( ndim , nyv , kxp2 + 1 ) ! local data integer j , k , ks , ny1 , joff , kxp2s real dnx , dny , dkx , dky ks = kstrt - 1 ny1 = ny + 1 joff = kxp2 * ks kxp2s = min ( kxp2 , max ( 0 , nx - joff )) joff = joff - 1 dnx = 6.28318530717959 / real ( nx + nx ) dny = 6.28318530717959 / real ( ny + ny ) ! calculate the gradient if ( kstrt . gt . nx ) return ! mode numbers 0 < kx < nx and 0 < ky < ny !$OMP PARALLEL DO PRIVATE(j,k,dkx,dky) do 20 j = 1 , kxp2s dkx = dnx * real ( j + joff ) if (( j + joff ). gt . 0 ) then do 10 k = 2 , ny dky = dny * real ( k - 1 ) f ( 1 , k , j ) = dkx * df ( k , j ) f ( 2 , k , j ) = dky * df ( k , j ) 10 continue endif ! mode numbers ky = 0, ny f ( 1 , 1 , j ) = 0.0 f ( 2 , 1 , j ) = 0.0 f ( 1 , ny + 1 , j ) = 0.0 f ( 2 , ny + 1 , j ) = 0.0 20 continue !$OMP END PARALLEL DO ! mode numbers kx = 0, nx if ( ks . eq . 0 ) then do 30 k = 2 , ny f ( 1 , k , 1 ) = 0.0 f ( 2 , k , 1 ) = 0.0 30 continue endif do 40 k = 1 , ny1 f ( 1 , k , kxp2s + 1 ) = 0.0 f ( 2 , k , kxp2s + 1 ) = 0.0 40 continue return end !----------------------------------------------------------------------- subroutine MPPCURLFD2 ( f , g , nx , ny , kstrt , nyv , kxp2 ) ! this subroutine calculates the curl in fourier space ! with dirichlet boundary conditions (zero potential) ! using fast sine/cosine transforms for distributed data. ! intended for calculating the magnetic field from the vector potential ! input: all except g, output: g ! approximate flop count is: 8*nx*ny ! the curl is calculated using the equations: ! gx(kx,ky) = ky*fz(kx,ky) ! gy(kx,ky) = -kx*fz(kx,ky) ! gz(kx,ky) = (kx*fy(kx,ky)-ky*fx(kx,ky)) ! where kx = pi*j/nx, ky = pi*k/ny, and j,k = fourier mode numbers, ! all for fourier mode (jj-1,k-1), where jj = j + kxp2*(kstrt - 1) ! nx/ny = system length in x/y direction ! kstrt = starting data block number ! nyv = first dimension of field arrays, must be >= ny+1 ! kxp2 = number of data values per block implicit none integer nx , ny , kstrt , nyv , kxp2 real f , g dimension f ( 3 , nyv , kxp2 + 1 ), g ( 3 , nyv , kxp2 + 1 ) ! local data integer j , k , ks , ny1 , joff , kxp2s real dnx , dny , dkx , dky ks = kstrt - 1 ny1 = ny + 1 joff = kxp2 * ks kxp2s = min ( kxp2 , max ( 0 , nx - joff )) joff = joff - 1 dnx = 6.28318530717959 / real ( nx + nx ) dny = 6.28318530717959 / real ( ny + ny ) ! calculate the curl if ( kstrt . gt . nx ) return ! mode numbers 0 < kx < nx and 0 < ky < ny !$OMP PARALLEL DO PRIVATE(j,k,dkx,dky) do 20 j = 1 , kxp2s dkx = dnx * real ( j + joff ) if (( j + joff ). gt . 0 ) then do 10 k = 2 , ny dky = dny * real ( k - 1 ) g ( 1 , k , j ) = dky * f ( 3 , k , j ) g ( 2 , k , j ) = - dkx * f ( 3 , k , j ) g ( 3 , k , j ) = dkx * f ( 2 , k , j ) - dky * f ( 1 , k , j ) 10 continue ! mode numbers ky = 0, ny g ( 1 , 1 , j ) = 0.0 g ( 2 , 1 , j ) = 0.0 g ( 3 , 1 , j ) = dkx * f ( 2 , 1 , j ) endif g ( 1 , ny + 1 , j ) = 0.0 g ( 2 , ny + 1 , j ) = 0.0 g ( 3 , ny + 1 , j ) = 0.0 20 continue !$OMP END PARALLEL DO ! mode numbers kx = 0, nx if ( ks . eq . 0 ) then do 30 k = 2 , ny dky = dny * real ( k - 1 ) g ( 1 , k , 1 ) = 0.0 g ( 2 , k , 1 ) = 0.0 g ( 3 , k , 1 ) = - dky * f ( 1 , k , 1 ) 30 continue g ( 1 , 1 , 1 ) = 0.0 g ( 2 , 1 , 1 ) = 0.0 g ( 3 , 1 , 1 ) = 0.0 endif do 40 k = 1 , ny1 g ( 1 , k , kxp2s + 1 ) = 0.0 g ( 2 , k , kxp2s + 1 ) = 0.0 g ( 3 , k , kxp2s + 1 ) = 0.0 40 continue return end","tags":"","loc":"sourcefile/fft2d_lib77.f.html"},{"title":"fft2d_class.f03 – QuickPIC","text":"This file depends on sourcefile~~fft2d_class.f03~~EfferentGraph sourcefile~fft2d_class.f03 fft2d_class.f03 sourcefile~parallel_pipe_class.f03 parallel_pipe_class.f03 sourcefile~fft2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~perrors_class.f03 perrors_class.f03 sourcefile~fft2d_class.f03->sourcefile~perrors_class.f03 sourcefile~ufield2d_class.f03 ufield2d_class.f03 sourcefile~fft2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~spect2d_class.f03 spect2d_class.f03 sourcefile~fft2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~fft2d_lib.f03 fft2d_lib.f03 sourcefile~fft2d_class.f03->sourcefile~fft2d_lib.f03 sourcefile~parallel_class.f03 parallel_class.f03 sourcefile~parallel_pipe_class.f03->sourcefile~parallel_class.f03 sourcefile~perrors_class.f03->sourcefile~parallel_class.f03 sourcefile~ufield2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~ufield2d_class.f03->sourcefile~perrors_class.f03 sourcefile~ufield2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~ufield2d_lib.f03 ufield2d_lib.f03 sourcefile~ufield2d_class.f03->sourcefile~ufield2d_lib.f03 sourcefile~hdf5io_class.f03 hdf5io_class.f03 sourcefile~ufield2d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~spect2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~spect2d_class.f03->sourcefile~perrors_class.f03 sourcefile~hdf5io_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~hdf5io_class.f03->sourcefile~perrors_class.f03 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~fft2d_class.f03~~AfferentGraph sourcefile~fft2d_class.f03 fft2d_class.f03 sourcefile~field2d_class.f03 field2d_class.f03 sourcefile~field2d_class.f03->sourcefile~fft2d_class.f03 sourcefile~simulation_class.f03 simulation_class.f03 sourcefile~simulation_class.f03->sourcefile~field2d_class.f03 sourcefile~species2d_class.f03 species2d_class.f03 sourcefile~simulation_class.f03->sourcefile~species2d_class.f03 sourcefile~beam3d_class.f03 beam3d_class.f03 sourcefile~simulation_class.f03->sourcefile~beam3d_class.f03 sourcefile~species2d_class.f03->sourcefile~field2d_class.f03 sourcefile~beam3d_class.f03->sourcefile~field2d_class.f03 sourcefile~main.f03 main.f03 sourcefile~main.f03->sourcefile~simulation_class.f03 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules fft2d_class Source Code fft2d_class.f03 Source Code ! fft2d class for QuickPIC Open Source 1.0 ! update: 04/18/2016 module fft2d_class use perrors_class use parallel_pipe_class use spect2d_class use ufield2d_class use fft2d_lib implicit none private public :: fft2d , get_fft2table type fft2d private ! ! ind = exponent which determines length in each direction ! nrc = (0,1) = table for real to complex (0) or complex to complex (1) ! mixup = array of bit reversed addresses ! sct = sine/cosine table class ( spect2d ), pointer , public :: sp => null () class ( perrors ), pointer , public :: err => null () class ( parallel_pipe ), pointer , public :: p => null () integer , dimension ( 2 ) :: ind integer :: nrc integer , dimension (:), pointer :: mixup complex , dimension (:), pointer :: sct contains generic :: new => init_fft2d generic :: del => end_fft2d generic :: fsst => iwpfsst2r generic :: fcct => iwpfcct2r generic :: fs3t => iwpfs3t2r generic :: divf => ipdivfd2 generic :: gradf => ipgradfd2 generic :: curlf => ipcurlfd2 procedure , private :: init_fft2d procedure , private :: end_fft2d procedure , private :: iwpfsst2r , iwpfcct2r , iwpfs3t2r procedure , private :: ipdivfd2 , ipgradfd2 , ipcurlfd2 end type ! type fft2d_link type ( fft2d_link ), pointer :: next => null () type ( fft2d ), pointer :: table => null () integer :: refcount end type fft2d_link ! character ( len = 10 ), save :: class = 'fft2d:' character ( len = 128 ), save :: erstr ! link list for fft tables integer , save :: numtables = 0 type ( fft2d_link ), target , save :: table_list contains ! subroutine init_fft2d ( this , pp , perr , psp , indx , indy , nrc ) implicit none class ( fft2d ), intent ( inout ) :: this class ( spect2d ), intent ( in ), pointer :: psp class ( perrors ), intent ( in ), pointer :: perr class ( parallel_pipe ), intent ( in ), pointer :: pp integer , intent ( in ) :: indx , indy , nrc ! local data character ( len = 18 ), save :: sname = 'init_fft2d:' integer :: nx , ny , n1 , n2 this % sp => psp this % err => perr this % p => pp call this % err % werrfl2 ( class // sname // ' started' ) if (( indx < 1 ) . or . ( indy < 1 )) then write ( erstr , * ) 'invalid indx or indy=' , indx , indy call this % err % equit ( class // sname // erstr ) return endif this % ind = ( / indx , indy / ) this % nrc = nrc nx = 2 ** indx ; ny = 2 ** indy select case ( this % sp % getpsolver ()) case ( 1 ) n1 = max ( nx / 2 , ny ); n2 = max ( nx , ny ) allocate ( this % mixup ( n1 ), this % sct ( n2 )) call WPFST2RINIT ( this % mixup , this % sct , indx , indy , n1 , n2 ) case default n1 = max ( nx / 2 , ny ); n2 = max ( nx , ny ) allocate ( this % mixup ( n1 ), this % sct ( n2 )) call WPFST2RINIT ( this % mixup , this % sct , indx , indy , n1 , n2 ) end select call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine init_fft2d ! subroutine end_fft2d ( this ) implicit none class ( fft2d ), intent ( inout ) :: this ! local data character ( len = 18 ), save :: sname = 'end_fft2d:' call this % err % werrfl2 ( class // sname // ' started' ) if ( associated ( this % mixup )) deallocate ( this % mixup ) if ( associated ( this % sct )) deallocate ( this % sct ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine end_fft2d ! subroutine iwpfsst2r ( this , rspace , krspace , isign ) ! this subroutine performs 2d real sine-cosine-sine transform for 1d partition ! rspace, krspace = ufield2d of input and output data ! isign = sign for transform (-1 = real to fourier, 1 = fourier to real) implicit none class ( fft2d ), intent ( in ) :: this class ( ufield2d ), intent ( inout ) :: rspace , krspace integer , intent ( in ) :: isign ! local data ! f = real space source or destination for transform ! g = real fourier space source or destination for transform ! inorder = interpolation order, determines starting point for transform ! kstrt = starting data block number, a global variable real , dimension (:,:,:), pointer :: f => null () real , dimension (:,:,:), pointer :: g => null () integer , dimension (:), pointer :: mixup => null () complex , dimension (:), pointer :: sctd => null () integer :: indx , indy integer :: ntpose = 1 , nxvh , nyv , kyp , kxp2 , kypd , kxp2d integer :: jblok , kblok , nxhyd , nxyd , order real :: ttp real , dimension (:,:,:), allocatable :: bs , br character ( len = 11 ), save :: sname = 'iwpfsst2r:' ! check for errors call this % err % werrfl2 ( class // sname // ' started' ) if (( rspace % getlayout () /= 0 ) . or . ( krspace % getlayout () /= 1 )) & & then erstr = ' invalid layout' call this % err % equit ( class // sname // erstr ) return endif if (( rspace % getnd1 () /= krspace % getnd2 ()). or .& &( rspace % getnd2 () /= krspace % getnd1 ())) then erstr = ' non-conforming array' call this % err % equit ( class // sname // erstr ) return endif ! unpack arguments indx = this % ind ( 1 ); indy = this % ind ( 2 ) kyp = rspace % getnd2p (); kxp2 = krspace % getnd2p () kblok = 1 ; jblok = 1 allocate ( bs ( rspace % getdim (), kxp2 + 1 , kyp + 1 )) allocate ( br ( krspace % getdim (), kxp2 + 1 , kyp + 1 )) f => rspace % getrf () g => krspace % getrf () nxvh = size ( f , 2 ) / 2 ; nyv = size ( g , 2 ) kypd = size ( f , 3 ); kxp2d = size ( g , 3 ) nxhyd = size ( this % mixup ); nxyd = size ( this % sct ) mixup => this % mixup ; sctd => this % sct ! choose the proper function order = this % sp % getinorder () select case ( order ) case ( 1 ) select case ( rspace % getdim ()) case ( 1 ) call WPPFSST2RM ( f ( 1 ,:,:), g , bs , br , isign , ntpose , mixup , sctd , ttp ,& & indx , indy , this % p % getlkstrt (), this % p % getlnvp (), nxvh , nyv , kxp2 ,& & kyp , kypd , kxp2d , nxhyd , nxyd ) !               call WPFSST2R(f(1,1,1),g,bs,br,isign,ntpose,mixup,sctd,ttp,& !               &indx,indy,this%p%getlkstrt(),nxvh,nyv,kxp2,kyp,kypd,kxp2d,& !               &jblok,kblok,nxhyd,nxyd) case ( 2 ) call WPPFCST2RM2 ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp ,& & indx , indy , this % p % getlkstrt (), this % p % getlnvp (), nxvh , nyv , kxp2 ,& & kyp , kypd , kxp2d , nxhyd , nxyd ) !               call WPFCST2R2(f(1,1,1),g,bs,br,isign,ntpose,mixup,sctd,ttp,& !               &indx,indy,this%p%getlkstrt(),nxvh,nyv,kxp2,kyp,kypd,kxp2d,& !               &jblok,kblok,nxhyd,nxyd) case ( 3 ) call WPPFCST2RM3 ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp ,& & indx , indy , this % p % getlkstrt (), this % p % getlnvp (), nxvh , nyv , kxp2 ,& & kyp , kypd , kxp2d , nxhyd , nxyd ) !               call WPFCST2R3(f(1,1,1),g,bs,br,isign,ntpose,mixup,sctd,ttp,& !               &indx,indy,this%p%getlkstrt(),nxvh,nyv,kxp2,kyp,kypd,kxp2d,& !               &jblok,kblok,nxhyd,nxyd) end select case default select case ( rspace % getdim ()) case ( 1 ) call WPPFSST2RM ( f ( 1 ,:,:), g , bs , br , isign , ntpose , mixup , sctd , ttp ,& & indx , indy , this % p % getlkstrt (), this % p % getlnvp (), nxvh , nyv , kxp2 ,& & kyp , kypd , kxp2d , nxhyd , nxyd ) !               call WPFSST2R(f(1,1,1),g,bs,br,isign,ntpose,mixup,sctd,ttp,& !               &indx,indy,this%p%getlkstrt(),nxvh,nyv,kxp2,kyp,kypd,kxp2d,& !               &jblok,kblok,nxhyd,nxyd) case ( 2 ) call WPPFCST2RM2 ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp ,& & indx , indy , this % p % getlkstrt (), this % p % getlnvp (), nxvh , nyv , kxp2 ,& & kyp , kypd , kxp2d , nxhyd , nxyd ) !               call WPFCST2R2(f(1,1,1),g,bs,br,isign,ntpose,mixup,sctd,ttp,& !               &indx,indy,this%p%getlkstrt(),nxvh,nyv,kxp2,kyp,kypd,kxp2d,& !               &jblok,kblok,nxhyd,nxyd) case ( 3 ) call WPPFCST2RM3 ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp ,& & indx , indy , this % p % getlkstrt (), this % p % getlnvp (), nxvh , nyv , kxp2 ,& & kyp , kypd , kxp2d , nxhyd , nxyd ) !               call WPFCST2R3(f(1,1,1),g,bs,br,isign,ntpose,mixup,sctd,ttp,& !               &indx,indy,this%p%getlkstrt(),nxvh,nyv,kxp2,kyp,kypd,kxp2d,& !               &jblok,kblok,nxhyd,nxyd) end select end select deallocate ( bs , br ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine iwpfsst2r ! subroutine iwpfcct2r ( this , rspace , krspace , isign ) ! this subroutine performs 2d real cosine-sine-cosine transform for 1d partition ! rspace, krspace = ufield2d of input and output data ! isign = sign for transform (-1 = real to fourier, 1 = fourier to real) implicit none class ( fft2d ), intent ( in ) :: this class ( ufield2d ), intent ( inout ) :: rspace , krspace integer , intent ( in ) :: isign ! local data ! f = real space source or destination for transform ! g = real fourier space source or destination for transform ! inorder = interpolation order, determines starting point for transform ! kstrt = starting data block number, a global variable real , dimension (:,:,:), pointer :: f => null () real , dimension (:,:,:), pointer :: g => null () integer , dimension (:), pointer :: mixup => null () complex , dimension (:), pointer :: sctd => null () integer :: indx , indy integer :: ntpose = 1 , nxvh , nyv , kyp , kxp2 , kypd , kxp2d integer :: jblok , kblok , nxhyd , nxyd , order real :: ttp real , dimension (:,:,:), allocatable :: bs , br character ( len = 11 ), save :: sname = 'iwpfcct2r:' ! check for errors call this % err % werrfl2 ( class // sname // ' started' ) if (( rspace % getlayout () /= 0 ) . or . ( krspace % getlayout () /= 1 )) & & then erstr = ' invalid layout' call this % err % equit ( class // sname // erstr ) return endif if (( rspace % getnd1 () /= krspace % getnd2 ()). or .& &( rspace % getnd2 () /= krspace % getnd1 ())) then erstr = ' non-conforming array' call this % err % equit ( class // sname // erstr ) return endif ! unpack arguments indx = this % ind ( 1 ); indy = this % ind ( 2 ) kyp = rspace % getnd2p (); kxp2 = krspace % getnd2p () kblok = 1 ; jblok = 1 allocate ( bs ( rspace % getdim (), kxp2 + 1 , kyp + 1 )) allocate ( br ( krspace % getdim (), kxp2 + 1 , kyp + 1 )) f => rspace % getrf () g => krspace % getrf () nxvh = size ( f , 2 ) / 2 ; nyv = size ( g , 2 ) kypd = size ( f , 3 ); kxp2d = size ( g , 3 ) nxhyd = size ( this % mixup ); nxyd = size ( this % sct ) mixup => this % mixup ; sctd => this % sct ! choose the proper function order = this % sp % getinorder () select case ( order ) case ( 1 ) select case ( rspace % getdim ()) case ( 1 ) call WPPFCCT2RM ( f ( 1 ,:,:), g , bs , br , isign , ntpose , mixup , sctd , ttp ,& & indx , indy , this % p % getlkstrt (), this % p % getlnvp (), nxvh , nyv , kxp2 ,& & kyp , kypd , kxp2d , nxhyd , nxyd ) !               call WPFCCT2R(f(1,1,1),g,bs,br,isign,ntpose,mixup,sctd,ttp,& !               &indx,indy,this%p%getlkstrt(),nxvh,nyv,kxp2,kyp,kypd,kxp2d,& !               &jblok,kblok,nxhyd,nxyd) case ( 2 ) call WPPFSCT2RM2 ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp ,& & indx , indy , this % p % getlkstrt (), this % p % getlnvp (), nxvh , nyv , kxp2 ,& & kyp , kypd , kxp2d , nxhyd , nxyd ) !               call WPFSCT2R2(f(1,1,1),g,bs,br,isign,ntpose,mixup,sctd,ttp,& !               &indx,indy,this%p%getlkstrt(),nxvh,nyv,kxp2,kyp,kypd,kxp2d,& !               &jblok,kblok,nxhyd,nxyd) case ( 3 ) call WPPFSCT2RM3 ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp ,& & indx , indy , this % p % getlkstrt (), this % p % getlnvp (), nxvh , nyv , kxp2 ,& & kyp , kypd , kxp2d , nxhyd , nxyd ) !               call WPFSCT2R3(f(1,1,1),g,bs,br,isign,ntpose,mixup,sctd,ttp,& !               &indx,indy,this%p%getlkstrt(),nxvh,nyv,kxp2,kyp,kypd,kxp2d,& !               &jblok,kblok,nxhyd,nxyd) end select case default select case ( rspace % getdim ()) case ( 1 ) call WPPFCCT2RM ( f ( 1 ,:,:), g , bs , br , isign , ntpose , mixup , sctd , ttp ,& & indx , indy , this % p % getlkstrt (), this % p % getlnvp (), nxvh , nyv , kxp2 ,& & kyp , kypd , kxp2d , nxhyd , nxyd ) !               call WPFCCT2R(f(1,1,1),g,bs,br,isign,ntpose,mixup,sctd,ttp,& !               &indx,indy,this%p%getlkstrt(),nxvh,nyv,kxp2,kyp,kypd,kxp2d,& !               &jblok,kblok,nxhyd,nxyd) case ( 2 ) call WPPFSCT2RM2 ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp ,& & indx , indy , this % p % getlkstrt (), this % p % getlnvp (), nxvh , nyv , kxp2 ,& & kyp , kypd , kxp2d , nxhyd , nxyd ) !               call WPFSCT2R2(f(1,1,1),g,bs,br,isign,ntpose,mixup,sctd,ttp,& !               &indx,indy,this%p%getlkstrt(),nxvh,nyv,kxp2,kyp,kypd,kxp2d,& !               &jblok,kblok,nxhyd,nxyd) case ( 3 ) call WPPFSCT2RM3 ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp ,& & indx , indy , this % p % getlkstrt (), this % p % getlnvp (), nxvh , nyv , kxp2 ,& & kyp , kypd , kxp2d , nxhyd , nxyd ) !               call WPFSCT2R3(f(1,1,1),g,bs,br,isign,ntpose,mixup,sctd,ttp,& !               &indx,indy,this%p%getlkstrt(),nxvh,nyv,kxp2,kyp,kypd,kxp2d,& !               &jblok,kblok,nxhyd,nxyd) end select end select deallocate ( bs , br ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine iwpfcct2r ! subroutine iwpfs3t2r ( this , rspace , krspace , isign ) ! this subroutine performs 2d real sine-cosine-sine transform for 1d partition ! rspace, krspace = ufield2d of input and output data ! isign = sign for transform (-1 = real to fourier, 1 = fourier to real) implicit none class ( fft2d ), intent ( in ) :: this class ( ufield2d ), intent ( inout ) :: rspace , krspace integer , intent ( in ) :: isign ! local data ! f = real space source or destination for transform ! g = real fourier space source or destination for transform ! inorder = interpolation order, determines starting point for transform ! kstrt = starting data block number, a global variable real , dimension (:,:,:), pointer :: f => null () real , dimension (:,:,:), pointer :: g => null () integer , dimension (:), pointer :: mixup => null () complex , dimension (:), pointer :: sctd => null () integer :: indx , indy integer :: ntpose = 1 , nxvh , nyv , kyp , kxp2 , kypd , kxp2d integer :: jblok , kblok , nxhyd , nxyd , order real :: ttp real , dimension (:,:,:), allocatable :: bs , br character ( len = 11 ), save :: sname = 'iwpfs3t2r:' ! check for errors call this % err % werrfl2 ( class // sname // ' started' ) if (( rspace % getlayout () /= 0 ) . or . ( krspace % getlayout () /= 1 )) & & then erstr = ' invalid layout' call this % err % equit ( class // sname // erstr ) return endif if (( rspace % getnd1 () /= krspace % getnd2 ()). or .& &( rspace % getnd2 () /= krspace % getnd1 ())) then erstr = ' non-conforming array' call this % err % equit ( class // sname // erstr ) return endif ! unpack arguments indx = this % ind ( 1 ); indy = this % ind ( 2 ) kyp = rspace % getnd2p (); kxp2 = krspace % getnd2p () allocate ( bs ( rspace % getdim (), kxp2 + 1 , kyp + 1 )) allocate ( br ( rspace % getdim (), kxp2 + 1 , kyp + 1 )) kblok = 1 ; jblok = 1 f => rspace % getrf () g => krspace % getrf () nxvh = size ( f , 2 ) / 2 ; nyv = size ( g , 2 ) kypd = size ( f , 3 ); kxp2d = size ( g , 3 ) nxhyd = size ( this % mixup ); nxyd = size ( this % sct ) mixup => this % mixup ; sctd => this % sct ! choose the proper function order = this % sp % getinorder () select case ( order ) case ( 1 ) select case ( rspace % getdim ()) case ( 3 ) call WPPFSST2RM23 ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp ,& & indx , indy , this % p % getlkstrt (), this % p % getlnvp (), nxvh , nyv , kxp2 ,& & kyp , kypd , kxp2d , nxhyd , nxyd ) !               call WPFS3T2R3(f(1,1,1),g,bs,br,isign,ntpose,mixup,sctd,ttp,& !               &indx,indy,this%p%getlkstrt(),nxvh,nyv,kxp2,kyp,kypd,kxp2d,& !               &jblok,kblok,nxhyd,nxyd) end select case default select case ( rspace % getdim ()) case ( 3 ) call WPPFSST2RM23 ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp ,& & indx , indy , this % p % getlkstrt (), this % p % getlnvp (), nxvh , nyv , kxp2 ,& & kyp , kypd , kxp2d , nxhyd , nxyd ) !               call WPFS3T2R3(f(1,1,1),g,bs,br,isign,ntpose,mixup,sctd,ttp,& !               &indx,indy,this%p%getlkstrt(),nxvh,nyv,kxp2,kyp,kypd,kxp2d,& !               &jblok,kblok,nxhyd,nxyd) end select end select deallocate ( bs , br ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine iwpfs3t2r ! subroutine ipdivfd2 ( this , krspace , kdspace ) ! this subroutine calculates the divergence in fourier space ! with dirichlet (zero potential) boundary conditions ! this = fft2d descriptor ! krspace = source ufield2d ! kdspace = destiny ufield2d implicit none class ( fft2d ), intent ( in ) :: this class ( ufield2d ), intent ( inout ) :: krspace , kdspace ! local data real , dimension (:,:,:), pointer :: f => null () real , dimension (:,:,:), pointer :: df => null () integer :: nx , ny , ndim , nyv , kxp2 character ( len = 10 ), save :: sname = 'ipdivfd2:' call this % err % werrfl2 ( class // sname // ' started' ) ! unpack arguments nx = 2 ** this % ind ( 1 ); ny = 2 ** this % ind ( 2 ) f => krspace % getrf () df => kdspace % getrf () ndim = size ( f , 1 ) nyv = size ( f , 2 ); kxp2 = size ( f , 3 ) - 1 ; ! call the operator call MPPDIVFD2 ( f , df ( 1 ,:,:), nx , ny , this % p % getlkstrt (), ndim , nyv , kxp2 ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine ipdivfd2 ! subroutine ipgradfd2 ( this , krspace , kdspace ) ! this subroutine calculates the gradient in fourier space ! with dirichlet (zero potential) boundary conditions ! this = fft2d descriptor ! krspace = source ufield2d ! kdspace = destiny ufield2d implicit none class ( fft2d ), intent ( in ) :: this class ( ufield2d ), intent ( inout ) :: krspace , kdspace ! local data integer :: nx , ny , ndim , nyv , kxp2 , j2blok real , dimension (:,:,:), pointer :: df => null () real , dimension (:,:,:), pointer :: f => null () character ( len = 11 ), save :: sname = 'ipgradfd2:' call this % err % werrfl2 ( class // sname // ' started' ) ! unpack arguments nx = 2 ** this % ind ( 1 ); ny = 2 ** this % ind ( 2 ) f => krspace % getrf () df => kdspace % getrf () ndim = size ( df , 1 ) nyv = size ( df , 2 ); kxp2 = size ( df , 3 ) - 1 ; ! call the operator call MPPGRADFD2 ( f ( 1 ,:,:), df , nx , ny , this % p % getlkstrt (), ndim , nyv , kxp2 ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine ipgradfd2 ! subroutine ipcurlfd2 ( this , krspace , kdspace ) ! this subroutine calculates the curl in fourier space ! with dirichlet (zero potential) boundary conditions ! this = fft2d descriptor ! krspace = ufield2d descriptor of data ! krspace = source ufield2d ! kdspace = destiny ufield2d implicit none class ( fft2d ), intent ( in ) :: this class ( ufield2d ), intent ( inout ) :: krspace , kdspace ! local data integer :: nx , ny , nyv , kxp2 , j2blok real , dimension (:,:,:), pointer :: pf => null (), pg => null () character ( len = 11 ), save :: sname = 'ipcurlfd2:' call this % err % werrfl2 ( class // sname // ' started' ) ! unpack arguments nx = 2 ** this % ind ( 1 ); ny = 2 ** this % ind ( 2 ) pf => krspace % getrf () pg => kdspace % getrf () nyv = size ( pf , 2 ); kxp2 = size ( pf , 3 ) - 1 ; j2blok = 1 ! choose the proper function select case ( size ( pf , 1 )) case ( 2 ) call PCURLFD22 ( pf , pg , nx , ny , this % p % getlkstrt (), nyv , kxp2 , j2blok ) case ( 3 ) call MPPCURLFD2 ( pf , pg , nx , ny , this % p % getlkstrt (), nyv , kxp2 ) end select call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine ipcurlfd2 ! function get_fft2table ( pp , perr , psp , indx , indy ) result ( table ) ! this function gets an fft table entry, either creates one or points ! to one if the required table already exists for real to complex ffts implicit none class ( spect2d ), intent ( in ), pointer :: psp class ( perrors ), intent ( in ), pointer :: perr class ( parallel_pipe ), intent ( in ), pointer :: pp integer , intent ( in ) :: indx , indy type ( fft2d ), pointer :: table ! local data type ( fft2d_link ), pointer :: link => null () type ( fft2d ), pointer :: ltable => null () integer :: nrc = 0 , ierr = 0 character ( len = 18 ), save :: sname = 'get_fft2table:' call perr % werrfl2 ( class // sname // ' started' ) nullify ( table ) select case ( psp % getpsolver ()) case ( 1 ) nrc = 0 case default nrc = 0 end select if ( numtables == 0 ) then nullify ( table_list % next , table_list % table ) table_list % refcount = 0 endif link => table_list table => link % table ! search link list of table to see if required table already exists do while ( associated ( table )) ! found it if (( indx == table % ind ( 1 )) . and . ( indy == table % ind ( 2 )) . and . ( t & & able % nrc == nrc ). and .( psp % getpsolver () == table % sp % getpsolver ())) then link % refcount = link % refcount + 1 call perr % werrfl2 ( class // sname // ' ended' ) return ! check next table, create new empty table if end is reached else if ( associated ( link % next )) then link => link % next else allocate ( link % next ) link => link % next nullify ( link % next , link % table ) link % refcount = 0 endif table => link % table endif end do ! allocate table entries allocate ( ltable ) link % table => ltable table => link % table call table % new ( pp , perr , psp , indx , indy , nrc ) link % refcount = 1 numtables = numtables + 1 end function get_fft2table ! end module fft2d_class","tags":"","loc":"sourcefile/fft2d_class.f03.html"},{"title":"main.f03 – QuickPIC","text":"This file depends on sourcefile~~main.f03~~EfferentGraph sourcefile~main.f03 main.f03 sourcefile~simulation_class.f03 simulation_class.f03 sourcefile~main.f03->sourcefile~simulation_class.f03 sourcefile~parallel_pipe_class.f03 parallel_pipe_class.f03 sourcefile~simulation_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~fdist3d_class.f03 fdist3d_class.f03 sourcefile~simulation_class.f03->sourcefile~fdist3d_class.f03 sourcefile~field3d_class.f03 field3d_class.f03 sourcefile~simulation_class.f03->sourcefile~field3d_class.f03 sourcefile~parallel_class.f03 parallel_class.f03 sourcefile~simulation_class.f03->sourcefile~parallel_class.f03 sourcefile~spect3d_class.f03 spect3d_class.f03 sourcefile~simulation_class.f03->sourcefile~spect3d_class.f03 sourcefile~hdf5io_class.f03 hdf5io_class.f03 sourcefile~simulation_class.f03->sourcefile~hdf5io_class.f03 sourcefile~perrors_class.f03 perrors_class.f03 sourcefile~simulation_class.f03->sourcefile~perrors_class.f03 sourcefile~spect2d_class.f03 spect2d_class.f03 sourcefile~simulation_class.f03->sourcefile~spect2d_class.f03 sourcefile~input_class.f03 input_class.f03 sourcefile~simulation_class.f03->sourcefile~input_class.f03 sourcefile~fdist2d_class.f03 fdist2d_class.f03 sourcefile~simulation_class.f03->sourcefile~fdist2d_class.f03 sourcefile~field2d_class.f03 field2d_class.f03 sourcefile~simulation_class.f03->sourcefile~field2d_class.f03 sourcefile~species2d_class.f03 species2d_class.f03 sourcefile~simulation_class.f03->sourcefile~species2d_class.f03 sourcefile~beam3d_class.f03 beam3d_class.f03 sourcefile~simulation_class.f03->sourcefile~beam3d_class.f03 sourcefile~parallel_pipe_class.f03->sourcefile~parallel_class.f03 sourcefile~fdist3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~fdist3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~fdist3d_class.f03->sourcefile~perrors_class.f03 sourcefile~fdist3d_class.f03->sourcefile~input_class.f03 sourcefile~ufield3d_class.f03 ufield3d_class.f03 sourcefile~fdist3d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~part3d_lib.f03 part3d_lib.f03 sourcefile~fdist3d_class.f03->sourcefile~part3d_lib.f03 sourcefile~field3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~field3d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~field3d_class.f03->sourcefile~perrors_class.f03 sourcefile~field3d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~spect3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~spect3d_class.f03->sourcefile~perrors_class.f03 sourcefile~spect3d_class.f03->sourcefile~spect2d_class.f03 sourcefile~hdf5io_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~hdf5io_class.f03->sourcefile~perrors_class.f03 sourcefile~perrors_class.f03->sourcefile~parallel_class.f03 sourcefile~spect2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~spect2d_class.f03->sourcefile~perrors_class.f03 sourcefile~input_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~input_class.f03->sourcefile~parallel_class.f03 sourcefile~input_class.f03->sourcefile~spect3d_class.f03 sourcefile~input_class.f03->sourcefile~perrors_class.f03 sourcefile~fdist2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~fdist2d_class.f03->sourcefile~perrors_class.f03 sourcefile~fdist2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~fdist2d_class.f03->sourcefile~input_class.f03 sourcefile~ufield2d_class.f03 ufield2d_class.f03 sourcefile~fdist2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~field2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field2d_class.f03->sourcefile~field3d_class.f03 sourcefile~field2d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~field2d_class.f03->sourcefile~perrors_class.f03 sourcefile~field2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~field2d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~field2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~fpois2d_class.f03 fpois2d_class.f03 sourcefile~field2d_class.f03->sourcefile~fpois2d_class.f03 sourcefile~fft2d_class.f03 fft2d_class.f03 sourcefile~field2d_class.f03->sourcefile~fft2d_class.f03 sourcefile~species2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~species2d_class.f03->sourcefile~field3d_class.f03 sourcefile~species2d_class.f03->sourcefile~spect3d_class.f03 sourcefile~species2d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~species2d_class.f03->sourcefile~perrors_class.f03 sourcefile~species2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~species2d_class.f03->sourcefile~fdist2d_class.f03 sourcefile~species2d_class.f03->sourcefile~field2d_class.f03 sourcefile~part2d_class.f03 part2d_class.f03 sourcefile~species2d_class.f03->sourcefile~part2d_class.f03 sourcefile~beam3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~beam3d_class.f03->sourcefile~fdist3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~field3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~beam3d_class.f03->sourcefile~perrors_class.f03 sourcefile~beam3d_class.f03->sourcefile~field2d_class.f03 sourcefile~part3d_class.f03 part3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~part3d_class.f03 sourcefile~ufield3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~ufield3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~ufield3d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~ufield3d_class.f03->sourcefile~perrors_class.f03 sourcefile~ufield3d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~ufield3d_lib.f03 ufield3d_lib.f03 sourcefile~ufield3d_class.f03->sourcefile~ufield3d_lib.f03 sourcefile~part2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~part2d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~part2d_class.f03->sourcefile~perrors_class.f03 sourcefile~part2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~part2d_class.f03->sourcefile~fdist2d_class.f03 sourcefile~part2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~part2d_lib.f03 part2d_lib.f03 sourcefile~part2d_class.f03->sourcefile~part2d_lib.f03 sourcefile~part3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~part3d_class.f03->sourcefile~fdist3d_class.f03 sourcefile~part3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~part3d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~part3d_class.f03->sourcefile~perrors_class.f03 sourcefile~part3d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~part3d_class.f03->sourcefile~part3d_lib.f03 sourcefile~ufield2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~ufield2d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~ufield2d_class.f03->sourcefile~perrors_class.f03 sourcefile~ufield2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~ufield2d_lib.f03 ufield2d_lib.f03 sourcefile~ufield2d_class.f03->sourcefile~ufield2d_lib.f03 sourcefile~fpois2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~fpois2d_class.f03->sourcefile~perrors_class.f03 sourcefile~fpois2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~fpois2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~fpois2d_lib.f03 fpois2d_lib.f03 sourcefile~fpois2d_class.f03->sourcefile~fpois2d_lib.f03 sourcefile~fft2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~fft2d_class.f03->sourcefile~perrors_class.f03 sourcefile~fft2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~fft2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~fft2d_lib.f03 fft2d_lib.f03 sourcefile~fft2d_class.f03->sourcefile~fft2d_lib.f03 var pansourcefilemainf03EfferentGraph = svgPanZoom('#sourcefilemainf03EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs quickpic Source Code main.f03 Source Code ! Main program for QuickPIC Open Source 1.0 ! update: 04/18/2016 program quickpic use simulation_class implicit none type ( simulation ) :: sim call sim % new () call sim % go () call sim % del () stop end program quickpic","tags":"","loc":"sourcefile/main.f03.html"},{"title":"fpois2d_lib77.f – QuickPIC","text":"Contents Subroutines PPOISDX2 PPOISD2 PPOISD22 PPOISDX23 PPOISD23 PBPOISD22 PBPOISD23 PBPOISD22N_QP MPPOISD22 MPPOISD23 MPPOTPD2 MPPSMOOTHD2 MPPBBPOISD23 Source Code fpois2d_lib77.f Source Code c----------------------------------------------------------------------- subroutine PPOISDX2 ( q , fx , fy , isign , ffd , ax , ay , affp , we , nx , ny , kstrt , ny 1 2 d , kxp2 , j2blok , nyd ) c this subroutine solves 2d poisson's equation in fourier space for c force/charge (or convolution of electric field over particle shape) c or for potential, or provides a smoothing function, with dirichlet c boundary conditions (zero potential), for distributed data. c fourier coefficients are constructed so that a real to complex fft c will perform the appropriate sin-sin, sin-cos, or cos-sin transform c for isign = 0,input: isign,ax,ay,affp,nx,ny,kstrt,ny2d,kxp2,j2blok,nyd c               output: ffd c for isign = -1, input: q,ffd,isign,nx,ny,kstrt,ny2d,kxp2,j2blok,nyd c                output: fx,fy,we c approximate flop count is: 11*nx*ny c for isign = 1, input: q,ffd,isign,nx,ny,kstrt,ny2d,kxp2,j2blok,nyd c                output: fx,we c approximate flop count is: 6*nx*ny c for isign = 2, input: q,ffd,isign,nx,ny,kstrt,ny2d,kxp2,j2blok,nyd c                output: fy c approximate flop count is: 2*nx*ny c if isign < 0, force/charge is calculated using the equations: c fx(kx,ky) = -sqrt(-1)*kx*g(kx,ky)*s(kx,ky)*q(kx,ky), c fy(kx,ky) = -sqrt(-1)*ky*g(kx,ky)*s(kx,ky)*q(kx,ky), c where kx = pi*j/nx, ky = pi*k/ny, and j,k = fourier mode numbers, c g(kx,ky) = (affp/(kx**2+ky**2))*s(kx,ky), c s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)/2) c if isign = 1, potential is calculated using the equation: c fx(kx,ky) = g(kx,ky)*q(kx,ky)*s(kx,ky) c if isign = 2, smoothing is calculated using the equation: c fy(kx,ky) = q(kx,ky)*s(kx,ky) c q(k,j,l) = complex charge density for fourier mode (jj-1,k-1) c fx(k,j,l) = x component of complex force/charge, c fy(k,j,l) = y component of complex force/charge, c all for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1) c if isign = 0, form factor array is prepared c ffd(k,2*j,l) = finite-size particle shape factor s c ffd(k,2*j-1,l) = potential green's function g c all for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1) c j2blok = number of data blocks c kxp2 = number of data values per block c kstrt = starting data block number c ax/ay = half-width of particle in x/y direction c affp = normalization constant = nx*ny/np, where np=number of particles c electric field energy is also calculated, using c we = 2*nx*ny*sum((affp/(kx**2+ky**2))*|q(kx,ky)*s(kx,ky)|**2) c nx/ny = system length in x/y direction c ny2d = first dimension of field arrays, must be >= 2*ny c nyd = first dimension of form factor array, must be >= ny double precision wp complex q , fx , fy , ffd , zero dimension q ( ny2d , kxp2 , j2blok ) dimension fx ( ny2d , kxp2 , j2blok ), fy ( ny2d , kxp2 , j2blok ) dimension ffd ( nyd , kxp2 , j2blok ) ny2 = 2 * ny + 2 ks = kstrt - 2 dnx = 6.28318530717959 / float ( nx + nx ) dny = 6.28318530717959 / float ( ny + ny ) zero = cmplx ( 0. , 0. ) if ( isign . ne . 0 ) go to 40 if ( kstrt . gt . nx ) return c prepare form factor array do 30 l = 1 , j2blok joff = kxp2 * ( l + ks ) - 1 do 20 j = 1 , kxp2 dkx = dnx * float ( j + joff ) at1 = dkx * dkx at2 = ( dkx * ax ) ** 2 do 10 k = 1 , ny dky = dny * float ( k - 1 ) at3 = dky * dky + at1 at4 = exp ( - . 5 * (( dky * ay ) ** 2 + at2 )) if ( at3 . eq . 0. ) then ffd ( k , j , l ) = cmplx ( affp , 1. ) else ffd ( k , j , l ) = cmplx ( affp * at4 / at3 , at4 ) endif 10 continue 20 continue 30 continue return 40 if ( isign . gt . 0 ) go to 100 c calculate force/charge and sum field energy wp = 0.0d0 if ( kstrt . gt . nx ) go to 90 do 80 l = 1 , j2blok c mode numbers kx > 0 and 0 < ky < ny joff = kxp2 * ( l + ks ) - 1 do 60 j = 1 , kxp2 dkx = dnx * float ( j + joff ) if (( j + joff ). gt . 0 ) then do 50 k = 2 , ny k1 = ny2 - k at1 = real ( ffd ( k , j , l )) * aimag ( ffd ( k , j , l )) at3 = - at1 * real ( q ( k , j , l )) at2 = dkx * at3 at3 = dny * float ( k - 1 ) * at3 fx ( k , j , l ) = cmplx ( 0. , at2 ) fx ( k1 , j , l ) = cmplx ( 0. , - at2 ) fy ( k , j , l ) = cmplx ( 0. , at3 ) fy ( k1 , j , l ) = cmplx ( 0. , at3 ) wp = wp + at1 * real ( q ( k , j , l )) ** 2 50 continue endif c mode numbers ky = 0, ny fx ( 1 , j , l ) = zero fx ( ny + 1 , j , l ) = zero fy ( 1 , j , l ) = zero fy ( ny + 1 , j , l ) = zero 60 continue c mode number kx = 0 if (( l + ks ). eq . 0 ) then do 70 k = 2 , ny k1 = ny2 - k fx ( k , 1 , l ) = zero fx ( k1 , 1 , l ) = zero fy ( k , 1 , l ) = zero fy ( k1 , 1 , l ) = zero 70 continue endif 80 continue 90 continue we = 2.0 * float ( nx * ny ) * wp return c calculate potential and sum field energy 100 if ( isign . gt . 1 ) go to 160 wp = 0.0d0 if ( kstrt . gt . nx ) go to 150 do 140 l = 1 , j2blok c mode numbers kx > 0 and 0 < ky < ny joff = kxp2 * ( l + ks ) - 1 do 120 j = 1 , kxp2 if (( j + joff ). gt . 0 ) then do 110 k = 2 , ny k1 = ny2 - k at2 = real ( ffd ( k , j , l )) at1 = at2 * aimag ( ffd ( k , j , l )) at3 = at2 * real ( q ( k , j , l )) fx ( k , j , l ) = cmplx ( at3 , 0. ) fx ( k1 , j , l ) = cmplx ( - at3 , 0. ) wp = wp + at1 * real ( q ( k , j , l )) ** 2 110 continue endif c mode numbers ky = 0, ny fx ( 1 , j , l ) = zero fx ( ny + 1 , j , l ) = zero 120 continue c mode number kx = 0 if (( l + ks ). eq . 0 ) then do 130 k = 2 , ny k1 = ny2 - k fx ( k , 1 , l ) = zero fx ( k1 , 1 , l ) = zero 130 continue endif 140 continue 150 continue we = 2.0 * float ( nx * ny ) * wp return c calculate smoothing 160 if ( kstrt . gt . nx ) go to 210 do 200 l = 1 , j2blok c mode numbers kx > 0 and 0 < ky < ny joff = kxp2 * ( l + ks ) - 1 do 180 j = 1 , kxp2 if (( j + joff ). gt . 0 ) then do 170 k = 2 , ny k1 = ny2 - k at1 = aimag ( ffd ( k , j , l )) at2 = at1 * real ( q ( k , j , l )) fy ( k , j , l ) = cmplx ( at2 , 0. ) fy ( k1 , j , l ) = cmplx ( - at2 , 0. ) 170 continue endif c mode numbers ky = 0, ny fy ( 1 , j , l ) = zero fy ( ny + 1 , j , l ) = zero 180 continue c mode number kx = 0 if (( l + ks ). eq . 0 ) then do 190 k = 2 , ny k1 = ny2 - k fy ( k , 1 , l ) = zero fy ( k1 , 1 , l ) = zero 190 continue endif 200 continue 210 continue return end c----------------------------------------------------------------------- subroutine PPOISD2 ( q , fx , fy , isign , ffd , ax , ay , affp , we , nx , ny , kstrt , ny 1 v , kxp2 , j2blok , nyd ) c this subroutine solves 2d poisson's equation in fourier space for c force/charge (or convolution of electric field over particle shape) c or for potential, or provides a smoothing function, with dirichlet c boundary conditions (zero potential), for distributed data. c fourier coefficients are constructed so that a real to complex fft c will perform the appropriate sin-sin, sin-cos, or cos-sin transform c for isign = 0,input: isign,ax,ay,affp,nx,ny,kstrt,ny2d,kxp2,j2blok,nyd c               output: ffd c for isign = -1, input: q,ffd,isign,nx,ny,kstrt,ny2d,kxp2,j2blok,nyd c                output: fx,fy,we c approximate flop count is: 10*nx*ny c for isign = 1, input: q,ffd,isign,nx,ny,kstrt,ny2d,kxp2,j2blok,nyd c                output: fx,we c approximate flop count is: 5*nx*ny c for isign = 2, input: q,ffd,isign,nx,ny,kstrt,ny2d,kxp2,j2blok,nyd c                output: fy c approximate flop count is: 1*nx*ny c if isign < 0, force/charge is calculated using the equations: c fx(kx,ky) = -sqrt(-1)*kx*g(kx,ky)*s(kx,ky)*q(kx,ky), c fy(kx,ky) = -sqrt(-1)*ky*g(kx,ky)*s(kx,ky)*q(kx,ky), c where kx = pi*j/nx, ky = pi*k/ny, and j,k = fourier mode numbers, c g(kx,ky) = (affp/(kx**2+ky**2))*s(kx,ky), c s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)/2) c if isign = 1, potential is calculated using the equation: c fx(kx,ky) = g(kx,ky)*q(kx,ky)*s(kx,ky) c if isign = 2, smoothing is calculated using the equation: c fy(kx,ky) = q(kx,ky)*s(kx,ky) c q(k,j,l) = complex charge density for fourier mode (jj-1,k-1) c fx(k,j,l) = x component of complex force/charge, c fy(k,j,l) = y component of complex force/charge, c all for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1) c if isign = 0, form factor array is prepared c ffd(k,2*j,l) = finite-size particle shape factor s c ffd(k,2*j-1,l) = potential green's function g c all for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1) c j2blok = number of data blocks c kxp2 = number of data values per block c kstrt = starting data block number c ax/ay = half-width of particle in x/y direction c affp = normalization constant = nx*ny/np, where np=number of particles c electric field energy is also calculated, using c we = 2*nx*ny*sum((affp/(kx**2+ky**2))*|q(kx,ky)*s(kx,ky)|**2) c nx/ny = system length in x/y direction c nyv = first dimension of field arrays, must be >= ny+1 c nyd = first dimension of form factor array, must be >= ny double precision wp complex ffd dimension q ( nyv , kxp2 + 1 , j2blok ) dimension fx ( nyv , kxp2 + 1 , j2blok ), fy ( nyv , kxp2 + 1 , j2blok ) dimension ffd ( nyd , kxp2 , j2blok ) ks = kstrt - 2 ny1 = ny + 1 dnx = 6.28318530717959 / float ( nx + nx ) dny = 6.28318530717959 / float ( ny + ny ) if ( isign . ne . 0 ) go to 40 if ( kstrt . gt . nx ) return c prepare form factor array do 30 l = 1 , j2blok joff = kxp2 * ( l + ks ) - 1 do 20 j = 1 , kxp2 dkx = dnx * float ( j + joff ) at1 = dkx * dkx at2 = ( dkx * ax ) ** 2 do 10 k = 1 , ny dky = dny * float ( k - 1 ) at3 = dky * dky + at1 at4 = exp ( - . 5 * (( dky * ay ) ** 2 + at2 )) if ( at3 . eq . 0. ) then ffd ( k , j , l ) = cmplx ( affp , 1. ) else ffd ( k , j , l ) = cmplx ( affp * at4 / at3 , at4 ) endif 10 continue 20 continue 30 continue return 40 if ( isign . gt . 0 ) go to 110 c calculate force/charge and sum field energy wp = 0.0d0 if ( kstrt . gt . nx ) go to 100 do 90 l = 1 , j2blok c mode numbers kx > 0 and 0 < ky < ny joff = kxp2 * ( l + ks ) - 1 do 60 j = 1 , kxp2 dkx = dnx * float ( j + joff ) if (( j + joff ). gt . 0 ) then do 50 k = 2 , ny at1 = real ( ffd ( k , j , l )) * aimag ( ffd ( k , j , l )) at3 = - at1 * q ( k , j , l ) at2 = dkx * at3 at3 = dny * float ( k - 1 ) * at3 fx ( k , j , l ) = at2 fy ( k , j , l ) = at3 wp = wp + at1 * q ( k , j , l ) ** 2 50 continue endif c mode numbers ky = 0, ny fx ( 1 , j , l ) = 0. fx ( ny + 1 , j , l ) = 0. fy ( 1 , j , l ) = 0. fy ( ny + 1 , j , l ) = 0. 60 continue c mode number kx = 0 if (( l + ks ). eq . 0 ) then do 70 k = 2 , ny fx ( k , 1 , l ) = 0. fy ( k , 1 , l ) = 0. 70 continue endif do 80 k = 1 , ny1 fx ( k , kxp2 + 1 , l ) = 0. fy ( k , kxp2 + 1 , l ) = 0. 80 continue 90 continue 100 continue we = 2.0 * float ( nx * ny ) * wp return c calculate potential and sum field energy 110 if ( isign . gt . 1 ) go to 180 wp = 0.0d0 if ( kstrt . gt . nx ) go to 170 do 160 l = 1 , j2blok c mode numbers kx > 0 and 0 < ky < ny joff = kxp2 * ( l + ks ) - 1 do 130 j = 1 , kxp2 if (( j + joff ). gt . 0 ) then do 120 k = 2 , ny at2 = real ( ffd ( k , j , l )) at1 = at2 * aimag ( ffd ( k , j , l )) c         at3 = at2*q(k,j,l) at3 = at1 * q ( k , j , l ) fx ( k , j , l ) = at3 wp = wp + at1 * q ( k , j , l ) ** 2 120 continue endif c mode numbers ky = 0, ny fx ( 1 , j , l ) = 0. fx ( ny + 1 , j , l ) = 0. 130 continue c mode number kx = 0 if (( l + ks ). eq . 0 ) then do 140 k = 2 , ny fx ( k , 1 , l ) = 0. 140 continue endif do 150 k = 1 , ny1 fx ( k , kxp2 + 1 , l ) = 0. 150 continue 160 continue 170 continue we = 2.0 * float ( nx * ny ) * wp return c calculate smoothing 180 if ( kstrt . gt . nx ) go to 240 do 230 l = 1 , j2blok c mode numbers kx > 0 and 0 < ky < ny joff = kxp2 * ( l + ks ) - 1 do 200 j = 1 , kxp2 if (( j + joff ). gt . 0 ) then do 190 k = 2 , ny at1 = aimag ( ffd ( k , j , l )) at2 = at1 * q ( k , j , l ) fy ( k , j , l ) = at2 190 continue endif c mode numbers ky = 0, ny fy ( 1 , j , l ) = 0. fy ( ny + 1 , j , l ) = 0. 200 continue c mode number kx = 0 if (( l + ks ). eq . 0 ) then do 210 k = 2 , ny fy ( k , 1 , l ) = 0. 210 continue endif do 220 k = 1 , ny1 fy ( k , kxp2 + 1 , l ) = 0. 220 continue 230 continue 240 continue return end c----------------------------------------------------------------------- subroutine PPOISD22 ( q , fxy , isign , ffd , ax , ay , affp , we , nx , ny , kstrt , nyv , 1 kxp2 , j2blok , nyd ) c this subroutine solves 2d poisson's equation in fourier space for c force/charge (or convolution of electric field over particle shape) c with dirichlet boundary conditions (zero potential), c for distributed data. c fourier coefficients are constructed so that a real to complex fft c will perform the appropriate sin-cos, or cos-sin transform c for isign = 0,input: isign,ax,ay,affp,nx,ny,kstrt,ny2d,kxp2,j2blok,nyd c               output: ffd c for isign /= 0, input: q,ffd,isign,nx,ny,kstrt,ny2d,kxp2,j2blok,nyd c                output: fxy,we c approximate flop count is: 10*nx*ny c equation used is: c fx(kx,ky) = -sqrt(-1)*kx*g(kx,ky)*s(kx,ky)*q(kx,ky), c fy(kx,ky) = -sqrt(-1)*ky*g(kx,ky)*s(kx,ky)*q(kx,ky), c where kx = pi*j/nx, ky = pi*k/ny, and j,k = fourier mode numbers, c g(kx,ky) = (affp/(kx**2+ky**2))*s(kx,ky), c s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)/2) c q(k,j,l) = complex charge density for fourier mode (jj-1,k-1) c fxy(1,k,j,l) = x component of complex force/charge, c fxy(2,k,j,l) = y component of complex force/charge, c all for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1) c if isign = 0, form factor array is prepared c ffd(k,2*j,l) = finite-size particle shape factor s c ffd(k,2*j-1,l) = potential green's function g c all for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1) c j2blok = number of data blocks c kxp2 = number of data values per block c kstrt = starting data block number c ax/ay = half-width of particle in x/y direction c affp = normalization constant = nx*ny/np, where np=number of particles c electric field energy is also calculated, using c we = 2*nx*ny*sum((affp/(kx**2+ky**2))*|q(kx,ky)*s(kx,ky)|**2) c nx/ny = system length in x/y direction c nyv = first dimension of field arrays, must be >= ny+1 c nyd = first dimension of form factor array, must be >= ny double precision wp complex ffd dimension q ( nyv , kxp2 + 1 , j2blok ), fxy ( 2 , nyv , kxp2 + 1 , j2blok ) dimension ffd ( nyd , kxp2 , j2blok ) ks = kstrt - 2 ny1 = ny + 1 dnx = 6.28318530717959 / float ( nx + nx ) dny = 6.28318530717959 / float ( ny + ny ) if ( isign . ne . 0 ) go to 40 if ( kstrt . gt . nx ) return c prepare form factor array do 30 l = 1 , j2blok joff = kxp2 * ( l + ks ) - 1 do 20 j = 1 , kxp2 dkx = dnx * float ( j + joff ) at1 = dkx * dkx at2 = ( dkx * ax ) ** 2 do 10 k = 1 , ny dky = dny * float ( k - 1 ) at3 = dky * dky + at1 at4 = exp ( - . 5 * (( dky * ay ) ** 2 + at2 )) if ( at3 . eq . 0. ) then ffd ( k , j , l ) = cmplx ( affp , 1. ) else ffd ( k , j , l ) = cmplx ( affp * at4 / at3 , at4 ) endif 10 continue 20 continue 30 continue return c calculate force/charge and sum field energy 40 wp = 0.0d0 if ( kstrt . gt . nx ) go to 100 do 90 l = 1 , j2blok c mode numbers kx > 0 and 0 < ky < ny joff = kxp2 * ( l + ks ) - 1 do 60 j = 1 , kxp2 dkx = dnx * float ( j + joff ) if (( j + joff ). gt . 0 ) then do 50 k = 2 , ny at1 = real ( ffd ( k , j , l )) * aimag ( ffd ( k , j , l )) at3 = - at1 * q ( k , j , l ) at2 = dkx * at3 at3 = dny * float ( k - 1 ) * at3 fxy ( 1 , k , j , l ) = at2 fxy ( 2 , k , j , l ) = at3 wp = wp + at1 * q ( k , j , l ) ** 2 50 continue endif c mode numbers ky = 0, ny fxy ( 1 , 1 , j , l ) = 0. fxy ( 2 , 1 , j , l ) = 0. fxy ( 1 , ny + 1 , j , l ) = 0. fxy ( 2 , ny + 1 , j , l ) = 0. 60 continue c mode number kx = 0 if (( l + ks ). eq . 0 ) then do 70 k = 2 , ny fxy ( 1 , k , 1 , l ) = 0. fxy ( 2 , k , 1 , l ) = 0. 70 continue endif do 80 k = 1 , ny1 fxy ( 1 , k , kxp2 + 1 , l ) = 0. fxy ( 2 , k , kxp2 + 1 , l ) = 0. 80 continue 90 continue 100 continue we = 2.0 * float ( nx * ny ) * wp return end c----------------------------------------------------------------------- subroutine PPOISDX23 ( q , fxy , isign , ffd , ax , ay , affp , we , nx , ny , kstrt , ny2 1 d , kxp2 , j2blok , nyd ) c this subroutine solves 2d poisson's equation in fourier space for c force/charge (or convolution of electric field over particle shape) c with dirichlet boundary conditions (zero potential), c for distributed data.  Zeros out z component c fourier coefficients are constructed so that a real to complex fft c will perform the appropriate sin-cos, or cos-sin transform c for isign = 0,input: isign,ax,ay,affp,nx,ny,kstrt,ny2d,kxp2,j2blok,nyd c               output: ffd c for isign /= 0, input: q,ffd,isign,nx,ny,kstrt,ny2d,kxp2,j2blok,nyd c                output: fxy,we c approximate flop count is: 11*nx*ny c equation used is: c fx(kx,ky) = -sqrt(-1)*kx*g(kx,ky)*s(kx,ky)*q(kx,ky), c fy(kx,ky) = -sqrt(-1)*ky*g(kx,ky)*s(kx,ky)*q(kx,ky), c fz(kx,ky) = zero, c where kx = pi*j/nx, ky = pi*k/ny, and j,k = fourier mode numbers, c g(kx,ky) = (affp/(kx**2+ky**2))*s(kx,ky), c s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)/2) c q(k,j,l) = complex charge density for fourier mode (jj-1,k-1) c fxy(1,k,j,l) = x component of complex force/charge, c fxy(2,k,j,l) = y component of complex force/charge, c fxy(3,k,j,l) = zero, c all for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1) c if isign = 0, form factor array is prepared c ffd(k,2*j,l) = finite-size particle shape factor s c ffd(k,2*j-1,l) = potential green's function g c all for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1) c j2blok = number of data blocks c kxp2 = number of data values per block c kstrt = starting data block number c ax/ay = half-width of particle in x/y direction c affp = normalization constant = nx*ny/np, where np=number of particles c electric field energy is also calculated, using c we = 2*nx*ny*sum((affp/(kx**2+ky**2))*|q(kx,ky)*s(kx,ky)|**2) c nx/ny = system length in x/y direction c ny2d = first dimension of field arrays, must be >= 2*ny c nyd = first dimension of form factor array, must be >= ny double precision wp complex q , fxy , ffd , zero dimension q ( ny2d , kxp2 , j2blok ), fxy ( 3 , ny2d , kxp2 , j2blok ) dimension ffd ( nyd , kxp2 , j2blok ) ny2 = 2 * ny + 2 ks = kstrt - 2 dnx = 6.28318530717959 / float ( nx + nx ) dny = 6.28318530717959 / float ( ny + ny ) zero = cmplx ( 0. , 0. ) if ( isign . ne . 0 ) go to 40 if ( kstrt . gt . nx ) return c prepare form factor array do 30 l = 1 , j2blok joff = kxp2 * ( l + ks ) - 1 do 20 j = 1 , kxp2 dkx = dnx * float ( j + joff ) at1 = dkx * dkx at2 = ( dkx * ax ) ** 2 do 10 k = 1 , ny dky = dny * float ( k - 1 ) at3 = dky * dky + at1 at4 = exp ( - . 5 * (( dky * ay ) ** 2 + at2 )) if ( at3 . eq . 0. ) then ffd ( k , j , l ) = cmplx ( affp , 1. ) else ffd ( k , j , l ) = cmplx ( affp * at4 / at3 , at4 ) endif 10 continue 20 continue 30 continue return c calculate force/charge and sum field energy 40 wp = 0.0d0 if ( kstrt . gt . nx ) go to 90 do 80 l = 1 , j2blok c mode numbers kx > 0 and 0 < ky < ny joff = kxp2 * ( l + ks ) - 1 do 60 j = 1 , kxp2 dkx = dnx * float ( j + joff ) if (( j + joff ). gt . 0 ) then do 50 k = 2 , ny k1 = ny2 - k at1 = real ( ffd ( k , j , l )) * aimag ( ffd ( k , j , l )) at3 = - at1 * real ( q ( k , j , l )) at2 = dkx * at3 at3 = dny * float ( k - 1 ) * at3 fxy ( 1 , k , j , l ) = cmplx ( 0. , at2 ) fxy ( 2 , k , j , l ) = cmplx ( 0. , at3 ) fxy ( 3 , k , j , l ) = zero fxy ( 1 , k1 , j , l ) = cmplx ( 0. , - at2 ) fxy ( 2 , k1 , j , l ) = cmplx ( 0. , at3 ) fxy ( 3 , k1 , j , l ) = zero wp = wp + at1 * real ( q ( k , j , l )) ** 2 50 continue endif c mode numbers ky = 0, ny fxy ( 1 , 1 , j , l ) = zero fxy ( 2 , 1 , j , l ) = zero fxy ( 3 , 1 , j , l ) = zero fxy ( 1 , ny + 1 , j , l ) = zero fxy ( 2 , ny + 1 , j , l ) = zero fxy ( 3 , ny + 1 , j , l ) = zero 60 continue c mode number kx = 0 if (( l + ks ). eq . 0 ) then do 70 k = 2 , ny k1 = ny2 - k fxy ( 1 , k , 1 , l ) = zero fxy ( 2 , k , 1 , l ) = zero fxy ( 3 , k , 1 , l ) = zero fxy ( 1 , k1 , 1 , l ) = zero fxy ( 2 , k1 , 1 , l ) = zero fxy ( 3 , k1 , 1 , l ) = zero 70 continue endif 80 continue 90 continue we = 2.0 * float ( nx * ny ) * wp return end c----------------------------------------------------------------------- subroutine PPOISD23 ( q , fxy , isign , ffd , ax , ay , affp , we , nx , ny , kstrt , nyv , 1 kxp2 , j2blok , nyd ) c this subroutine solves 2d poisson's equation in fourier space for c force/charge (or convolution of electric field over particle shape) c with dirichlet boundary conditions (zero potential), c for distributed data.  Zeros out z component c fourier coefficients are constructed so that a real to complex fft c will perform the appropriate sin-cos, or cos-sin transform c for isign = 0,input: isign,ax,ay,affp,nx,ny,kstrt,ny2d,kxp2,j2blok,nyd c               output: ffd c for isign /= 0, input: q,ffd,isign,nx,ny,kstrt,ny2d,kxp2,j2blok,nyd c                output: fxy,we c approximate flop count is: 10*nx*ny c equation used is: c fx(kx,ky) = -sqrt(-1)*kx*g(kx,ky)*s(kx,ky)*q(kx,ky), c fy(kx,ky) = -sqrt(-1)*ky*g(kx,ky)*s(kx,ky)*q(kx,ky), c fz(kx,ky) = zero, c where kx = pi*j/nx, ky = pi*k/ny, and j,k = fourier mode numbers, c g(kx,ky) = (affp/(kx**2+ky**2))*s(kx,ky), c s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)/2) c q(k,j,l) = complex charge density for fourier mode (jj-1,k-1) c fxy(1,k,j,l) = x component of complex force/charge, c fxy(2,k,j,l) = y component of complex force/charge, c fxy(3,k,j,l) = zero, c all for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1) c if isign = 0, form factor array is prepared c ffd(k,2*j,l) = finite-size particle shape factor s c ffd(k,2*j-1,l) = potential green's function g c all for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1) c j2blok = number of data blocks c kxp2 = number of data values per block c kstrt = starting data block number c ax/ay = half-width of particle in x/y direction c affp = normalization constant = nx*ny/np, where np=number of particles c electric field energy is also calculated, using c we = 2*nx*ny*sum((affp/(kx**2+ky**2))*|q(kx,ky)*s(kx,ky)|**2) c nx/ny = system length in x/y direction c nyv = first dimension of field arrays, must be >= ny+1 c nyd = first dimension of form factor array, must be >= ny double precision wp complex ffd dimension q ( nyv , kxp2 + 1 , j2blok ), fxy ( 3 , nyv , kxp2 + 1 , j2blok ) dimension ffd ( nyd , kxp2 , j2blok ) ks = kstrt - 2 ny1 = ny + 1 dnx = 6.28318530717959 / float ( nx + nx ) dny = 6.28318530717959 / float ( ny + ny ) if ( isign . ne . 0 ) go to 40 if ( kstrt . gt . nx ) return c prepare form factor array do 30 l = 1 , j2blok joff = kxp2 * ( l + ks ) - 1 do 20 j = 1 , kxp2 dkx = dnx * float ( j + joff ) at1 = dkx * dkx at2 = ( dkx * ax ) ** 2 do 10 k = 1 , ny dky = dny * float ( k - 1 ) at3 = dky * dky + at1 at4 = exp ( - . 5 * (( dky * ay ) ** 2 + at2 )) if ( at3 . eq . 0. ) then ffd ( k , j , l ) = cmplx ( affp , 1. ) else ffd ( k , j , l ) = cmplx ( affp * at4 / at3 , at4 ) endif 10 continue 20 continue 30 continue return c calculate force/charge and sum field energy 40 wp = 0.0d0 if ( kstrt . gt . nx ) go to 100 do 90 l = 1 , j2blok c mode numbers kx > 0 and 0 < ky < ny joff = kxp2 * ( l + ks ) - 1 do 60 j = 1 , kxp2 dkx = dnx * float ( j + joff ) if (( j + joff ). gt . 0 ) then do 50 k = 2 , ny at1 = real ( ffd ( k , j , l )) * aimag ( ffd ( k , j , l )) at3 = - at1 * q ( k , j , l ) at2 = dkx * at3 at3 = dny * float ( k - 1 ) * at3 fxy ( 1 , k , j , l ) = at2 fxy ( 2 , k , j , l ) = at3 fxy ( 3 , k , j , l ) = 0. wp = wp + at1 * q ( k , j , l ) ** 2 50 continue endif c mode numbers ky = 0, ny fxy ( 1 , 1 , j , l ) = 0. fxy ( 2 , 1 , j , l ) = 0. fxy ( 3 , 1 , j , l ) = 0. fxy ( 1 , ny + 1 , j , l ) = 0. fxy ( 2 , ny + 1 , j , l ) = 0. fxy ( 3 , ny + 1 , j , l ) = 0. 60 continue c mode number kx = 0 if (( l + ks ). eq . 0 ) then do 70 k = 2 , ny fxy ( 1 , k , 1 , l ) = 0. fxy ( 2 , k , 1 , l ) = 0. fxy ( 3 , k , 1 , l ) = 0. 70 continue endif do 80 k = 1 , ny1 fxy ( 1 , k , kxp2 + 1 , l ) = 0. fxy ( 2 , k , kxp2 + 1 , l ) = 0. fxy ( 3 , k , kxp2 + 1 , l ) = 0. 80 continue 90 continue 100 continue we = 2.0 * float ( nx * ny ) * wp return end c----------------------------------------------------------------------- subroutine PBPOISD22 ( cu , bxy , bz , isign , ffd , ax , ay , affp , ci , wm , nx , ny , ks 1 trt , nyv , kxp2 , j2blok , nyd ) c this subroutine solves 2d poisson's equation in fourier space for c magnetic field (or convolution of magnetic field over particle shape) c or for vector potential, or provides a smoothing function, c with dirichlet boundary conditions (zero potential), c for distributed data. c fourier coefficients are constructed so that a real to complex fft c will perform the appropriate sin-cos, or cos-sin transform c for isign = 0, input: isign,ax,ay,affp,nx,ny,kstrt,ny2d,kxp,j2blok,nyd c output: ffd c for isign = -1, input:cu,ffd,isign,ci,nx,ny,kstrt,ny2d,kxp2,j2blok,nyd c output: bz,wm c approximate flop count is: 15*nxc*nyc + 7*(nxc + nyc) c for isign = 1, input: cu,ffd,isign,ci,nx,ny,kstrt,ny2d,kxp2,j2blok,nyd c output: bxy,wm c approximate flop count is: 10*nxc*nyc + 6*(nxc + nyc) c for isign = 2, input: cu,ffd,isign,nx,ny,kstrt,ny2d,kxp2,j2blok,nyd c output: bxy c approximate flop count is: 2*nxc*nyc + 1*(nxc + nyc) c where nxc = (nx/2-1)/nvp, nyc = ny/2 - 1, and nvp = number of procs c if isign = 0, form factor array is prepared c if isign < 0, magnetic field is calculated using the equations: c bz(kx,ky) = ci*ci*sqrt(-1)*g(kx,ky)*(kx*cuy(kx,ky)-ky*cux(kx,ky))* c             s(kx,ky), c where kx = pi*j/nx, ky = pi*k/ny, and j,k = fourier mode numbers, c g(kx,ky) = (affp/(kx**2+ky**2))*s(kx,ky), c s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)/2) c if isign = 1, vector potential is calculated using the equation: c bx(kx,ky) = ci*ci*g(kx,ky)*cux(kx,ky) c by(kx,ky) = ci*ci*g(kx,ky)*cuy(kx,ky) c if isign = 2, smoothing is calculated using the equation: c bx(kx,ky) = cux(kx,ky)*s(kx,ky) c by(kx,ky) = cuy(kx,ky)*s(kx,ky) c cu(i,k,j,l) = i-th component of complex current density and c bxy(i,k,j,l) = i-th component of complex vector potential, c bz(k,j,l) = i-th component of complex magnetic field, c for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1) c j2blok = number of data blocks c kxp2 = number of data values per block c kstrt = starting data block number c aimag(ffd(k,j,l)) = finite-size particle shape factor s c real(ffd(k,j,l)) = potential green's function g c for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1) c ax/ay = half-width of particle in x/y direction c affp = normalization constant = nx*ny/np, where np=number of particles c ci = reciprical of velocity of light c magnetic field energy is also calculated, using c wm = nx*ny*nz*sum((affp/(kx**2+ky**2+kz**2))*ci*ci c    |cu(kx,ky,kz)*s(kx,ky,kz)|**2) c this expression is valid only if the current is divergence-free c nx/ny = system length in x/y direction c nyv = first dimension of field arrays, must be >= ny+1 c nyd = first dimension of form factor array, must be >= ny double precision wp complex ffd dimension cu ( 2 , nyv , kxp2 + 1 , j2blok ), bxy ( 2 , nyv , kxp2 + 1 , j2blok ) dimension bz ( nyv , kxp2 + 1 , j2blok ) dimension ffd ( nyd , kxp2 , j2blok ) ks = kstrt - 2 ny1 = ny + 1 dnx = 6.28318530717959 / float ( nx + nx ) dny = 6.28318530717959 / float ( ny + ny ) ci2 = ci * ci if ( isign . ne . 0 ) go to 40 if ( kstrt . gt . nx ) return c prepare form factor array do 30 l = 1 , j2blok joff = kxp2 * ( l + ks ) - 1 do 20 j = 1 , kxp2 dkx = dnx * float ( j + joff ) at1 = dkx * dkx at2 = ( dkx * ax ) ** 2 do 10 k = 1 , ny dky = dny * float ( k - 1 ) at3 = dky * dky + at1 at4 = exp ( - . 5 * (( dky * ay ) ** 2 + at2 )) if ( at3 . eq . 0. ) then ffd ( k , j , l ) = cmplx ( affp , 1. ) else ffd ( k , j , l ) = cmplx ( affp * at4 / at3 , at4 ) endif 10 continue 20 continue 30 continue return 40 if ( isign . gt . 0 ) go to 110 c calculate magnetic field and sum field energy wp = 0.0d0 if ( kstrt . gt . nx ) go to 100 do 90 l = 1 , j2blok c mode numbers 0 < kx < nx and 0 < ky < ny joff = kxp2 * ( l + ks ) - 1 do 60 j = 1 , kxp2 dkx = dnx * float ( j + joff ) if (( j + joff ). gt . 0 ) then do 50 k = 2 , ny dky = dny * float ( k - 1 ) at1 = ci2 * real ( ffd ( k , j , l )) * aimag ( ffd ( k , j , l )) at2 = dky * at1 at3 = dkx * at1 bz ( k , j , l ) = at3 * cu ( 2 , k , j , l ) - at2 * cu ( 1 , k , j , l ) wp = wp + 2.0 * at1 * ( cu ( 1 , k , j , l ) ** 2 + cu ( 2 , k , j , l ) ** 2 ) 50 continue c mode numbers ky = 0, ny at1 = ci2 * real ( ffd ( 1 , j , l )) * aimag ( ffd ( 1 , j , l )) at2 = dkx * at1 bz ( 1 , j , l ) = at2 * cu ( 2 , 1 , j , l ) wp = wp + at1 * cu ( 2 , 1 , j , l ) ** 2 endif bz ( ny + 1 , j , l ) = 0. 60 continue c mode numbers kx = 0, nx/2 if (( l + ks ). eq . 0 ) then do 70 k = 2 , ny dky = dny * float ( k - 1 ) at1 = ci2 * real ( ffd ( k , 1 , l )) * aimag ( ffd ( k , 1 , l )) at2 = dky * at1 bz ( k , 1 , l ) = - at2 * cu ( 1 , k , 1 , l ) wp = wp + at1 * cu ( 1 , k , 1 , l ) ** 2 70 continue bz ( 1 , 1 , l ) = 0. endif do 80 k = 1 , ny1 bz ( k , kxp2 + 1 , l ) = 0. 80 continue 90 continue 100 continue wm = float ( nx * ny ) * wp return c calculate vector potential and sum field energy 110 if ( isign . gt . 1 ) go to 180 wp = 0.0d0 if ( kstrt . gt . nx ) go to 170 do 160 l = 1 , j2blok c mode numbers 0 < kx < nx and 0 < ky < ny joff = kxp2 * ( l + ks ) - 1 do 130 j = 1 , kxp2 if (( j + joff ). gt . 0 ) then do 120 k = 2 , ny at2 = ci2 * real ( ffd ( k , j , l )) at1 = at2 * aimag ( ffd ( k , j , l )) c         bxy(1,k,j,l) = at2*cu(1,k,j,l) c         bxy(2,k,j,l) = at2*cu(2,k,j,l) bxy ( 1 , k , j , l ) = at1 * cu ( 1 , k , j , l ) bxy ( 2 , k , j , l ) = at1 * cu ( 2 , k , j , l ) wp = wp + 2.0 * at1 * ( cu ( 1 , k , j , l ) ** 2 + cu ( 2 , k , j , l ) ** 2 ) 120 continue c mode numbers ky = 0, ny at2 = ci2 * real ( ffd ( 1 , j , l )) at1 = at2 * aimag ( ffd ( 1 , j , l )) bxy ( 1 , 1 , j , l ) = 0. c         bxy(2,1,j,l) = at2*cu(2,1,j,l) bxy ( 2 , 1 , j , l ) = at1 * cu ( 2 , 1 , j , l ) wp = wp + at1 * cu ( 2 , 1 , j , l ) ** 2 endif bxy ( 1 , ny + 1 , j , l ) = 0. bxy ( 2 , ny + 1 , j , l ) = 0. 130 continue c mode numbers kx = 0, nx/2 if (( l + ks ). eq . 0 ) then do 140 k = 2 , ny at2 = ci2 * real ( ffd ( k , 1 , l )) at1 = at2 * aimag ( ffd ( k , 1 , l )) c         bxy(1,k,1,l) = at2*cu(1,k,1,l) bxy ( 1 , k , 1 , l ) = at1 * cu ( 1 , k , 1 , l ) bxy ( 2 , k , 1 , l ) = 0. wp = wp + at1 * cu ( 1 , k , 1 , l ) ** 2 140 continue bxy ( 1 , 1 , 1 , l ) = 0. bxy ( 2 , 1 , 1 , l ) = 0. endif do 150 k = 1 , ny1 bxy ( 1 , k , kxp2 + 1 , l ) = 0. bxy ( 2 , k , kxp2 + 1 , l ) = 0. 150 continue 160 continue 170 continue wm = float ( nx * ny ) * wp return c calculate smoothing 180 if ( kstrt . gt . nx ) go to 240 do 230 l = 1 , j2blok c mode numbers 0 < kx < nx and 0 < ky < ny joff = kxp2 * ( l + ks ) - 1 do 200 j = 1 , kxp2 if (( j + joff ). gt . 0 ) then do 190 k = 2 , ny at1 = aimag ( ffd ( k , j , l )) bxy ( 1 , k , j , l ) = at1 * cu ( 1 , k , j , l ) bxy ( 2 , k , j , l ) = at1 * cu ( 2 , k , j , l ) 190 continue c mode numbers ky = 0, ny at1 = aimag ( ffd ( 1 , j , l )) bxy ( 1 , 1 , j , l ) = 0. bxy ( 2 , 1 , j , l ) = at1 * cu ( 2 , 1 , j , l ) endif bxy ( 1 , ny + 1 , j , l ) = 0. bxy ( 2 , ny + 1 , j , l ) = 0. 200 continue c mode numbers kx = 0, nx/2 if (( l + ks ). eq . 0 ) then do 210 k = 2 , ny at1 = aimag ( ffd ( k , 1 , l )) bxy ( 1 , k , 1 , l ) = at1 * cu ( 1 , k , 1 , l ) bxy ( 2 , k , 1 , l ) = 0. 210 continue bxy ( 1 , 1 , 1 , l ) = 0. bxy ( 2 , 1 , 1 , l ) = 0. endif do 220 k = 1 , ny1 bxy ( 1 , k , kxp2 + 1 , l ) = 0. bxy ( 2 , k , kxp2 + 1 , l ) = 0. 220 continue 230 continue 240 continue return end c----------------------------------------------------------------------- subroutine PBPOISD23 ( cu , bxy , isign , ffd , ax , ay , affp , ci , wm , nx , ny , kstrt 1 , nyv , kxp2 , j2blok , nyd ) c this subroutine solves 2-1/2d poisson's equation in fourier space for c magnetic field (or convolution of magnetic field over particle shape) c or for vector potential, or provides a smoothing function, c with dirichlet boundary conditions (zero potential), c for distributed data. c fourier coefficients are constructed so that a real to complex fft c will perform the appropriate sin-cos, or cos-sin transform c for isign = 0, input: isign,ax,ay,affp,nx,ny,kstrt,ny2d,kxp,j2blok,nyd c output: ffd c for isign = -1, input:cu,ffd,isign,ci,nx,ny,kstrt,ny2d,kxp2,j2blok,nyd c output: bxy,wm c approximate flop count is: 20*nxc*nyc + 8*(nxc + nyc) c for isign = 1, input: cu,ffd,isign,ci,nx,ny,kstrt,ny2d,kxp2,j2blok,nyd c output: bxy,wm c approximate flop count is: 13*nxc*nyc + 8*(nxc + nyc) c for isign = 2, input: cu,ffd,isign,nx,ny,kstrt,ny2d,kxp2,j2blok,nyd c output: bxy c approximate flop count is: 3*nxc*nyc + 1*(nxc + nyc) c where nxc = (nx/2-1)/nvp, nyc = ny/2 - 1, and nvp = number of procs c if isign = 0, form factor array is prepared c if isign < 0, magnetic field is calculated using the equations: c bx(kx,ky) = ci*ci*sqrt(-1)*g(kx,ky)*ky*cuz(kx,ky)*s(kx,ky), c by(kx,ky) = -ci*ci*sqrt(-1)*g(kx,ky)*kx*cuz(kx,ky)*s(kx,ky), c bz(kx,ky) = ci*ci*sqrt(-1)*g(kx,ky)*(kx*cuy(kx,ky)-ky*cux(kx,ky))* c             s(kx,ky), c where kx = pi*j/nx, ky = pi*k/ny, and j,k = fourier mode numbers, c g(kx,ky) = (affp/(kx**2+ky**2))*s(kx,ky), c s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)/2) c if isign = 1, vector potential is calculated using the equation: c bx(kx,ky) = ci*ci*g(kx,ky)*cux(kx,ky) c by(kx,ky) = ci*ci*g(kx,ky)*cuy(kx,ky) c bz(kx,ky) = ci*ci*g(kx,ky)*cuz(kx,ky) c if isign = 2, smoothing is calculated using the equation: c bx(kx,ky) = cux(kx,ky)*s(kx,ky) c by(kx,ky) = cuy(kx,ky)*s(kx,ky) c bz(kx,ky) = cuz(kx,ky)*s(kx,ky) c cu(i,k,j,l) = i-th component of complex current density and c bxy(i,k,j,l) = i-th component of complex magnetic field, c for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1) c j2blok = number of data blocks c kxp2 = number of data values per block c kstrt = starting data block number c aimag(ffd(k,j,l)) = finite-size particle shape factor s c real(ffd(k,j,l)) = potential green's function g c for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1) c ax/ay = half-width of particle in x/y direction c affp = normalization constant = nx*ny/np, where np=number of particles c ci = reciprical of velocity of light c magnetic field energy is also calculated, using c wm = nx*ny*nz*sum((affp/(kx**2+ky**2+kz**2))*ci*ci c    |cu(kx,ky,kz)*s(kx,ky,kz)|**2) c this expression is valid only if the current is divergence-free c nx/ny = system length in x/y direction c nyv = first dimension of field arrays, must be >= ny+1 c nyd = first dimension of form factor array, must be >= ny double precision wp complex ffd dimension cu ( 3 , nyv , kxp2 + 1 , j2blok ), bxy ( 3 , nyv , kxp2 + 1 , j2blok ) dimension ffd ( nyd , kxp2 , j2blok ) ks = kstrt - 2 ny1 = ny + 1 dnx = 6.28318530717959 / float ( nx + nx ) dny = 6.28318530717959 / float ( ny + ny ) ci2 = ci * ci if ( isign . ne . 0 ) go to 40 if ( kstrt . gt . nx ) return c prepare form factor array do 30 l = 1 , j2blok joff = kxp2 * ( l + ks ) - 1 do 20 j = 1 , kxp2 dkx = dnx * float ( j + joff ) at1 = dkx * dkx at2 = ( dkx * ax ) ** 2 do 10 k = 1 , ny dky = dny * float ( k - 1 ) at3 = dky * dky + at1 at4 = exp ( - . 5 * (( dky * ay ) ** 2 + at2 )) if ( at3 . eq . 0. ) then ffd ( k , j , l ) = cmplx ( affp , 1. ) else ffd ( k , j , l ) = cmplx ( affp * at4 / at3 , at4 ) endif 10 continue 20 continue 30 continue return 40 if ( isign . gt . 0 ) go to 110 c calculate magnetic field and sum field energy wp = 0.0d0 if ( kstrt . gt . nx ) go to 100 do 90 l = 1 , j2blok c mode numbers 0 < kx < nx and 0 < ky < ny joff = kxp2 * ( l + ks ) - 1 do 60 j = 1 , kxp2 dkx = dnx * float ( j + joff ) if (( j + joff ). gt . 0 ) then do 50 k = 2 , ny dky = dny * float ( k - 1 ) at1 = ci2 * real ( ffd ( k , j , l )) * aimag ( ffd ( k , j , l )) at2 = dky * at1 at3 = dkx * at1 bxy ( 1 , k , j , l ) = at2 * cu ( 3 , k , j , l ) bxy ( 2 , k , j , l ) = - at3 * cu ( 3 , k , j , l ) bxy ( 3 , k , j , l ) = at3 * cu ( 2 , k , j , l ) - at2 * cu ( 1 , k , j , l ) wp = wp + 2.0 * at1 * ( cu ( 1 , k , j , l ) ** 2 + cu ( 2 , k , j , l ) ** 2 + cu ( 3 , k , j , l 1 ) ** 2 ) 50 continue c mode numbers ky = 0, ny at1 = ci2 * real ( ffd ( 1 , j , l )) * aimag ( ffd ( 1 , j , l )) at2 = dkx * at1 bxy ( 1 , 1 , j , l ) = 0. bxy ( 2 , 1 , j , l ) = 0. bxy ( 3 , 1 , j , l ) = at2 * cu ( 2 , 1 , j , l ) wp = wp + at1 * ( cu ( 2 , 1 , j , l ) ** 2 + cu ( 3 , 1 , j , l ) ** 2 ) endif bxy ( 1 , ny + 1 , j , l ) = 0. bxy ( 2 , ny + 1 , j , l ) = 0. bxy ( 3 , ny + 1 , j , l ) = 0. 60 continue c mode numbers kx = 0, nx/2 if (( l + ks ). eq . 0 ) then do 70 k = 2 , ny dky = dny * float ( k - 1 ) at1 = ci2 * real ( ffd ( k , 1 , l )) * aimag ( ffd ( k , 1 , l )) at2 = dky * at1 bxy ( 1 , k , 1 , l ) = 0. bxy ( 2 , k , 1 , l ) = 0. bxy ( 3 , k , 1 , l ) = - at2 * cu ( 1 , k , 1 , l ) wp = wp + at1 * ( cu ( 1 , k , 1 , l ) ** 2 + cu ( 3 , k , 1 , l ) ** 2 ) 70 continue bxy ( 1 , 1 , 1 , l ) = 0. bxy ( 2 , 1 , 1 , l ) = 0. bxy ( 3 , 1 , 1 , l ) = 0. endif do 80 k = 1 , ny1 bxy ( 1 , k , kxp2 + 1 , l ) = 0. bxy ( 2 , k , kxp2 + 1 , l ) = 0. bxy ( 3 , k , kxp2 + 1 , l ) = 0. 80 continue 90 continue 100 continue wm = float ( nx * ny ) * wp return c calculate vector potential and sum field energy 110 if ( isign . gt . 1 ) go to 180 wp = 0.0d0 if ( kstrt . gt . nx ) go to 170 do 160 l = 1 , j2blok c mode numbers 0 < kx < nx and 0 < ky < ny joff = kxp2 * ( l + ks ) - 1 do 130 j = 1 , kxp2 if (( j + joff ). gt . 0 ) then do 120 k = 2 , ny at2 = ci2 * real ( ffd ( k , j , l )) at1 = at2 * aimag ( ffd ( k , j , l )) c         bxy(1,k,j,l) = at2*cu(1,k,j,l) c         bxy(2,k,j,l) = at2*cu(2,k,j,l) c         bxy(3,k,j,l) = at2*cu(3,k,j,l) bxy ( 1 , k , j , l ) = at1 * cu ( 1 , k , j , l ) bxy ( 2 , k , j , l ) = at1 * cu ( 2 , k , j , l ) bxy ( 3 , k , j , l ) = at1 * cu ( 3 , k , j , l ) wp = wp + 2.0 * at1 * ( cu ( 1 , k , j , l ) ** 2 + cu ( 2 , k , j , l ) ** 2 + cu ( 3 , k , j , l 1 ) ** 2 ) 120 continue c mode numbers ky = 0, ny at2 = ci2 * real ( ffd ( 1 , j , l )) at1 = at2 * aimag ( ffd ( 1 , j , l )) bxy ( 1 , 1 , j , l ) = 0. c         bxy(2,1,j,l) = at2*cu(2,1,j,l) bxy ( 2 , 1 , j , l ) = at1 * cu ( 2 , 1 , j , l ) bxy ( 3 , 1 , j , l ) = 0. wp = wp + at1 * ( cu ( 2 , 1 , j , l ) ** 2 + cu ( 3 , 1 , j , l ) ** 2 ) endif bxy ( 1 , ny + 1 , j , l ) = 0. bxy ( 2 , ny + 1 , j , l ) = 0. bxy ( 3 , ny + 1 , j , l ) = 0. 130 continue c mode numbers kx = 0, nx/2 if (( l + ks ). eq . 0 ) then do 140 k = 2 , ny at2 = ci2 * real ( ffd ( k , 1 , l )) at1 = at2 * aimag ( ffd ( k , 1 , l )) c         bxy(1,k,1,l) = at2*cu(1,k,1,l) bxy ( 1 , k , 1 , l ) = at1 * cu ( 1 , k , 1 , l ) bxy ( 2 , k , 1 , l ) = 0. bxy ( 3 , k , 1 , l ) = 0. wp = wp + at1 * ( cu ( 1 , k , 1 , l ) ** 2 + cu ( 3 , k , 1 , l ) ** 2 ) 140 continue bxy ( 1 , 1 , 1 , l ) = 0. bxy ( 2 , 1 , 1 , l ) = 0. bxy ( 3 , 1 , 1 , l ) = 0. endif do 150 k = 1 , ny1 bxy ( 1 , k , kxp2 + 1 , l ) = 0. bxy ( 2 , k , kxp2 + 1 , l ) = 0. bxy ( 3 , k , kxp2 + 1 , l ) = 0. 150 continue 160 continue 170 continue wm = float ( nx * ny ) * wp return c calculate smoothing 180 if ( kstrt . gt . nx ) go to 240 do 230 l = 1 , j2blok c mode numbers 0 < kx < nx and 0 < ky < ny joff = kxp2 * ( l + ks ) - 1 do 200 j = 1 , kxp2 if (( j + joff ). gt . 0 ) then do 190 k = 2 , ny at1 = aimag ( ffd ( k , j , l )) bxy ( 1 , k , j , l ) = at1 * cu ( 1 , k , j , l ) bxy ( 2 , k , j , l ) = at1 * cu ( 2 , k , j , l ) bxy ( 3 , k , j , l ) = at1 * cu ( 3 , k , j , l ) 190 continue c mode numbers ky = 0, ny at1 = aimag ( ffd ( 1 , j , l )) bxy ( 1 , 1 , j , l ) = 0. bxy ( 2 , 1 , j , l ) = at1 * cu ( 2 , 1 , j , l ) bxy ( 3 , 1 , j , l ) = 0. endif bxy ( 1 , ny + 1 , j , l ) = 0. bxy ( 2 , ny + 1 , j , l ) = 0. bxy ( 3 , ny + 1 , j , l ) = 0. 200 continue c mode numbers kx = 0, nx/2 if (( l + ks ). eq . 0 ) then do 210 k = 2 , ny at1 = aimag ( ffd ( k , 1 , l )) bxy ( 1 , k , 1 , l ) = at1 * cu ( 1 , k , 1 , l ) bxy ( 2 , k , 1 , l ) = 0. bxy ( 3 , k , 1 , l ) = 0. 210 continue bxy ( 1 , 1 , 1 , l ) = 0. bxy ( 2 , 1 , 1 , l ) = 0. bxy ( 3 , 1 , 1 , l ) = 0. endif do 220 k = 1 , ny1 bxy ( 1 , k , kxp2 + 1 , l ) = 0. bxy ( 2 , k , kxp2 + 1 , l ) = 0. bxy ( 3 , k , kxp2 + 1 , l ) = 0. 220 continue 230 continue 240 continue return end c----------------------------------------------------------------------- subroutine PBPOISD22N_QP ( cu , dcu , amu , bxy , bz , isign , ffd , ax , ay , affp , ci 1 , wm , nx , ny , kstrt , nyv , kxp2 , j2blok , nyd , aa , dex ) c this subroutine solves 2d poisson's equation in fourier space for c magnetic field (or convolution of magnetic field over particle shape) c or for vector potential, or provides a smoothing function, c with dirichlet boundary conditions (zero potential), c for distributed data. c fourier coefficients are constructed so that a real to complex fft c will perform the appropriate sin-cos, or cos-sin transform c for isign = 0, input: isign,ax,ay,affp,nx,ny,kstrt,ny2d,kxp,j2blok,nyd c output: ffd c for isign = -1, input:cu,ffd,isign,ci,nx,ny,kstrt,ny2d,kxp2,j2blok,nyd c output: bz,wm c approximate flop count is: 15*nxc*nyc + 7*(nxc + nyc) c for isign = 1, input: cu,ffd,isign,ci,nx,ny,kstrt,ny2d,kxp2,j2blok,nyd c output: bxy,wm c approximate flop count is: 10*nxc*nyc + 6*(nxc + nyc) c for isign = 2, input: cu,ffd,isign,nx,ny,kstrt,ny2d,kxp2,j2blok,nyd c output: bxy c approximate flop count is: 2*nxc*nyc + 1*(nxc + nyc) c where nxc = (nx/2-1)/nvp, nyc = ny/2 - 1, and nvp = number of procs c if isign = 0, form factor array is prepared c if isign < 0, magnetic field is calculated using the equations: c bz(kx,ky) = ci*ci*sqrt(-1)*g(kx,ky)*(kx*cuy(kx,ky)-ky*cux(kx,ky))* c             s(kx,ky), c where kx = pi*j/nx, ky = pi*k/ny, and j,k = fourier mode numbers, c g(kx,ky) = (affp/(kx**2+ky**2))*s(kx,ky), c s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)/2) c if isign = 1, vector potential is calculated using the equation: c bx(kx,ky) = ci*ci*g(kx,ky)*cux(kx,ky) c by(kx,ky) = ci*ci*g(kx,ky)*cuy(kx,ky) c if isign = 2, smoothing is calculated using the equation: c bx(kx,ky) = cux(kx,ky)*s(kx,ky) c by(kx,ky) = cuy(kx,ky)*s(kx,ky) c cu(i,k,j,l) = i-th component of complex current density and c bxy(i,k,j,l) = i-th component of complex vector potential, c bz(k,j,l) = i-th component of complex magnetic field, c for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1) c j2blok = number of data blocks c kxp2 = number of data values per block c kstrt = starting data block number c aimag(ffd(k,j,l)) = finite-size particle shape factor s c real(ffd(k,j,l)) = potential green's function g c for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1) c ax/ay = half-width of particle in x/y direction c affp = normalization constant = nx*ny/np, where np=number of particles c ci = reciprical of velocity of light c magnetic field energy is also calculated, using c wm = nx*ny*nz*sum((affp/(kx**2+ky**2+kz**2))*ci*ci c    |cu(kx,ky,kz)*s(kx,ky,kz)|**2) c this expression is valid only if the current is divergence-free c nx/ny = system length in x/y direction c nyv = first dimension of field arrays, must be >= ny+1 c nyd = first dimension of form factor array, must be >= ny double precision wp complex ffd real cu , dcu , amu , dex , idex dimension cu ( 3 , nyv , kxp2 + 1 , j2blok ), bxy ( 2 , nyv , kxp2 + 1 , j2blok ) dimension dcu ( 2 , nyv , kxp2 + 1 , j2blok ), amu ( 3 , nyv , kxp2 + 1 , j2blok ) dimension bz ( nyv , kxp2 + 1 , j2blok ) dimension ffd ( nyd , kxp2 , j2blok ) idex = 1.0 / dex ks = kstrt - 2 ny1 = ny + 1 dnx = 6.28318530717959 / float ( nx + nx ) dny = 6.28318530717959 / float ( ny + ny ) ci2 = ci * ci if ( isign . ne . 0 ) go to 40 if ( kstrt . gt . nx ) return c prepare form factor array do 30 l = 1 , j2blok joff = kxp2 * ( l + ks ) - 1 do 20 j = 1 , kxp2 dkx = dnx * float ( j + joff ) at1 = dkx * dkx at2 = ( dkx * ax ) ** 2 do 10 k = 1 , ny dky = dny * float ( k - 1 ) at3 = dky * dky + at1 at4 = exp ( - . 5 * (( dky * ay ) ** 2 + at2 )) if ( at3 . eq . 0. ) then ffd ( k , j , l ) = cmplx ( affp , 1. ) else ffd ( k , j , l ) = cmplx ( affp * at4 / at3 , at4 ) endif 10 continue 20 continue 30 continue return 40 if ( isign . gt . 0 ) go to 110 c calculate magnetic field and sum field energy wp = 0.0d0 if ( kstrt . gt . nx ) go to 100 do 90 l = 1 , j2blok c mode numbers 0 < kx < nx and 0 < ky < ny joff = kxp2 * ( l + ks ) - 1 do 60 j = 1 , kxp2 dkx = dnx * float ( j + joff ) if (( j + joff ). gt . 0 ) then do 50 k = 2 , ny dky = dny * float ( k - 1 ) at1 = ci2 * real ( ffd ( k , j , l )) * aimag ( ffd ( k , j , l )) at2 = dky * at1 at3 = dkx * at1 bz ( k , j , l ) = at3 * cu ( 2 , k , j , l ) - at2 * cu ( 1 , k , j , l ) wp = wp + 2.0 * at1 * ( cu ( 1 , k , j , l ) ** 2 + cu ( 2 , k , j , l ) ** 2 ) 50 continue c mode numbers ky = 0, ny at1 = ci2 * real ( ffd ( 1 , j , l )) * aimag ( ffd ( 1 , j , l )) at2 = dkx * at1 bz ( 1 , j , l ) = at2 * cu ( 2 , 1 , j , l ) wp = wp + at1 * cu ( 2 , 1 , j , l ) ** 2 endif bz ( ny + 1 , j , l ) = 0. 60 continue c mode numbers kx = 0, nx/2 if (( l + ks ). eq . 0 ) then do 70 k = 2 , ny dky = dny * float ( k - 1 ) at1 = ci2 * real ( ffd ( k , 1 , l )) * aimag ( ffd ( k , 1 , l )) at2 = dky * at1 bz ( k , 1 , l ) = - at2 * cu ( 1 , k , 1 , l ) wp = wp + at1 * cu ( 1 , k , 1 , l ) ** 2 70 continue bz ( 1 , 1 , l ) = 0. endif do 80 k = 1 , ny1 bz ( k , kxp2 + 1 , l ) = 0. 80 continue 90 continue 100 continue wm = float ( nx * ny ) * wp return c calculate vector potential and sum field energy 110 if ( isign . gt . 1 ) go to 180 wp = 0.0d0 if ( kstrt . gt . nx ) go to 170 do 160 l = 1 , j2blok c mode numbers 0 < kx < nx and 0 < ky < ny joff = kxp2 * ( l + ks ) - 1 do 130 j = 1 , kxp2 dkx = dnx * float ( j + joff ) if (( j + joff ). gt . 0 ) then do 120 k = 2 , ny dky = dny * float ( k - 1 ) dcu ( 1 , k , j , l ) = - dcu ( 1 , k , j , l ) + dkx * amu ( 1 , k , j , l ) - dky * amu ( 3 , k , j , l ) aat1 = dcu ( 1 , k , j , l ) - dkx * cu ( 3 , k , j , l ) * idex dcu ( 2 , k , j , l ) = - dcu ( 2 , k , j , l ) - dkx * amu ( 3 , k , j , l ) + dky * amu ( 2 , k , j , l ) aat2 = dcu ( 2 , k , j , l ) - dky * cu ( 3 , k , j , l ) * idex c------------------------------------------------------- c         at2 = real(ffd(k,j,l)) c         at2 = ci2*at2/(1+aa*at2) c         at1 = at2*aimag(ffd(k,j,l)) c         bxy(1,k,j,l) = at2*cu(1,k,j,l) c         bxy(2,k,j,l) = at2*cu(2,k,j,l) c------------------------------------------------------- c         at2 = real(ffd(k,j,l)) c         at1 = at2*aimag(ffd(k,j,l)) c         at2 = at2/aimag(ffd(k,j,l))*aa c         bxy(1,k,j,l) = (at1*cu(1,k,j,l)+at2*bxy(1,k,j,l))/(1+at2) c         bxy(2,k,j,l) = (at1*cu(2,k,j,l)+at2*bxy(2,k,j,l))/(1+at2) c------------------------------------------------------- at2 = real ( ffd ( k , j , l )) at2 = ci2 * at2 / ( 1 + aa * at2 ) at1 = at2 * aimag ( ffd ( k , j , l )) bxy ( 1 , k , j , l ) = at1 * aat1 + aa * at2 * bxy ( 1 , k , j , l ) bxy ( 2 , k , j , l ) = at1 * aat2 + aa * at2 * bxy ( 2 , k , j , l ) wp = wp + 2.0 * at1 * ( dcu ( 1 , k , j , l ) ** 2 + dcu ( 2 , k , j , l ) ** 2 ) 120 continue c mode numbers ky = 0, ny c----------------------------------------------------------------- c         at2 = real(ffd(k,j,l)) c         at2 = ci2*at2/(1+aa*at2) c         at1 = at2*aimag(ffd(1,j,l)) c         bxy(1,1,j,l) = 0. c         bxy(2,1,j,l) = at2*cu(2,1,j,l) c----------------------------------------------------------------- c         at2 = real(ffd(k,j,l)) c         at1 = at2*aimag(ffd(k,j,l)) c         at2 = at2/aimag(ffd(k,j,l))*aa c         bxy(1,1,j,l) = 0. c         bxy(2,1,j,l) = (at1*cu(2,1,j,l)+at2*bxy(2,1,j,l))/(1+at2) c----------------------------------------------------------------- dcu ( 1 , 1 , j , l ) = - dcu ( 1 , 1 , j , l ) + dkx * amu ( 1 , 1 , j , l ) dcu ( 2 , 1 , j , l ) = - dcu ( 2 , 1 , j , l ) - dkx * amu ( 3 , 1 , j , l ) at2 = real ( ffd ( 1 , j , l )) at2 = ci2 * at2 / ( 1 + aa * at2 ) at1 = at2 * aimag ( ffd ( 1 , j , l )) bxy ( 1 , 1 , j , l ) = 0. bxy ( 2 , 1 , j , l ) = at1 * dcu ( 2 , 1 , j , l ) + aa * at2 * bxy ( 2 , 1 , j , l ) wp = wp + at1 * dcu ( 2 , 1 , j , l ) ** 2 endif bxy ( 1 , ny + 1 , j , l ) = 0. bxy ( 2 , ny + 1 , j , l ) = 0. 130 continue c mode numbers kx = 0, nx/2 if (( l + ks ). eq . 0 ) then do 140 k = 2 , ny c----------------------------------------------------------------- c         at2 = real(ffd(k,j,l)) c         at2 = ci2*at2/(1+aa*at2) c         at1 = at2*aimag(ffd(k,1,l)) c         bxy(1,k,1,l) = at2*cu(1,k,1,l) c         bxy(2,k,1,l) = 0. c----------------------------------------------------------------- c         at2 = real(ffd(k,j,l)) c         at1 = at2*aimag(ffd(k,j,l)) c         at2 = at2/aimag(ffd(k,j,l))*aa c         bxy(1,k,1,l) = (at1*cu(1,k,1,l)+at2*bxy(1,k,1,l))/(1+at2) c         bxy(2,k,1,l) = 0. c----------------------------------------------------------------- dky = dny * float ( k - 1 ) dcu ( 1 , k , 1 , l ) = - dcu ( 1 , k , 1 , l ) - dky * amu ( 3 , k , 1 , l ) dcu ( 2 , k , 1 , l ) = - dcu ( 2 , k , 1 , l ) + dky * amu ( 2 , k , 1 , l ) at2 = real ( ffd ( k , 1 , l )) at2 = ci2 * at2 / ( 1 + aa * at2 ) at1 = at2 * aimag ( ffd ( k , 1 , l )) bxy ( 1 , k , 1 , l ) = at1 * dcu ( 1 , k , 1 , l ) + aa * at2 * bxy ( 1 , k , 1 , l ) bxy ( 2 , k , 1 , l ) = 0. wp = wp + at1 * dcu ( 1 , k , 1 , l ) ** 2 140 continue bxy ( 1 , 1 , 1 , l ) = 0. bxy ( 2 , 1 , 1 , l ) = 0. endif do 150 k = 1 , ny1 bxy ( 1 , k , kxp2 + 1 , l ) = 0. bxy ( 2 , k , kxp2 + 1 , l ) = 0. 150 continue 160 continue 170 continue wm = float ( nx * ny ) * wp return c calculate smoothing 180 if ( kstrt . gt . nx ) go to 240 do 230 l = 1 , j2blok c mode numbers 0 < kx < nx and 0 < ky < ny joff = kxp2 * ( l + ks ) - 1 do 200 j = 1 , kxp2 if (( j + joff ). gt . 0 ) then do 190 k = 2 , ny at1 = aimag ( ffd ( k , j , l )) bxy ( 1 , k , j , l ) = at1 * cu ( 1 , k , j , l ) bxy ( 2 , k , j , l ) = at1 * cu ( 2 , k , j , l ) 190 continue c mode numbers ky = 0, ny at1 = aimag ( ffd ( 1 , j , l )) bxy ( 1 , 1 , j , l ) = 0. bxy ( 2 , 1 , j , l ) = at1 * cu ( 2 , 1 , j , l ) endif bxy ( 1 , ny + 1 , j , l ) = 0. bxy ( 2 , ny + 1 , j , l ) = 0. 200 continue c mode numbers kx = 0, nx/2 if (( l + ks ). eq . 0 ) then do 210 k = 2 , ny at1 = aimag ( ffd ( k , 1 , l )) bxy ( 1 , k , 1 , l ) = at1 * cu ( 1 , k , 1 , l ) bxy ( 2 , k , 1 , l ) = 0. 210 continue bxy ( 1 , 1 , 1 , l ) = 0. bxy ( 2 , 1 , 1 , l ) = 0. endif do 220 k = 1 , ny1 bxy ( 1 , k , kxp2 + 1 , l ) = 0. bxy ( 2 , k , kxp2 + 1 , l ) = 0. 220 continue 230 continue 240 continue return end !----------------------------------------------------------------------- subroutine MPPOISD22 ( q , fxy , isign , ffd , ax , ay , affp , we , nx , ny , kstrt , nyv & & , kxp2 , nyd ) ! this subroutine solves 2d poisson's equation in fourier space for ! force/charge (or convolution of electric field over particle shape) ! with dirichlet boundary conditions (zero potential), ! using fast sine/cosine transforms for distributed data. ! for isign = 0,input: isign,ax,ay,affp,nx,ny,kstrt,ny2d,kxp2,nyd !               output: ffd ! for isign /= 0, input: q,ffd,isign,nx,ny,kstrt,ny2d,kxp2,nyd !                 output: fxy,we ! approximate flop count is: 10*nx*ny ! equation used is: ! fx(kx,ky) = -kx*g(kx,ky)*s(kx,ky)*q(kx,ky), ! fy(kx,ky) = -ky*g(kx,ky)*s(kx,ky)*q(kx,ky), ! where kx = pi*j/nx, ky = pi*k/ny, and j,k = fourier mode numbers, ! modes nx and ny are zeroed out ! g(kx,ky) = (affp/(kx**2+ky**2))*s(kx,ky), ! s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)/2) ! q(k,j) = transformed charge density for fourier mode (jj-1,k-1) ! fxy(1,k,j) = x component of transformed force/charge, ! fxy(2,k,j) = y component of transformed force/charge, ! all for fourier mode (jj-1,k-1), where jj = j + kxp2*(kstrt - 1) ! if isign = 0, form factor array is prepared ! aimag(ffd(k,j)= finite-size particle shape factor s ! real(ffd(k,j)) = potential green's function g ! all for fourier mode (jj-1,k-1), where jj = j + kxp2*(kstrt - 1) ! kxp2 = number of data values per block ! kstrt = starting data block number ! ax/ay = half-width of particle in x/y direction ! affp = normalization constant = nx*ny/np, where np=number of particles ! electric field energy is also calculated, using ! we = 2*nx*ny*sum((affp/(kx**2+ky**2))*|q(kx,ky)*s(kx,ky)|**2) ! nx/ny = system length in x/y direction ! nyv = first dimension of field arrays, must be >= ny+1 ! nyd = first dimension of form factor array, must be >= ny implicit none integer isign , nx , ny , kstrt , nyv , kxp2 , nyd real ax , ay , affp , we real q , fxy dimension q ( nyv , kxp2 + 1 ), fxy ( 2 , nyv , kxp2 + 1 ) complex ffd dimension ffd ( nyd , kxp2 ) ! local data integer j , k , ks , ny1 , joff , kxp2s real dnx , dny , dkx , dky , at1 , at2 , at3 , at4 double precision wp , sum1 ks = kstrt - 1 ny1 = ny + 1 joff = kxp2 * ks kxp2s = min ( kxp2 , max ( 0 , nx - joff )) joff = joff - 1 dnx = 6.28318530717959 / real ( nx + nx ) dny = 6.28318530717959 / real ( ny + ny ) if ( isign . ne . 0 ) go to 30 ! prepare form factor array do 20 j = 1 , kxp2s dkx = dnx * real ( j + joff ) at1 = dkx * dkx at2 = ( dkx * ax ) ** 2 do 10 k = 1 , ny dky = dny * real ( k - 1 ) at3 = dky * dky + at1 at4 = exp ( - 0.5 * (( dky * ay ) ** 2 + at2 )) if ( at3 . eq . 0.0 ) then ffd ( k , j ) = cmplx ( affp , 1.0 ) else ffd ( k , j ) = cmplx ( affp * at4 / at3 , at4 ) endif 10 continue 20 continue return ! calculate force/charge and sum field energy 30 sum1 = 0.0d0 if ( kstrt . gt . nx ) go to 80 ! mode numbers kx > 0 and 0 < ky < ny !$OMP PARALLEL DO PRIVATE(j,k,dkx,at1,at2,at3,wp) !$OMP& REDUCTION(+:sum1) do 50 j = 1 , kxp2s dkx = dnx * real ( j + joff ) wp = 0.0d0 if (( j + joff ). gt . 0 ) then do 40 k = 2 , ny at1 = real ( ffd ( k , j )) * aimag ( ffd ( k , j )) at3 = - at1 * q ( k , j ) at2 = dkx * at3 at3 = dny * real ( k - 1 ) * at3 fxy ( 1 , k , j ) = at2 fxy ( 2 , k , j ) = at3 wp = wp + at1 * q ( k , j ) ** 2 40 continue endif ! mode numbers ky = 0, ny fxy ( 1 , 1 , j ) = 0.0 fxy ( 2 , 1 , j ) = 0.0 fxy ( 1 , ny + 1 , j ) = 0.0 fxy ( 2 , ny + 1 , j ) = 0.0 sum1 = sum1 + wp 50 continue !$OMP END PARALLEL DO ! mode number kx = 0 if ( ks . eq . 0 ) then do 60 k = 2 , ny fxy ( 1 , k , 1 ) = 0.0 fxy ( 2 , k , 1 ) = 0.0 60 continue endif ! zero out kx = nx mode and unused extra cells do 70 k = 1 , ny1 fxy ( 1 , k , kxp2s + 1 ) = 0.0 fxy ( 2 , k , kxp2s + 1 ) = 0.0 70 continue 80 continue we = 2.0 * real ( nx ) * real ( ny ) * sum1 return end !----------------------------------------------------------------------- subroutine MPPOISD23 ( q , fxy , isign , ffd , ax , ay , affp , we , nx , ny , kstrt , nyv & & , kxp2 , nyd ) ! this subroutine solves 2-1/2d poisson's equation in fourier space for ! force/charge (or convolution of electric field over particle shape) ! with dirichlet boundary conditions (zero potential), ! using fast sine/cosine transforms for distributed data. ! Zeros out z component ! for isign = 0,input: isign,ax,ay,affp,nx,ny,kstrt,ny2d,kxp2,nyd !               output: ffd ! for isign /= 0, input: q,ffd,isign,nx,ny,kstrt,ny2d,kxp2,nyd !                 output: fxy,we ! approximate flop count is: 10*nx*ny ! equation used is: ! fx(kx,ky) = -kx*g(kx,ky)*s(kx,ky)*q(kx,ky), ! fy(kx,ky) = -ky*g(kx,ky)*s(kx,ky)*q(kx,ky), ! fz(kx,ky) = zero, ! where kx = pi*j/nx, ky = pi*k/ny, and j,k = fourier mode numbers, ! modes nx and ny are zeroed out ! g(kx,ky) = (affp/(kx**2+ky**2))*s(kx,ky), ! s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)/2) ! q(k,j) = transformed charge density for fourier mode (jj-1,k-1) ! fxy(1,k,j) = x component of transformed force/charge, ! fxy(2,k,j) = y component of transformed force/charge, ! fxy(3,k,j) = zero, ! all for fourier mode (jj-1,k-1), where jj = j + kxp2*(kstrt - 1) ! if isign = 0, form factor array is prepared ! aimag(ffd(k,j)= finite-size particle shape factor s ! real(ffd(k,j)) = potential green's function g ! all for fourier mode (jj-1,k-1), where jj = j + kxp2*(kstrt - 1) ! kxp2 = number of data values per block ! kstrt = starting data block number ! ax/ay = half-width of particle in x/y direction ! affp = normalization constant = nx*ny/np, where np=number of particles ! electric field energy is also calculated, using ! we = 2*nx*ny*sum((affp/(kx**2+ky**2))*|q(kx,ky)*s(kx,ky)|**2) ! nx/ny = system length in x/y direction ! nyv = first dimension of field arrays, must be >= ny+1 ! nyd = first dimension of form factor array, must be >= ny implicit none integer isign , nx , ny , kstrt , nyv , kxp2 , nyd real ax , ay , affp , we real q , fxy dimension q ( nyv , kxp2 + 1 ), fxy ( 3 , nyv , kxp2 + 1 ) complex ffd dimension ffd ( nyd , kxp2 ) ! local data integer j , k , ks , ny1 , joff , kxp2s real dnx , dny , dkx , dky , at1 , at2 , at3 , at4 double precision wp , sum1 ks = kstrt - 1 ny1 = ny + 1 joff = kxp2 * ks kxp2s = min ( kxp2 , max ( 0 , nx - joff )) joff = joff - 1 dnx = 6.28318530717959 / real ( nx + nx ) dny = 6.28318530717959 / real ( ny + ny ) if ( isign . ne . 0 ) go to 30 ! prepare form factor array do 20 j = 1 , kxp2s dkx = dnx * real ( j + joff ) at1 = dkx * dkx at2 = ( dkx * ax ) ** 2 do 10 k = 1 , ny dky = dny * real ( k - 1 ) at3 = dky * dky + at1 at4 = exp ( - 0.5 * (( dky * ay ) ** 2 + at2 )) if ( at3 . eq . 0.0 ) then ffd ( k , j ) = cmplx ( affp , 1.0 ) else ffd ( k , j ) = cmplx ( affp * at4 / at3 , at4 ) endif 10 continue 20 continue return ! calculate force/charge and sum field energy 30 sum1 = 0.0d0 if ( kstrt . gt . nx ) go to 80 ! mode numbers kx > 0 and 0 < ky < ny !$OMP PARALLEL DO PRIVATE(j,k,dkx,at1,at2,at3,wp) !$OMP& REDUCTION(+:sum1) do 50 j = 1 , kxp2s dkx = dnx * real ( j + joff ) wp = 0.0d0 if (( j + joff ). gt . 0 ) then do 40 k = 2 , ny at1 = real ( ffd ( k , j )) * aimag ( ffd ( k , j )) at3 = - at1 * q ( k , j ) at2 = dkx * at3 at3 = dny * real ( k - 1 ) * at3 fxy ( 1 , k , j ) = at2 fxy ( 2 , k , j ) = at3 fxy ( 3 , k , j ) = 0.0 wp = wp + at1 * q ( k , j ) ** 2 40 continue endif ! mode numbers ky = 0, ny fxy ( 1 , 1 , j ) = 0.0 fxy ( 2 , 1 , j ) = 0.0 fxy ( 3 , 1 , j ) = 0.0 fxy ( 1 , ny + 1 , j ) = 0.0 fxy ( 2 , ny + 1 , j ) = 0.0 fxy ( 3 , ny + 1 , j ) = 0.0 sum1 = sum1 + wp 50 continue !$OMP END PARALLEL DO ! mode number kx = 0 if ( ks . eq . 0 ) then do 60 k = 2 , ny fxy ( 1 , k , 1 ) = 0.0 fxy ( 2 , k , 1 ) = 0.0 fxy ( 3 , k , 1 ) = 0.0 60 continue endif ! zero out kx = nx mode and unused extra cells do 70 k = 1 , ny1 fxy ( 1 , k , kxp2s + 1 ) = 0.0 fxy ( 2 , k , kxp2s + 1 ) = 0.0 fxy ( 3 , k , kxp2s + 1 ) = 0.0 70 continue 80 continue we = 2.0 * real ( nx ) * real ( ny ) * sum1 return end !----------------------------------------------------------------------- subroutine MPPOTPD2 ( q , pot , ffd , we , nx , ny , kstrt , nyv , kxp2 , nyd ) ! this subroutine solves 2d poisson's equation in fourier space for ! potential, with dirichlet boundary conditions (zero potential), ! using fast sine transforms for distributed data. ! input: q,ffd,nx,ny,kstrt,nyv,kxp2,nyd, output: pot,we ! approximate flop count is: 5*nx*ny ! potential is calculated using the equation: ! fx(kx,ky) = g(kx,ky)*q(kx,ky)*s(kx,ky) ! where kx = pi*j/nx, ky = pi*k/ny, and j,k = fourier mode numbers, ! modes nx and ny are zeroed out ! g(kx,ky) = (affp/(kx**2+ky**2))*s(kx,ky), ! s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)/2) ! q(k,j) = transformed charge density for fourier mode (jj-1,k-1) ! pot(k,j) = transformed potential, ! all for fourier mode (jj-1,k-1), where jj = j + kxp2*(kstrt - 1) ! kxp2 = number of data values per block ! kstrt = starting data block number ! aimag(ffd(k,j)= finite-size particle shape factor s ! real(ffd(k,j)) = potential green's function g ! electric field energy is also calculated, using ! we = 2*nx*ny*sum((affp/(kx**2+ky**2))*|q(kx,ky)*s(kx,ky)|**2) ! where affp = normalization constant = nx*ny/np, ! where np=number of particles ! nx/ny = system length in x/y direction ! nyv = second dimension of field arrays, must be >= ny+1 ! nyd = first dimension of form factor array, must be >= ny implicit none integer nx , ny , kstrt , nyv , kxp2 , nyd real we real q , pot dimension q ( nyv , kxp2 + 1 ), pot ( nyv , kxp2 + 1 ) complex ffd dimension ffd ( nyd , kxp2 ) ! local data integer j , k , ks , ny1 , joff , kxp2s real at1 , at2 , at3 double precision wp , sum1 ks = kstrt - 1 ny1 = ny + 1 joff = kxp2 * ks kxp2s = min ( kxp2 , max ( 0 , nx - joff )) joff = joff - 1 ! calculate potential and sum field energy sum1 = 0.0d0 if ( kstrt . gt . nx ) go to 50 ! mode numbers kx > 0 and 0 < ky < ny !$OMP PARALLEL DO PRIVATE(j,k,at1,at2,at3,wp) !$OMP& REDUCTION(+:sum1) do 20 j = 1 , kxp2s wp = 0.0d0 if (( j + joff ). gt . 0 ) then do 10 k = 2 , ny at2 = real ( ffd ( k , j )) at1 = at2 * aimag ( ffd ( k , j )) at3 = at2 * q ( k , j ) pot ( k , j ) = at3 wp = wp + at1 * q ( k , j ) ** 2 10 continue endif ! mode numbers ky = 0, ny pot ( 1 , j ) = 0.0 pot ( ny + 1 , j ) = 0.0 sum1 = sum1 + wp 20 continue !$OMP END PARALLEL DO ! mode number kx = 0 if ( ks . eq . 0 ) then do 30 k = 2 , ny pot ( k , 1 ) = 0.0 30 continue endif ! zero out kx = nx mode and unused extra cells do 40 k = 1 , ny1 pot ( k , kxp2s + 1 ) = 0.0 40 continue 50 continue we = 2.0 * real ( nx ) * real ( ny ) * sum1 return end !----------------------------------------------------------------------- subroutine MPPSMOOTHD2 ( q , qs , ffd , nx , ny , kstrt , nyv , kxp2 , nyd ) ! this subroutine provides a 2d scalar smoothing function ! in fourier space, with dirichlet boundary conditions (zero potential), ! using fast sine transforms for distributed data. ! input: q,ffd,nx,ny,kstrt,nyv,kxp2,nyd, output: qs ! approximate flop count is: 1*nx*ny ! smoothing is calculated using the equation: ! qs(kx,ky) = q(kx,ky)*s(kx,ky) ! where kx = pi*j/nx, ky = pi*k/ny, and j,k = fourier mode numbers, ! modes nx and ny are zeroed out ! s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)/2) ! q(k,j) = transformed charge density for fourier mode (jj-1,k-1) ! qs(k,j) = transformed smoothed charge density, ! all for fourier mode (jj-1,k-1), where jj = j + kxp2*(kstrt - 1) ! kxp2 = number of data values per block ! kstrt = starting data block number ! aimag(ffd(k,j)) = finite-size particle shape factor s ! nx/ny = system length in x/y direction ! nyv = first dimension of field arrays, must be >= ny+1 ! nyd = first dimension of form factor array, must be >= ny implicit none integer nx , ny , kstrt , nyv , kxp2 , nyd real q , qs dimension q ( nyv , kxp2 + 1 ), qs ( nyv , kxp2 + 1 ) complex ffd dimension ffd ( nyd , kxp2 ) ! local data integer j , k , ks , ny1 , joff , kxp2s real at1 , at2 ks = kstrt - 1 ny1 = ny + 1 joff = kxp2 * ks kxp2s = min ( kxp2 , max ( 0 , nx - joff )) joff = joff - 1 ! calculate smoothing if ( kstrt . gt . nx ) return ! mode numbers kx > 0 and 0 < ky < ny !$OMP PARALLEL DO PRIVATE(j,k,at1,at2) do 20 j = 1 , kxp2s if (( j + joff ). gt . 0 ) then do 10 k = 2 , ny at1 = aimag ( ffd ( k , j )) at2 = at1 * q ( k , j ) qs ( k , j ) = at2 10 continue endif ! mode numbers ky = 0, ny qs ( 1 , j ) = 0.0 qs ( ny + 1 , j ) = 0.0 20 continue !$OMP END PARALLEL DO ! mode number kx = 0 if ( ks . eq . 0 ) then do 30 k = 2 , ny qs ( k , 1 ) = 0.0 30 continue endif ! zero out kx = nx mode and unused extra cells do 40 k = 1 , ny1 qs ( k , kxp2s + 1 ) = 0.0 40 continue return end !----------------------------------------------------------------------- subroutine MPPBBPOISD23 ( cu , bxy , ffd , ci , wm , nx , ny , kstrt , nyv , kxp2 , nyd ) ! this subroutine solves 2-1/2d poisson's equation in fourier space for ! smoothed magnetic field (or convolution of magnetic field over ! particle shape) with dirichlet boundary conditions (zero potential), ! using fast sine/cosine transforms for distributed data. ! input: cu,ffd,ci,nx,ny,kstrt,ny2d,kxp2,nyd, output: bxy,wm ! approximate flop count is: 20*nx*ny ! magnetic field is calculated using the equations: ! bx(kx,ky) = ci*ci**g(kx,ky)*ky*cuz(kx,ky)*s(kx,ky), ! by(kx,ky) = -ci*ci*sg(kx,ky)*kx*cuz(kx,ky)*s(kx,ky), ! bz(kx,ky) = ci*ci*g(kx,ky)*(kx*cuy(kx,ky)-ky*cux(kx,ky))*s(kx,ky), ! where kx = pi*j/nx, ky = pi*k/ny, and j,k = fourier mode numbers, ! modes nx and ny are zeroed out ! g(kx,ky) = (affp/(kx**2+ky**2))*s(kx,ky), ! s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)/2) ! cu(i,k,j) = i-th component of transformed current density and ! bxy(i,k,j) = i-th component of transformed magnetic field, ! all for fourier mode (jj-1,k-1), where jj = j + kxp2*(kstrt - 1) ! aimag(ffd(k,j)) = finite-size particle shape factor s ! real(ffd(k,j)) = potential green's function g ! all for fourier mode (jj-1,k-1), where jj = j + kxp2*(kstrt - 1) ! kxp2 = number of data values per block ! kstrt = starting data block number= ! ci = reciprocal of velocity of light ! magnetic field energy is also calculated, using ! wm = nx*ny*nz*sum((affp/(kx**2+ky**2+kz**2))*ci*ci !    |cu(kx,ky,kz)*s(kx,ky,kz)|**2) ! where affp = normalization constant = nx*ny/np, ! where np=number of particles ! this expression is valid only if the current is divergence-free ! nx/ny = system length in x/y direction ! nyv = second dimension of field arrays, must be >= ny+1 ! nyd = first dimension of form factor array, must be >= ny implicit none integer nx , ny , kstrt , nyv , kxp2 , nyd real ci , wm real cu , bxy dimension cu ( 3 , nyv , kxp2 + 1 ), bxy ( 3 , nyv , kxp2 + 1 ) complex ffd dimension ffd ( nyd , kxp2 ) ! local data integer j , k , ks , ny1 , joff , kxp2s real dnx , dny , dkx , dky , ci2 , at1 , at2 , at3 double precision wp , sum1 ks = kstrt - 1 ny1 = ny + 1 joff = kxp2 * ks kxp2s = min ( kxp2 , max ( 0 , nx - joff )) joff = joff - 1 dnx = 6.28318530717959 / real ( nx + nx ) dny = 6.28318530717959 / real ( ny + ny ) ci2 = ci * ci ! calculate smoothed magnetic field and sum field energy sum1 = 0.0d0 if ( kstrt . gt . nx ) go to 50 ! mode numbers kx > 0 and 0 < ky < ny !$OMP PARALLEL DO PRIVATE(j,k,dkx,dky,at1,at2,at3,wp) !$OMP& REDUCTION(+:sum1) do 20 j = 1 , kxp2s dkx = dnx * real ( j + joff ) wp = 0.0d0 if (( j + joff ). gt . 0 ) then do 10 k = 2 , ny dky = dny * real ( k - 1 ) at1 = ci2 * real ( ffd ( k , j )) * aimag ( ffd ( k , j )) at2 = dky * at1 at3 = dkx * at1 bxy ( 1 , k , j ) = at2 * cu ( 3 , k , j ) bxy ( 2 , k , j ) = - at3 * cu ( 3 , k , j ) bxy ( 3 , k , j ) = at3 * cu ( 2 , k , j ) - at2 * cu ( 1 , k , j ) wp = wp + 2.0 * at1 * ( cu ( 1 , k , j ) ** 2 + cu ( 2 , k , j ) ** 2 + cu ( 3 , k , j ) ** 2 ) 10 continue ! mode numbers ky = 0, ny at1 = ci2 * real ( ffd ( 1 , j )) * aimag ( ffd ( 1 , j )) at2 = dkx * at1 bxy ( 1 , 1 , j ) = 0.0 bxy ( 2 , 1 , j ) = 0.0 bxy ( 3 , 1 , j ) = at2 * cu ( 2 , 1 , j ) wp = wp + at1 * ( cu ( 2 , 1 , j ) ** 2 + cu ( 3 , 1 , j ) ** 2 ) endif bxy ( 1 , ny + 1 , j ) = 0.0 bxy ( 2 , ny + 1 , j ) = 0.0 bxy ( 3 , ny + 1 , j ) = 0.0 sum1 = sum1 + wp 20 continue !$OMP END PARALLEL DO wp = 0.0d0 ! mode numbers kx = 0, nx if ( ks . eq . 0 ) then do 30 k = 2 , ny dky = dny * real ( k - 1 ) at1 = ci2 * real ( ffd ( k , 1 )) * aimag ( ffd ( k , 1 )) at2 = dky * at1 bxy ( 1 , k , 1 ) = 0.0 bxy ( 2 , k , 1 ) = 0.0 bxy ( 3 , k , 1 ) = - at2 * cu ( 1 , k , 1 ) wp = wp + at1 * ( cu ( 1 , k , 1 ) ** 2 + cu ( 3 , k , 1 ) ** 2 ) 30 continue bxy ( 1 , 1 , 1 ) = 0.0 bxy ( 2 , 1 , 1 ) = 0.0 bxy ( 3 , 1 , 1 ) = 0.0 endif sum1 = sum1 + wp ! zero out kx = nx mode and unused extra cells do 40 k = 1 , ny1 bxy ( 1 , k , kxp2s + 1 ) = 0.0 bxy ( 2 , k , kxp2s + 1 ) = 0.0 bxy ( 3 , k , kxp2s + 1 ) = 0.0 40 continue 50 continue wm = real ( nx ) * real ( ny ) * sum1 return end","tags":"","loc":"sourcefile/fpois2d_lib77.f.html"},{"title":"part3d_lib.f03 – QuickPIC","text":"Files dependent on this one sourcefile~~part3d_lib.f03~~AfferentGraph sourcefile~part3d_lib.f03 part3d_lib.f03 sourcefile~fdist3d_class.f03 fdist3d_class.f03 sourcefile~fdist3d_class.f03->sourcefile~part3d_lib.f03 sourcefile~part3d_class.f03 part3d_class.f03 sourcefile~part3d_class.f03->sourcefile~part3d_lib.f03 sourcefile~part3d_class.f03->sourcefile~fdist3d_class.f03 sourcefile~simulation_class.f03 simulation_class.f03 sourcefile~simulation_class.f03->sourcefile~fdist3d_class.f03 sourcefile~beam3d_class.f03 beam3d_class.f03 sourcefile~simulation_class.f03->sourcefile~beam3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~fdist3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~part3d_class.f03 sourcefile~main.f03 main.f03 sourcefile~main.f03->sourcefile~simulation_class.f03 var pansourcefilepart3d_libf03AfferentGraph = svgPanZoom('#sourcefilepart3d_libf03AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules part3d_lib Source Code part3d_lib.f03 Source Code ! part3d_lib module for QuickPIC Open Source 1.0 ! update: 04/18/2016 module part3d_lib implicit none ! interface subroutine PRVDIST32_RANDOM ( part , qm , edges , npp , nps , vtx , vty , vtz , vdx ,& & vdy , vdz , npx , npy , npz , nx , ny , nz , ipbc , idimp , npmax , mblok , nblok , idps & &, sigx , sigy , sigz , x0 , y0 , z0 , cx , cy , lquiet , ierr ) implicit none integer , intent ( in ) :: npmax , nblok , npx , npy , npz , idimp , nx , ny , nz , i & & dps , mblok , ipbc integer , intent ( inout ) :: nps , npp , ierr real , intent ( in ) :: qm , sigx , sigy , sigz , x0 , y0 , z0 , cx , cy , edges , vtx , vty & &, vtz , vdx , vdy , vdz real , intent ( inout ) :: part logical , intent ( in ) :: lquiet dimension part ( idimp , npmax , nblok ) dimension edges ( idps , nblok ) dimension cx ( 0 : 2 ), cy ( 0 : 2 ) end subroutine end interface ! interface subroutine PGPOST32L ( part , q , npp , noff , idimp , npmax , mnblok , nxv ,& & nypmx , nzpmx , idds ) implicit none integer , intent ( in ) :: npp , noff , idimp , npmax , mnblok , nxv , nypmx , nz & & pmx , idds real , intent ( inout ) :: part real , intent ( inout ) :: q dimension part ( idimp , npmax , mnblok ), q ( nxv , nypmx , nzpmx , mnblok ) dimension noff ( idds , mnblok ) end subroutine end interface ! interface subroutine PGBPUSH32L_QP ( part , fxyz , bxyz , npp , noff , qbm , dt , dtc , ek ,& & nx , ny , nz , idimp , npmax , mnblok , nxv , nypmx , nzpmx , idds , ipbc , deltax , d & & eltaz , cofd ) implicit none real , intent ( inout ) :: part integer , intent ( inout ) :: npp real , intent ( inout ) :: fxyz , bxyz real , intent ( in ) :: qbm , dt , dtc , ek , deltax , deltaz , cofd integer , intent ( in ) :: noff , nx , ny , nz , idimp , npmax , mnblok , nxv , nyp & & mx , nzpmx , idds , ipbc dimension part ( idimp , npmax , mnblok ) dimension fxyz ( 3 , nxv , nypmx , nzpmx , mnblok ) dimension bxyz ( 3 , nxv , nypmx , nzpmx , mnblok ) dimension noff ( idds , mnblok ) end subroutine end interface ! interface subroutine PMOVE32 ( part , edges , npp , sbufr , sbufl , rbufr , rbufl , ihole & &, pbuff , jsr , jsl , jss , ny , nz , kstrt , nvpy , nvpz , idimp , npmax , mblok , nbl & & ok , idps , nbmax , idds , ntmax , tag1 , tag2 , id , info ) implicit none real , intent ( inout ) :: part , pbuff real , intent ( in ) :: edges , sbufr , sbufl , rbufr , rbufl integer , intent ( inout ) :: npp , id , info integer , intent ( in ) :: ihole , jsr , jsl , jss integer , intent ( in ) :: ny , nz , kstrt , nvpy , nvpz , idimp , npmax integer , intent ( in ) :: idps , nbmax , idds , ntmax , mblok , nblok integer , intent ( in ) :: tag1 , tag2 dimension part ( idimp , npmax , mblok * nblok ) dimension pbuff ( idimp , nbmax ) dimension edges ( idps , mblok * nblok ) dimension sbufl ( idimp , nbmax , mblok * nblok ) dimension sbufr ( idimp , nbmax , mblok * nblok ) dimension rbufl ( idimp , nbmax , mblok * nblok ) dimension rbufr ( idimp , nbmax , mblok * nblok ) dimension jsl ( idds , mblok * nblok ), jsr ( idds , mblok * nblok ) dimension jss ( idds , mblok * nblok ) dimension ihole ( ntmax , mblok * nblok ) dimension info ( 9 ) end subroutine end interface ! end module part3d_lib","tags":"","loc":"sourcefile/part3d_lib.f03.html"},{"title":"part2d_lib.f03 – QuickPIC","text":"Files dependent on this one sourcefile~~part2d_lib.f03~~AfferentGraph sourcefile~part2d_lib.f03 part2d_lib.f03 sourcefile~part2d_class.f03 part2d_class.f03 sourcefile~part2d_class.f03->sourcefile~part2d_lib.f03 sourcefile~species2d_class.f03 species2d_class.f03 sourcefile~species2d_class.f03->sourcefile~part2d_class.f03 sourcefile~simulation_class.f03 simulation_class.f03 sourcefile~simulation_class.f03->sourcefile~species2d_class.f03 sourcefile~main.f03 main.f03 sourcefile~main.f03->sourcefile~simulation_class.f03 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules part2d_lib Source Code part2d_lib.f03 Source Code ! part2d_lib_h module for QuickPIC Open Source 1.0 ! update: 04/18/2016 module part2d_lib use mpi implicit none public ! integer :: nproc , lgrp , mreal , mint , mcplx , mdouble , lworld common / PPARMS / nproc , lgrp , mreal , mint , mcplx , mdouble , lworld ! interface subroutine PPDBLKP2L ( part , kpic , npp , noff , nppmx , idimp , npmax , mx , my & &, mx1 , mxyp1 , irc ) implicit none integer , intent ( in ) :: idimp , npmax , mx , my , mx1 , mxyp1 , npp integer , intent ( in ) :: noff integer , intent ( inout ) :: nppmx , irc real , dimension ( idimp , npmax ), intent ( in ) :: part integer , dimension ( mxyp1 ), intent ( inout ) :: kpic end subroutine end interface ! interface subroutine PPPMOVIN2L ( part , ppart , kpic , npp , noff , nppmx , idimp , & & npmax , mx , my , mx1 , mxyp1 , irc ) implicit none integer , intent ( in ) :: nppmx , idimp , npmax , mx , my , mx1 , mxyp1 integer , intent ( in ) :: npp , noff integer , intent ( inout ) :: irc real , dimension ( idimp , npmax ), intent ( in ) :: part real , dimension ( idimp , nppmx , mxyp1 ), intent ( inout ) :: ppart integer , dimension ( mxyp1 ), intent ( inout ) :: kpic end subroutine end interface ! interface subroutine PPPCHECK2L ( ppart , kpic , noff , nyp , idimp , nppmx , nx , mx , my ,& & mx1 , myp1 , irc ) implicit none integer , intent ( in ) :: idimp , nppmx , nx , mx , my , mx1 , myp1 integer , intent ( in ) :: noff , nyp integer , intent ( inout ) :: irc real , dimension ( idimp , nppmx , mx1 * myp1 ), intent ( in ) :: ppart integer , dimension ( mx1 * myp1 ), intent ( in ) :: kpic end subroutine end interface ! interface subroutine PPGPPOST2L ( ppart , q , kpic , noff , idimp , nppmx , mx , my , & & nxv , nypmx , mx1 , mxyp1 ) implicit none integer , intent ( in ) :: idimp , nppmx , mx , my , nxv , nypmx integer , intent ( in ) :: mx1 , mxyp1 integer , intent ( in ) :: noff real , dimension ( idimp , nppmx , mxyp1 ), intent ( in ) :: ppart real , dimension ( nxv , nypmx ), intent ( inout ) :: q integer , dimension ( mxyp1 ), intent ( in ) :: kpic end subroutine end interface ! interface subroutine PPGRDCJPPOST2L_QP ( ppart , fxy , bxy , psit , cu , dcu , amu , kpic , noff ,& & nyp , qbm , dt , ci , idimp , nppmx , nx , mx , my , nxv , nypmx , mx1 , mxyp1 , dex ) implicit none integer , intent ( in ) :: noff , nyp , idimp , nppmx , nx , mx , my integer , intent ( in ) :: nxv , nypmx , mx1 , mxyp1 real , intent ( in ) :: qbm , dt , ci real , dimension ( idimp , nppmx , mxyp1 ), intent ( inout ) :: ppart real , dimension ( 2 , nxv , nypmx ), intent ( in ) :: fxy real , dimension ( 3 , nxv , nypmx ), intent ( in ) :: bxy real , dimension ( nxv , nypmx ), intent ( in ) :: psit real , dimension ( 3 , nxv , nypmx ), intent ( inout ) :: cu real , dimension ( 2 , nxv , nypmx ), intent ( inout ) :: dcu real , dimension ( 3 , nxv , nypmx ), intent ( inout ) :: amu integer , dimension ( mxyp1 ), intent ( in ) :: kpic real , intent ( in ) :: dex end subroutine end interface ! interface subroutine PPGRBPPUSHF23L_QP ( ppart , fxy , bxy , psit , kpic , ncl , ihole ,& & noff , nyp , qbm , dt , dtc , ci , ek , idimp , nppmx , nx , ny , mx , my , nxv , nypmx , mx1 , mx & & yp1 , ntmax , irc , dex ) implicit none integer noff , nyp , idimp , nppmx , nx , ny , mx , my , nxv , nypmx integer mx1 , mxyp1 , ntmax , irc real qbm , dt , dtc , ci , ek , dex real ppart , fxy , bxy , psit integer kpic , ncl , ihole dimension ppart ( idimp , nppmx , mxyp1 ) dimension fxy ( 2 , nxv , nypmx ), bxy ( 3 , nxv , nypmx ) dimension psit ( nxv , nypmx ) dimension kpic ( mxyp1 ), ncl ( 8 , mxyp1 ) dimension ihole ( 2 , ntmax + 1 , mxyp1 ) end subroutine end interface ! interface subroutine PPPORDER2LA ( ppart , ppbuff , sbufl , sbufr , kpic , ncl , ihole ,& & ncll , nclr , noff , nyp , idimp , nppmx , nx , ny , mx , my , mx1 , myp1 , npbmx , ntmax , & & nbmax , irc ) implicit none integer , intent ( in ) :: idimp , nppmx , nx , ny , mx , my , mx1 , myp1 integer , intent ( in ) :: npbmx , ntmax , nbmax , noff , nyp integer , intent ( inout ) :: irc real , dimension ( idimp , nppmx , mx1 * myp1 ), intent ( inout ) :: ppart real , dimension ( idimp , npbmx , mx1 * myp1 ), intent ( inout ) :: ppbuff real , dimension ( idimp , nbmax ), intent ( inout ) :: sbufl , sbufr integer , dimension ( mx1 * myp1 ), intent ( in ) :: kpic integer , dimension ( 8 , mx1 * myp1 ), intent ( inout ) :: ncl integer , dimension ( 2 , ntmax + 1 , mx1 * myp1 ), intent ( inout ) :: ihole integer , dimension ( 3 , mx1 ), intent ( inout ) :: ncll , nclr end subroutine end interface ! interface subroutine PPPORDERF2LA ( ppart , ppbuff , sbufl , sbufr , ncl , ihole , ncll & &, nclr , idimp , nppmx , mx1 , myp1 , npbmx , ntmax , nbmax , irc ) implicit none integer , intent ( in ) :: idimp , nppmx , mx1 , myp1 , npbmx , ntmax integer , intent ( in ) :: nbmax integer , intent ( inout ) :: irc real , dimension ( idimp , nppmx , mx1 * myp1 ), intent ( inout ) :: ppart real , dimension ( idimp , npbmx , mx1 * myp1 ), intent ( inout ) :: ppbuff real , dimension ( idimp , nbmax ), intent ( inout ) :: sbufl , sbufr integer , dimension ( 8 , mx1 * myp1 ), intent ( inout ) :: ncl integer , dimension ( 2 , ntmax + 1 , mx1 * myp1 ), intent ( in ) :: ihole integer , dimension ( 3 , mx1 ), intent ( inout ) :: ncll , nclr end subroutine end interface ! interface subroutine PPPORDER2LB ( ppart , ppbuff , rbufl , rbufr , kpic , ncl , ihole ,& & mcll , mclr , idimp , nppmx , mx1 , myp1 , npbmx , ntmax , nbmax , irc ) implicit none integer , intent ( in ) :: idimp , nppmx , mx1 , myp1 , npbmx , ntmax integer , intent ( in ) :: nbmax integer , intent ( inout ) :: irc real , dimension ( idimp , nppmx , mx1 * myp1 ), intent ( inout ) :: ppart real , dimension ( idimp , npbmx , mx1 * myp1 ), intent ( in ) :: ppbuff real , dimension ( idimp , nbmax ), intent ( in ) :: rbufl , rbufr integer , dimension ( mx1 * myp1 ), intent ( inout ) :: kpic integer , dimension ( 8 , mx1 * myp1 ), intent ( in ) :: ncl integer , dimension ( 2 , ntmax + 1 , mx1 * myp1 ), intent ( in ) :: ihole integer , dimension ( 3 , mx1 ), intent ( in ) :: mcll , mclr end subroutine end interface ! interface subroutine WPGPSIPOST2L_QP ( ppart , psi , kpic , qbm , noff , nyp , idimp , np & & pmx , nx , mx , my , nxv , nypmx , mx1 , mxyp1 , dex ) implicit none integer , intent ( in ) :: noff , nyp , idimp , nppmx , nx , mx , my integer , intent ( in ) :: mx1 , mxyp1 , nxv , nypmx real , intent ( in ) :: dex , qbm real , dimension ( idimp , nppmx , mxyp1 ), intent ( inout ) :: ppart real , dimension ( nxv , nypmx ), intent ( in ) :: psi integer , dimension ( mxyp1 ), intent ( in ) :: kpic end subroutine end interface ! interface subroutine PPPCOPYOUT2 ( part , ppart , kpic , npp , npmax , nppmx , idimp , & & mxyp1 , irc ) implicit none integer , intent ( in ) :: npmax , nppmx , idimp , mxyp1 integer , intent ( inout ) :: npp , irc real , dimension ( idimp , npmax ), intent ( inout ) :: part real , dimension ( idimp , nppmx , mxyp1 ), intent ( in ) :: ppart integer , dimension ( mxyp1 ), intent ( in ) :: kpic end subroutine end interface ! contains ! subroutine PPPMOVE2 ( sbufr , sbufl , rbufr , rbufl , ncll , nclr , mcll , mclr , & & kstrt , nvp , idimp , nbmax , mx1 ) ! this subroutine moves particles into appropriate spatial regions ! for distributed data, with 1d domain decomposition in y. ! tiles are assumed to be arranged in 2D linear memory ! output: rbufr, rbufl, mcll, mclr ! sbufl = buffer for particles being sent to lower processor ! sbufr = buffer for particles being sent to upper processor ! rbufl = buffer for particles being received from lower processor ! rbufr = buffer for particles being received from upper processor ! ncll = particle number being sent to lower processor ! nclr = particle number being sent to upper processor ! mcll = particle number being received from lower processor ! mclr = particle number being received from upper processor ! kstrt = starting data block number ! nvp = number of real or virtual processors ! idimp = size of phase space = 4 or 5 ! nbmax =  size of buffers for passing particles between processors ! mx1 = (system length in x direction - 1)/mx + 1 implicit none integer , intent ( in ) :: kstrt , nvp , idimp , nbmax , mx1 real , dimension ( idimp , nbmax ), intent ( in ) :: sbufl , sbufr real , dimension ( idimp , nbmax ), intent ( inout ) :: rbufl , rbufr integer , dimension ( 3 , mx1 ), intent ( in ) :: ncll , nclr integer , dimension ( 3 , mx1 ), intent ( inout ) :: mcll , mclr ! lgrp = current communicator ! mint = default datatype for integers ! mreal = default datatype for reals ! local data integer :: ierr , ks , kl , kr , i , j , jsl , jsr integer :: nbsize , ncsize integer , dimension ( 8 ) :: msid integer , dimension ( 4 ) :: itg integer , dimension ( 10 ) :: istatus data itg / 3 , 4 , 5 , 6 / ks = kstrt - 1 nbsize = idimp * nbmax ncsize = 3 * mx1 ! copy particle buffers: update rbufl, rbufr, mcll, mclr ! special case for one processor if ( nvp == 1 ) then do j = 1 , mx1 do i = 1 , 3 mcll ( i , j ) = nclr ( i , j ) enddo continue enddo do j = 1 , mx1 do i = 1 , 3 mclr ( i , j ) = ncll ( i , j ) enddo enddo do j = 1 , nclr ( 3 , mx1 ) do i = 1 , idimp rbufl ( i , j ) = sbufr ( i , j ) enddo enddo do j = 1 , ncll ( 3 , mx1 ) do i = 1 , idimp rbufr ( i , j ) = sbufl ( i , j ) enddo enddo ! this segment is used for mpi computers else ! get particles from below and above kr = ks + 1 if ( kr >= nvp ) kr = kr - nvp kl = ks - 1 if ( kl < 0 ) kl = kl + nvp ! post receives call MPI_IRECV ( mcll , ncsize , mint , kl , itg ( 1 ), lgrp , msid ( 1 ), ierr ) call MPI_IRECV ( mclr , ncsize , mint , kr , itg ( 2 ), lgrp , msid ( 2 ), ierr ) call MPI_IRECV ( rbufl , nbsize , mreal , kl , itg ( 3 ), lgrp , msid ( 3 ), ierr ) call MPI_IRECV ( rbufr , nbsize , mreal , kr , itg ( 4 ), lgrp , msid ( 4 ), ierr ) ! send particle number offsets call MPI_ISEND ( nclr , ncsize , mint , kr , itg ( 1 ), lgrp , msid ( 5 ), ierr ) call MPI_ISEND ( ncll , ncsize , mint , kl , itg ( 2 ), lgrp , msid ( 6 ), ierr ) call MPI_WAIT ( msid ( 1 ), istatus , ierr ) call MPI_WAIT ( msid ( 2 ), istatus , ierr ) ! send particles jsr = idimp * nclr ( 3 , mx1 ) call MPI_ISEND ( sbufr , jsr , mreal , kr , itg ( 3 ), lgrp , msid ( 7 ), ierr ) jsl = idimp * ncll ( 3 , mx1 ) call MPI_ISEND ( sbufl , jsl , mreal , kl , itg ( 4 ), lgrp , msid ( 8 ), ierr ) call MPI_WAIT ( msid ( 3 ), istatus , ierr ) call MPI_WAIT ( msid ( 4 ), istatus , ierr ) endif ! make sure sbufr, sbufl, ncll, and nclr have been sent if ( nvp /= 1 ) then do i = 1 , 4 call MPI_WAIT ( msid ( i + 4 ), istatus , ierr ) enddo endif end subroutine PPPMOVE2 end module part2d_lib","tags":"","loc":"sourcefile/part2d_lib.f03.html"},{"title":"part3d_class.f03 – QuickPIC","text":"This file depends on sourcefile~~part3d_class.f03~~EfferentGraph sourcefile~part3d_class.f03 part3d_class.f03 sourcefile~parallel_pipe_class.f03 parallel_pipe_class.f03 sourcefile~part3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~fdist3d_class.f03 fdist3d_class.f03 sourcefile~part3d_class.f03->sourcefile~fdist3d_class.f03 sourcefile~hdf5io_class.f03 hdf5io_class.f03 sourcefile~part3d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~ufield3d_class.f03 ufield3d_class.f03 sourcefile~part3d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~spect3d_class.f03 spect3d_class.f03 sourcefile~part3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~part3d_lib.f03 part3d_lib.f03 sourcefile~part3d_class.f03->sourcefile~part3d_lib.f03 sourcefile~perrors_class.f03 perrors_class.f03 sourcefile~part3d_class.f03->sourcefile~perrors_class.f03 sourcefile~parallel_class.f03 parallel_class.f03 sourcefile~parallel_pipe_class.f03->sourcefile~parallel_class.f03 sourcefile~fdist3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~fdist3d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~fdist3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~fdist3d_class.f03->sourcefile~part3d_lib.f03 sourcefile~fdist3d_class.f03->sourcefile~perrors_class.f03 sourcefile~input_class.f03 input_class.f03 sourcefile~fdist3d_class.f03->sourcefile~input_class.f03 sourcefile~hdf5io_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~hdf5io_class.f03->sourcefile~perrors_class.f03 sourcefile~ufield3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~ufield3d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~ufield3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~ufield3d_class.f03->sourcefile~perrors_class.f03 sourcefile~ufield2d_class.f03 ufield2d_class.f03 sourcefile~ufield3d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~ufield3d_lib.f03 ufield3d_lib.f03 sourcefile~ufield3d_class.f03->sourcefile~ufield3d_lib.f03 sourcefile~spect3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~spect3d_class.f03->sourcefile~perrors_class.f03 sourcefile~spect2d_class.f03 spect2d_class.f03 sourcefile~spect3d_class.f03->sourcefile~spect2d_class.f03 sourcefile~perrors_class.f03->sourcefile~parallel_class.f03 sourcefile~ufield2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~ufield2d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~ufield2d_class.f03->sourcefile~perrors_class.f03 sourcefile~ufield2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~ufield2d_lib.f03 ufield2d_lib.f03 sourcefile~ufield2d_class.f03->sourcefile~ufield2d_lib.f03 sourcefile~spect2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~spect2d_class.f03->sourcefile~perrors_class.f03 sourcefile~input_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~input_class.f03->sourcefile~spect3d_class.f03 sourcefile~input_class.f03->sourcefile~perrors_class.f03 sourcefile~input_class.f03->sourcefile~parallel_class.f03 var pansourcefilepart3d_classf03EfferentGraph = svgPanZoom('#sourcefilepart3d_classf03EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~part3d_class.f03~~AfferentGraph sourcefile~part3d_class.f03 part3d_class.f03 sourcefile~beam3d_class.f03 beam3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~part3d_class.f03 sourcefile~simulation_class.f03 simulation_class.f03 sourcefile~simulation_class.f03->sourcefile~beam3d_class.f03 sourcefile~main.f03 main.f03 sourcefile~main.f03->sourcefile~simulation_class.f03 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules part3d_class Source Code part3d_class.f03 Source Code ! part3d class for QuickPIC Open Source 1.0 ! update: 04/18/2016 module part3d_class use perrors_class use parallel_pipe_class use spect3d_class use fdist3d_class use ufield3d_class use part3d_lib use hdf5io_class use mpi implicit none private public :: part3d type part3d private class ( spect3d ), pointer , public :: sp => null () class ( perrors ), pointer , public :: err => null () class ( parallel_pipe ), pointer , public :: p => null () ! ! qbm = particle charge/mass ratio ! dt = time interval between successive calculations ! ci = reciprical of velocity of light ! xdim = dimension of the particle coordinates ! nbmax = size of buffer for passing particles between processors ! npp = number of particles in current partition ! npmax = maximum number of particles in each partition ! part(:,:) = initial particle coordinates ! real :: qbm , dt , ci integer :: npmax , nbmax , xdim , npp = 0 real , dimension (:,:), pointer :: part => null (), pbuff => null () contains generic :: new => init_part3d generic :: del => end_part3d generic :: push => partpush generic :: pmv => pmove generic :: qdp => qdeposit generic :: wr => writehdf5_part3d generic :: wrst => writerst_part3d generic :: rrst => readrst_part3d procedure , private :: init_part3d procedure , private :: end_part3d procedure , private :: partpush procedure , private :: pmove procedure , private :: qdeposit , writehdf5_part3d procedure , private :: writerst_part3d , readrst_part3d procedure :: getnpp end type save character ( len = 10 ) :: class = 'part3d:' character ( len = 128 ) :: erstr ! ! buffer data for particle managers real , dimension (:,:), allocatable :: sbufl , sbufr , rbufl , rbufr integer , dimension (:), allocatable :: ihole integer :: szbuf = 0 contains ! subroutine init_part3d ( this , pp , perr , psp , pf , fd , qbm , dt , ci , xdim ) implicit none class ( part3d ), intent ( inout ) :: this class ( spect3d ), intent ( in ), pointer :: psp class ( perrors ), intent ( in ), pointer :: perr class ( parallel_pipe ), intent ( in ), pointer :: pp class ( fdist3d ), intent ( inout ) :: pf class ( ufield3d ), pointer , intent ( in ) :: fd real , intent ( in ) :: qbm , dt , ci integer , intent ( in ) :: xdim ! local data character ( len = 18 ), save :: sname = 'init_part3d:' integer :: noff , nxyp , nx , prof , npmax , nbmax this % sp => psp this % err => perr this % p => pp call this % err % werrfl2 ( class // sname // ' started' ) this % qbm = qbm this % dt = dt this % ci = ci this % xdim = xdim npmax = pf % getnpmax () this % npmax = npmax nbmax = int ( 0.01 * this % npmax ) this % nbmax = nbmax prof = pf % getnpf () allocate ( this % part ( xdim , npmax ), this % pbuff ( xdim , nbmax )) call pf % dist ( this % part , this % npp , fd ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine init_part3d ! subroutine end_part3d ( this ) implicit none class ( part3d ), intent ( inout ) :: this character ( len = 18 ), save :: sname = 'end_part3d:' call this % err % werrfl2 ( class // sname // ' started' ) deallocate ( this % part , this % pbuff ) call this % err % werrfl2 ( class // sname // ' ended' ) return end subroutine end_part3d ! subroutine qdeposit ( this , q ) ! deposit the charge density implicit none class ( part3d ), intent ( in ) :: this class ( ufield3d ), pointer , intent ( in ) :: q character ( len = 18 ), save :: sname = 'qdeposit:' ! local data real , dimension (:,:,:,:), pointer :: pq => null () real , dimension (:,:), pointer :: part integer :: npp integer , dimension ( 2 ) :: noff integer :: idimp , npmax , nxv , nypmx , nzpmx , nxyzp integer :: order , opt call this % err % werrfl2 ( class // sname // ' started' ) pq => q % getrf () part => this % part noff = q % getnoff () npp = this % npp idimp = this % xdim ; npmax = this % npmax nxv = size ( pq , 2 ); nypmx = size ( pq , 3 ); nzpmx = size ( pq , 4 ) nxyzp = nxv * nypmx * nzpmx select case ( this % sp % getinorder ()) case ( 1 ) call PGPOST32L ( part , pq ( 1 ,:,:,:), npp , noff , idimp , npmax , 1 , nxv , nypmx ,& & nzpmx , 2 ) case default call PGPOST32L ( part , pq ( 1 ,:,:,:), npp , noff , idimp , npmax , 1 , nxv , nypmx ,& & nzpmx , 2 ) end select call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine qdeposit ! subroutine partpush ( this , ef , bf , dex , dez ) implicit none class ( part3d ), intent ( inout ) :: this class ( ufield3d ), pointer , intent ( in ) :: ef , bf real , intent ( in ) :: dex , dez character ( len = 18 ), save :: sname = 'partpush' ! local data real , dimension (:,:,:,:), pointer :: pef => null (), pbf => null () integer :: nx , ny , nz , ipbc real :: qbm , dt , dtc , ek integer , dimension ( 2 ) :: noff integer :: idimp , npmax , nxv , nypmx , nzpmx , nxyzp call this % err % werrfl2 ( class // sname // ' started' ) pef => ef % getrf (); pbf => bf % getrf () qbm = this % qbm ; dt = this % dt nx = ef % getnd1 (); ny = ef % getnd2 (); nz = ef % getnd3 () idimp = this % xdim ; npmax = this % npmax ; ipbc = this % sp % getpsolver () noff = ef % getnoff () nxv = size ( pef , 2 ); nypmx = size ( pef , 3 ); nzpmx = size ( pef , 4 ) nxyzp = nxv * nypmx * nzpmx select case ( this % sp % getinorder ()) case ( 1 ) call PGBPUSH32L_QP ( this % part , pef , pbf , this % npp , noff , qbm , dt , dt , ek ,& & nx , ny , nz , idimp , npmax , 1 , nxv , nypmx , nzpmx , 2 , ipbc , dex , dez , 0.0 ) case default call PGBPUSH32L_QP ( this % part , pef , pbf , this % npp , noff , qbm , dt , dt , ek ,& & nx , ny , nz , idimp , npmax , 1 , nxv , nypmx , nzpmx , 2 , ipbc , dex , dez , 0.0 ) end select call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine partpush ! subroutine pmove ( this , fd , rtag , stag , sid ) implicit none class ( part3d ), intent ( inout ) :: this class ( ufield3d ), pointer , intent ( in ) :: fd integer , intent ( in ) :: rtag , stag integer , intent ( inout ) :: sid character ( len = 18 ), save :: sname = 'pmove:' ! local data integer :: ny , nz , nvpy , nvpz , nbmax , idds = 2 integer :: ierr real , dimension ( 4 ) :: edges integer , dimension ( 2 ) :: noff integer , dimension ( 2 ) :: jsl , jsr , jss integer , dimension ( 9 ) :: info integer :: idimp , npmax , idps , ntmax real , dimension (:,:), pointer :: pbuff call this % err % werrfl2 ( class // sname // ' started' ) idimp = this % xdim ; npmax = this % npmax ; nbmax = this % nbmax idps = size ( edges , 1 ) ntmax = 2 * nbmax ny = fd % getnd2 (); nz = fd % getnd3 () nvpy = this % p % getlnvp () nvpz = this % p % getnstage () noff = fd % getnoff () edges ( 1 ) = noff ( 1 ); edges ( 3 ) = noff ( 2 ) edges ( 2 ) = edges ( 1 ) + fd % getnd2p () edges ( 4 ) = edges ( 3 ) + fd % getnd3p () pbuff => this % pbuff ! check if size of buffers has changed if ( szbuf . ne . nbmax ) then if ( szbuf /= 0 ) deallocate ( sbufl , sbufr , rbufl , rbufr , ihole ) ! allocate buffers allocate ( sbufl ( idimp , nbmax )) allocate ( sbufr ( idimp , nbmax )) allocate ( rbufl ( idimp , nbmax )) allocate ( rbufr ( idimp , nbmax )) allocate ( ihole ( ntmax )) szbuf = nbmax endif call PMOVE32 ( this % part , edges , this % npp , sbufr , sbufl , rbufr , rbufl , ihole , pbuff , & & jsr , jsl , jss , ny , nz , this % p % getkstrt (), nvpy , nvpz , idimp , npmax , 1 , 1 , idps , nbmax ,& & idds , ntmax , rtag , stag , sid , info ) if ( info ( 1 ) /= 0 ) then write ( erstr , * ) 'PMOVE32 error' call this % err % equit ( class // sname // erstr ) endif if ( this % p % getstageid () == this % p % getnstage () - 1 ) sid = MPI_REQUEST_NULL call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine pmove ! function getnpp ( this ) implicit none class ( part3d ), intent ( in ) :: this integer :: getnpp getnpp = this % npp end function getnpp ! subroutine writehdf5_part3d ( this , file , dspl , delta , rtag , stag , id ) implicit none class ( part3d ), intent ( inout ) :: this class ( hdf5file ), intent ( in ) :: file real , dimension ( 3 ), intent ( in ) :: delta integer , intent ( in ) :: dspl , rtag , stag integer , intent ( inout ) :: id ! local data character ( len = 18 ), save :: sname = 'writehdf5_part3d:' integer :: ierr = 0 call this % err % werrfl2 ( class // sname // ' started' ) call pwpart_pipe ( this % p , this % err , file , this % part , this % npp , dspl , delta ,& & rtag , stag , id , ierr ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine writehdf5_part3d ! subroutine writerst_part3d ( this , file ) implicit none class ( part3d ), intent ( inout ) :: this class ( hdf5file ), intent ( in ) :: file ! local data character ( len = 18 ), save :: sname = 'writerst_part3d:' integer :: ierr = 0 call this % err % werrfl2 ( class // sname // ' started' ) call wpart ( this % p , this % err , file , this % part , this % npp , 1 , ierr ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine writerst_part3d ! subroutine readrst_part3d ( this , file ) implicit none class ( part3d ), intent ( inout ) :: this class ( hdf5file ), intent ( in ) :: file ! local data character ( len = 18 ), save :: sname = 'readrst_part3d:' integer :: ierr = 0 call this % err % werrfl2 ( class // sname // ' started' ) call rpart ( this % p , this % err , file , this % part , this % npp , ierr ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine readrst_part3d ! end module part3d_class","tags":"","loc":"sourcefile/part3d_class.f03.html"},{"title":"simulation_class.f03 – QuickPIC","text":"This file depends on sourcefile~~simulation_class.f03~~EfferentGraph sourcefile~simulation_class.f03 simulation_class.f03 sourcefile~parallel_pipe_class.f03 parallel_pipe_class.f03 sourcefile~simulation_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~fdist3d_class.f03 fdist3d_class.f03 sourcefile~simulation_class.f03->sourcefile~fdist3d_class.f03 sourcefile~field3d_class.f03 field3d_class.f03 sourcefile~simulation_class.f03->sourcefile~field3d_class.f03 sourcefile~parallel_class.f03 parallel_class.f03 sourcefile~simulation_class.f03->sourcefile~parallel_class.f03 sourcefile~spect3d_class.f03 spect3d_class.f03 sourcefile~simulation_class.f03->sourcefile~spect3d_class.f03 sourcefile~hdf5io_class.f03 hdf5io_class.f03 sourcefile~simulation_class.f03->sourcefile~hdf5io_class.f03 sourcefile~perrors_class.f03 perrors_class.f03 sourcefile~simulation_class.f03->sourcefile~perrors_class.f03 sourcefile~spect2d_class.f03 spect2d_class.f03 sourcefile~simulation_class.f03->sourcefile~spect2d_class.f03 sourcefile~input_class.f03 input_class.f03 sourcefile~simulation_class.f03->sourcefile~input_class.f03 sourcefile~fdist2d_class.f03 fdist2d_class.f03 sourcefile~simulation_class.f03->sourcefile~fdist2d_class.f03 sourcefile~field2d_class.f03 field2d_class.f03 sourcefile~simulation_class.f03->sourcefile~field2d_class.f03 sourcefile~species2d_class.f03 species2d_class.f03 sourcefile~simulation_class.f03->sourcefile~species2d_class.f03 sourcefile~beam3d_class.f03 beam3d_class.f03 sourcefile~simulation_class.f03->sourcefile~beam3d_class.f03 sourcefile~parallel_pipe_class.f03->sourcefile~parallel_class.f03 sourcefile~fdist3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~fdist3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~fdist3d_class.f03->sourcefile~perrors_class.f03 sourcefile~fdist3d_class.f03->sourcefile~input_class.f03 sourcefile~ufield3d_class.f03 ufield3d_class.f03 sourcefile~fdist3d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~part3d_lib.f03 part3d_lib.f03 sourcefile~fdist3d_class.f03->sourcefile~part3d_lib.f03 sourcefile~field3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~field3d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~field3d_class.f03->sourcefile~perrors_class.f03 sourcefile~field3d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~spect3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~spect3d_class.f03->sourcefile~perrors_class.f03 sourcefile~spect3d_class.f03->sourcefile~spect2d_class.f03 sourcefile~hdf5io_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~hdf5io_class.f03->sourcefile~perrors_class.f03 sourcefile~perrors_class.f03->sourcefile~parallel_class.f03 sourcefile~spect2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~spect2d_class.f03->sourcefile~perrors_class.f03 sourcefile~input_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~input_class.f03->sourcefile~parallel_class.f03 sourcefile~input_class.f03->sourcefile~spect3d_class.f03 sourcefile~input_class.f03->sourcefile~perrors_class.f03 sourcefile~fdist2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~fdist2d_class.f03->sourcefile~perrors_class.f03 sourcefile~fdist2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~fdist2d_class.f03->sourcefile~input_class.f03 sourcefile~ufield2d_class.f03 ufield2d_class.f03 sourcefile~fdist2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~field2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field2d_class.f03->sourcefile~field3d_class.f03 sourcefile~field2d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~field2d_class.f03->sourcefile~perrors_class.f03 sourcefile~field2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~field2d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~field2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~fpois2d_class.f03 fpois2d_class.f03 sourcefile~field2d_class.f03->sourcefile~fpois2d_class.f03 sourcefile~fft2d_class.f03 fft2d_class.f03 sourcefile~field2d_class.f03->sourcefile~fft2d_class.f03 sourcefile~species2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~species2d_class.f03->sourcefile~field3d_class.f03 sourcefile~species2d_class.f03->sourcefile~spect3d_class.f03 sourcefile~species2d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~species2d_class.f03->sourcefile~perrors_class.f03 sourcefile~species2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~species2d_class.f03->sourcefile~fdist2d_class.f03 sourcefile~species2d_class.f03->sourcefile~field2d_class.f03 sourcefile~part2d_class.f03 part2d_class.f03 sourcefile~species2d_class.f03->sourcefile~part2d_class.f03 sourcefile~beam3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~beam3d_class.f03->sourcefile~fdist3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~field3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~beam3d_class.f03->sourcefile~perrors_class.f03 sourcefile~beam3d_class.f03->sourcefile~field2d_class.f03 sourcefile~part3d_class.f03 part3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~part3d_class.f03 sourcefile~ufield3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~ufield3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~ufield3d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~ufield3d_class.f03->sourcefile~perrors_class.f03 sourcefile~ufield3d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~ufield3d_lib.f03 ufield3d_lib.f03 sourcefile~ufield3d_class.f03->sourcefile~ufield3d_lib.f03 sourcefile~part2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~part2d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~part2d_class.f03->sourcefile~perrors_class.f03 sourcefile~part2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~part2d_class.f03->sourcefile~fdist2d_class.f03 sourcefile~part2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~part2d_lib.f03 part2d_lib.f03 sourcefile~part2d_class.f03->sourcefile~part2d_lib.f03 sourcefile~part3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~part3d_class.f03->sourcefile~fdist3d_class.f03 sourcefile~part3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~part3d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~part3d_class.f03->sourcefile~perrors_class.f03 sourcefile~part3d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~part3d_class.f03->sourcefile~part3d_lib.f03 sourcefile~ufield2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~ufield2d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~ufield2d_class.f03->sourcefile~perrors_class.f03 sourcefile~ufield2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~ufield2d_lib.f03 ufield2d_lib.f03 sourcefile~ufield2d_class.f03->sourcefile~ufield2d_lib.f03 sourcefile~fpois2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~fpois2d_class.f03->sourcefile~perrors_class.f03 sourcefile~fpois2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~fpois2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~fpois2d_lib.f03 fpois2d_lib.f03 sourcefile~fpois2d_class.f03->sourcefile~fpois2d_lib.f03 sourcefile~fft2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~fft2d_class.f03->sourcefile~perrors_class.f03 sourcefile~fft2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~fft2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~fft2d_lib.f03 fft2d_lib.f03 sourcefile~fft2d_class.f03->sourcefile~fft2d_lib.f03 var pansourcefilesimulation_classf03EfferentGraph = svgPanZoom('#sourcefilesimulation_classf03EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~simulation_class.f03~~AfferentGraph sourcefile~simulation_class.f03 simulation_class.f03 sourcefile~main.f03 main.f03 sourcefile~main.f03->sourcefile~simulation_class.f03 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules simulation_class Source Code simulation_class.f03 Source Code ! simulation module for QuickPIC Open Source 1.0 ! update: 01/09/2018 module simulation_class use parallel_class use parallel_pipe_class use perrors_class use spect3d_class use spect2d_class use field2d_class use fdist2d_class use field3d_class use beam3d_class use species2d_class use fdist3d_class use hdf5io_class use input_class use mpi implicit none private public :: simulation type fdist2d_wrap class ( fdist2d ), allocatable :: p end type fdist2d_wrap ! type fdist3d_wrap class ( fdist3d ), allocatable :: p end type fdist3d_wrap ! type sim_fields private class ( parallel_pipe ), pointer :: p => null () class ( perrors ), pointer :: err => null () class ( spect3d ), pointer :: sp3 => null () class ( spect2d ), pointer :: sp2 => null () type ( field2d ), allocatable :: qb , qe , psit , psi , div_vpot , reg type ( field2d ), allocatable :: fxy , bxyz , cu , dcu , amu , epw , epwb type ( field3d ), allocatable :: bexyz , bbxyz type ( field3d ), allocatable :: psi3d , cu3d contains generic :: new => init_sim_fields generic :: del => end_sim_fields procedure , private :: init_sim_fields , end_sim_fields end type sim_fields ! type sim_beams private class ( parallel_pipe ), pointer :: p => null () class ( perrors ), pointer :: err => null () class ( spect3d ), pointer :: sp3 => null () class ( spect2d ), pointer :: sp2 => null () type ( beam3d ), dimension (:), allocatable :: beam type ( fdist3d_wrap ), dimension (:), allocatable :: pf contains generic :: new => init_sim_beams generic :: del => end_sim_beams procedure , private :: init_sim_beams , end_sim_beams end type sim_beams ! type sim_species private class ( parallel_pipe ), pointer :: p => null () class ( perrors ), pointer :: err => null () class ( spect3d ), pointer :: sp3 => null () class ( spect2d ), pointer :: sp2 => null () type ( fdist2d_wrap ), dimension (:), allocatable :: pf type ( species2d ), dimension (:), allocatable :: spe contains generic :: new => init_sim_species generic :: del => end_sim_species procedure , private :: init_sim_species , end_sim_species end type sim_species ! type sim_diag private class ( parallel_pipe ), pointer :: p => null () class ( perrors ), pointer :: err => null () class ( spect3d ), pointer :: sp3 => null () class ( spect2d ), pointer :: sp2 => null () type ( hdf5file ) :: file class ( * ), pointer :: obj => null () integer , allocatable :: slice , slice_pos , psample , dim integer :: df end type sim_diag ! type simulation private !         type(input) :: sim type ( input_json ), pointer :: in => null () class ( parallel_pipe ), pointer :: p => null () class ( perrors ), pointer :: err => null () class ( spect3d ), pointer :: sp3 => null () class ( spect2d ), pointer :: sp2 => null () type ( sim_fields ) :: fields type ( sim_beams ) :: beams type ( sim_species ) :: species type ( sim_diag ), dimension (:), allocatable :: diag integer :: iter , nstep3d , nstep2d , start3d , nbeams , nspecies , tstep integer , dimension ( 8 ) :: tag integer , dimension (:), allocatable :: tag_spe , id_spe , id integer , dimension (:), allocatable :: tag_beam , id_beam integer , dimension (:,:), allocatable :: id_bq , tag_bq real :: dex , dxi , dex2 , dt contains generic :: new => init_simulation generic :: del => end_simulation generic :: go => go_simulation procedure , private :: init_simulation , end_simulation procedure , private :: init_diag , diag_simulation procedure , private :: go_simulation end type simulation ! character ( len = 20 ), save :: class = 'simulation: ' character ( len = 128 ), save :: erstr contains ! subroutine init_simulation ( this ) implicit none class ( simulation ), intent ( inout ) :: this ! local data character ( len = 18 ), save :: sname = 'init_simulation:' real :: min , max , n0 , dx , dy , dz , dt integer :: indx , indy , indz logical :: read_rst allocate ( this % in ) call this % in % new () this % err => this % in % err this % p => this % in % pp this % sp3 => this % in % sp this % sp2 => this % in % sp call this % err % werrfl2 ( class // sname // ' started' ) call this % in % get ( 'simulation.n0' , n0 ) call this % in % get ( 'simulation.indx' , indx ) call this % in % get ( 'simulation.indy' , indy ) call this % in % get ( 'simulation.indz' , indz ) call this % in % get ( 'simulation.box.x(1)' , min ) call this % in % get ( 'simulation.box.x(2)' , max ) dx = ( max - min ) / real ( 2 ** indx ) call this % in % get ( 'simulation.box.y(1)' , min ) call this % in % get ( 'simulation.box.y(2)' , max ) dy = ( max - min ) / real ( 2 ** indy ) call this % in % get ( 'simulation.box.z(1)' , min ) call this % in % get ( 'simulation.box.z(2)' , max ) dz = ( max - min ) / real ( 2 ** indz ) this % dex = dx this % dxi = dz this % dex2 = dx * dx this % nstep2d = 2 ** this % sp3 % getindz () / this % p % getnstage () call this % in % get ( 'simulation.time' , min ) call this % in % get ( 'simulation.dt' , max ) this % nstep3d = min / max call this % in % get ( 'simulation.read_restart' , read_rst ) call this % in % get ( 'simulation.dt' , dt ) this % dt = dt if ( read_rst ) then call this % in % get ( 'simulation.restart_timestep' , this % start3d ) this % start3d = this % start3d + 1 else this % start3d = 1 end if call this % in % get ( 'simulation.iter' , this % iter ) call this % in % get ( 'simulation.nbeams' , this % nbeams ) call this % in % get ( 'simulation.nspecies' , this % nspecies ) call this % fields % new ( this % in ) call this % beams % new ( this % in , this % fields ) call this % species % new ( this % in , this % fields ,( this % start3d - 1 ) * dt ) call this % init_diag () allocate ( this % tag_spe ( this % nspecies ), this % tag_beam ( this % nbeams )) allocate ( this % id_spe ( this % nspecies ), this % id_beam ( this % nbeams )) allocate ( this % id_bq ( this % nbeams , 3 ), this % tag_bq ( this % nbeams , 2 )) allocate ( this % id ( 9 + size ( this % diag ))) this % id (:) = MPI_REQUEST_NULL this % id_spe (:) = MPI_REQUEST_NULL this % id_beam (:) = MPI_REQUEST_NULL this % id_bq (:,:) = MPI_REQUEST_NULL call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine init_simulation ! subroutine end_simulation ( this ) implicit none class ( simulation ), intent ( inout ) :: this ! local data character ( len = 18 ), save :: sname = 'end_simulation:' integer :: ierr call this % err % werrfl2 ( class // sname // ' started' ) !         call this%fields%del() !         call this%beams%del() !         call this%species%del() call MPI_FINALIZE ( ierr ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine end_simulation ! subroutine init_sim_fields ( this , input ) implicit none class ( sim_fields ), intent ( inout ) :: this type ( input_json ), pointer , intent ( inout ) :: input ! local data character ( len = 18 ), save :: sname = 'init_sim_fields:' character ( len = 18 ), save :: class = 'sim_fields:' character ( len = 20 ) :: s1 , s2 , s3 character ( len = :), allocatable :: ff integer :: i , n , ndump , j , k , l , m this % err => input % err this % p => input % pp this % sp3 => input % sp this % sp2 => input % sp call this % err % werrfl2 ( class // sname // ' started' ) allocate ( this % qb , this % qe , this % psit , this % psi ) allocate ( this % div_vpot , this % reg , this % fxy , this % bxyz , this % cu ) allocate ( this % dcu , this % amu , this % epw , this % epwb ) allocate ( this % bexyz , this % bbxyz ) call this % bexyz % new ( this % p , this % err , this % sp3 , dim = 3 ) call this % bbxyz % new ( this % p , this % err , this % sp3 , dim = 3 ) call this % qb % new ( this % p , this % err , this % sp2 , dim = 1 , fftflag = . true ., gcells = 1 ) call this % qe % new ( this % p , this % err , this % sp2 , dim = 1 , fftflag = . true .) call this % psit % new ( this % p , this % err , this % sp2 , dim = 1 , fftflag = . true .) call this % div_vpot % new ( this % p , this % err , this % sp2 , dim = 1 , fftflag = . true .) call this % psi % new ( this % p , this % err , this % sp2 , dim = 1 , fftflag = . true .) call this % reg % new ( this % p , this % err , this % sp2 , dim = 1 , fftflag = . true .) call this % fxy % new ( this % p , this % err , this % sp2 , dim = 2 , fftflag = . true .) call this % cu % new ( this % p , this % err , this % sp2 , dim = 3 , fftflag = . true ., state = 1 ) call this % dcu % new ( this % p , this % err , this % sp2 , dim = 2 , fftflag = . true .) call this % amu % new ( this % p , this % err , this % sp2 , dim = 3 , fftflag = . true .) call this % epw % new ( this % p , this % err , this % sp2 , dim = 2 , fftflag = . true ., state = 1 ) call this % epwb % new ( this % p , this % err , this % sp2 , dim = 2 , fftflag = . true .) call this % bxyz % new ( this % p , this % err , this % sp2 , dim = 3 , fftflag = . true .) call input % get ( 'simulation.nspecies' , n ) loop1 : do i = 1 , n write ( s1 , '(I4.4)' ) i call input % info ( 'species(' // trim ( s1 ) // ').diag' , n_children = m ) do j = 1 , m write ( s2 , '(I4.4)' ) j call input % get ( 'species(' // trim ( s1 ) // ').diag' // '(' // trim ( s2 ) // ').ndump' , ndump ) if ( ndump > 0 ) then call input % info ( 'species(' // trim ( s1 ) // ').diag' // '(' // trim ( s2 ) // ').name' , n_children = l ) do k = 1 , l write ( s3 , '(I4.4)' ) k if ( allocated ( ff )) deallocate ( ff ) call input % get ( 'species(' // trim ( s1 ) // ').diag' // '(' // trim ( s2 ) // ').name' & & // '(' // trim ( s3 ) // ')' , ff ) if ( ff == 'jx' . or . ff == 'jy' . or . ff == 'jz' ) then allocate ( this % cu3d ) call this % cu3d % new ( this % p , this % err , this % sp3 , dim = 1 ) exit loop1 end if end do end if end do end do loop1 call input % info ( 'field.diag' , n_children = n ) loop2 : do i = 1 , n write ( s1 , '(I4.4)' ) i call input % get ( 'field.diag(' // trim ( s1 ) // ').ndump' , ndump ) if ( ndump > 0 ) then call input % info ( 'field.diag(' // trim ( s1 ) // ').name' , n_children = m ) do j = 1 , m write ( s2 , '(I4.4)' ) j if ( allocated ( ff )) deallocate ( ff ) call input % get ( 'field.diag(' // trim ( s1 ) // ').name(' // trim ( s2 ) // ')' , ff ) if ( ff == 'psi' ) then allocate ( this % psi3d ) call this % psi3d % new ( this % p , this % err , this % sp3 , dim = 1 ) exit loop2 end if end do end if end do loop2 call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine init_sim_fields ! subroutine end_sim_fields ( this ) implicit none class ( sim_fields ), intent ( inout ) :: this ! local data character ( len = 18 ), save :: sname = 'end_sim_fields:' character ( len = 18 ), save :: class = 'sim_fields:' integer :: i , n call this % err % werrfl2 ( class // sname // ' started' ) call this % bexyz % del () call this % bbxyz % del () call this % qb % del () call this % qe % del () call this % psit % del () call this % div_vpot % del () call this % psi % del () call this % reg % del () call this % fxy % del () call this % cu % del () call this % dcu % del () call this % amu % del () call this % epw % del () call this % epwb % del () call this % bxyz % del () if ( allocated ( this % psi3d )) call this % psi3d % del () if ( allocated ( this % cu3d )) call this % cu3d % del () call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine end_sim_fields ! subroutine init_sim_beams ( this , input , fields ) implicit none class ( sim_beams ), intent ( inout ) :: this type ( input_json ), pointer , intent ( inout ) :: input class ( sim_fields ), intent ( inout ) :: fields ! local data character ( len = 18 ), save :: class = 'sim_beams:' character ( len = 18 ), save :: sname = 'init_sim_beams:' integer :: i , n integer :: npf , npx , npy , npz , npp real , dimension ( 3 , 100 ) :: arg logical :: quiet real :: gamma real :: qm , qbm , dt logical :: read_rst integer :: rst_timestep , ierr type ( hdf5file ) :: file_rst character ( len = 20 ) :: sn , sid , stime , s1 this % err => input % err this % p => input % pp this % sp3 => input % sp this % sp2 => input % sp call this % err % werrfl2 ( class // sname // ' started' ) call input % get ( 'simulation.nbeams' , n ) allocate ( this % beam ( n ), this % pf ( n )) do i = 1 , n arg (:,:) = 0.0 write ( sn , '(I3.3)' ) i s1 = 'beam(' // trim ( sn ) // ')' call input % get ( trim ( s1 ) // '.profile' , npf ) select case ( npf ) case ( 0 ) allocate ( fdist3d_000 :: this % pf ( i )% p ) call this % pf ( i )% p % new ( input , i ) ! Add new distributions under this line case default write ( erstr , * ) 'Invalid species profile number:' , npf call this % err % equit ( class // sname // erstr ) end select call input % get ( trim ( s1 ) // '.q' , qm ) call input % get ( trim ( s1 ) // '.m' , qbm ) qbm = qm / qbm call input % get ( 'simulation.dt' , dt ) call this % beam ( i )% new ( this % p , this % err , this % sp3 , this % pf ( i )% p , qbm = qbm ,& & dt = dt , ci = 1.0 , xdim = 7 ) call input % get ( 'simulation.read_restart' , read_rst ) if ( read_rst ) then call input % get ( 'simulation.restart_timestep' , rst_timestep ) write ( sn , '(I4.4)' ) i write ( sid , '(I10.10)' ) this % p % getidproc () write ( stime , '(I8.8)' ) rst_timestep call file_rst % new (& & filename = './RST/Beam-' // trim ( sn ) // '/' ,& & dataname = 'RST-beam' // trim ( sn ) // '-' // trim ( sid ),& & n = rst_timestep ) call this % beam ( i )% rrst ( file_rst ) end if end do call MPI_BARRIER ( this % p % getlworld (), ierr ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine init_sim_beams ! subroutine end_sim_beams ( this ) implicit none class ( sim_beams ), intent ( inout ) :: this ! local data character ( len = 18 ), save :: sname = 'end_sim_beams:' character ( len = 18 ), save :: class = 'sim_beams:' integer :: i , n call this % err % werrfl2 ( class // sname // ' started' ) n = size ( this % beam ) do i = 1 , n call this % beam ( i )% del () end do call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine end_sim_beams ! subroutine init_sim_species ( this , input , fields , s ) implicit none class ( sim_species ), intent ( inout ) :: this type ( input_json ), pointer , intent ( inout ) :: input class ( sim_fields ), intent ( inout ) :: fields real , intent ( in ) :: s ! local data character ( len = 18 ), save :: class = 'sim_species:' character ( len = 18 ), save :: sname = 'init_sim_species:' integer :: i , n , ndump integer :: npf real , dimension ( 3 , 100 ) :: arg character ( len = 20 ) :: sn , s1 integer :: indz , xppc , yppc real :: min , max , cwp , n0 real :: qm , qbm , dz this % err => input % err this % p => input % pp this % sp3 => input % sp this % sp2 => input % sp call this % err % werrfl2 ( class // sname // ' started' ) call input % get ( 'simulation.n0' , n0 ) call input % get ( 'simulation.indz' , indz ) cwp = 5.32150254 * 1 e9 / sqrt ( n0 ) call input % get ( 'simulation.box.z(1)' , min ) call input % get ( 'simulation.box.z(2)' , max ) dz = ( max - min ) / real ( 2 ** indz ) call input % get ( 'simulation.nspecies' , n ) allocate ( this % spe ( n ), this % pf ( n )) do i = 1 , n write ( sn , '(I3.3)' ) i s1 = 'species(' // trim ( sn ) // ')' call input % get ( trim ( s1 ) // '.profile' , npf ) select case ( npf ) case ( 0 ) allocate ( fdist2d_000 :: this % pf ( i )% p ) call this % pf ( i )% p % new ( input , i ) ! Add new distributions under this line case default write ( erstr , * ) 'Invalid species profile number:' , npf call this % err % equit ( class // sname // erstr ) end select call input % get ( trim ( s1 ) // '.q' , qm ) call input % get ( trim ( s1 ) // '.m' , qbm ) qbm = qm / qbm call this % spe ( i )% new ( this % p , this % err , this % sp3 , this % pf ( i )% p ,& & qbm = qbm , dt = dz , ci = 1.0 , xdim = 8 , s = s ) end do call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine init_sim_species ! subroutine end_sim_species ( this ) implicit none class ( sim_species ), intent ( inout ) :: this ! local data character ( len = 18 ), save :: sname = 'end_sim_species:' character ( len = 18 ), save :: class = 'sim_species:' integer :: i , n call this % err % werrfl2 ( class // sname // ' started' ) n = size ( this % spe ) do i = 1 , n call this % spe ( i )% del () end do call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine end_sim_species ! subroutine go_simulation ( this ) implicit none class ( simulation ), intent ( inout ) :: this ! local data character ( len = 18 ), save :: sname = 'go_simulation:' integer , dimension ( 10 ) :: istat integer :: i , j , l , m , n , ierr call this % err % werrfl2 ( class // sname // ' started' ) do i = this % start3d , this % nstep3d this % tstep = i write ( erstr , * ) '3D step:' , i call this % err % werrfl0 ( erstr ) do m = 1 , this % nbeams this % tag_bq ( m , 1 ) = ntag () this % tag_bq ( m , 2 ) = ntag () call this % beams % beam ( m )% qdp ( this % id_bq ( m , 1 ), this % id_bq ( m , 2 ),& & this % id_bq ( m , 3 ), this % tag_bq ( m , 1 ), this % tag_bq ( m , 2 )) end do do l = 1 , this % nspecies this % tag_spe ( l ) = ntag () call this % species % spe ( l )% precv ( this % tag_spe ( l )) end do this % tag ( 3 ) = ntag () call this % fields % cu % precv ( this % tag ( 3 )) this % tag ( 4 ) = ntag () call this % fields % epw % precv ( this % tag ( 4 )) this % tag ( 5 ) = ntag () call this % fields % fxy % precv ( this % tag ( 5 )) this % tag ( 6 ) = ntag () call this % fields % psit % precv ( this % tag ( 6 )) this % tag ( 7 ) = ntag () call this % fields % bxyz % precv ( this % tag ( 7 )) call this % fields % fxy % cb ( this % fields % bexyz , 1 ,( / 1 , 2 / ),( / 1 , 2 / )) call this % fields % psit % cb ( this % fields % bexyz , 1 ,( / 1 / ),( / 3 / )) call this % fields % bxyz % cb ( this % fields % bbxyz , 1 ,( / 1 , 2 , 3 / ),( / 1 , 2 , 3 / )) do j = 1 , this % nstep2d write ( erstr , * ) '2D step:' , j call this % err % werrfl0 ( erstr ) if ( j == this % nstep2d ) then do m = 1 , this % nbeams call MPI_WAIT ( this % id_bq ( m , 2 ), istat , ierr ) end do endif call this % fields % qb % as ( 0.0 ) do m = 1 , this % nbeams call this % beams % beam ( m )% qdp ( this % fields % qb , j + 1 ) end do call this % fields % qb % fftrk ( 1 ) call this % fields % qb % elf ( this % fields % epwb ) call this % fields % qe % as ( 0.0 ) do l = 1 , this % nspecies call this % species % spe ( l )% qdp ( this % fields % qe ) end do call this % fields % qe % fftrk ( 1 ) call this % fields % qe % pot ( this % fields % psi ) call this % fields % psi % grad ( this % fields % fxy ) call this % fields % fxy % fftkr ( 1 ) call this % fields % psi % fftkr ( 1 ) do l = 1 , this % nspecies call this % species % spe ( l )% extpsi ( this % fields % psi , this % dex ) end do call this % fields % psi % mult ( this % fields % psi , this % dex * this % dex ) if ( allocated ( this % fields % psi3d )) call this % fields % psi % cb ( this % fields % psi3d , j + 1 ,( / 1 / ),( / 1 / )) call this % fields % cu % div ( this % fields % div_vpot ) call this % fields % div_vpot % pot ( this % fields % psit ) call this % fields % psit % mult ( this % fields % psit , - this % dex ) call this % fields % psit % fftkr ( 1 ) call this % fields % cu % bf ( this % fields % bxyz ) do l = 1 , this % iter call this % fields % bxyz % mult ( this % fields % epw ,( / 1 , 2 / ),( / 2 , 1 / ),( /- this % dex , this % dex / )) call this % fields % bxyz % mult ( this % fields % bxyz ,( / 3 / ),( / 3 / ),( / this % dex / )) call this % fields % bxyz % sub ( this % fields % bxyz , this % fields % epwb ,( / 1 / ),( / 1 / ),( / 2 / )) call this % fields % bxyz % add ( this % fields % bxyz , this % fields % epwb ,( / 2 / ),( / 2 / ),( / 1 / )) call this % fields % bxyz % fftkr ( 2 ) call this % fields % cu % as ( 0.0 ) call this % fields % dcu % as ( 0.0 ) call this % fields % amu % as ( 0.0 ) do m = 1 , this % nspecies call this % species % spe ( m )% amjdp ( this % fields % fxy , this % fields % bxyz , this % fields % psit ,& & this % fields % cu , this % fields % amu , this % fields % dcu , this % dex ) end do call this % fields % cu % mult ( this % fields % cu , this % dex ) call this % fields % amu % mult ( this % fields % amu , this % dex ) call this % fields % dcu % mult ( this % fields % dcu , this % dex ) if ( l == this % iter ) then do m = 1 , this % nspecies call this % species % spe ( m )% cbq ( j + 1 ) end do if ( allocated ( this % fields % cu3d )) then call this % fields % cu % cb ( this % fields % cu3d , j + 1 ,( / 1 , 2 , 3 / ),( / 1 , 2 , 3 / )) end if endif call this % fields % cu % fftrk ( 1 ) call this % fields % dcu % fftrk ( 1 ) call this % fields % amu % fftrk ( 3 ) call this % fields % cu % bfqp ( this % fields % dcu , this % fields % amu , this % fields % epw , this % dex2 ,& & this % dex ) call this % fields % cu % div ( this % fields % div_vpot ) call this % fields % div_vpot % pot ( this % fields % psit ) call this % fields % psit % mult ( this % fields % psit , - this % dex ) call this % fields % psit % fftkr ( 1 ) call this % fields % cu % bf ( this % fields % bxyz ) enddo call this % fields % bxyz % mult ( this % fields % epw ,( / 1 , 2 / ),( / 2 , 1 / ),( /- this % dex , this % dex / )) call this % fields % bxyz % mult ( this % fields % bxyz ,( / 3 / ),( / 3 / ),( / this % dex / )) call this % fields % bxyz % sub ( this % fields % bxyz , this % fields % epwb ,( / 1 / ),( / 1 / ),( / 2 / )) call this % fields % bxyz % add ( this % fields % bxyz , this % fields % epwb ,( / 2 / ),( / 2 / ),( / 1 / )) call this % fields % bxyz % fftkr ( 2 ) call this % fields % fxy % mult ( this % fields % fxy , - 1.0 ) call this % fields % fxy % add ( this % fields % fxy , this % fields % bxyz ,( / 1 / ),( / 1 / ),( / 2 / )) call this % fields % fxy % sub ( this % fields % fxy , this % fields % bxyz ,( / 2 / ),( / 2 / ),( / 1 / )) call this % fields % dcu % mult ( this % fields % dcu , this % dxi ) call this % fields % cu % sub ( this % fields % cu , this % fields % dcu ,( / 1 , 2 / ),( / 1 , 2 / ),( / 1 , 2 / )) do m = 1 , this % nspecies call this % species % spe ( m )% push ( this % fields % fxy , this % fields % bxyz , this % fields % psit ,& & this % dex ) end do call this % fields % fxy % mult ( this % fields % fxy , this % dex ) call this % fields % fxy % cb ( this % fields % bexyz , j + 1 ,( / 1 , 2 / ),( / 1 , 2 / )) call this % fields % psit % cb ( this % fields % bexyz , j + 1 ,( / 1 / ),( / 3 / )) call this % fields % bxyz % mult ( this % fields % bxyz ,( / 1 , 2 / ),( / 1 , 2 / ),( / this % dex , this % dex / )) call this % fields % bxyz % cb ( this % fields % bbxyz , j + 1 ,( / 1 , 2 , 3 / ),( / 1 , 2 , 3 / )) enddo do m = 1 , this % nspecies call this % species % spe ( m )% psend ( this % tag_spe ( m ), this % id_spe ( m )) end do call MPI_WAIT ( this % id ( 5 ), istat , ierr ) call this % fields % cu % psend ( this % tag ( 3 ), this % id ( 5 )) call MPI_WAIT ( this % id ( 6 ), istat , ierr ) call this % fields % epw % psend ( this % tag ( 4 ), this % id ( 6 )) call MPI_WAIT ( this % id ( 7 ), istat , ierr ) call this % fields % fxy % psend ( this % tag ( 5 ), this % id ( 7 )) call MPI_WAIT ( this % id ( 8 ), istat , ierr ) call this % fields % psit % psend ( this % tag ( 6 ), this % id ( 8 )) call MPI_WAIT ( this % id ( 9 ), istat , ierr ) call this % fields % bxyz % psend ( this % tag ( 7 ), this % id ( 9 )) do m = 1 , this % nbeams this % tag_beam ( m ) = ntag () call MPI_WAIT ( this % id_beam ( m ), istat , ierr ) call this % beams % beam ( m )% push ( this % fields % bexyz , this % fields % bbxyz , this % dex , this % dxi ,& & this % tag_beam ( m ), this % tag_beam ( m ), this % id_beam ( m )) end do call this % diag_simulation () do m = 1 , this % nspecies call MPI_WAIT ( this % id_spe ( m ), istat , ierr ) call this % species % spe ( m )% renew ( i * this % dt ) end do end do call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine go_simulation ! subroutine init_diag ( this ) implicit none class ( simulation ), intent ( inout ), target :: this ! local data character ( len = 18 ), save :: sname = 'init_diag:' integer :: n_diag = 0 , ndump , slice , slice_pos , sample integer :: n , m , l , i , j , k , ii character ( len = 20 ) :: s1 , s2 , s3 , s4 , sn1 , sn2 , sn3 , sn4 character ( len = :), allocatable :: ss , sl real :: min , max , n0 , dt real :: alx1 , aly1 , alz1 , alx2 , aly2 , alz2 logical :: rst integer :: ierr , indx , indy , indz , dim class ( * ), pointer :: obj => null () call this % err % werrfl2 ( class // sname // ' started' ) call this % in % get ( 'simulation.n0' , n0 ) call this % in % get ( 'simulation.indx' , indx ) call this % in % get ( 'simulation.indy' , indy ) call this % in % get ( 'simulation.indz' , indz ) call this % in % get ( 'simulation.box.x(1)' , min ) call this % in % get ( 'simulation.box.x(2)' , max ) alx1 = min alx2 = max call this % in % get ( 'simulation.box.y(1)' , min ) call this % in % get ( 'simulation.box.y(2)' , max ) aly1 = min aly2 = max call this % in % get ( 'simulation.box.z(1)' , min ) call this % in % get ( 'simulation.box.z(2)' , max ) alz1 = min alz2 = max call this % in % get ( 'simulation.dt' , dt ) do i = 1 , this % nbeams write ( s1 , '(I4.4)' ) i call this % in % info ( 'beam(' // trim ( s1 ) // ').diag' , n_children = m ) do j = 1 , m write ( s2 , '(I4.4)' ) j call this % in % get ( 'beam(' // trim ( s1 ) // ').diag' // '(' // trim ( s2 ) // ').ndump' , ndump ) if ( ndump > 0 ) then call this % in % info ( 'beam(' // trim ( s1 ) // ').diag' // '(' // trim ( s2 ) // ').name' , n_children = l ) if ( this % in % found ( 'beam(' // trim ( s1 ) // ').diag' // '(' // trim ( s2 ) // ').slice' )) then call this % in % info ( 'beam(' // trim ( s1 ) // ').diag' // '(' // trim ( s2 ) // ').slice' , n_children = n ) n_diag = n_diag + l * n else n_diag = n_diag + l end if end if end do end do do i = 1 , this % nspecies write ( s1 , '(I4.4)' ) i call this % in % info ( 'species(' // trim ( s1 ) // ').diag' , n_children = m ) do j = 1 , m write ( s2 , '(I4.4)' ) j call this % in % get ( 'species(' // trim ( s1 ) // ').diag' // '(' // trim ( s2 ) // ').ndump' , ndump ) if ( ndump > 0 ) then call this % in % info ( 'species(' // trim ( s1 ) // ').diag' // '(' // trim ( s2 ) // ').name' , n_children = l ) if ( this % in % found ( 'species(' // trim ( s1 ) // ').diag' // '(' // trim ( s2 ) // ').slice' )) then call this % in % info ( 'species(' // trim ( s1 ) // ').diag' // '(' // trim ( s2 ) // ').slice' , n_children = n ) n_diag = n_diag + l * n else n_diag = n_diag + l end if end if end do end do call this % in % info ( 'field.diag' , n_children = n ) do i = 1 , n write ( s1 , '(I4.4)' ) i call this % in % get ( 'field.diag(' // trim ( s1 ) // ').ndump' , ndump ) if ( ndump > 0 ) then call this % in % info ( 'field.diag(' // trim ( s1 ) // ').name' , n_children = l ) if ( this % in % found ( 'field.diag(' // trim ( s1 ) // ').slice' )) then call this % in % info ( 'field.diag(' // trim ( s1 ) // ').slice' , n_children = m ) n_diag = n_diag + l * m else n_diag = n_diag + l end if end if end do call this % in % get ( 'simulation.dump_restart' , rst ) if ( rst ) n_diag = n_diag + this % nbeams allocate ( this % diag ( n_diag )) n_diag = 0 do i = 1 , this % nbeams write ( s1 , '(I4.4)' ) i call this % in % info ( 'beam(' // trim ( s1 ) // ').diag' , n_children = m ) do j = 1 , m write ( s2 , '(I4.4)' ) j call this % in % get ( 'beam(' // trim ( s1 ) // ').diag' // '(' // trim ( s2 ) // ').ndump' , ndump ) if ( ndump > 0 ) then call this % in % info ( 'beam(' // trim ( s1 ) // ').diag' // '(' // trim ( s2 ) // ').name' , n_children = l ) do k = 1 , l write ( s3 , '(I4.4)' ) k if ( allocated ( ss )) deallocate ( ss ) call this % in % get ( 'beam(' // trim ( s1 ) // ').diag' // '(' // trim ( s2 ) // ').name' & & // '(' // trim ( s3 ) // ')' , ss ) select case ( trim ( ss )) case ( 'charge' ) if ( this % in % found ( 'beam(' // trim ( s1 ) // ').diag' // '(' // trim ( s2 ) // ').slice' )) then call this % in % info ( 'beam(' // trim ( s1 ) // ').diag' // '(' // trim ( s2 ) // ').slice' , n_children = n ) do ii = 1 , n n_diag = n_diag + 1 this % diag ( n_diag )% df = ndump this % diag ( n_diag )% obj => this % beams % beam ( i ) allocate ( this % diag ( n_diag )% slice , this % diag ( n_diag )% slice_pos ) allocate ( this % diag ( n_diag )% dim ) this % diag ( n_diag )% dim = 1 if ( allocated ( sl )) deallocate ( sl ) write ( s4 , '(I4.4)' ) ii call this % in % get ( 'beam(' // trim ( s1 ) // ').diag' // '(' // trim ( s2 ) // ').& &slice(' // trim ( s4 ) // ').(1)' , sl ) select case ( sl ) case ( 'yz' ) this % diag ( n_diag )% slice = 1 call this % diag ( n_diag )% file % new (& & axismin = ( / aly1 , alz1 , alx1 / ),& & axismax = ( / aly2 , alz2 , alx2 / ),& & axisname = ( / 'y  ' , '\\xi' , 'x  ' / ),& & axislabel = ( / 'y  ' , '\\xi' , 'x  ' / )) case ( 'xz' ) this % diag ( n_diag )% slice = 2 call this % diag ( n_diag )% file % new (& & axismin = ( / alx1 , alz1 , aly1 / ),& & axismax = ( / alx2 , alz2 , aly2 / ),& & axisname = ( / 'x  ' , '\\xi' , 'y  ' / ),& & axislabel = ( / 'x  ' , '\\xi' , 'y  ' / )) case ( 'xy' ) this % diag ( n_diag )% slice = 3 call this % diag ( n_diag )% file % new (& & axismin = ( / alx1 , aly1 , alz1 / ),& & axismax = ( / alx2 , aly2 , alz2 / ),& & axisname = ( / 'x' , 'y' , 'z' / ),& & axislabel = ( / 'x' , 'y' , 'z' / )) end select call this % in % get ( 'beam(' // trim ( s1 ) // ').diag' // '(' // trim ( s2 ) // ').& &slice(' // trim ( s4 ) // ').(2)' , this % diag ( n_diag )% slice_pos ) if ( this % p % getidproc () == 0 ) then call system ( 'mkdir -p ./Beam' // trim ( s1 ) // '/Charge_slice_' // trim ( s4 ) // '/' ) end if call this % diag ( n_diag )% file % new (& & timeunits = '1 / \\omega_p' ,& & dt = dt ,& & axisunits = ( / 'c / \\omega_p' , 'c / \\omega_p' , 'c / \\omega_p' / ),& & rank = 2 ,& & filename = './Beam' // trim ( s1 ) // '/Charge_slice_' // trim ( s4 ) // '/' ,& & dataname = 'charge_slice_' // sl ,& & units = 'n_0' ,& & label = 'Charge Density' ) end do else n_diag = n_diag + 1 this % diag ( n_diag )% df = ndump this % diag ( n_diag )% obj => this % beams % beam ( i ) allocate ( this % diag ( n_diag )% dim ) this % diag ( n_diag )% dim = 1 if ( this % p % getidproc () == 0 ) then call system ( 'mkdir -p ./Beam' // trim ( s1 ) // '/Charge/' ) end if call this % diag ( n_diag )% file % new (& & timeunits = '1 / \\omega_p' ,& & dt = dt ,& & axisname = ( / 'x  ' , 'y  ' , '\\xi' / ),& & axislabel = ( / 'x  ' , 'y  ' , '\\xi' / ),& & axisunits = ( / 'c / \\omega_p' , 'c / \\omega_p' , 'c / \\omega_p' / ),& & axismin = ( / alx1 , aly1 , alz1 / ),& & axismax = ( / alx2 , aly2 , alz2 / ),& & rank = 3 ,& & filename = './Beam' // trim ( s1 ) // '/Charge/' ,& & dataname = 'charge' ,& & units = 'n_0' ,& & label = 'Charge Density' ) end if case ( 'raw' ) n_diag = n_diag + 1 this % diag ( n_diag )% df = ndump this % diag ( n_diag )% obj => this % beams % beam ( i ) allocate ( this % diag ( n_diag )% psample ) call this % in % get ( 'beam(' // trim ( s1 ) // ').diag' // '(' // trim ( s2 ) // ').& &sample' , this % diag ( n_diag )% psample ) if ( this % p % getidproc () == 0 ) then call system ( 'mkdir -p ./Beam' // trim ( s1 ) // '/Raw/' ) end if call this % diag ( n_diag )% file % new (& & timeunits = '1 / \\omega_p' ,& & dt = dt ,& & ty = 'particles' ,& & filename = './Beam' // trim ( s1 ) // '/Raw/' ,& & dataname = 'raw' ,& & units = '' ,& & label = 'Beam Raw' ) end select end do end if end do end do do i = 1 , this % nspecies write ( s1 , '(I4.4)' ) i call this % in % info ( 'species(' // trim ( s1 ) // ').diag' , n_children = m ) do j = 1 , m write ( s2 , '(I4.4)' ) j call this % in % get ( 'species(' // trim ( s1 ) // ').diag' // '(' // trim ( s2 ) // ').ndump' , ndump ) if ( ndump > 0 ) then call this % in % info ( 'species(' // trim ( s1 ) // ').diag' // '(' // trim ( s2 ) // ').name' , n_children = l ) do k = 1 , l write ( s3 , '(I4.4)' ) k if ( allocated ( ss )) deallocate ( ss ) call this % in % get ( 'species(' // trim ( s1 ) // ').diag' // '(' // trim ( s2 ) // ').name' & & // '(' // trim ( s3 ) // ')' , ss ) select case ( trim ( ss )) case ( 'charge' ) sn1 = 'Charge' sn2 = 'charge' sn3 = 'n_0' sn4 = 'Charge Density' dim = 1 obj => this % species % spe ( i ) case ( 'jx' ) sn1 = 'Jx' sn2 = 'jx' sn3 = 'n_0 c' sn4 = 'J_x' dim = 1 obj => this % fields % cu3d case ( 'jy' ) sn1 = 'Jy' sn2 = 'jy' sn3 = 'n_0 c' sn4 = 'J_y' dim = 2 obj => this % fields % cu3d case ( 'jz' ) sn1 = 'Jz' sn2 = 'jz' sn3 = 'n_0 c' sn4 = 'J_z' dim = 3 obj => this % fields % cu3d end select if ( this % in % found ( 'species(' // trim ( s1 ) // ').diag' // '(' // trim ( s2 ) // ').slice' )) then call this % in % info ( 'species(' // trim ( s1 ) // ').diag' // '(' // trim ( s2 ) // ').slice' , n_children = n ) do ii = 1 , n n_diag = n_diag + 1 this % diag ( n_diag )% df = ndump this % diag ( n_diag )% obj => obj allocate ( this % diag ( n_diag )% slice , this % diag ( n_diag )% slice_pos ) allocate ( this % diag ( n_diag )% dim ) this % diag ( n_diag )% dim = dim if ( allocated ( sl )) deallocate ( sl ) write ( s4 , '(I4.4)' ) ii call this % in % get ( 'species(' // trim ( s1 ) // ').diag' // '(' // trim ( s2 ) // ').& &slice(' // trim ( s4 ) // ').(1)' , sl ) select case ( sl ) case ( 'yz' ) this % diag ( n_diag )% slice = 1 call this % diag ( n_diag )% file % new (& & axismin = ( / aly1 , alz1 , alx1 / ),& & axismax = ( / aly2 , alz2 , alx2 / ),& & axisname = ( / 'y  ' , '\\xi' , 'x  ' / ),& & axislabel = ( / 'y  ' , '\\xi' , 'x  ' / )) case ( 'xz' ) this % diag ( n_diag )% slice = 2 call this % diag ( n_diag )% file % new (& & axismin = ( / alx1 , alz1 , aly1 / ),& & axismax = ( / alx2 , alz2 , aly2 / ),& & axisname = ( / 'x  ' , '\\xi' , 'y  ' / ),& & axislabel = ( / 'x  ' , '\\xi' , 'y  ' / )) case ( 'xy' ) this % diag ( n_diag )% slice = 3 call this % diag ( n_diag )% file % new (& & axismin = ( / alx1 , aly1 , alz1 / ),& & axismax = ( / alx2 , aly2 , alz2 / ),& & axisname = ( / 'x' , 'y' , 'z' / ),& & axislabel = ( / 'x' , 'y' , 'z' / )) end select call this % in % get ( 'species(' // trim ( s1 ) // ').diag' // '(' // trim ( s2 ) // ').& &slice(' // trim ( s4 ) // ').(2)' , this % diag ( n_diag )% slice_pos ) if ( this % p % getidproc () == 0 ) then call system ( 'mkdir -p ./Species' // trim ( s1 ) // '/' // trim ( sn1 ) // '_slice_' // trim ( s4 ) // '/' ) end if call this % diag ( n_diag )% file % new (& & timeunits = '1 / \\omega_p' ,& & dt = dt ,& & axisunits = ( / 'c / \\omega_p' , 'c / \\omega_p' , 'c / \\omega_p' / ),& & rank = 2 ,& & filename = './Species' // trim ( s1 ) // '/' // trim ( sn1 ) // '_slice_' // trim ( s4 ) // '/' ,& & dataname = trim ( sn2 ) // '_slice_' // sl ,& & units = trim ( sn3 ),& & label = trim ( sn4 )) end do else n_diag = n_diag + 1 this % diag ( n_diag )% df = ndump this % diag ( n_diag )% obj => obj allocate ( this % diag ( n_diag )% dim ) this % diag ( n_diag )% dim = dim if ( this % p % getidproc () == 0 ) then call system ( 'mkdir -p ./Species' // trim ( s1 ) // '/' // trim ( sn1 ) // '/' ) end if call this % diag ( n_diag )% file % new (& & timeunits = '1 / \\omega_p' ,& & dt = dt ,& & axisname = ( / 'x  ' , 'y  ' , '\\xi' / ),& & axislabel = ( / 'x  ' , 'y  ' , '\\xi' / ),& & axisunits = ( / 'c / \\omega_p' , 'c / \\omega_p' , 'c / \\omega_p' / ),& & axismin = ( / alx1 , aly1 , alz1 / ),& & axismax = ( / alx2 , aly2 , alz2 / ),& & rank = 3 ,& & filename = './Species' // trim ( s1 ) // '/' // trim ( sn1 ) // '/' ,& & dataname = trim ( sn2 ),& & units = trim ( sn3 ),& & label = trim ( sn4 )) end if end do end if end do end do call this % in % info ( 'field.diag' , n_children = n ) do i = 1 , n write ( s1 , '(I4.4)' ) i call this % in % get ( 'field.diag(' // trim ( s1 ) // ').ndump' , ndump ) if ( ndump > 0 ) then call this % in % info ( 'field.diag(' // trim ( s1 ) // ').name' , n_children = m ) do j = 1 , m write ( s2 , '(I4.4)' ) j if ( allocated ( ss )) deallocate ( ss ) call this % in % get ( 'field.diag(' // trim ( s1 ) // ').name(' // trim ( s2 ) // ')' , ss ) select case ( trim ( ss )) case ( 'ex' ) sn1 = 'Ex' sn2 = 'ex' sn3 = 'mc\\omega_p/e' sn4 = 'Electric Field' dim = 1 obj => this % fields % bexyz case ( 'ey' ) sn1 = 'Ey' sn2 = 'ey' sn3 = 'mc\\omega_p/e' sn4 = 'Electric Field' dim = 2 obj => this % fields % bexyz case ( 'ez' ) sn1 = 'Ez' sn2 = 'ez' sn3 = 'mc\\omega_p/e' sn4 = 'Electric Field' dim = 3 obj => this % fields % bexyz case ( 'bx' ) sn1 = 'Bx' sn2 = 'bx' sn3 = 'mc\\omega_p/e' sn4 = 'Magnetic Field' dim = 1 obj => this % fields % bbxyz case ( 'by' ) sn1 = 'By' sn2 = 'by' sn3 = 'mc\\omega_p/e' sn4 = 'Magnetic Field' dim = 2 obj => this % fields % bbxyz case ( 'bz' ) sn1 = 'Bz' sn2 = 'bz' sn3 = 'mc\\omega_p/e' sn4 = 'Magnetic Field' dim = 3 obj => this % fields % bbxyz case ( 'psi' ) sn1 = 'Psi' sn2 = 'psi' sn3 = 'mc&#94;2' sn4 = '\\Psi' dim = 1 obj => this % fields % psi3d end select if ( this % in % found ( 'field.diag(' // trim ( s1 ) // ').slice' )) then call this % in % info ( 'field.diag(' // trim ( s1 ) // ').slice' , n_children = l ) do k = 1 , l n_diag = n_diag + 1 this % diag ( n_diag )% df = ndump this % diag ( n_diag )% obj => obj allocate ( this % diag ( n_diag )% slice , this % diag ( n_diag )% slice_pos ) allocate ( this % diag ( n_diag )% dim ) this % diag ( n_diag )% dim = dim if ( allocated ( sl )) deallocate ( sl ) write ( s3 , '(I4.4)' ) k call this % in % get ( 'field.diag(' // trim ( s1 ) // ').& &slice(' // trim ( s3 ) // ').(1)' , sl ) select case ( sl ) case ( 'yz' ) this % diag ( n_diag )% slice = 1 call this % diag ( n_diag )% file % new (& & axismin = ( / aly1 , alz1 , alx1 / ),& & axismax = ( / aly2 , alz2 , alx2 / ),& & axisname = ( / 'y  ' , '\\xi' , 'x  ' / ),& & axislabel = ( / 'y  ' , '\\xi' , 'x  ' / )) case ( 'xz' ) this % diag ( n_diag )% slice = 2 call this % diag ( n_diag )% file % new (& & axismin = ( / alx1 , alz1 , aly1 / ),& & axismax = ( / alx2 , alz2 , aly2 / ),& & axisname = ( / 'x  ' , '\\xi' , 'y  ' / ),& & axislabel = ( / 'x  ' , '\\xi' , 'y  ' / )) case ( 'xy' ) this % diag ( n_diag )% slice = 3 call this % diag ( n_diag )% file % new (& & axismin = ( / alx1 , aly1 , alz1 / ),& & axismax = ( / alx2 , aly2 , alz2 / ),& & axisname = ( / 'x' , 'y' , 'z' / ),& & axislabel = ( / 'x' , 'y' , 'z' / )) end select call this % in % get ( 'field.diag(' // trim ( s1 ) // ').& &slice(' // trim ( s3 ) // ').(2)' , this % diag ( n_diag )% slice_pos ) if ( this % p % getidproc () == 0 ) then call system ( 'mkdir -p ./Fields/' // trim ( sn1 ) // '_slice' // trim ( s3 ) // '/' ) end if call this % diag ( n_diag )% file % new (& & timeunits = '1 / \\omega_p' ,& & dt = dt ,& & axisunits = ( / 'c / \\omega_p' , 'c / \\omega_p' , 'c / \\omega_p' / ),& & rank = 2 ,& & filename = './Fields/' // trim ( sn1 ) // '_slice' // trim ( s3 ) // '/' ,& & dataname = trim ( sn2 ) // 'slice' // sl ,& & units = trim ( sn3 ),& & label = trim ( sn4 )) end do else n_diag = n_diag + 1 this % diag ( n_diag )% df = ndump this % diag ( n_diag )% obj => obj allocate ( this % diag ( n_diag )% dim ) this % diag ( n_diag )% dim = dim if ( this % p % getidproc () == 0 ) then call system ( 'mkdir -p ./Fields/' // trim ( sn1 ) // '/' ) end if call this % diag ( n_diag )% file % new (& & timeunits = '1 / \\omega_p' ,& & dt = dt ,& & axisname = ( / 'x  ' , 'y  ' , '\\xi' / ),& & axislabel = ( / 'x  ' , 'y  ' , '\\xi' / ),& & axisunits = ( / 'c / \\omega_p' , 'c / \\omega_p' , 'c / \\omega_p' / ),& & axismin = ( / alx1 , aly1 , alz1 / ),& & axismax = ( / alx2 , aly2 , alz2 / ),& & rank = 3 ,& & filename = './Fields/' // trim ( sn1 ) // '/' ,& & dataname = trim ( sn2 ),& & units = trim ( sn3 ),& & label = trim ( sn4 )) end if end do end if end do if ( rst ) then call this % in % get ( 'simulation.ndump_restart' , ndump ) do i = 1 , this % nbeams write ( s1 , '(I4.4)' ) i write ( s2 , '(I10.10)' ) this % p % getidproc () n_diag = n_diag + 1 this % diag ( n_diag )% df = ndump this % diag ( n_diag )% obj => this % beams % beam ( i ) if ( this % p % getidproc () == 0 ) then call system ( 'mkdir -p ./RST/Beam-' // trim ( s1 ) // '/' ) end if call this % diag ( n_diag )% file % new (& & ty = 'rst' ,& & filename = './RST/Beam-' // trim ( s1 ) // '/' ,& & dataname = 'RST-beam' // trim ( s1 ) // '-' // trim ( s2 )) end do end if call MPI_BARRIER ( this % p % getlworld (), ierr ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine init_diag ! subroutine diag_simulation ( this ) implicit none class ( simulation ), intent ( inout ) :: this ! local data character ( len = 18 ), save :: sname = 'diag_simulation:' integer :: n , m , l , i , j , k , ierr , idn = 9 integer , dimension ( 10 ) :: istat real :: dt call this % err % werrfl2 ( class // sname // ' started' ) call this % in % get ( 'simulation.dt' , dt ) n = size ( this % diag ) do i = 1 , n if ( mod ( this % tstep - 1 , this % diag ( i )% df ) == 0 ) then call this % diag ( i )% file % new ( n = this % tstep , t = this % tstep * dt ) select type ( obj => this % diag ( i )% obj ) type is ( field3d ) if ( allocated ( this % diag ( i )% slice )) then this % tag ( 1 ) = ntag () call MPI_WAIT ( this % id ( idn + i ), istat , ierr ) call obj % wr ( this % diag ( i )% file , this % diag ( i )% dim , this % diag ( i )% slice , this % diag ( i )% slice_pos ,& & this % tag ( 1 ), this % tag ( 1 ), this % id ( idn + i )) else this % tag ( 1 ) = ntag () call MPI_WAIT ( this % id ( idn + i ), istat , ierr ) call obj % wr ( this % diag ( i )% file , this % diag ( i )% dim , this % tag ( 1 ), this % tag ( 1 ), this % id ( idn + i )) end if type is ( beam3d ) if ( allocated ( this % diag ( i )% psample )) then this % tag ( 1 ) = ntag () call MPI_WAIT ( this % id ( idn + i ), istat , ierr ) call obj % wr ( this % diag ( i )% file , this % diag ( i )% psample ,( / this % dex , this % dex , this % dxi / ),& & this % tag ( 1 ), this % tag ( 1 ), this % id ( idn + i )) else if ( allocated ( this % diag ( i )% slice )) then this % tag ( 1 ) = ntag () call MPI_WAIT ( this % id ( idn + i ), istat , ierr ) call obj % wrq ( this % diag ( i )% file , this % diag ( i )% slice , this % diag ( i )% slice_pos ,& & this % tag ( 1 ), this % tag ( 1 ), this % id ( idn + i )) else if ( allocated ( this % diag ( i )% dim )) then this % tag ( 1 ) = ntag () call MPI_WAIT ( this % id ( idn + i ), istat , ierr ) call obj % wrq ( this % diag ( i )% file , this % tag ( 1 ), this % tag ( 1 ), this % id ( idn + i )) else call obj % wrst ( this % diag ( i )% file ) end if type is ( species2d ) if ( allocated ( this % diag ( i )% slice )) then this % tag ( 1 ) = ntag () call MPI_WAIT ( this % id ( idn + i ), istat , ierr ) call obj % wrq ( this % diag ( i )% file , this % diag ( i )% slice , this % diag ( i )% slice_pos ,& & this % tag ( 1 ), this % tag ( 1 ), this % id ( idn + i )) else this % tag ( 1 ) = ntag () call MPI_WAIT ( this % id ( idn + i ), istat , ierr ) call obj % wrq ( this % diag ( i )% file , this % tag ( 1 ), this % tag ( 1 ), this % id ( idn + i )) end if end select end if end do call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine diag_simulation ! function ntag () implicit none integer , save :: tag = 0 integer :: ntag ntag = tag tag = tag + 1 end function ntag ! end module simulation_class","tags":"","loc":"sourcefile/simulation_class.f03.html"},{"title":"field2d_class.f03 – QuickPIC","text":"This file depends on sourcefile~~field2d_class.f03~~EfferentGraph sourcefile~field2d_class.f03 field2d_class.f03 sourcefile~parallel_pipe_class.f03 parallel_pipe_class.f03 sourcefile~field2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field3d_class.f03 field3d_class.f03 sourcefile~field2d_class.f03->sourcefile~field3d_class.f03 sourcefile~ufield3d_class.f03 ufield3d_class.f03 sourcefile~field2d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~hdf5io_class.f03 hdf5io_class.f03 sourcefile~field2d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~perrors_class.f03 perrors_class.f03 sourcefile~field2d_class.f03->sourcefile~perrors_class.f03 sourcefile~ufield2d_class.f03 ufield2d_class.f03 sourcefile~field2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~spect2d_class.f03 spect2d_class.f03 sourcefile~field2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~fpois2d_class.f03 fpois2d_class.f03 sourcefile~field2d_class.f03->sourcefile~fpois2d_class.f03 sourcefile~fft2d_class.f03 fft2d_class.f03 sourcefile~field2d_class.f03->sourcefile~fft2d_class.f03 sourcefile~parallel_class.f03 parallel_class.f03 sourcefile~parallel_pipe_class.f03->sourcefile~parallel_class.f03 sourcefile~field3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field3d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~field3d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~field3d_class.f03->sourcefile~perrors_class.f03 sourcefile~spect3d_class.f03 spect3d_class.f03 sourcefile~field3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~ufield3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~ufield3d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~ufield3d_class.f03->sourcefile~perrors_class.f03 sourcefile~ufield3d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~ufield3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~ufield3d_lib.f03 ufield3d_lib.f03 sourcefile~ufield3d_class.f03->sourcefile~ufield3d_lib.f03 sourcefile~hdf5io_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~hdf5io_class.f03->sourcefile~perrors_class.f03 sourcefile~perrors_class.f03->sourcefile~parallel_class.f03 sourcefile~ufield2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~ufield2d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~ufield2d_class.f03->sourcefile~perrors_class.f03 sourcefile~ufield2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~ufield2d_lib.f03 ufield2d_lib.f03 sourcefile~ufield2d_class.f03->sourcefile~ufield2d_lib.f03 sourcefile~spect2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~spect2d_class.f03->sourcefile~perrors_class.f03 sourcefile~fpois2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~fpois2d_class.f03->sourcefile~perrors_class.f03 sourcefile~fpois2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~fpois2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~fpois2d_lib.f03 fpois2d_lib.f03 sourcefile~fpois2d_class.f03->sourcefile~fpois2d_lib.f03 sourcefile~fft2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~fft2d_class.f03->sourcefile~perrors_class.f03 sourcefile~fft2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~fft2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~fft2d_lib.f03 fft2d_lib.f03 sourcefile~fft2d_class.f03->sourcefile~fft2d_lib.f03 sourcefile~spect3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~spect3d_class.f03->sourcefile~perrors_class.f03 sourcefile~spect3d_class.f03->sourcefile~spect2d_class.f03 var pansourcefilefield2d_classf03EfferentGraph = svgPanZoom('#sourcefilefield2d_classf03EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~field2d_class.f03~~AfferentGraph sourcefile~field2d_class.f03 field2d_class.f03 sourcefile~simulation_class.f03 simulation_class.f03 sourcefile~simulation_class.f03->sourcefile~field2d_class.f03 sourcefile~species2d_class.f03 species2d_class.f03 sourcefile~simulation_class.f03->sourcefile~species2d_class.f03 sourcefile~beam3d_class.f03 beam3d_class.f03 sourcefile~simulation_class.f03->sourcefile~beam3d_class.f03 sourcefile~species2d_class.f03->sourcefile~field2d_class.f03 sourcefile~beam3d_class.f03->sourcefile~field2d_class.f03 sourcefile~main.f03 main.f03 sourcefile~main.f03->sourcefile~simulation_class.f03 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules field2d_class Source Code field2d_class.f03 Source Code ! field2d class for QuickPIC Open Source 1.0 ! update: 04/18/2016 module field2d_class use perrors_class use parallel_pipe_class use spect2d_class use field3d_class use ufield2d_class use ufield3d_class use fft2d_class use fpois2d_class use hdf5io_class implicit none private public :: field2d type field2d private ! state = (0,1) = current data is in (rs,ks) ! gcells = (0,1) = (no, yes) guard cell processing is performed class ( spect2d ), pointer , public :: sp => null () class ( perrors ), pointer , public :: err => null () class ( parallel_pipe ), pointer , public :: p => null () class ( ufield2d ), pointer :: rs => null (), ks => null () class ( fft2d ), pointer :: ft => null () class ( fpois2d ), pointer :: pt => null () integer :: state , gcells contains generic :: new => init_field2d generic :: del => end_field2d generic :: fftrk => fftrk_field2d generic :: fftkr => fftkr_field2d generic :: div => divf_field2d generic :: grad => gradf_field2d generic :: curl => curlf_field2d generic :: pot => potential_field2d generic :: smooth => smoothf_field2d generic :: elf => elfield_field2d generic :: bf => bfield_field2d generic :: bfqp => bfield_qp_field2d generic :: cg => copyguard_field2d generic :: ag => acopyguard_field2d generic :: psend => pipesend_field2d generic :: precv => piperecv_field2d generic :: cp => copyfrom generic :: ca => copyadd generic :: cb => copyto generic :: as => asc , asa generic :: add => sum1 , sum2 generic :: sub => minus1 , minus2 generic :: mult => multiply1 , multiply2 generic :: wr => writehdf5_field2d procedure , private :: init_field2d , end_field2d procedure , private :: fftrk_field2d , fftkr_field2d , divf_field2d procedure , private :: gradf_field2d , curlf_field2d , potential_field2d procedure , private :: smoothf_field2d , elfield_field2d , bfield_field2d procedure , private :: bfield_qp_field2d , copyguard_field2d procedure , private :: acopyguard_field2d , pipesend_field2d procedure , private :: piperecv_field2d , asc , asa , sum1 , minus1 , multiply1 procedure , private :: writehdf5_field2d , multiply2 , sum2 , minus2 procedure , private :: copyfrom , copyto , copyadd procedure :: getstate , getgcells , getrs , getks end type character ( len = 10 ), save :: class = 'field2d:' character ( len = 128 ), save :: erstr contains ! subroutine init_field2d ( this , pp , perr , psp , dim , fftflag , state , gcells ) ! fftflag = (.false.,.true.) = (no,yes) initial ks, fft and poisson solver table implicit none class ( field2d ), intent ( inout ) :: this class ( spect2d ), intent ( in ), pointer :: psp class ( perrors ), intent ( in ), pointer :: perr class ( parallel_pipe ), intent ( in ), pointer :: pp integer , intent ( in ) :: dim logical , intent ( in ) :: fftflag integer , intent ( in ), optional :: state , gcells ! local data character ( len = 18 ), save :: sname = 'init_field2d:' integer :: nvpy , indx , indy , nd1 , nd2 this % err => perr call this % err % werrfl2 ( class // sname // ' started' ) this % sp => psp this % p => pp if ( present ( state )) then this % state = state else this % state = 0 endif if ( present ( gcells )) then this % gcells = gcells else this % gcells = 0 endif nvpy = pp % getlnvp () indx = psp % getindx () indy = psp % getindy () nd1 = 2 ** indx nd2 = 2 ** indy allocate ( this % rs ) call this % rs % new ( pp , perr , psp , dim , 0 , 0 , nvpy ) if ( fftflag ) then allocate ( this % ks ) call this % ks % new ( pp , perr , psp , dim , 1 , nd1 , nd2 , 0 , nvpy ) select case ( psp % getpsolver ()) case ( 1 ) this % ft => get_fft2table ( pp , perr , psp , indx , indy ) this % pt => get_pois2table ( pp , perr , psp , ax = 0.912871 , ay = 0.912871 , affp = 1.0 ) case default this % ft => get_fft2table ( pp , perr , psp , indx , indy ) this % pt => get_pois2table ( pp , perr , psp , ax = 0.912871 , ay = 0.912871 , affp = 1.0 ) end select endif call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine init_field2d ! subroutine end_field2d ( this ) implicit none class ( field2d ), intent ( inout ) :: this character ( len = 18 ), save :: sname = 'end_field2d:' call this % err % werrfl2 ( class // sname // ' started' ) call this % rs % del () if ( associated ( this % ks )) call this % ks % del () deallocate ( this % rs , this % ks ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine end_field2d ! subroutine fftrk_field2d ( this , kind ) implicit none class ( field2d ), intent ( inout ) :: this integer , intent ( in ) :: kind character ( len = 18 ), save :: sname = 'fftrk_field2d:' call this % err % werrfl2 ( class // sname // ' started' ) if ( this % state /= 0 ) then call this % err % equit ( class // sname // 'data is in ks' ) return endif if ( this % gcells == 0 ) call this % err % werrfl2 ( 'guard cell not processed' ) select case ( kind ) case ( 1 ) call this % ft % fsst ( this % rs , this % ks , - 1 ) case ( 2 ) call this % ft % fcct ( this % rs , this % ks , - 1 ) case ( 3 ) if ( this % rs % getdim () /= 3 ) then call this % err % equit ( class // sname // 'wrong fft kind' ) return endif call this % ft % fs3t ( this % rs , this % ks , - 1 ) end select this % state = 1 call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine fftrk_field2d ! subroutine fftkr_field2d ( this , kind ) implicit none class ( field2d ), intent ( inout ) :: this integer , intent ( in ) :: kind character ( len = 18 ), save :: sname = 'fftkr_field2d:' call this % err % werrfl2 ( class // sname // ' started' ) if ( this % state /= 1 ) then call this % err % equit ( class // sname // 'data is in rs' ) return endif select case ( kind ) case ( 1 ) call this % ft % fsst ( this % rs , this % ks , 1 ) case ( 2 ) call this % ft % fcct ( this % rs , this % ks , 1 ) case ( 3 ) if ( this % rs % getdim () /= 3 ) then call this % err % equit ( class // sname // 'wrong fft kind' ) return endif call this % ft % fs3t ( this % rs , this % ks , 1 ) end select this % state = 0 call this % rs % cg () call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine fftkr_field2d ! subroutine divf_field2d ( this , that ) implicit none class ( field2d ), intent ( inout ) :: this , that character ( len = 18 ), save :: sname = 'divf_field2d:' call this % err % werrfl2 ( class // sname // ' started' ) if ( this % state /= 1 ) then call this % err % equit ( class // sname // 'data is in rs' ) return endif call this % ft % divf ( this % ks , that % ks ) that % state = 1 call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine divf_field2d ! subroutine gradf_field2d ( this , that ) implicit none class ( field2d ), intent ( inout ) :: this , that character ( len = 18 ), save :: sname = 'gradf_field2d:' call this % err % werrfl2 ( class // sname // ' started' ) if ( this % state /= 1 ) then call this % err % equit ( class // sname // 'data is in rs' ) return endif call this % ft % gradf ( this % ks , that % ks ) that % state = 1 call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine gradf_field2d ! subroutine curlf_field2d ( this , that ) implicit none class ( field2d ), intent ( inout ) :: this , that character ( len = 18 ), save :: sname = 'curlf_field2d:' call this % err % werrfl2 ( class // sname // ' started' ) if ( this % state /= 1 ) then call this % err % equit ( class // sname // 'data is in rs' ) return endif call this % ft % curlf ( this % ks , that % ks ) that % state = 1 call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine curlf_field2d ! subroutine potential_field2d ( this , that ) implicit none class ( field2d ), intent ( inout ) :: this , that character ( len = 18 ), save :: sname = 'potential_field2d:' real :: we call this % err % werrfl2 ( class // sname // ' started' ) if ( this % state /= 1 ) then call this % err % equit ( class // sname // 'data is in rs' ) return endif call this % pt % potential ( this % ks , that % ks , we ) that % state = 1 call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine potential_field2d ! subroutine smoothf_field2d ( this , that ) implicit none class ( field2d ), intent ( inout ) :: this , that character ( len = 18 ), save :: sname = 'smoothf_field2d:' real :: we call this % err % werrfl2 ( class // sname // ' started' ) if ( this % state /= 1 ) then call this % err % equit ( class // sname // 'data is in rs' ) return endif call this % pt % smoothf ( this % ks , that % ks ) that % state = 1 call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine smoothf_field2d ! subroutine elfield_field2d ( this , that ) implicit none class ( field2d ), intent ( inout ) :: this , that character ( len = 18 ), save :: sname = 'elfield_field2d:' real :: we call this % err % werrfl2 ( class // sname // ' started' ) if ( this % state /= 1 ) then call this % err % equit ( class // sname // 'data is in rs' ) return endif call this % pt % elfield ( this % ks , that % ks , we ) that % state = 1 call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine elfield_field2d ! subroutine bfield_field2d ( this , that ) implicit none class ( field2d ), intent ( inout ) :: this , that character ( len = 18 ), save :: sname = 'bfield_field2d:' real :: we call this % err % werrfl2 ( class // sname // ' started' ) if ( this % state /= 1 ) then call this % err % equit ( class // sname // 'data is in rs' ) return endif call this % pt % bfield ( this % ks , that % ks , 1.0 , we ) that % state = 1 call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine bfield_field2d ! subroutine bfield_qp_field2d ( cu , dcu , amu , bxy , c , dex ) implicit none class ( field2d ), intent ( inout ) :: cu , dcu , amu , bxy real , intent ( in ) :: c , dex character ( len = 18 ), save :: sname = 'bfield_qp_field2d:' real :: we call cu % err % werrfl2 ( class // sname // ' started' ) if (( cu % state /= 1 ). or .( dcu % state /= 1 ). or .( amu % state /= 1 )) then call cu % err % equit ( class // sname // 'data is in rs' ) return endif call cu % pt % bfield_qp ( cu % ks , dcu % ks , amu % ks , bxy % ks , 1.0 , c , dex , we ) bxy % state = 1 call cu % err % werrfl2 ( class // sname // ' ended' ) end subroutine bfield_qp_field2d ! subroutine copyguard_field2d ( this ) implicit none class ( field2d ), intent ( inout ) :: this character ( len = 18 ), save :: sname = 'copyguard_field2d:' call this % err % werrfl2 ( class // sname // ' started' ) if ( this % state /= 0 ) then call this % err % equit ( class // sname // 'data is in ks' ) return endif call this % rs % cg () this % gcells = 1 this % state = 0 call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine copyguard_field2d ! subroutine acopyguard_field2d ( this ) implicit none class ( field2d ), intent ( inout ) :: this character ( len = 18 ), save :: sname = 'acopyguard_field2d:' call this % err % werrfl2 ( class // sname // ' started' ) if ( this % state /= 0 ) then call this % err % equit ( class // sname // 'data is in ks' ) return endif call this % rs % ag () this % gcells = 1 this % state = 0 call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine acopyguard_field2d ! subroutine pipesend_field2d ( this , stag , id ) implicit none class ( field2d ), intent ( inout ) :: this integer , intent ( in ) :: stag integer , intent ( inout ) :: id character ( len = 18 ), save :: sname = 'pipesend_field2d:' call this % err % werrfl2 ( class // sname // ' started' ) if ( this % state == 0 ) then call this % rs % psend ( stag , id ) else call this % ks % psend ( stag , id ) endif call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine pipesend_field2d ! subroutine piperecv_field2d ( this , rtag ) implicit none class ( field2d ), intent ( inout ) :: this integer , intent ( in ) :: rtag character ( len = 18 ), save :: sname = 'piperecv_field2d:' call this % err % werrfl2 ( class // sname // ' started' ) if ( this % state == 0 ) then call this % rs % precv ( rtag ) else call this % ks % precv ( rtag ) endif call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine piperecv_field2d ! subroutine asc ( this , value ) implicit none class ( field2d ), intent ( inout ) :: this real , intent ( in ) :: value character ( len = 18 ), save :: sname = 'asc:' call this % err % werrfl2 ( class // sname // ' started' ) call this % rs % as ( value ) this % state = 0 this % gcells = 1 call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine asc ! subroutine copyto ( this , that , lpos , sdim , ddim ) implicit none class ( field2d ), intent ( inout ) :: this class ( field3d ), intent ( in ) :: that integer , intent ( in ) :: lpos integer , intent ( in ), dimension (:) :: sdim , ddim ! local data character ( len = 20 ), save :: sname = 'copyto:' class ( ufield3d ), pointer :: rs3d call this % err % werrfl2 ( class // sname // ' started' ) rs3d => that % getrs () call rs3d % cp ( this % rs , lpos , sdim , ddim ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine copyto ! subroutine copyfrom ( this , that , lpos , sdim , ddim ) implicit none class ( field2d ), intent ( inout ) :: this class ( field3d ), intent ( in ) :: that integer , intent ( in ) :: lpos integer , intent ( in ), dimension (:) :: sdim , ddim ! local data character ( len = 20 ), save :: sname = 'copyfrom:' class ( ufield3d ), pointer :: rs3d call this % err % werrfl2 ( class // sname // ' started' ) rs3d => that % getrs () call rs3d % cb ( this % rs , lpos , sdim , ddim ) this % gcells = 1 this % state = 0 call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine copyfrom ! subroutine copyadd ( this , that , lpos , sdim , ddim ) implicit none class ( field2d ), intent ( inout ) :: this class ( field3d ), intent ( in ) :: that integer , intent ( in ) :: lpos integer , intent ( in ), dimension (:) :: sdim , ddim ! local data character ( len = 20 ), save :: sname = 'copyadd:' class ( ufield3d ), pointer :: rs3d call this % err % werrfl2 ( class // sname // ' started' ) rs3d => that % getrs () call rs3d % ca ( this % rs , lpos , sdim , ddim ) this % gcells = 1 this % state = 0 call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine copyadd ! subroutine asa ( this , that ) implicit none class ( field2d ), intent ( inout ) :: this , that character ( len = 18 ), save :: sname = 'asc:' call this % err % werrfl2 ( class // sname // ' started' ) if ( that % state == 0 ) then call this % rs % as ( that % rs ) else call this % ks % as ( that % ks ) endif this % state = that % state this % gcells = that % gcells call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine asa ! subroutine sum1 ( this , a1 , a2 ) implicit none class ( field2d ), intent ( inout ) :: this class ( field2d ), intent ( in ) :: a1 , a2 character ( len = 18 ), save :: sname = 'sum:' call this % err % werrfl2 ( class // sname // ' started' ) if ( a1 % state /= a2 % state ) then call this % err % equit ( class // sname // 'states are different' ) return else if ( a1 % state == 0 ) then if ( a1 % gcells /= a2 % gcells ) then call this % err % equit ( class // sname // 'gcells are different' ) return else call this % rs % add ( a1 % rs , a2 % rs ) this % state = 0 this % gcells = a1 % gcells endif else call this % ks % add ( a1 % ks , a2 % ks ) this % state = 1 endif call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine sum1 ! subroutine sum2 ( this , a1 , a2 , dim , dim1 , dim2 ) implicit none class ( field2d ), intent ( inout ) :: this class ( field2d ), intent ( in ) :: a1 , a2 integer , dimension (:), intent ( in ) :: dim , dim1 , dim2 character ( len = 18 ), save :: sname = 'sum:' call this % err % werrfl2 ( class // sname // ' started' ) if ( a1 % state /= a2 % state ) then call this % err % equit ( class // sname // 'states are different' ) return else if ( a1 % state == 0 ) then if ( a1 % gcells /= a2 % gcells ) then call this % err % equit ( class // sname // 'gcells are different' ) return else call this % rs % add ( a1 % rs , a2 % rs , dim , dim1 , dim2 ) this % state = 0 this % gcells = a1 % gcells endif else call this % ks % add ( a1 % ks , a2 % ks , dim , dim1 , dim2 ) this % state = 1 endif call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine sum2 ! subroutine minus1 ( this , a1 , a2 ) implicit none class ( field2d ), intent ( inout ) :: this class ( field2d ), intent ( in ) :: a1 , a2 character ( len = 18 ), save :: sname = 'minus:' call this % err % werrfl2 ( class // sname // ' started' ) if ( a1 % state /= a2 % state ) then call this % err % equit ( class // sname // 'states are different' ) return else if ( a1 % state == 0 ) then if ( a1 % gcells /= a2 % gcells ) then call this % err % equit ( class // sname // 'gcells are different' ) return else call this % rs % sub ( a1 % rs , a2 % rs ) this % state = 0 this % gcells = a1 % gcells endif else call this % ks % sub ( a1 % ks , a2 % ks ) this % state = 1 endif call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine minus1 ! subroutine minus2 ( this , a1 , a2 , dim , dim1 , dim2 ) implicit none class ( field2d ), intent ( inout ) :: this class ( field2d ), intent ( in ) :: a1 , a2 integer , dimension (:), intent ( in ) :: dim , dim1 , dim2 character ( len = 18 ), save :: sname = 'minus:' call this % err % werrfl2 ( class // sname // ' started' ) if ( a1 % state /= a2 % state ) then call this % err % equit ( class // sname // 'states are different' ) return else if ( a1 % state == 0 ) then if ( a1 % gcells /= a2 % gcells ) then call this % err % equit ( class // sname // 'gcells are different' ) return else call this % rs % sub ( a1 % rs , a2 % rs , dim , dim1 , dim2 ) this % state = 0 this % gcells = a1 % gcells endif else call this % ks % sub ( a1 % ks , a2 % ks , dim , dim1 , dim2 ) this % state = 1 endif call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine minus2 ! subroutine multiply1 ( this , a1 , value ) implicit none class ( field2d ), intent ( inout ) :: this class ( field2d ), intent ( in ) :: a1 real , intent ( in ) :: value character ( len = 18 ), save :: sname = 'multiply1:' call this % err % werrfl2 ( class // sname // ' started' ) if ( a1 % state == 0 ) then call this % rs % mult ( a1 % rs , value ) this % state = 0 this % gcells = a1 % gcells else call this % ks % mult ( a1 % ks , value ) this % state = 1 endif call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine multiply1 ! subroutine multiply2 ( this , a1 , dim , dim1 , value ) implicit none class ( field2d ), intent ( inout ) :: this class ( field2d ), intent ( in ) :: a1 integer , dimension (:), intent ( in ) :: dim , dim1 real , dimension (:), intent ( in ) :: value character ( len = 18 ), save :: sname = 'multiply2:' call this % err % werrfl2 ( class // sname // ' started' ) if ( a1 % state == 0 ) then call this % rs % mult ( a1 % rs , dim , dim1 , value ) this % state = 0 this % gcells = a1 % gcells else call this % ks % mult ( a1 % ks , dim , dim1 , value ) this % state = 1 endif call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine multiply2 ! subroutine writehdf5_field2d ( this , file , dim ) implicit none class ( field2d ), intent ( inout ) :: this class ( hdf5file ), intent ( in ) :: file integer , intent ( in ) :: dim character ( len = 20 ), save :: sname = 'writehdf5_field2d:' call this % err % werrfl2 ( class // sname // ' started' ) call this % rs % wr ( file , dim ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine writehdf5_field2d ! function getstate ( this ) implicit none class ( field2d ), intent ( in ) :: this integer :: getstate getstate = this % state end function getstate ! function getgcells ( this ) implicit none class ( field2d ), intent ( in ) :: this integer :: getgcells getgcells = this % gcells end function getgcells ! function getrs ( this ) implicit none class ( field2d ), intent ( in ) :: this class ( ufield2d ), pointer :: getrs getrs => this % rs end function getrs ! function getks ( this ) implicit none class ( field2d ), intent ( in ) :: this class ( ufield2d ), pointer :: getks getks => this % ks end function getks ! end module field2d_class","tags":"","loc":"sourcefile/field2d_class.f03.html"},{"title":"ufield3d_class.f03 – QuickPIC","text":"This file depends on sourcefile~~ufield3d_class.f03~~EfferentGraph sourcefile~ufield3d_class.f03 ufield3d_class.f03 sourcefile~parallel_pipe_class.f03 parallel_pipe_class.f03 sourcefile~ufield3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~hdf5io_class.f03 hdf5io_class.f03 sourcefile~ufield3d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~spect3d_class.f03 spect3d_class.f03 sourcefile~ufield3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~perrors_class.f03 perrors_class.f03 sourcefile~ufield3d_class.f03->sourcefile~perrors_class.f03 sourcefile~ufield2d_class.f03 ufield2d_class.f03 sourcefile~ufield3d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~ufield3d_lib.f03 ufield3d_lib.f03 sourcefile~ufield3d_class.f03->sourcefile~ufield3d_lib.f03 sourcefile~parallel_class.f03 parallel_class.f03 sourcefile~parallel_pipe_class.f03->sourcefile~parallel_class.f03 sourcefile~hdf5io_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~hdf5io_class.f03->sourcefile~perrors_class.f03 sourcefile~spect3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~spect3d_class.f03->sourcefile~perrors_class.f03 sourcefile~spect2d_class.f03 spect2d_class.f03 sourcefile~spect3d_class.f03->sourcefile~spect2d_class.f03 sourcefile~perrors_class.f03->sourcefile~parallel_class.f03 sourcefile~ufield2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~ufield2d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~ufield2d_class.f03->sourcefile~perrors_class.f03 sourcefile~ufield2d_lib.f03 ufield2d_lib.f03 sourcefile~ufield2d_class.f03->sourcefile~ufield2d_lib.f03 sourcefile~ufield2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~spect2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~spect2d_class.f03->sourcefile~perrors_class.f03 var pansourcefileufield3d_classf03EfferentGraph = svgPanZoom('#sourcefileufield3d_classf03EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~ufield3d_class.f03~~AfferentGraph sourcefile~ufield3d_class.f03 ufield3d_class.f03 sourcefile~fdist3d_class.f03 fdist3d_class.f03 sourcefile~fdist3d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~field3d_class.f03 field3d_class.f03 sourcefile~field3d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~field2d_class.f03 field2d_class.f03 sourcefile~field2d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~field2d_class.f03->sourcefile~field3d_class.f03 sourcefile~part3d_class.f03 part3d_class.f03 sourcefile~part3d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~part3d_class.f03->sourcefile~fdist3d_class.f03 sourcefile~simulation_class.f03 simulation_class.f03 sourcefile~simulation_class.f03->sourcefile~fdist3d_class.f03 sourcefile~simulation_class.f03->sourcefile~field3d_class.f03 sourcefile~simulation_class.f03->sourcefile~field2d_class.f03 sourcefile~species2d_class.f03 species2d_class.f03 sourcefile~simulation_class.f03->sourcefile~species2d_class.f03 sourcefile~beam3d_class.f03 beam3d_class.f03 sourcefile~simulation_class.f03->sourcefile~beam3d_class.f03 sourcefile~species2d_class.f03->sourcefile~field3d_class.f03 sourcefile~species2d_class.f03->sourcefile~field2d_class.f03 sourcefile~beam3d_class.f03->sourcefile~fdist3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~field3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~field2d_class.f03 sourcefile~beam3d_class.f03->sourcefile~part3d_class.f03 sourcefile~main.f03 main.f03 sourcefile~main.f03->sourcefile~simulation_class.f03 var pansourcefileufield3d_classf03AfferentGraph = svgPanZoom('#sourcefileufield3d_classf03AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules ufield3d_class Source Code ufield3d_class.f03 Source Code ! ufield3d class for QuickPIC Open Source 1.0 ! update: 04/18/2016 module ufield3d_class use perrors_class use parallel_pipe_class use spect3d_class use ufield3d_lib use ufield2d_class use hdf5io_class use mpi implicit none private public :: ufield3d type ufield3d private ! dim = dimension of the field ! nd1, nd2, nd3 = size of global array data in each dimension ! nvpx, nvpy, nvpz = number of processors in each dimension ! nd1p, nd2p, nd3p = size of local array data in each dimension (without guardcell) ! rf = pointer of the local 3d field array ! noff = smallest global gridpoint in y ! class ( spect3d ), pointer , public :: sp => null () class ( perrors ), pointer , public :: err => null () class ( parallel_pipe ), pointer , public :: p => null () integer :: dim integer , dimension ( 2 ) :: noff integer :: nd1 , nvpx , nd1p integer :: nd2 , nvpy , nd2p integer :: nd3 , nvpz , nd3p real , dimension (:,:,:,:), pointer :: rf => null () contains generic :: new => init_ufield3d generic :: del => end_ufield3d generic :: pcg => copyguard_pipe generic :: ag => acopyguard generic :: cp => copyin generic :: cb => copyout generic :: ca => copyadd generic :: wr => writehdf5_3d , writehdf5_2dslice generic :: as => asc , asa generic :: add => sum generic :: sub => minus generic :: mult => multiply final :: final_ufield3d procedure , private :: init_ufield3d procedure , private :: end_ufield3d procedure :: getdim procedure :: getnd1 , getnvpx , getnd1p procedure :: getnd2 , getnvpy , getnd2p procedure :: getnd3 , getnvpz , getnd3p procedure :: getrf , getnoff procedure , private :: copyguard_pipe , acopyguard procedure , private :: copyin , copyout , copyadd procedure , private :: writehdf5_3d , writehdf5_2dslice procedure , private :: asc , asa , sum , minus , multiply end type character ( len = 10 ), save :: class = 'ufield3d:' character ( len = 128 ), save :: erstr contains ! subroutine init_ufield3d ( this , pp , perr , psp , dim , nvpx , nvpy , nvpz ) implicit none class ( ufield3d ), intent ( inout ) :: this integer , intent ( in ) :: dim integer , intent ( in ) :: nvpx , nvpy , nvpz class ( spect3d ), intent ( in ), pointer :: psp class ( perrors ), intent ( in ), pointer :: perr class ( parallel_pipe ), intent ( in ), pointer :: pp ! local data character ( len = 18 ), save :: sname = 'init_ufield3d:' integer :: nd1 , nd2 , nd3 call perr % werrfl2 ( class // sname // ' started' ) this % sp => psp this % err => perr this % p => pp this % dim = dim nd1 = 2 ** psp % getindx () nd2 = 2 ** psp % getindy () nd3 = 2 ** psp % getindz () this % nd1 = nd1 this % nd2 = nd2 this % nd3 = nd3 ! make sure data is a multiple of the number of processors if (((( this % nd2 / nvpy ) * nvpy ) /= this % nd2 ) . and . ((( nvpy / this % nd2 ) * & & this % nd2 ) /= nvpy )) then write ( erstr , * ) 'data, proc number not multiples:' , this % nd2 & &, nvpy call this % err % equit ( class // sname // erstr ) return endif ! save number of processors in each dimension this % nvpx = 0 this % nvpy = nvpy this % nvpz = nvpz this % nd1p = nd1 this % nd2p = nd2 / nvpy this % nd3p = nd3 / nvpz this % noff ( 1 ) = ( pp % getlkstrt () - 1 ) * nd2 / nvpy this % noff ( 2 ) = pp % getstageid () * nd3 / pp % getnstage () allocate ( this % rf ( dim , this % nd1p + 2 , this % nd2p + 1 , this % nd3p + 1 )) this % rf (:,:,:,:) = 0.0 call perr % werrfl2 ( class // sname // ' ended' ) end subroutine init_ufield3d ! subroutine end_ufield3d ( this ) implicit none class ( ufield3d ), intent ( inout ) :: this ! local data character ( len = 18 ), save :: sname = 'end_ufield3d:' call this % err % werrfl2 ( class // sname // ' started' ) if ( associated ( this % rf )) deallocate ( this % rf ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine end_ufield3d ! subroutine final_ufield3d ( this ) implicit none type ( ufield3d ), intent ( inout ) :: this ! local data character ( len = 18 ), save :: sname = 'final_ufield3d:' call this % err % werrfl2 ( class // sname // ' started' ) if ( associated ( this % rf )) deallocate ( this % rf ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine final_ufield3d ! function getnvpy ( this ) implicit none class ( ufield3d ), intent ( in ) :: this integer :: getnvpy getnvpy = this % nvpy end function getnvpy ! function getnvpx ( this ) implicit none class ( ufield3d ), intent ( in ) :: this integer :: getnvpx getnvpx = this % nvpx end function getnvpx ! function getnvpz ( this ) implicit none class ( ufield3d ), intent ( in ) :: this integer :: getnvpz getnvpz = this % nvpz end function getnvpz ! function getnd2 ( this ) implicit none class ( ufield3d ), intent ( in ) :: this integer :: getnd2 getnd2 = this % nd2 end function getnd2 ! function getnd1 ( this ) implicit none class ( ufield3d ), intent ( in ) :: this integer :: getnd1 getnd1 = this % nd1 end function getnd1 ! function getnd3 ( this ) implicit none class ( ufield3d ), intent ( in ) :: this integer :: getnd3 getnd3 = this % nd3 end function getnd3 ! function getnd3p ( this ) implicit none class ( ufield3d ), intent ( in ) :: this integer :: getnd3p getnd3p = this % nd3p end function getnd3p ! function getnd2p ( this ) implicit none class ( ufield3d ), intent ( in ) :: this integer :: getnd2p getnd2p = this % nd2p end function getnd2p ! function getnd1p ( this ) implicit none class ( ufield3d ), intent ( in ) :: this integer :: getnd1p getnd1p = this % nd1p end function getnd1p ! function getdim ( this ) implicit none class ( ufield3d ), intent ( in ) :: this integer :: getdim getdim = this % dim end function getdim ! function getnoff ( this ) implicit none class ( ufield3d ), intent ( in ) :: this integer , dimension ( 2 ) :: getnoff getnoff = this % noff end function getnoff ! function getrf ( this ) implicit none class ( ufield3d ), intent ( in ) :: this real , dimension (:,:,:,:), pointer :: getrf getrf => this % rf end function getrf ! subroutine copyguard_pipe ( this , rtag , stag , rid , sid ) implicit none class ( ufield3d ), intent ( inout ) :: this integer , intent ( in ) :: rtag , stag integer , intent ( inout ) :: rid , sid ! local data integer :: nvpy , nvpz , kyp , kzp , ngds = 1 real , dimension (:,:,:,:), pointer :: f character ( len = 18 ), save :: sname = 'copyguard:' integer :: nxv , nypmx , nzpmx , ierr real , dimension (:,:,:), pointer :: scs call this % err % werrfl2 ( class // sname // ' started' ) f => this % rf nxv = size ( f , 1 ) * size ( f , 2 ); nypmx = size ( f , 3 ); nzpmx = size ( f , 4 ) nvpy = this % p % getlnvp (); kyp = this % nd2p ; kzp = this % nd3p nvpz = this % p % getnstage () allocate ( scs ( size ( f , 1 ) * size ( f , 2 ), size ( f , 4 ), 2 * ngds )) select case ( this % sp % getpsolver ()) case ( 1 ) select case ( this % sp % getinorder ()) case ( 1 ) call PCGUARD32L ( f , scs , this % p % getkstrt (), nvpy , nvpz , nxv , nypmx , nzpmx ,& & 1 , 1 , kyp , kzp , ngds , rtag , stag , rid , sid , ierr ) if ( this % p % getstageid () == 0 ) then sid = MPI_REQUEST_NULL endif if ( this % p % getstageid () == this % p % getnstage () - 1 ) then rid = MPI_REQUEST_NULL endif case default call PCGUARD32L ( f , scs , this % p % getkstrt (), nvpy , nvpz , nxv , nypmx , nzpmx ,& & 1 , 1 , kyp , kzp , ngds , rtag , stag , rid , sid , ierr ) if ( this % p % getstageid () == 0 ) then sid = MPI_REQUEST_NULL endif if ( this % p % getstageid () == this % p % getnstage () - 1 ) then rid = MPI_REQUEST_NULL endif end select case default call PCGUARD32L ( f , scs , this % p % getkstrt (), nvpy , nvpz , nxv , nypmx , nzpmx ,& & 1 , 1 , kyp , kzp , ngds , rtag , stag , rid , sid , ierr ) if ( this % p % getstageid () == 0 ) then sid = MPI_REQUEST_NULL endif if ( this % p % getstageid () == this % p % getnstage () - 1 ) then rid = MPI_REQUEST_NULL endif end select call this % err % werrfl2 ( class // sname // ' ended' ) deallocate ( scs ) end subroutine copyguard_pipe ! subroutine acopyguard ( this , rtag , stag , id ) implicit none class ( ufield3d ), intent ( inout ) :: this integer , intent ( in ) :: rtag , stag integer , intent ( inout ) :: id ! local data integer :: nvpy , nvpz , nx , kyp , kzp , ngds = 1 real , dimension (:,:,:,:), pointer :: f character ( len = 18 ), save :: sname = 'acopyguard:' integer :: nxv , nypmx , nzpmx , ierr real , dimension (:,:,:,:), pointer :: scs , scr call this % err % werrfl2 ( class // sname // ' started' ) f => this % rf nxv = size ( f , 2 ); nypmx = size ( f , 3 ); nzpmx = size ( f , 4 ) nvpy = this % p % getlnvp (); kyp = this % nd2p ; kzp = this % nd3p nvpz = this % p % getnstage (); nx = this % nd1p if ( size ( f , 1 ) == 1 ) then allocate ( scs ( size ( f , 2 ), size ( f , 4 ), 2 * ngds , 1 ), scr ( size ( f , 2 ), size ( f , 3 ),& & ngds , 1 )) else if ( size ( f , 1 ) == 3 ) then allocate ( scs ( size ( f , 1 ), size ( f , 2 ), size ( f , 4 ), 2 * ngds )) end if select case ( this % sp % getpsolver ()) case ( 1 ) select case ( this % sp % getinorder ()) case ( 1 ) if ( size ( f , 1 ) == 1 ) then call PAGUARD32L ( f , scs , scr , this % p % getkstrt (), nvpy , nvpz , nx , nxv ,& & nypmx , nzpmx , 1 , 1 , kyp , kzp , ngds , rtag , stag , id , ierr ) if ( this % p % getstageid () == this % p % getnstage () - 1 ) then id = MPI_REQUEST_NULL endif else if ( size ( f , 1 ) == 3 ) then call PACGUARD32L ( f , scs , this % p % getlkstrt (), nvpy , nvpz , nx , nxv ,& & nypmx , nzpmx , 1 , 1 , kyp , kzp , ngds ) end if case default call PAGUARD32L ( f , scs , scr , this % p % getkstrt (), nvpy , nvpz , nx , nxv ,& & nypmx , nzpmx , 1 , 1 , kyp , kzp , ngds , rtag , stag , id , ierr ) end select case default call PAGUARD32L ( f , scs , scr , this % p % getkstrt (), nvpy , nvpz , nx , nxv ,& & nypmx , nzpmx , 1 , 1 , kyp , kzp , ngds , rtag , stag , id , ierr ) end select deallocate ( scs , scr ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine acopyguard ! subroutine copyin ( this , fd2d , lpos , sdim , ddim ) ! copy 2d field to 3d field at the local longitudinal position lpos implicit none class ( ufield3d ), intent ( inout ) :: this class ( ufield2d ), intent ( in ), target :: fd2d integer , intent ( in ) :: lpos integer , dimension (:), intent ( in ) :: sdim , ddim ! local data character ( len = 18 ), save :: sname = 'copyin:' real , dimension (:,:,:), pointer :: rf2d integer :: i , j , k , rank , nd1 , nd2 call this % err % werrfl2 ( class // sname // ' started' ) rf2d => fd2d % getrf () rank = size ( sdim ) nd1 = size ( this % rf , 2 ) nd2 = size ( this % rf , 3 ) !$OMP PARALLEL DO PRIVATE(i,j,k) do k = 1 , nd2 do j = 1 , nd1 do i = 1 , rank this % rf ( ddim ( i ), j , k , lpos ) = rf2d ( sdim ( i ), j , k ) enddo enddo enddo !$OMP END PARALLEL DO call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine copyin ! subroutine copyout ( this , fd2d , lpos , sdim , ddim ) ! copy 3d field from the local longitudinal position lpos to a 2d field implicit none class ( ufield3d ), intent ( inout ) :: this class ( ufield2d ), intent ( in ), target :: fd2d integer , intent ( in ) :: lpos integer , dimension (:), intent ( in ) :: sdim , ddim ! local data character ( len = 18 ), save :: sname = 'copyout:' real , dimension (:,:,:), pointer :: rf2d integer :: i , j , k , rank , nd1 , nd2 call this % err % werrfl2 ( class // sname // ' started' ) rf2d => fd2d % getrf () rank = size ( sdim ) nd1 = size ( this % rf , 2 ) nd2 = size ( this % rf , 3 ) !$OMP PARALLEL DO PRIVATE(i,j,k) do k = 1 , nd2 do j = 1 , nd1 do i = 1 , rank rf2d ( ddim ( i ), j , k ) = this % rf ( sdim ( i ), j , k , lpos ) enddo enddo enddo !$OMP END PARALLEL DO call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine copyout ! subroutine copyadd ( this , fd2d , lpos , sdim , ddim ) ! copy 3d field from the local longitudinal position lpos to a 2d field implicit none class ( ufield3d ), intent ( inout ) :: this class ( ufield2d ), intent ( in ), target :: fd2d integer , intent ( in ) :: lpos integer , dimension (:), intent ( in ) :: sdim , ddim ! local data character ( len = 18 ), save :: sname = 'copyadd:' real , dimension (:,:,:), pointer :: rf2d integer :: i , j , k , rank , nd1 , nd2 call this % err % werrfl2 ( class // sname // ' started' ) rf2d => fd2d % getrf () rank = size ( sdim ) nd1 = size ( this % rf , 2 ) nd2 = size ( this % rf , 3 ) !$OMP PARALLEL DO PRIVATE(i,j,k) do k = 1 , nd2 do j = 1 , nd1 do i = 1 , rank rf2d ( ddim ( i ), j , k ) = rf2d ( ddim ( i ), j , k ) + this % rf ( sdim ( i ), j , k , lpos ) enddo enddo enddo !$OMP END PARALLEL DO call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine copyadd ! subroutine writehdf5_3d ( this , file , dim , rtag , stag , id ) implicit none class ( ufield3d ), intent ( inout ) :: this class ( hdf5file ), intent ( in ) :: file integer , intent ( in ) :: dim , rtag , stag integer , intent ( inout ) :: id ! local data integer , dimension ( 3 ) :: gsize , lsize integer , dimension ( 2 ) :: noff integer :: ierr character ( len = 18 ), save :: sname = 'writehdf5_3d:' call this % err % werrfl2 ( class // sname // ' started' ) gsize = ( / this % nd1 , this % nd2 , this % nd3 / ) lsize = ( / this % nd1p , this % nd2p , this % nd3p / ) noff = this % noff call pwfield_pipe ( this % p , this % err , file , this % rf ( dim ,:,:,:), gsize , lsize ,& & noff , rtag , stag , id , ierr ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine writehdf5_3d ! subroutine writehdf5_2dslice ( this , file , dim , slice , spos , rtag , stag , id ) ! spos = global position of the slice implicit none class ( ufield3d ), intent ( inout ) :: this class ( hdf5file ), intent ( in ) :: file integer , intent ( in ) :: dim , rtag , stag , slice , spos integer , intent ( inout ) :: id ! local data integer , dimension ( 2 ) :: gsize , lsize integer , dimension ( 2 ) :: noff integer :: ks , lpos , ierr character ( len = 18 ), save :: sname = 'writehdf5_2dslice:' call this % err % werrfl2 ( class // sname // ' started' ) noff = this % noff select case ( slice ) case ( 1 ) gsize = ( / this % nd2 , this % nd3 / ) if ( this % p % getnstage () == 1 ) then lsize = ( / this % nd2p , this % nd3p / ) call pwfield_pipe ( this % p , this % err , file , this % rf ( dim , spos ,:,:),& & gsize , lsize , noff , rtag , stag , id , ierr ) else if ( this % p % getstageid () == 0 ) then lsize = ( / this % nd2p , this % nd3p + 1 / ) call pwfield_pipe ( this % p , this % err , file , this % rf ( dim , spos ,:,:),& & gsize , lsize , noff , rtag , stag , id , ierr ) else if ( this % p % getstageid () /= ( this % p % getnstage () - 1 )) then lsize = ( / this % nd2p , this % nd3p / ) call pwfield_pipe ( this % p , this % err , file , this % rf ( dim , spos ,:, 2 :),& & gsize , lsize , noff + ( / 0 , 1 / ), rtag , stag , id , ierr ) else lsize = ( / this % nd2p , this % nd3p - 1 / ) call pwfield_pipe ( this % p , this % err , file , this % rf ( dim , spos ,:, 2 :),& & gsize , lsize , noff + ( / 0 , 1 / ), rtag , stag , id , ierr ) end if end if case ( 2 ) ks = ( spos - 1 ) / this % nd2p if ( this % p % getlkstrt () == ks + 1 ) then gsize = ( / this % nd1 , this % nd3 / ) if ( this % p % getnstage () == 1 ) then lsize = ( / this % nd1p , this % nd3p / ) lpos = spos - ks * this % nd2p call wfield_pipe ( this % p , this % err , file , this % rf ( dim ,:, lpos ,:),& & gsize , lsize , noff , rtag , stag , id , ierr ) else if ( this % p % getstageid () == 0 ) then lsize = ( / this % nd1p , this % nd3p + 1 / ) lpos = spos - ks * this % nd2p call wfield_pipe ( this % p , this % err , file , this % rf ( dim ,:, lpos ,:),& & gsize , lsize , noff , rtag , stag , id , ierr ) else if ( this % p % getstageid () /= ( this % p % getnstage () - 1 )) then lsize = ( / this % nd1p , this % nd3p / ) lpos = spos - ks * this % nd2p call wfield_pipe ( this % p , this % err , file , this % rf ( dim ,:, lpos , 2 :),& & gsize , lsize , noff + ( / 0 , 1 / ), rtag , stag , id , ierr ) else lsize = ( / this % nd1p , this % nd3p - 1 / ) lpos = spos - ks * this % nd2p call wfield_pipe ( this % p , this % err , file , this % rf ( dim ,:, lpos , 2 :),& & gsize , lsize , noff + ( / 0 , 1 / ), rtag , stag , id , ierr ) end if end if else id = MPI_REQUEST_NULL endif case ( 3 ) ks = ( spos - 1 ) / this % nd3p if ( this % p % getstageid () == ks ) then gsize = ( / this % nd1 , this % nd2 / ) lsize = ( / this % nd1p , this % nd2p / ) lpos = spos - ks * this % nd3p call pwfield ( this % p , this % err , file , this % rf ( dim ,:,:, lpos ),& & gsize , lsize , noff ( 1 ), ierr ) endif id = MPI_REQUEST_NULL end select call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine writehdf5_2dslice ! subroutine sum ( this , a1 , a2 ) implicit none class ( ufield3d ), intent ( inout ) :: this class ( ufield3d ), target , intent ( in ) :: a1 , a2 ! local data character ( len = 18 ), save :: sname = 'sum:' integer :: i , j , k , l real , dimension (:,:,:,:), pointer :: rf1 => null (), rf2 => null (),& & rf3 => null () call this % err % werrfl2 ( class // sname // ' started' ) rf1 => this % rf rf2 => a1 % rf rf3 => a2 % rf !$OMP PARALLEL DO PRIVATE(i,j,k,l) do l = 1 , size ( rf1 , 4 ) do k = 1 , size ( rf1 , 3 ) do j = 1 , size ( rf1 , 2 ) do i = 1 , size ( rf1 , 1 ) rf1 ( i , j , k , l ) = rf2 ( i , j , k , l ) + rf3 ( i , j , k , l ) enddo enddo enddo enddo !$OMP END PARALLEL DO call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine sum ! subroutine minus ( this , a1 , a2 ) implicit none class ( ufield3d ), intent ( inout ) :: this class ( ufield3d ), target , intent ( in ) :: a1 , a2 ! local data character ( len = 18 ), save :: sname = 'minus:' integer :: i , j , k , l real , dimension (:,:,:,:), pointer :: rf1 => null (), rf2 => null (),& & rf3 => null () call this % err % werrfl2 ( class // sname // ' started' ) rf1 => this % rf rf2 => a1 % rf rf3 => a2 % rf !$OMP PARALLEL DO PRIVATE(i,j,k) do l = 1 , size ( rf1 , 4 ) do k = 1 , size ( rf1 , 3 ) do j = 1 , size ( rf1 , 2 ) do i = 1 , size ( rf1 , 1 ) rf1 ( i , j , k , l ) = rf2 ( i , j , k , l ) - rf3 ( i , j , k , l ) enddo enddo enddo enddo !$OMP END PARALLEL DO call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine minus ! subroutine multiply ( this , a1 , value ) implicit none class ( ufield3d ), intent ( inout ) :: this class ( ufield3d ), target , intent ( in ) :: a1 real , intent ( in ) :: value ! local data character ( len = 18 ), save :: sname = 'multiply:' integer :: i , j , k , l real , dimension (:,:,:,:), pointer :: rf1 => null (), rf2 => null () call this % err % werrfl2 ( class // sname // ' started' ) rf1 => this % rf rf2 => a1 % rf !$OMP PARALLEL DO PRIVATE(i,j,k) do l = 1 , size ( rf1 , 4 ) do k = 1 , size ( rf1 , 3 ) do j = 1 , size ( rf1 , 2 ) do i = 1 , size ( rf1 , 1 ) rf1 ( i , j , k , l ) = rf2 ( i , j , k , l ) * value enddo enddo enddo enddo !$OMP END PARALLEL DO call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine multiply ! subroutine asc ( this , value ) implicit none class ( ufield3d ), intent ( inout ) :: this real , intent ( in ) :: value ! local data character ( len = 18 ), save :: sname = 'asc:' integer :: i , j , k , l real , dimension (:,:,:,:), pointer :: rf => null () call this % err % werrfl2 ( class // sname // ' started' ) rf => this % rf !$OMP PARALLEL DO PRIVATE(i,j,k) do l = 1 , size ( rf , 4 ) do k = 1 , size ( rf , 3 ) do j = 1 , size ( rf , 2 ) do i = 1 , size ( rf , 1 ) rf ( i , j , k , l ) = value enddo enddo enddo enddo !$OMP END PARALLEL DO call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine asc ! subroutine asa ( this , that ) implicit none class ( ufield3d ), intent ( inout ) :: this class ( ufield3d ), target , intent ( in ) :: that ! local data character ( len = 18 ), save :: sname = 'asa:' integer :: i , j , k , l real , dimension (:,:,:,:), pointer :: rf1 => null (), rf2 => null () call this % err % werrfl2 ( class // sname // ' started' ) rf1 => this % rf rf2 => that % rf !$OMP PARALLEL DO PRIVATE(i,j,k) do l = 1 , size ( rf1 , 4 ) do k = 1 , size ( rf1 , 3 ) do j = 1 , size ( rf1 , 2 ) do i = 1 , size ( rf1 , 1 ) rf1 ( i , j , k , l ) = rf2 ( i , j , k , l ) enddo enddo enddo enddo !$OMP END PARALLEL DO !         deallocate(rf2) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine asa ! end module ufield3d_class","tags":"","loc":"sourcefile/ufield3d_class.f03.html"},{"title":"ufield2d_lib77.f – QuickPIC","text":"Contents Subroutines PWRITE2 Source Code ufield2d_lib77.f Source Code c----------------------------------------------------------------------- subroutine PWRITE2 ( f , nx , kyp , nxv , kypmx , nblok , iunit , nrec , lrec , name ) c this subroutine collects distributed real 2d data f and writes to a c direct access binary file c f = input data to be written, modified on node 0 c nx/kyp = length of data f in x/y on each processor to write c nxv = first dimension of data array f, must be >= nx c kypmx = second dimension of data array f, must be >= kyp c nblok = number of parallel partitions c iunit = fortran unit number c nrec = current record number for write, if nrec > 0 c if nrec < 0, open new file and write first record c if nrec = 0, open old file, do not write c lrec = record length (used only if nrec <= 0) c name = file name (used only if nrec <= 0) c input: f, nx, kyp, nxv, kypmx, nblok, iunit, nrec, lrec, fname c output: nrec implicit none integer nx , kyp , nxv , kypmx , nblok , iunit , nrec , lrec real f character * ( * ) name dimension f ( nxv , kypmx , nblok ) c common block for parallel processing integer nproc , lgrp , lstat , mreal , mint , mcplx , mdouble , lworld c lstat = length of status array parameter ( lstat = 10 ) c nproc = number of real or virtual processors obtained c lgrp = current communicator c lworld = MPI_COMM_WORLD communicator common / PPARMS / nproc , lgrp , mreal , mint , mcplx , mdouble , lworld c local data integer istatus , nvp , idproc , np , ioff , id , nrec0 , i , j , k , l integer ierr dimension istatus ( lstat ) c determine the rank of the calling process in the communicator call MPI_COMM_RANK ( lgrp , idproc , ierr ) c determine the size of the group associated with a communicator call MPI_COMM_SIZE ( lgrp , nvp , ierr ) c node 0 receives messages from other nodes if ( idproc . eq . 0 ) then if ( nrec . lt . 0 ) then open ( unit = iunit , file = name , form = 'unformatted' , access = 'direct' 1 , recl = lrec , status = 'replace' ) nrec = 1 c open old file else if ( nrec . eq . 0 ) then open ( unit = iunit , file = name , form = 'unformatted' , access = 'direct' 1 , recl = lrec , status = 'old' ) endif c no special diagnostic node if ( nvp . eq . nproc ) then np = nvp ioff = 1 c special diagnostic node present else np = nvp - nproc ioff = 0 id = 1 call MPI_RECV ( f , nxv * kyp , mreal , id , 99 , lgrp , istatus , ierr ) endif c first write data for node 0 nrec0 = nrec write ( unit = iunit , rec = nrec ) ((( f ( j , k , l ), j = 1 , nx ), k = 1 , kyp ), l = 1 , nb 1 lok ) nrec = nrec + 1 c then write data from remaining nodes do 10 i = 2 , np id = i - ioff call MPI_RECV ( f , nxv * kyp , mreal , id , 99 , lgrp , istatus , ierr ) write ( unit = iunit , rec = nrec ) ((( f ( j , k , l ), j = 1 , nx ), k = 1 , kyp ), l = 1 1 , nblok ) nrec = nrec + 1 10 continue c read data back for node 0 read ( unit = iunit , rec = nrec0 ) ((( f ( j , k , l ), j = 1 , nx ), k = 1 , kyp ), l = 1 , nb 1 lok ) c other nodes send data to node 0 elseif ( idproc . le .( nproc + 1 )) then call MPI_SEND ( f , nxv * kyp , mreal , 0 , 99 , lgrp , ierr ) endif return end","tags":"","loc":"sourcefile/ufield2d_lib77.f.html"},{"title":"ufield3d_lib77.f – QuickPIC","text":"Contents Subroutines PCGUARD32L PACGUARD32L PAGUARD32L Source Code ufield3d_lib77.f Source Code c----------------------------------------------------------------------- subroutine PCGUARD32L ( f , scs , kstrt , nvpy , nvpz , nxv , nypmx , nzpmx , mblok , 1 nblok , kyp , kzp , ngds , tag1 , tag2 , rid , sid , ierr ) c this subroutine copies data from field to particle partitions, copying c data to guard cells, where the field and particle partitions are c assumed to be the same. c f(j,k,l,m) = real data for grid j,k,l in particle partition m.  the c number of grids per partition is uniform and includes one extra guard c cell. c scs(j,k,m) = scratch array for particle partition m c kstrt = starting data block number c nvpy/nvpz = number of real or virtual processors in y/z c nxv = first dimension of f, must be >= nx c nypmx = maximum size of particle partition in y, including guard cells c nzpmx = maximum size of particle partition in z, including guard cells c mblok/nblok = number of particle partitions in y/z c kyp/kzp = number of complex grids in y/z for each field partition. c ngds = number of guard cells c linear interpolation, for distributed data, c with 2D spatial decomposition implicit none integer kstrt , nvpy , nvpz , nxv , nypmx , nzpmx , mblok , nblok , ngds integer kyp , kzp , tag1 , tag2 , rid , sid , ierr real f , scs dimension f ( nxv , nypmx , nzpmx , mblok * nblok ) dimension scs ( nxv , nzpmx , 2 * ngds , mblok * nblok ) c common block for parallel processing integer nproc , lgrp , lstat , mreal , mint , mcplx , mdouble , lworld c lstat = length of status array parameter ( lstat = 10 ) c lgrp = current communicator c mreal = default datatype for reals common / PPARMS / nproc , lgrp , mreal , mint , mcplx , mdouble , lworld c local data integer istatus integer ky , kz , js , ks , moff , noff , kr , kl , mnblok integer nxvz , nxvy , m , my , mz , j , k dimension istatus ( lstat ) ks = ( kstrt - 1 ) / nvpy js = kstrt - nvpy * ks - 2 ks = ks - 1 noff = nypmx * nzpmx mnblok = mblok * nblok nxvz = nxv * nzpmx nxvy = nxv * nypmx c copy to guard cells in z do 130 mz = 1 , nblok moff = mblok * ( mz - 1 ) do 120 my = 1 , mblok m = my + moff ky = my + js + 1 kz = mz + ks kr = kz + 1 c      if (kr.ge.nvpz) kr = kr - nvpz kl = kz - 1 c      if (kl.lt.0) kl = kl + nvpz c     kr = ky + nvpy*kr c     kl = ky + nvpy*kl c this segment is used for mpi computers if ( kr . lt . nvpz ) then call MPI_IRECV ( f ( 1 , 1 , kzp + 1 , m ), nxvy , mreal , ky + nvpy * kr - 1 , tag1 , lwor 1 ld , rid , ierr ) endif if ( kl . ge . 0 ) then call MPI_ISEND ( f ( 1 , 1 , 1 , m ), nxvy , mreal , ky + nvpy * kl - 1 , tag2 , lworld , s 1 id , ierr ) endif 120 continue 130 continue return end c----------------------------------------------------------------------- subroutine PACGUARD32L ( f , scs , kstrt , nvpy , nvpz , nx , nxv , nypmx , nzpmx , mb 1 lok , nblok , kyp , kzp , ngds ) c this subroutine copies data from particle to field partitions, adding c data from guard cells, where the field and particle partitions are c assumed to be the same. c f(3,j,k,l,m) = real data for grid j,k,l in particle partition m.  the c number of grids per partition is uniform and includes one extra guard c cell. c scs = scratch array for particle partition m c kstrt = starting data block number c nvpy/nvpz = number of real or virtual processors in y/z c nx = system length in x direction c nxv = first dimension of f, must be >= nx+1 c nypmx = maximum size of particle partition in y, including guard cells c nzpmx = maximum size of particle partition in z, including guard cells c mblok/nblok = number of particle partitions in y/z c kyp/kzp = number of complex grids in y/z for each field partition. c ngds = number of guard cells c linear interpolation, for distributed data c with 2D spatial decomposition implicit none integer kstrt , nvpy , nvpz , nx , nxv , nypmx , nzpmx , mblok , nblok integer ngds , kyp , kzp real f , scs dimension f ( 3 , nxv , nypmx , nzpmx , mblok * nblok ) dimension scs ( 3 , nxv , nzpmx , 2 * ngds , mblok * nblok ) c common block for parallel processing integer nproc , lgrp , lstat , mreal , mint , mcplx , mdouble , lworld c lstat = length of status array parameter ( lstat = 10 ) c lgrp = current communicator c mreal = default datatype for reals common / PPARMS / nproc , lgrp , mreal , mint , mcplx , mdouble , lworld c local data integer ierr , msid , istatus integer ky , kz , js , ks , moff , noff , kr , kl , mnblok integer nx1 , kyp1 , kzp1 , nxvz , nxvy , m , my , mz , j , k , n dimension istatus ( lstat ) nx1 = nx + 1 kyp1 = kyp + 1 kzp1 = kzp + 1 ks = ( kstrt - 1 ) / nvpy js = kstrt - nvpy * ks - 2 ks = ks - 1 noff = nypmx * nzpmx mnblok = mblok * nblok nxvz = nxv * nzpmx nxvy = nxv * nypmx c special case for one processor in y if ( nvpy . eq . 1 ) then go to 170 endif c buffer data in y do 80 m = 1 , mnblok do 70 k = 1 , nzpmx do 60 j = 1 , nxv do 50 n = 1 , 3 scs ( n , j , k , 1 , m ) = f ( n , j , kyp + 1 , k , m ) 50 continue 60 continue 70 continue 80 continue c add guard cells in y do 160 mz = 1 , nblok moff = mblok * ( mz - 1 ) do 150 my = 1 , mblok m = my + moff ky = my + js kz = nvpy * ( mz + ks ) + 1 kr = ky + 1 c      if (kr.ge.nvpy) kr = kr - nvpy kl = ky - 1 c      if (kl.lt.0) kl = kl + nvpy c      kr = kr + kz c      kl = kl + kz c this segment is used for shared memory computers c     do 110 k = 1, nzpmx c     do 100 j = 1, nxv c     do 90 n = 1, 3 c     scs(n,j,k,2,m) = scs(n,j,k,1,kl) c  90 continue c 100 continue c 110 continue c this segment is used for mpi computers if ( kl . ge . 0 ) then call MPI_IRECV ( scs ( 1 , 1 , 1 , 2 , m ), 3 * nxvz , mreal , kl + kz - 1 , noff + 1 , lgrp , 1 msid , ierr ) endif if ( kr . lt . nvpy ) then call MPI_SEND ( scs ( 1 , 1 , 1 , 1 , m ), 3 * nxvz , mreal , kr + kz - 1 , noff + 1 , lgrp , i 1 err ) endif if ( kl . ge . 0 ) then call MPI_WAIT ( msid , istatus , ierr ) do 140 k = 1 , kzp1 do 130 j = 1 , nx1 do 120 n = 1 , 3 f ( n , j , 1 , k , m ) = f ( n , j , 1 , k , m ) + scs ( n , j , k , 2 , m ) 120 continue 130 continue 140 continue endif 150 continue 160 continue 170 return end c----------------------------------------------------------------------- subroutine PAGUARD32L ( f , scs , scr , kstrt , nvpy , nvpz , nx , nxv , nypmx , nzpmx 1 , mblok , nblok , kyp , kzp , ngds , tag1 , tag2 , id , ierr ) c this subroutine copies data from particle to field partitions, adding c data from guard cells, where the field and particle partitions are c assumed to be the same. c f(j,k,l,m) = real data for grid j,k,l in particle partition m.  the c number of grids per partition is uniform and includes one extra guard c cell. c scs/scr = scratch array for particle partition m c kstrt = starting data block number c nvpy/nvpz = number of real or virtual processors in y/z c nx = system length in x direction c nxv = first dimension of f, must be >= nx+1 c nypmx = maximum size of particle partition in y, including guard cells c nzpmx = maximum size of particle partition in z, including guard cells c mblok/nblok = number of particle partitions in y/z c kyp/kzp = number of complex grids in y/z for each field partition. c ngds = number of guard cells c linear interpolation, for distributed data c with 2D spatial decomposition implicit none integer kstrt , nvpy , nvpz , nx , nxv , nypmx , nzpmx , mblok , nblok integer ngds , kyp , kzp , tag1 , tag2 , id , ierr real f , scs , scr dimension f ( nxv , nypmx , nzpmx , mblok * nblok ) dimension scs ( nxv , nzpmx , 2 * ngds , mblok * nblok ) dimension scr ( nxv , nypmx , mblok * nblok ) c common block for parallel processing integer nproc , lgrp , lstat , mreal , mint , mcplx , mdouble , lworld c lstat = length of status array parameter ( lstat = 10 ) c lgrp = current communicator c mreal = default datatype for reals common / PPARMS / nproc , lgrp , mreal , mint , mcplx , mdouble , lworld c local data integer msid , istatus integer ky , kz , js , ks , moff , noff , kr , kl , mnblok integer nx1 , kyp1 , kzp1 , nxvz , nxvy , m , my , mz , j , k dimension istatus ( lstat ) nx1 = nx + 1 kyp1 = kyp + 1 kzp1 = kzp + 1 ks = ( kstrt - 1 ) / nvpy js = kstrt - nvpy * ks - 2 ks = ks - 1 noff = nypmx * nzpmx mnblok = mblok * nblok nxvz = nxv * nzpmx nxvy = nxv * nypmx c special case for one processor in y if ( nvpy . eq . 1 ) then go to 130 endif c buffer data in y do 60 m = 1 , mnblok do 50 k = 1 , nzpmx do 40 j = 1 , nxv scs ( j , k , 1 , m ) = f ( j , kyp + 1 , k , m ) 40 continue 50 continue 60 continue c add guard cells in y do 120 mz = 1 , nblok moff = mblok * ( mz - 1 ) do 110 my = 1 , mblok m = my + moff ky = my + js kz = nvpy * ( mz + ks ) + 1 kr = ky + 1 c      if (kr.ge.nvpy) kr = kr - nvpy kl = ky - 1 c      if (kl.lt.0) kl = kl + nvpy c      kr = kr + kz c      kl = kl + kz c this segment is used for shared memory computers c     do 80 k = 1, nzpmx c     do 70 j = 1, nxv c     scs(j,k,2,m) = scs(j,k,1,kl) c  70 continue c  80 continue c this segment is used for mpi computers if ( kl . ge . 0 ) then call MPI_IRECV ( scs ( 1 , 1 , 2 , m ), nxvz , mreal , kl + kz - 1 , noff + 1 , lworld , ms 1 id , ierr ) endif if ( kr . lt . nvpy ) then call MPI_SEND ( scs ( 1 , 1 , 1 , m ), nxvz , mreal , kr + kz - 1 , noff + 1 , lworld , ier 1 r ) endif if ( kl . ge . 0 ) then call MPI_WAIT ( msid , istatus , ierr ) do 100 k = 1 , kzp1 do 90 j = 1 , nx1 f ( j , 1 , k , m ) = f ( j , 1 , k , m ) + scs ( j , k , 2 , m ) 90 continue 100 continue endif 110 continue 120 continue c special case for one processor in z 130 if ( nvpz . eq . 1 ) then return endif c add guard cells in z do 220 mz = 1 , nblok moff = mblok * ( mz - 1 ) do 210 my = 1 , mblok m = my + moff ky = my + js + 1 kz = mz + ks kr = kz + 1 c      if (kr.ge.nvpz) kr = kr - nvpz kl = kz - 1 c      if (kl.lt.0) kl = kl + nvpz c      kr = ky + nvpy*kr c      kl = ky + nvpy*kl c this segment is used for shared memory computers c     do 180 k = 1, nypmx c     do 170 j = 1, nxv c     scr(j,k,m) = f(j,k,kzp+1,kl) c 170 continue c 180 continue c this segment is used for mpi computers if ( kl . ge . 0 ) then call MPI_IRECV ( scr , nxvy , mreal , ky + nvpy * kl - 1 , tag1 , lworld , msid , ier 1 r ) endif if ( kr . lt . nvpz ) then call MPI_ISEND ( f ( 1 , 1 , kzp + 1 , m ), nxvy , mreal , ky + nvpy * kr - 1 , tag2 , lwor 1 ld , id , ierr ) endif if ( kl . ge . 0 ) then call MPI_WAIT ( msid , istatus , ierr ) do 200 k = 1 , kyp1 do 190 j = 1 , nx1 f ( j , k , 1 , m ) = f ( j , k , 1 , m ) + scr ( j , k , m ) 190 continue 200 continue endif 210 continue 220 continue return end c-----------------------------------------------------------------------","tags":"","loc":"sourcefile/ufield3d_lib77.f.html"},{"title":"fdist3d_class.f03 – QuickPIC","text":"This file depends on sourcefile~~fdist3d_class.f03~~EfferentGraph sourcefile~fdist3d_class.f03 fdist3d_class.f03 sourcefile~parallel_pipe_class.f03 parallel_pipe_class.f03 sourcefile~fdist3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~ufield3d_class.f03 ufield3d_class.f03 sourcefile~fdist3d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~spect3d_class.f03 spect3d_class.f03 sourcefile~fdist3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~part3d_lib.f03 part3d_lib.f03 sourcefile~fdist3d_class.f03->sourcefile~part3d_lib.f03 sourcefile~perrors_class.f03 perrors_class.f03 sourcefile~fdist3d_class.f03->sourcefile~perrors_class.f03 sourcefile~input_class.f03 input_class.f03 sourcefile~fdist3d_class.f03->sourcefile~input_class.f03 sourcefile~parallel_class.f03 parallel_class.f03 sourcefile~parallel_pipe_class.f03->sourcefile~parallel_class.f03 sourcefile~ufield3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~ufield3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~ufield3d_class.f03->sourcefile~perrors_class.f03 sourcefile~hdf5io_class.f03 hdf5io_class.f03 sourcefile~ufield3d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~ufield2d_class.f03 ufield2d_class.f03 sourcefile~ufield3d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~ufield3d_lib.f03 ufield3d_lib.f03 sourcefile~ufield3d_class.f03->sourcefile~ufield3d_lib.f03 sourcefile~spect3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~spect3d_class.f03->sourcefile~perrors_class.f03 sourcefile~spect2d_class.f03 spect2d_class.f03 sourcefile~spect3d_class.f03->sourcefile~spect2d_class.f03 sourcefile~perrors_class.f03->sourcefile~parallel_class.f03 sourcefile~input_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~input_class.f03->sourcefile~spect3d_class.f03 sourcefile~input_class.f03->sourcefile~perrors_class.f03 sourcefile~input_class.f03->sourcefile~parallel_class.f03 sourcefile~hdf5io_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~hdf5io_class.f03->sourcefile~perrors_class.f03 sourcefile~ufield2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~ufield2d_class.f03->sourcefile~perrors_class.f03 sourcefile~ufield2d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~ufield2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~ufield2d_lib.f03 ufield2d_lib.f03 sourcefile~ufield2d_class.f03->sourcefile~ufield2d_lib.f03 sourcefile~spect2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~spect2d_class.f03->sourcefile~perrors_class.f03 var pansourcefilefdist3d_classf03EfferentGraph = svgPanZoom('#sourcefilefdist3d_classf03EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~fdist3d_class.f03~~AfferentGraph sourcefile~fdist3d_class.f03 fdist3d_class.f03 sourcefile~simulation_class.f03 simulation_class.f03 sourcefile~simulation_class.f03->sourcefile~fdist3d_class.f03 sourcefile~beam3d_class.f03 beam3d_class.f03 sourcefile~simulation_class.f03->sourcefile~beam3d_class.f03 sourcefile~part3d_class.f03 part3d_class.f03 sourcefile~part3d_class.f03->sourcefile~fdist3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~fdist3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~part3d_class.f03 sourcefile~main.f03 main.f03 sourcefile~main.f03->sourcefile~simulation_class.f03 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules fdist3d_class Source Code fdist3d_class.f03 Source Code ! fdist3d class for QuickPIC Open Source 1.0 ! update: 04/18/2016 module fdist3d_class use perrors_class use parallel_pipe_class use spect3d_class use ufield3d_class use part3d_lib use input_class implicit none private public :: fdist3d , fdist3d_000 type , abstract :: fdist3d private class ( spect3d ), pointer , public :: sp => null () class ( perrors ), pointer , public :: err => null () class ( parallel_pipe ), pointer , public :: p => null () ! ! ndprof = profile type integer :: npf , npmax contains generic :: new => init_fdist3d generic :: del => end_fdist3d generic :: dist => dist3d procedure ( ab_init_fdist3d ), deferred , private :: init_fdist3d procedure , private :: end_fdist3d procedure ( ab_dist3d ), deferred , private :: dist3d procedure :: getnpf , getnpmax end type abstract interface ! subroutine ab_dist3d ( this , part3d , npp , fd ) import fdist3d import ufield3d implicit none class ( fdist3d ), intent ( inout ) :: this real , dimension (:,:), pointer , intent ( inout ) :: part3d integer , intent ( inout ) :: npp class ( ufield3d ), intent ( in ), pointer :: fd end subroutine ab_dist3d ! subroutine ab_init_fdist3d ( this , input , i ) import fdist3d import input_json implicit none class ( fdist3d ), intent ( inout ) :: this type ( input_json ), intent ( inout ), pointer :: input integer , intent ( in ) :: i end subroutine ab_init_fdist3d ! end interface type , extends ( fdist3d ) :: fdist3d_000 private integer :: npx , npy , npz real :: qm , sigx , sigy , sigz real :: bcx , bcy , bcz , sigvx , sigvy , sigvz real :: cx1 , cx2 , cx3 , cy1 , cy2 , cy3 , gamma , np logical :: quiet contains procedure , private :: init_fdist3d => init_fdist3d_000 procedure , private :: dist3d => dist3d_000 end type fdist3d_000 character ( len = 10 ), save :: class = 'fdist3d:' character ( len = 128 ), save :: erstr contains ! function getnpf ( this ) implicit none class ( fdist3d ), intent ( in ) :: this integer :: getnpf getnpf = this % npf end function getnpf ! function getnpmax ( this ) implicit none class ( fdist3d ), intent ( in ) :: this integer :: getnpmax getnpmax = this % npmax end function getnpmax ! subroutine end_fdist3d ( this ) implicit none class ( fdist3d ), intent ( inout ) :: this character ( len = 18 ), save :: sname = 'end_fdist3d:' call this % err % werrfl2 ( class // sname // ' started' ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine end_fdist3d ! subroutine init_fdist3d_000 ( this , input , i ) implicit none class ( fdist3d_000 ), intent ( inout ) :: this type ( input_json ), intent ( inout ), pointer :: input integer , intent ( in ) :: i ! local data integer :: npf , npx , npy , npz , npmax real :: qm , sigx , sigy , sigz , bcx , bcy , bcz , sigvx , sigvy , sigvz real :: cx1 , cx2 , cx3 , cy1 , cy2 , cy3 , gamma , np logical :: quiet real :: min , max , cwp , n0 real :: alx , aly , alz , dx , dy , dz integer :: indx , indy , indz character ( len = 20 ) :: sn , s1 character ( len = 18 ), save :: sname = 'init_fdist3d_000:' this % sp => input % sp this % err => input % err this % p => input % pp call this % err % werrfl2 ( class // sname // ' started' ) write ( sn , '(I3.3)' ) i s1 = 'beam(' // trim ( sn ) // ')' call input % get ( 'simulation.n0' , n0 ) call input % get ( 'simulation.indx' , indx ) call input % get ( 'simulation.indy' , indy ) call input % get ( 'simulation.indz' , indz ) cwp = 5.32150254 * 1 e9 / sqrt ( n0 ) call input % get ( 'simulation.box.x(1)' , min ) call input % get ( 'simulation.box.x(2)' , max ) call input % get ( trim ( s1 ) // '.center(1)' , bcx ) bcx = bcx - min alx = ( max - min ) dx = alx / real ( 2 ** indx ) call input % get ( 'simulation.box.y(1)' , min ) call input % get ( 'simulation.box.y(2)' , max ) call input % get ( trim ( s1 ) // '.center(2)' , bcy ) bcy = bcy - min aly = ( max - min ) dy = aly / real ( 2 ** indy ) call input % get ( 'simulation.box.z(1)' , min ) call input % get ( 'simulation.box.z(2)' , max ) call input % get ( trim ( s1 ) // '.center(3)' , bcz ) bcz = bcz - min alz = ( max - min ) dz = alz / real ( 2 ** indz ) call input % get ( trim ( s1 ) // '.profile' , npf ) call input % get ( trim ( s1 ) // '.np(1)' , npx ) call input % get ( trim ( s1 ) // '.np(2)' , npy ) call input % get ( trim ( s1 ) // '.np(3)' , npz ) call input % get ( trim ( s1 ) // '.q' , qm ) call input % get ( trim ( s1 ) // '.sigma(1)' , sigx ) call input % get ( trim ( s1 ) // '.sigma(2)' , sigy ) call input % get ( trim ( s1 ) // '.sigma(3)' , sigz ) call input % get ( trim ( s1 ) // '.sigma_v(1)' , sigvx ) call input % get ( trim ( s1 ) // '.sigma_v(2)' , sigvy ) call input % get ( trim ( s1 ) // '.sigma_v(3)' , sigvz ) call input % get ( trim ( s1 ) // '.centroid_x(1)' , cx1 ) call input % get ( trim ( s1 ) // '.centroid_x(2)' , cx2 ) call input % get ( trim ( s1 ) // '.centroid_x(3)' , cx3 ) call input % get ( trim ( s1 ) // '.centroid_y(1)' , cy1 ) call input % get ( trim ( s1 ) // '.centroid_y(2)' , cy2 ) call input % get ( trim ( s1 ) // '.centroid_y(3)' , cy3 ) call input % get ( trim ( s1 ) // '.quiet_start' , quiet ) call input % get ( trim ( s1 ) // '.gamma' , gamma ) call input % get ( trim ( s1 ) // '.peak_density' , np ) call input % get ( trim ( s1 ) // '.npmax' , npmax ) this % npf = npf this % npx = npx this % npy = npy this % npz = npz this % npmax = npmax qm = qm * np * ( 2 * 3.1415926535897932 ) ** 1.5 * sigx * sigy * sigz qm = qm * ( 2 ** indz ) qm = qm * ( 2 ** indx ) qm = qm * ( 2 ** indy ) / ( npx * alx * aly * alz ) qm = qm / npy qm = qm / npz this % qm = qm this % bcx = bcx / dx this % bcy = bcy / dy this % bcz = bcz / dz this % sigx = sigx / dx this % sigy = sigy / dy this % sigz = sigz / dz this % sigvx = sigvx this % sigvy = sigvy this % sigvz = sigvz this % cx1 = cx1 * dz * dz / dx this % cx2 = cx2 * dz / dx this % cx3 = cx3 / dx this % cy1 = cy1 * dz * dz / dy this % cy2 = cy2 * dz / dy this % cy3 = cy3 / dy this % gamma = gamma this % np = np this % quiet = quiet call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine init_fdist3d_000 ! subroutine dist3d_000 ( this , part3d , npp , fd ) implicit none class ( fdist3d_000 ), intent ( inout ) :: this real , dimension (:,:), pointer , intent ( inout ) :: part3d integer , intent ( inout ) :: npp class ( ufield3d ), intent ( in ), pointer :: fd ! local data1 ! edges(1) = lower boundary in y of particle partition ! edges(2) = upper boundary in y of particle partition ! edges(3) = lower boundary in z of particle partition ! edges(4) = upper boundary in z of particle partition real , dimension (:,:), pointer :: pt => null () integer :: npx , npy , npz , nx , ny , nz , ipbc real :: vtx , vty , vtz , vdx , vdy , vdz real :: sigx , sigy , sigz , x0 , y0 , z0 real , dimension ( 3 ) :: cx , cy real , dimension ( 4 ) :: edges integer , dimension ( 2 ) :: noff integer :: nps = 1 logical :: lquiet = . false . integer :: idimp , npmax , ierr = 0 character ( len = 18 ), save :: sname = 'dist3d_000:' call this % err % werrfl2 ( class // sname // ' started' ) npx = this % npx ; npy = this % npy ; npz = this % npz nx = fd % getnd1 (); ny = fd % getnd2 (); nz = fd % getnd3 () ipbc = this % sp % getpsolver () pt => part3d vtx = this % sigvx ; vty = this % sigvy ; vtz = this % sigvz vdx = 0.0 ; vdy = 0.0 ; vdz = this % gamma sigx = this % sigx ; sigy = this % sigy ; sigz = this % sigz x0 = this % bcx ; y0 = this % bcy ; z0 = this % bcz cx = ( / this % cx1 , this % cx2 , this % cx3 / ); cy = ( / this % cy1 , this % cy2 , this % cy3 / ) lquiet = this % quiet idimp = size ( part3d , 1 ); npmax = size ( part3d , 2 ) noff = fd % getnoff () edges ( 1 ) = noff ( 1 ); edges ( 3 ) = noff ( 2 ) edges ( 2 ) = edges ( 1 ) + fd % getnd2p () edges ( 4 ) = edges ( 3 ) + fd % getnd3p () call PRVDIST32_RANDOM ( pt , this % qm , edges , npp , nps , vtx , vty , vtz , vdx , vdy ,& & vdz , npx , npy , npz , nx , ny , nz , ipbc , idimp , npmax , 1 , 1 , 4 , sigx , sigy , sigz ,& & x0 , y0 , z0 , cx , cy , lquiet , ierr ) if ( ierr /= 0 ) then write ( erstr , * ) 'PRVDIST32_RANDOM error' call this % err % equit ( class // sname // erstr ) endif call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine dist3d_000 ! end module fdist3d_class","tags":"","loc":"sourcefile/fdist3d_class.f03.html"},{"title":"parallel_class.f03 – QuickPIC","text":"Files dependent on this one sourcefile~~parallel_class.f03~~AfferentGraph sourcefile~parallel_class.f03 parallel_class.f03 sourcefile~parallel_pipe_class.f03 parallel_pipe_class.f03 sourcefile~parallel_pipe_class.f03->sourcefile~parallel_class.f03 sourcefile~perrors_class.f03 perrors_class.f03 sourcefile~perrors_class.f03->sourcefile~parallel_class.f03 sourcefile~simulation_class.f03 simulation_class.f03 sourcefile~simulation_class.f03->sourcefile~parallel_class.f03 sourcefile~simulation_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~simulation_class.f03->sourcefile~perrors_class.f03 sourcefile~input_class.f03 input_class.f03 sourcefile~simulation_class.f03->sourcefile~input_class.f03 sourcefile~fdist3d_class.f03 fdist3d_class.f03 sourcefile~simulation_class.f03->sourcefile~fdist3d_class.f03 sourcefile~field3d_class.f03 field3d_class.f03 sourcefile~simulation_class.f03->sourcefile~field3d_class.f03 sourcefile~hdf5io_class.f03 hdf5io_class.f03 sourcefile~simulation_class.f03->sourcefile~hdf5io_class.f03 sourcefile~spect3d_class.f03 spect3d_class.f03 sourcefile~simulation_class.f03->sourcefile~spect3d_class.f03 sourcefile~spect2d_class.f03 spect2d_class.f03 sourcefile~simulation_class.f03->sourcefile~spect2d_class.f03 sourcefile~fdist2d_class.f03 fdist2d_class.f03 sourcefile~simulation_class.f03->sourcefile~fdist2d_class.f03 sourcefile~field2d_class.f03 field2d_class.f03 sourcefile~simulation_class.f03->sourcefile~field2d_class.f03 sourcefile~species2d_class.f03 species2d_class.f03 sourcefile~simulation_class.f03->sourcefile~species2d_class.f03 sourcefile~beam3d_class.f03 beam3d_class.f03 sourcefile~simulation_class.f03->sourcefile~beam3d_class.f03 sourcefile~input_class.f03->sourcefile~parallel_class.f03 sourcefile~input_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~input_class.f03->sourcefile~perrors_class.f03 sourcefile~input_class.f03->sourcefile~spect3d_class.f03 sourcefile~fdist3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~fdist3d_class.f03->sourcefile~perrors_class.f03 sourcefile~fdist3d_class.f03->sourcefile~input_class.f03 sourcefile~fdist3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~ufield3d_class.f03 ufield3d_class.f03 sourcefile~fdist3d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~field3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field3d_class.f03->sourcefile~perrors_class.f03 sourcefile~field3d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~field3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~field3d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~hdf5io_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~hdf5io_class.f03->sourcefile~perrors_class.f03 sourcefile~spect3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~spect3d_class.f03->sourcefile~perrors_class.f03 sourcefile~spect3d_class.f03->sourcefile~spect2d_class.f03 sourcefile~ufield3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~ufield3d_class.f03->sourcefile~perrors_class.f03 sourcefile~ufield3d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~ufield3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~ufield2d_class.f03 ufield2d_class.f03 sourcefile~ufield3d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~part3d_class.f03 part3d_class.f03 sourcefile~part3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~part3d_class.f03->sourcefile~perrors_class.f03 sourcefile~part3d_class.f03->sourcefile~fdist3d_class.f03 sourcefile~part3d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~part3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~part3d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~part2d_class.f03 part2d_class.f03 sourcefile~part2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~part2d_class.f03->sourcefile~perrors_class.f03 sourcefile~part2d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~part2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~part2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~part2d_class.f03->sourcefile~fdist2d_class.f03 sourcefile~main.f03 main.f03 sourcefile~main.f03->sourcefile~simulation_class.f03 sourcefile~ufield2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~ufield2d_class.f03->sourcefile~perrors_class.f03 sourcefile~ufield2d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~ufield2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~spect2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~spect2d_class.f03->sourcefile~perrors_class.f03 sourcefile~fpois2d_class.f03 fpois2d_class.f03 sourcefile~fpois2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~fpois2d_class.f03->sourcefile~perrors_class.f03 sourcefile~fpois2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~fpois2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~fdist2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~fdist2d_class.f03->sourcefile~perrors_class.f03 sourcefile~fdist2d_class.f03->sourcefile~input_class.f03 sourcefile~fdist2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~fdist2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~field2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field2d_class.f03->sourcefile~perrors_class.f03 sourcefile~field2d_class.f03->sourcefile~field3d_class.f03 sourcefile~field2d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~field2d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~field2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~field2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~field2d_class.f03->sourcefile~fpois2d_class.f03 sourcefile~fft2d_class.f03 fft2d_class.f03 sourcefile~field2d_class.f03->sourcefile~fft2d_class.f03 sourcefile~species2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~species2d_class.f03->sourcefile~perrors_class.f03 sourcefile~species2d_class.f03->sourcefile~field3d_class.f03 sourcefile~species2d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~species2d_class.f03->sourcefile~spect3d_class.f03 sourcefile~species2d_class.f03->sourcefile~part2d_class.f03 sourcefile~species2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~species2d_class.f03->sourcefile~fdist2d_class.f03 sourcefile~species2d_class.f03->sourcefile~field2d_class.f03 sourcefile~beam3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~beam3d_class.f03->sourcefile~perrors_class.f03 sourcefile~beam3d_class.f03->sourcefile~fdist3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~field3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~beam3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~part3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~field2d_class.f03 sourcefile~fft2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~fft2d_class.f03->sourcefile~perrors_class.f03 sourcefile~fft2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~fft2d_class.f03->sourcefile~spect2d_class.f03 var pansourcefileparallel_classf03AfferentGraph = svgPanZoom('#sourcefileparallel_classf03AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules parallel_class Source Code parallel_class.f03 Source Code ! Parallel class for QuickPIC Open Source 1.0 ! update: 04/18/2016 module parallel_class use mpi use omp_lib implicit none private public :: parallel type parallel private ! nvp: number of MPI nodes ! idproc: processor id ! kstrt: idproc+1 ! mreal = default datatype for reals ! mint = default datatype for integers ! mcplx = default datatype for complex type ! mdouble = default double precision type ! lworld = MPI_COMM_WORLD communicator integer :: nvp integer :: idproc integer :: kstrt integer :: mreal , mint , mcplx , mdouble , mchar , lworld contains generic :: new => init_parallel generic :: del => end_parallel procedure :: getnvp procedure :: getidproc procedure :: getkstrt procedure :: getlworld procedure :: getmreal procedure :: getmint procedure :: getmdouble procedure :: getmcplx procedure :: getmchar procedure , private :: init_parallel procedure , private :: end_parallel end type parallel contains ! function getnvp ( this ) implicit none class ( parallel ), intent ( in ) :: this integer :: getnvp getnvp = this % nvp end function getnvp ! function getidproc ( this ) implicit none class ( parallel ), intent ( in ) :: this integer :: getidproc getidproc = this % idproc end function getidproc ! function getkstrt ( this ) implicit none class ( parallel ), intent ( in ) :: this integer :: getkstrt getkstrt = this % kstrt end function getkstrt ! function getlworld ( this ) implicit none class ( parallel ), intent ( in ) :: this integer :: getlworld getlworld = this % lworld end function getlworld ! function getmint ( this ) implicit none class ( parallel ), intent ( in ) :: this integer :: getmint getmint = this % mint end function getmint ! function getmreal ( this ) implicit none class ( parallel ), intent ( in ) :: this integer :: getmreal getmreal = this % mreal end function getmreal ! function getmdouble ( this ) implicit none class ( parallel ), intent ( in ) :: this integer :: getmdouble getmdouble = this % mdouble end function getmdouble ! function getmcplx ( this ) implicit none class ( parallel ), intent ( in ) :: this integer :: getmcplx getmcplx = this % mcplx end function getmcplx ! function getmchar ( this ) implicit none class ( parallel ), intent ( in ) :: this integer :: getmchar getmchar = this % mchar end function getmchar ! subroutine init_parallel ( this ) implicit none class ( parallel ), intent ( inout ) :: this ! nvpp = number of shared memory threads (0=default) integer :: nvpp = 0 ! initialize for shared memory parallel processing using openmp call init_omp ( nvpp ) ! initialize for distributed memory parallel processing using mpi call ppinit2 ( this % idproc , this % nvp , this % lworld ,& & this % mint , this % mreal , this % mdouble , this % mcplx , this % mchar ) this % kstrt = this % idproc + 1 end subroutine init_parallel ! subroutine ppinit2 ( idproc , nvp , lworld , mint , mreal , mdouble , mcplx , mchar ) ! this subroutine initializes parallel processing using mpi implicit none integer , intent ( inout ) :: idproc , nvp integer , intent ( inout ) :: lworld , mint , mreal , mdouble , mcplx , mchar ! nproc = number of real or virtual processors obtained ! mreal = default datatype for reals ! mint = default datatype for integers ! mcplx = default datatype for complex type ! mdouble = default double precision type ! mchar = default datatype for character type ! lworld = MPI_COMM_WORLD communicator ! local data integer :: ierror , ndprec , idprec integer :: iprec logical :: flag real :: prec integer :: nproc ! ndprec = (0,1) = (no,yes) use (normal,autodouble) precision if ( digits ( prec ) > 24 ) then ndprec = 1 else ndprec = 0 endif ! idprec = (0,1) = (no,yes) use (normal,autodouble) integer precision if ( digits ( iprec ) > 31 ) then idprec = 1 else idprec = 0 endif ! this segment is used for mpi computers ! indicate whether MPI_INIT has been called call MPI_INITIALIZED ( flag , ierror ) if (. not . flag ) then ! initialize the MPI execution environment call MPI_INIT ( ierror ) if ( ierror /= 0 ) stop endif lworld = MPI_COMM_WORLD ! determine the rank of the calling process in the communicator call MPI_COMM_RANK ( lworld , idproc , ierror ) ! determine the size of the group associated with a communicator call MPI_COMM_SIZE ( lworld , nproc , ierror ) ! set default datatypes mint = MPI_INTEGER mdouble = MPI_DOUBLE_PRECISION mchar = MPI_CHARACTER ! single precision real if ( ndprec == 0 ) then mreal = MPI_REAL mcplx = MPI_COMPLEX ! double precision real else mreal = MPI_DOUBLE_PRECISION mcplx = MPI_DOUBLE_COMPLEX endif ! single precision integer !     if (idprec==0) then !        mint = MPI_INTEGER ! double precision integer !     else !        mint = MPI_INTEGER8 !     endif ! operators nvp = nproc end subroutine ppinit2 ! subroutine init_omp ( nth ) ! initialize openmp library ! use nth threads if nth > 0; otherwise, use the number found implicit none integer , intent ( in ) :: nth ! local data integer :: ncpus , nthreads , tid ! determine how many processors are available ncpus = omp_get_num_procs () nthreads = omp_get_max_threads () if ( nth > 0 ) nthreads = nth call omp_set_num_threads ( nthreads ) !$OMP PARALLEL PRIVATE(tid) tid = OMP_GET_THREAD_NUM () !$OMP END PARALLEL end subroutine init_omp ! subroutine end_parallel ( this ) ! this subroutine terminates parallel processing implicit none class ( parallel ), intent ( inout ) :: this ! lworld = MPI_COMM_WORLD communicator ! local data integer :: ierror logical :: flag ! indicate whether MPI_INIT has been called call MPI_INITIALIZED ( flag , ierror ) if ( flag ) then ! synchronize processes call MPI_BARRIER ( this % getlworld (), ierror ) ! terminate MPI execution environment call MPI_FINALIZE ( ierror ) endif end subroutine end_parallel ! end module parallel_class","tags":"","loc":"sourcefile/parallel_class.f03.html"},{"title":"part2d_class.f03 – QuickPIC","text":"This file depends on sourcefile~~part2d_class.f03~~EfferentGraph sourcefile~part2d_class.f03 part2d_class.f03 sourcefile~parallel_pipe_class.f03 parallel_pipe_class.f03 sourcefile~part2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~hdf5io_class.f03 hdf5io_class.f03 sourcefile~part2d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~perrors_class.f03 perrors_class.f03 sourcefile~part2d_class.f03->sourcefile~perrors_class.f03 sourcefile~ufield2d_class.f03 ufield2d_class.f03 sourcefile~part2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~spect2d_class.f03 spect2d_class.f03 sourcefile~part2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~fdist2d_class.f03 fdist2d_class.f03 sourcefile~part2d_class.f03->sourcefile~fdist2d_class.f03 sourcefile~part2d_lib.f03 part2d_lib.f03 sourcefile~part2d_class.f03->sourcefile~part2d_lib.f03 sourcefile~parallel_class.f03 parallel_class.f03 sourcefile~parallel_pipe_class.f03->sourcefile~parallel_class.f03 sourcefile~hdf5io_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~hdf5io_class.f03->sourcefile~perrors_class.f03 sourcefile~perrors_class.f03->sourcefile~parallel_class.f03 sourcefile~ufield2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~ufield2d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~ufield2d_class.f03->sourcefile~perrors_class.f03 sourcefile~ufield2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~ufield2d_lib.f03 ufield2d_lib.f03 sourcefile~ufield2d_class.f03->sourcefile~ufield2d_lib.f03 sourcefile~spect2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~spect2d_class.f03->sourcefile~perrors_class.f03 sourcefile~fdist2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~fdist2d_class.f03->sourcefile~perrors_class.f03 sourcefile~fdist2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~fdist2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~input_class.f03 input_class.f03 sourcefile~fdist2d_class.f03->sourcefile~input_class.f03 sourcefile~input_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~input_class.f03->sourcefile~perrors_class.f03 sourcefile~input_class.f03->sourcefile~parallel_class.f03 sourcefile~spect3d_class.f03 spect3d_class.f03 sourcefile~input_class.f03->sourcefile~spect3d_class.f03 sourcefile~spect3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~spect3d_class.f03->sourcefile~perrors_class.f03 sourcefile~spect3d_class.f03->sourcefile~spect2d_class.f03 var pansourcefilepart2d_classf03EfferentGraph = svgPanZoom('#sourcefilepart2d_classf03EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~part2d_class.f03~~AfferentGraph sourcefile~part2d_class.f03 part2d_class.f03 sourcefile~species2d_class.f03 species2d_class.f03 sourcefile~species2d_class.f03->sourcefile~part2d_class.f03 sourcefile~simulation_class.f03 simulation_class.f03 sourcefile~simulation_class.f03->sourcefile~species2d_class.f03 sourcefile~main.f03 main.f03 sourcefile~main.f03->sourcefile~simulation_class.f03 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules part2d_class Source Code part2d_class.f03 Source Code ! part2d class for QuickPIC Open Source 1.0 ! update: 04/18/2016 module part2d_class use perrors_class use parallel_pipe_class use spect2d_class use fdist2d_class use ufield2d_class use part2d_lib use hdf5io_class use mpi implicit none private public :: part2d type part2d private class ( spect2d ), pointer , public :: sp => null () class ( perrors ), pointer , public :: err => null () class ( parallel_pipe ), pointer , public :: p => null () ! ! qbm = particle charge/mass ratio ! dt = time interval between successive calculations ! ci = reciprical of velocity of light ! xdim = dimension of the particle coordinates ! nbmax = size of buffer for passing particles between processors ! np = total number of particles ! npp = number of particles in current partition ! npmax = maximum number of particles in each partition ! part(:,:) = initial particle coordinates ! ppart(:,:,:) = particle coordinates for OpenMP ! nppmx, nppmx0, nbmaxp, ntmaxp, npbmx, irc, ncl, ihole, kpic = parameters for OpenMP ! real :: qbm , dt , ci integer :: npmax , nbmax , np , xdim , npp = 0 real , dimension (:,:), pointer :: part => null () real , dimension (:,:,:), pointer :: ppart => null () integer :: nppmx , nppmx0 , nbmaxp , ntmaxp , npbmx , irc = 0 integer , dimension (:,:), pointer :: ncl => null () integer , dimension (:,:,:), pointer :: ihole => null () integer , dimension (:), pointer :: kpic => null () contains generic :: new => init_part2d generic :: renew => renew_part2d generic :: del => end_part2d generic :: qdp => qdeposit generic :: amjdp => amjdeposit generic :: push => partpush generic :: pmv => pmove generic :: extpsi => extractpsi generic :: pcp => partcopy generic :: pcb => partcopyback generic :: psend => pipesend_part2d generic :: precv => piperecv_part2d generic :: wr => writehdf5_part2d procedure , private :: init_part2d , renew_part2d procedure , private :: end_part2d procedure , private :: qdeposit procedure , private :: amjdeposit procedure , private :: partpush procedure , private :: pmove procedure , private :: extractpsi procedure , private :: partcopy procedure , private :: partcopyback procedure , private :: pipesend_part2d procedure , private :: piperecv_part2d , writehdf5_part2d end type save character ( len = 10 ) :: class = 'part2d:' character ( len = 128 ) :: erstr ! parameters for OpenMP integer :: mx = 16 , my = 16 integer :: mx1 , myp1 , mxyp1 ! ppbuff = buffer array for reordering tiled particle array real , dimension (:,:,:), allocatable :: ppbuff integer :: szpbuf = 0 ! sbufl/sbufr = particle buffers sent to nearby processors ! rbufl/rbufr = particle buffers received from nearby processors real , dimension (:,:), allocatable :: sbufl , sbufr , rbufl , rbufr integer :: szbufs = 0 ! ncll/nclr/mcll/mclr = number offsets send/received from processors integer , dimension (:,:), allocatable :: ncll , nclr , mcll , mclr integer :: sznbufs = 0 contains ! subroutine init_part2d ( this , pp , perr , psp , pf , fd , qbm , dt , ci , xdim , s ) implicit none class ( part2d ), intent ( inout ) :: this class ( spect2d ), intent ( in ), pointer :: psp class ( perrors ), intent ( in ), pointer :: perr class ( parallel_pipe ), intent ( in ), pointer :: pp class ( fdist2d ), intent ( inout ) :: pf class ( ufield2d ), intent ( in ), pointer :: fd real , intent ( in ) :: qbm , dt , ci , s integer , intent ( in ) :: xdim ! local data character ( len = 18 ), save :: sname = 'init_part2d:' integer :: xtras , noff , nxyp , nx , npmax , nbmax this % sp => psp this % err => perr this % p => pp call this % err % werrfl2 ( class // sname // ' started' ) this % qbm = qbm this % dt = dt this % ci = ci this % xdim = xdim npmax = pf % getnpmax () this % npmax = npmax nbmax = max ( int ( 0.01 * npmax ), 100 ) this % nbmax = nbmax noff = fd % getnoff () nxyp = fd % getnd2p () nx = fd % getnd1p () allocate ( this % part ( xdim , npmax )) mx1 = ( nx - 1 ) / mx + 1 myp1 = ( nxyp - 1 ) / my + 1 ; mxyp1 = mx1 * myp1 allocate ( this % kpic ( mxyp1 )) call pf % dist ( this % part , this % npp , fd , s ) ! find number of particles in each of mx, my tiles: updates kpic, nppmx call PPDBLKP2L ( this % part , this % kpic , this % npp , noff , this % nppmx ,& & this % xdim , npmax , mx , my , mx1 , mxyp1 , this % irc ) ! check for errors if ( this % irc /= 0 ) then write ( erstr , * ) 'PPDBLKP2L error, irc=' , this % irc call this % err % equit ( class // sname // erstr ); return endif xtras = 10 ! ! allocate vector particle data this % nppmx0 = ( 1.0 + xtras ) * this % nppmx this % ntmaxp = xtras * this % nppmx this % npbmx = xtras * this % nppmx this % nbmaxp = 0.25 * mx1 * this % npbmx allocate ( this % ppart ( xdim , this % nppmx0 , mxyp1 )) allocate ( this % ncl ( 8 , mxyp1 )) allocate ( this % ihole ( 2 , this % ntmaxp + 1 , mxyp1 )) ! ! copy ordered particle data for OpenMP call PPPMOVIN2L ( this % part , this % ppart , this % kpic , this % npp , noff ,& & this % nppmx0 , this % xdim , npmax , mx , my , mx1 , mxyp1 , this % irc ) ! check for errors if ( this % irc /= 0 ) then write ( erstr , * ) 'PPPMOVIN2L overflow error, irc=' , this % irc call this % err % equit ( class // sname // erstr ); return endif ! ! sanity check !         call PPPCHECK2L(this%ppart,this%kpic,noff,nxyp,this%xdim,& !         &this%nppmx0,nx,mx,my,mx1,myp1,this%irc) ! check error !         if (this%irc /= 0) then !            write (erstr,*) 'PPPCHECK2L error: irc=', this%irc !            call this%err%equit(class//sname//erstr); return !         endif call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine init_part2d ! subroutine end_part2d ( this ) implicit none class ( part2d ), intent ( inout ) :: this character ( len = 18 ), save :: sname = 'end_part2d:' call this % err % werrfl2 ( class // sname // ' started' ) deallocate ( this % part , this % ppart , this % ncl , this % ihole , this % kpic ) call this % err % werrfl2 ( class // sname // ' ended' ) return end subroutine end_part2d ! subroutine renew_part2d ( this , pf , fd , s ) implicit none class ( part2d ), intent ( inout ) :: this class ( fdist2d ), intent ( inout ) :: pf class ( ufield2d ), pointer , intent ( in ) :: fd real , intent ( in ) :: s ! local data character ( len = 18 ), save :: sname = 'renew_part2d:' integer :: noff , prof call this % err % werrfl2 ( class // sname // ' started' ) noff = fd % getnoff () prof = pf % getnpf () call pf % dist ( this % part , this % npp , fd , s ) call PPDBLKP2L ( this % part , this % kpic , this % npp , noff , this % nppmx ,& & this % xdim , this % npmax , mx , my , mx1 , mxyp1 , this % irc ) ! check for errors if ( this % irc /= 0 ) then write ( erstr , * ) 'PPDBLKP2L error, irc=' , this % irc call this % err % equit ( class // sname // erstr ); return endif ! copy ordered particle data for OpenMP call PPPMOVIN2L ( this % part , this % ppart , this % kpic , this % npp , noff ,& & this % nppmx0 , this % xdim , this % npmax , mx , my , mx1 , mxyp1 , this % irc ) ! check for errors if ( this % irc /= 0 ) then write ( erstr , * ) 'PPPMOVIN2L overflow error, irc=' , this % irc call this % err % equit ( class // sname // erstr ); return endif call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine renew_part2d ! subroutine qdeposit ( this , q ) ! deposit the charge density implicit none class ( part2d ), intent ( in ) :: this class ( ufield2d ), pointer , intent ( in ) :: q ! local data character ( len = 18 ), save :: sname = 'qdeposit:' real , dimension (:,:,:), pointer :: pq => null () integer :: noff , nxv , nypmx call this % err % werrfl2 ( class // sname // ' started' ) pq => q % getrf () noff = q % getnoff () nxv = size ( pq , 2 ) nypmx = size ( pq , 3 ) call PPGPPOST2L ( this % ppart , pq ( 1 ,:,:), this % kpic , noff ,& & this % xdim , this % nppmx0 , mx , my , nxv , nypmx , mx1 , mxyp1 ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine qdeposit ! subroutine amjdeposit ( this , ef , bf , psit , cu , amu , dcu , dex ) ! deposit the current, acceleration and momentum flux implicit none class ( part2d ), intent ( inout ) :: this class ( ufield2d ), pointer , intent ( in ) :: cu , amu , dcu class ( ufield2d ), pointer , intent ( in ) :: ef , bf , psit real , intent ( in ) :: dex character ( len = 18 ), save :: sname = 'amjdeposit' ! local data real , dimension (:,:,:), pointer :: pef => null (), pbf => null () real , dimension (:,:,:), pointer :: ppsit => null (), pcu => null () real , dimension (:,:,:), pointer :: pamu => null (), pdcu => null () integer :: noff , nyp , nx , nxv , nypmx call this % err % werrfl2 ( class // sname // ' started' ) pef => ef % getrf (); pbf => bf % getrf () ppsit => psit % getrf (); pcu => cu % getrf () pamu => amu % getrf (); pdcu => dcu % getrf () noff = ef % getnoff () nxv = size ( pef , 2 ); nypmx = size ( pef , 3 ) nx = ef % getnd1 (); nyp = ef % getnd2p () call PPGRDCJPPOST2L_QP ( this % ppart , pef , pbf , ppsit ( 1 ,:,:), pcu , pdcu ,& & pamu , this % kpic , noff , nyp , this % qbm , this % dt , this % ci , this % xdim ,& & this % nppmx0 , nx , mx , my , nxv , nypmx , mx1 , mxyp1 , dex ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine amjdeposit ! subroutine partpush ( this , ef , bf , psit , dex ) implicit none class ( part2d ), intent ( inout ) :: this class ( ufield2d ), pointer , intent ( in ) :: ef , bf , psit real , intent ( in ) :: dex character ( len = 18 ), save :: sname = 'partpush' ! local data real , dimension (:,:,:), pointer :: pef => null (), pbf => null () real , dimension (:,:,:), pointer :: ppsit => null () integer :: noff , nyp , nx , ny , nxv , nypmx real :: ek call this % err % werrfl2 ( class // sname // ' started' ) pef => ef % getrf (); pbf => bf % getrf () ppsit => psit % getrf () noff = ef % getnoff (); ny = ef % getnd2 () nxv = size ( pef , 2 ); nypmx = size ( pef , 3 ) nx = ef % getnd1 (); nyp = ef % getnd2p () call PPGRBPPUSHF23L_QP ( this % ppart , pef , pbf , ppsit ( 1 ,:,:), this % kpic ,& & this % ncl , this % ihole , noff , nyp , this % qbm , this % dt , this % dt , this % ci , ek ,& & this % xdim , this % nppmx0 , nx , ny , mx , my , nxv , nypmx , mx1 , mxyp1 , this % ntmaxp ,& & this % irc , dex ) if ( this % irc /= 0 ) then write ( erstr , * ) 'PPGRBPPUSHF23L_QP error, irc=' , this % irc call this % err % equit ( class // sname // erstr ); return endif call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine partpush ! subroutine pmove ( this , fd ) implicit none class ( part2d ), intent ( inout ) :: this class ( ufield2d ), pointer , intent ( in ) :: fd character ( len = 18 ), save :: sname = 'pmove:' ! local data ! list = (true,false) = list of particles leaving tiles found in push integer :: noff , nyp , nx , ny , nxv , nypmx , kstrt , nvp integer :: npbmx , nbmax , idimp , nppmx , ntmax , irc real , dimension (:,:,:), pointer :: ppart => null () integer , dimension (:,:), pointer :: ncl => null () integer , dimension (:,:,:), pointer :: ihole => null () integer , dimension (:), pointer :: kpic => null () logical :: list = . true . call this % err % werrfl2 ( class // sname // ' started' ) noff = fd % getnoff (); ny = fd % getnd2 () nx = fd % getnd1 (); nyp = fd % getnd2p () npbmx = this % npbmx ; nbmax = this % nbmaxp idimp = this % xdim ; nppmx = this % nppmx0 ntmax = this % ntmaxp ; ppart => this % ppart kstrt = this % p % getlkstrt (); nvp = this % p % getlnvp () ncl => this % ncl ; ihole => this % ihole ; kpic => this % kpic irc = this % irc ! check if required size of buffer has increased if ( szpbuf < idimp * npbmx * mxyp1 ) then if ( szpbuf /= 0 ) deallocate ( ppbuff ) ! allocate new buffer allocate ( ppbuff ( idimp , npbmx , mxyp1 )) szpbuf = idimp * npbmx * mxyp1 endif ! check if required size of buffers has increased if ( szbufs < idimp * nbmax ) then if ( szbufs /= 0 ) deallocate ( sbufl , sbufr , rbufl , rbufr ) ! allocate new buffers allocate ( sbufl ( idimp , nbmax ), sbufr ( idimp , nbmax )) allocate ( rbufl ( idimp , nbmax ), rbufr ( idimp , nbmax )) szbufs = idimp * nbmax endif ! check if required size of buffers has increased if ( sznbufs < 3 * mx1 ) then if ( sznbufs /= 0 ) deallocate ( ncll , nclr , mcll , mclr ) ! allocate new buffers allocate ( ncll ( 3 , mx1 ), nclr ( 3 , mx1 ), mcll ( 3 , mx1 ), mclr ( 3 , mx1 )) sznbufs = 3 * mx1 endif ! ! first part of particle reorder on x and y cell with mx, my tiles: ! list of particles leaving tile already calculated by push if ( list ) then ! updates: ppart, ppbuff, sbufl, sbufr, ncl, ncll, nclr, irc call PPPORDERF2LA ( ppart , ppbuff , sbufl , sbufr , ncl , ihole , ncll , nclr ,& & idimp , nppmx , mx1 , myp1 , npbmx , ntmax , nbmax , irc ) if ( irc /= 0 ) then write ( erstr , * ) kstrt , 'mporderf2a error: ntmax, irc=' , ntmax , irc endif ! calculate list of particles leaving tile else ! updates ppart, ppbuff, sbufl, sbufr, ncl, ihole, ncll, nclr, irc call PPPORDER2LA ( ppart , ppbuff , sbufl , sbufr , kpic , ncl , ihole , ncll , nclr & &, noff , nyp , idimp , nppmx , nx , ny , mx , my , mx1 , myp1 , npbmx , ntmax , nbmax , irc ) if ( irc /= 0 ) then write ( erstr , * ) kstrt , 'mporder2a error: ntmax, irc=' , ntmax , irc endif endif if ( irc /= 0 ) then call this % err % equit ( class // sname // erstr ) return endif ! ! move particles into appropriate spatial regions with MPI: ! updates rbufr, rbufl, mcll, mclr call PPPMOVE2 ( sbufr , sbufl , rbufr , rbufl , ncll , nclr , mcll , mclr , kstrt ,& & nvp , idimp , nbmax , mx1 ) ! ! second part of particle reorder on x and y cell with mx, my tiles: ! updates ppart, kpic call PPPORDER2LB ( ppart , ppbuff , rbufl , rbufr , kpic , ncl , ihole , mcll , mclr ,& & idimp , nppmx , mx1 , myp1 , npbmx , ntmax , nbmax , irc ) if ( irc /= 0 ) then write ( erstr , * ) kstrt , 'mporder2b error: nppmx, irc=' , nppmx , irc call this % err % equit ( class // sname // erstr ) stop endif this % irc = irc call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine pmove ! subroutine extractpsi ( this , psi , dex ) implicit none class ( part2d ), intent ( inout ) :: this class ( ufield2d ), pointer , intent ( in ) :: psi real , intent ( in ) :: dex character ( len = 18 ), save :: sname = 'extractpsi' ! local data real , dimension (:,:,:), pointer :: ppsi integer :: noff , nyp , nx , nxv , nypmx call this % err % werrfl2 ( class // sname // ' started' ) ppsi => psi % getrf (); noff = psi % getnoff () nyp = psi % getnd2p (); nx = psi % getnd1 () nxv = size ( ppsi , 2 ); nypmx = size ( ppsi , 3 ) call WPGPSIPOST2L_QP ( this % ppart , ppsi ( 1 ,:,:), this % kpic , this % qbm , noff ,& & nyp , this % xdim , this % nppmx0 , nx , mx , my , nxv , nypmx , mx1 , mxyp1 , dex ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine extractpsi ! subroutine partcopy ( this , fd ) implicit none class ( part2d ), intent ( inout ) :: this class ( ufield2d ), pointer , intent ( in ) :: fd ! local data character ( len = 18 ), save :: sname = 'partcopy:' integer :: noff call this % err % werrfl2 ( class // sname // ' started' ) noff = fd % getnoff () ! copy ordered particle data for OpenMP call PPPMOVIN2L ( this % part , this % ppart , this % kpic , this % npp , noff ,& & this % nppmx0 , this % xdim , this % npmax , mx , my , mx1 , mxyp1 , this % irc ) ! check for errors if ( this % irc /= 0 ) then write ( erstr , * ) 'PPPMOVIN2L overflow error, irc=' , this % irc call this % err % equit ( class // sname // erstr ); return endif call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine partcopy ! subroutine partcopyback ( this ) implicit none class ( part2d ), intent ( inout ) :: this ! local data character ( len = 18 ), save :: sname = 'partcopyback:' call this % err % werrfl2 ( class // sname // ' started' ) this % irc = 0 call PPPCOPYOUT2 ( this % part , this % ppart , this % kpic , this % npp ,& & this % npmax , this % nppmx0 , this % xdim , mxyp1 , this % irc ) if ( this % irc /= 0 ) then write ( erstr , * ) 'PPPCOPYOUT2 overflow error, irc=' , this % irc call this % err % equit ( class // sname // erstr ); return endif call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine partcopyback ! subroutine pipesend_part2d ( this , tag , id ) implicit none class ( part2d ), intent ( inout ) :: this integer , intent ( in ) :: tag integer , intent ( inout ) :: id ! local data character ( len = 18 ), save :: sname = 'pipesend_part2d:' integer :: des , ierr call this % err % werrfl2 ( class // sname // ' started' ) des = this % p % getidproc () + this % p % getlnvp () if ( des >= this % p % getnvp ()) then id = MPI_REQUEST_NULL call this % err % werrfl2 ( class // sname // ' ended' ) return endif call this % pcb () call MPI_ISEND ( this % part , this % npp * this % xdim , this % p % getmreal (),& & des , tag , this % p % getlworld (), id , ierr ) ! check for errors if ( ierr /= 0 ) then write ( erstr , * ) 'MPI_ISEND failed' call this % err % equit ( class // sname // erstr ); return endif call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine pipesend_part2d ! subroutine piperecv_part2d ( this , fd , tag ) implicit none class ( part2d ), intent ( inout ) :: this class ( ufield2d ), pointer , intent ( in ) :: fd integer , intent ( in ) :: tag ! local data character ( len = 18 ), save :: sname = 'piperecv_part2d:' integer , dimension ( 10 ) :: istat integer :: nps , id , des , ierr call this % err % werrfl2 ( class // sname // ' started' ) des = this % p % getidproc () - this % p % getlnvp () if ( des < 0 ) then call this % err % werrfl2 ( class // sname // ' ended' ) return endif call MPI_IRECV ( this % part , this % npmax * this % xdim , this % p % getmreal (),& & des , tag , this % p % getlworld (), id , ierr ) call MPI_WAIT ( id , istat , ierr ) call MPI_GET_COUNT ( istat , this % p % getmreal (), nps , ierr ) this % npp = nps / this % xdim call this % pcp ( fd ) ! check for errors if ( ierr /= 0 ) then write ( erstr , * ) 'MPI failed' call this % err % equit ( class // sname // erstr ); return endif call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine piperecv_part2d ! subroutine writehdf5_part2d ( this , file , delta ) implicit none class ( part2d ), intent ( inout ) :: this class ( hdf5file ), intent ( in ) :: file real , dimension ( 2 ), intent ( in ) :: delta ! local data character ( len = 18 ), save :: sname = 'writehdf5_part2d:' integer :: ierr call this % err % werrfl2 ( class // sname // ' started' ) call this % pcb () call pwpart ( this % p , this % err , file , this % part , this % npp , 1 , delta , ierr ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine writehdf5_part2d ! end module part2d_class","tags":"","loc":"sourcefile/part2d_class.f03.html"},{"title":"spect3d_class.f03 – QuickPIC","text":"This file depends on sourcefile~~spect3d_class.f03~~EfferentGraph sourcefile~spect3d_class.f03 spect3d_class.f03 sourcefile~parallel_pipe_class.f03 parallel_pipe_class.f03 sourcefile~spect3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~perrors_class.f03 perrors_class.f03 sourcefile~spect3d_class.f03->sourcefile~perrors_class.f03 sourcefile~spect2d_class.f03 spect2d_class.f03 sourcefile~spect3d_class.f03->sourcefile~spect2d_class.f03 sourcefile~parallel_class.f03 parallel_class.f03 sourcefile~parallel_pipe_class.f03->sourcefile~parallel_class.f03 sourcefile~perrors_class.f03->sourcefile~parallel_class.f03 sourcefile~spect2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~spect2d_class.f03->sourcefile~perrors_class.f03 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~spect3d_class.f03~~AfferentGraph sourcefile~spect3d_class.f03 spect3d_class.f03 sourcefile~fdist3d_class.f03 fdist3d_class.f03 sourcefile~fdist3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~ufield3d_class.f03 ufield3d_class.f03 sourcefile~fdist3d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~input_class.f03 input_class.f03 sourcefile~fdist3d_class.f03->sourcefile~input_class.f03 sourcefile~field3d_class.f03 field3d_class.f03 sourcefile~field3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~field3d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~ufield3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~part3d_class.f03 part3d_class.f03 sourcefile~part3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~part3d_class.f03->sourcefile~fdist3d_class.f03 sourcefile~part3d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~simulation_class.f03 simulation_class.f03 sourcefile~simulation_class.f03->sourcefile~spect3d_class.f03 sourcefile~simulation_class.f03->sourcefile~fdist3d_class.f03 sourcefile~simulation_class.f03->sourcefile~field3d_class.f03 sourcefile~simulation_class.f03->sourcefile~input_class.f03 sourcefile~species2d_class.f03 species2d_class.f03 sourcefile~simulation_class.f03->sourcefile~species2d_class.f03 sourcefile~beam3d_class.f03 beam3d_class.f03 sourcefile~simulation_class.f03->sourcefile~beam3d_class.f03 sourcefile~fdist2d_class.f03 fdist2d_class.f03 sourcefile~simulation_class.f03->sourcefile~fdist2d_class.f03 sourcefile~field2d_class.f03 field2d_class.f03 sourcefile~simulation_class.f03->sourcefile~field2d_class.f03 sourcefile~input_class.f03->sourcefile~spect3d_class.f03 sourcefile~species2d_class.f03->sourcefile~spect3d_class.f03 sourcefile~species2d_class.f03->sourcefile~field3d_class.f03 sourcefile~species2d_class.f03->sourcefile~fdist2d_class.f03 sourcefile~species2d_class.f03->sourcefile~field2d_class.f03 sourcefile~part2d_class.f03 part2d_class.f03 sourcefile~species2d_class.f03->sourcefile~part2d_class.f03 sourcefile~beam3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~fdist3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~field3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~part3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~field2d_class.f03 sourcefile~fdist2d_class.f03->sourcefile~input_class.f03 sourcefile~field2d_class.f03->sourcefile~field3d_class.f03 sourcefile~field2d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~main.f03 main.f03 sourcefile~main.f03->sourcefile~simulation_class.f03 sourcefile~part2d_class.f03->sourcefile~fdist2d_class.f03 var pansourcefilespect3d_classf03AfferentGraph = svgPanZoom('#sourcefilespect3d_classf03AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules spect3d_class Source Code spect3d_class.f03 Source Code ! Spect3d class for QuickPIC Open Source 1.0 ! update: 04/18/2016 module spect3d_class use perrors_class use parallel_pipe_class use spect2d_class implicit none private public :: spect3d type , extends ( spect2d ) :: spect3d private integer :: indz contains procedure , private :: init_spect3d procedure , private :: end_spect2d => end_spect3d generic :: new => init_spect3d !         generic :: del => end_spect3d procedure :: getindz end type spect3d contains ! subroutine init_spect3d ( this , pp , perr , indx , indy , indz , psolver , inorder ) implicit none class ( spect3d ), intent ( inout ) :: this class ( perrors ), intent ( in ), pointer :: perr class ( parallel_pipe ), intent ( in ), pointer :: pp integer , intent ( in ) :: indx , indy , indz , psolver , inorder call this % spect2d % new ( pp , perr , indx , indy , psolver , inorder ) this % indz = indz end subroutine init_spect3d ! subroutine end_spect3d ( this ) implicit none class ( spect3d ), intent ( inout ) :: this return end subroutine end_spect3d ! function getindz ( this ) implicit none class ( spect3d ), intent ( in ) :: this integer :: getindz getindz = this % indz end function getindz ! end module spect3d_class","tags":"","loc":"sourcefile/spect3d_class.f03.html"},{"title":"ufield2d_lib.f03 – QuickPIC","text":"Files dependent on this one sourcefile~~ufield2d_lib.f03~~AfferentGraph sourcefile~ufield2d_lib.f03 ufield2d_lib.f03 sourcefile~ufield2d_class.f03 ufield2d_class.f03 sourcefile~ufield2d_class.f03->sourcefile~ufield2d_lib.f03 sourcefile~ufield3d_class.f03 ufield3d_class.f03 sourcefile~ufield3d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~part2d_class.f03 part2d_class.f03 sourcefile~part2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~fdist2d_class.f03 fdist2d_class.f03 sourcefile~part2d_class.f03->sourcefile~fdist2d_class.f03 sourcefile~fpois2d_class.f03 fpois2d_class.f03 sourcefile~fpois2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~fdist2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~field2d_class.f03 field2d_class.f03 sourcefile~field2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~field2d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~field2d_class.f03->sourcefile~fpois2d_class.f03 sourcefile~fft2d_class.f03 fft2d_class.f03 sourcefile~field2d_class.f03->sourcefile~fft2d_class.f03 sourcefile~field3d_class.f03 field3d_class.f03 sourcefile~field2d_class.f03->sourcefile~field3d_class.f03 sourcefile~fft2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~fdist3d_class.f03 fdist3d_class.f03 sourcefile~fdist3d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~field3d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~simulation_class.f03 simulation_class.f03 sourcefile~simulation_class.f03->sourcefile~fdist2d_class.f03 sourcefile~simulation_class.f03->sourcefile~field2d_class.f03 sourcefile~simulation_class.f03->sourcefile~fdist3d_class.f03 sourcefile~simulation_class.f03->sourcefile~field3d_class.f03 sourcefile~species2d_class.f03 species2d_class.f03 sourcefile~simulation_class.f03->sourcefile~species2d_class.f03 sourcefile~beam3d_class.f03 beam3d_class.f03 sourcefile~simulation_class.f03->sourcefile~beam3d_class.f03 sourcefile~part3d_class.f03 part3d_class.f03 sourcefile~part3d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~part3d_class.f03->sourcefile~fdist3d_class.f03 sourcefile~species2d_class.f03->sourcefile~part2d_class.f03 sourcefile~species2d_class.f03->sourcefile~fdist2d_class.f03 sourcefile~species2d_class.f03->sourcefile~field2d_class.f03 sourcefile~species2d_class.f03->sourcefile~field3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~field2d_class.f03 sourcefile~beam3d_class.f03->sourcefile~fdist3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~field3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~part3d_class.f03 sourcefile~main.f03 main.f03 sourcefile~main.f03->sourcefile~simulation_class.f03 var pansourcefileufield2d_libf03AfferentGraph = svgPanZoom('#sourcefileufield2d_libf03AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules ufield2d_lib Source Code ufield2d_lib.f03 Source Code ! ufield2d_lib module for QuickPIC Open Source 1.0 ! update: 04/18/2016 module ufield2d_lib use mpi implicit none public contains ! subroutine PPNCGUARD2L ( f , nyp , kstrt , nvp , nxv , nypmx , lgrp , mreal ) ! this subroutine copies data to guard cells in non-uniform partitions ! f(j,k) = real data for grid j,k in particle partition. ! the grid is non-uniform and includes one extra guard cell. ! output: f ! nyp = number of primary gridpoints in field partition ! it is assumed the nyp > 0. ! kstrt = starting data block number ! nvp = number of real or virtual processors ! nxv = first dimension of f, must be >= nx ! nypmx = maximum size of field partition, including guard cell. ! linear interpolation, for distributed data ! lgrp = current communicator ! mreal = default datatype for reals implicit none integer , intent ( in ) :: lgrp , mreal integer , intent ( in ) :: nyp , kstrt , nvp , nxv , nypmx real , dimension ( nxv , nypmx ), intent ( inout ) :: f ! local data integer :: j , ks , moff , kl , kr integer :: msid , ierr integer , dimension ( MPI_STATUS_SIZE ) :: istatus ! special case for one processor if ( nvp == 1 ) then do j = 1 , nxv f ( j , nyp + 1 ) = f ( j , 1 ) enddo return endif ks = kstrt - 1 moff = nypmx * nvp + 2 ! copy to guard cells kr = ks + 1 kl = ks - 1 ks = nyp + 1 ! this segment is used for mpi computers if ( kr < nvp ) then call MPI_IRECV ( f ( 1 , ks ), nxv , mreal , kr , moff , lgrp , msid , ierr ) end if if ( kl >= 0 ) then call MPI_SEND ( f , nxv , mreal , kl , moff , lgrp , ierr ) end if if ( kr < nvp ) then call MPI_WAIT ( msid , istatus , ierr ) end if end subroutine ! subroutine PPNACGUARD2L ( f , scr , nyp , nx , ndim , kstrt , nvp , nxv , nypmx , lgrp , mreal ) ! this subroutine adds data from guard cells in non-uniform partitions ! f(ndim,j,k) = real data for grid j,k in particle partition. ! the grid is non-uniform and includes one extra guard cell. ! output: f, scr ! scr(ndim,j) = scratch array for particle partition ! nyp = number of primary gridpoints in particle partition ! it is assumed the nyp > 0. ! kstrt = starting data block number ! nvp = number of real or virtual processors ! nx = system length in x direction ! ndim = leading dimension of array f ! nxv = first dimension of f, must be >= nx ! nypmx = maximum size of field partition, including guard cells. ! linear interpolation, for distributed data ! lgrp = current communicator ! mreal = default datatype for reals implicit none integer , intent ( in ) :: lgrp , mreal integer , intent ( in ) :: nyp , kstrt , nvp , nx , ndim , nxv , nypmx real , dimension ( ndim , nxv , nypmx ), intent ( inout ) :: f real , dimension ( ndim , nxv ), intent ( inout ) :: scr ! local data integer :: j , n , nx1 , ks , moff , kl , kr integer :: nnxv integer :: msid , ierr integer , dimension ( MPI_STATUS_SIZE ) :: istatus nx1 = nx + 1 ! special case for one processor if ( nvp == 1 ) then do j = 1 , nx1 do n = 1 , ndim f ( n , j , 1 ) = f ( n , j , 1 ) + f ( n , j , nyp + 1 ) f ( n , j , nyp + 1 ) = 0.0 enddo enddo return endif ks = kstrt - 1 moff = nypmx * nvp + 1 nnxv = ndim * nxv ! add guard cells kr = ks + 1 kl = ks - 1 ks = nyp + 1 ! this segment is used for mpi computers if ( kl >= 0 ) then call MPI_IRECV ( scr , nnxv , mreal , kl , moff , lgrp , msid , ierr ) end if if ( kr < nvp ) then call MPI_SEND ( f ( 1 , 1 , ks ), nnxv , mreal , kr , moff , lgrp , ierr ) end if if ( kl >= 0 ) then call MPI_WAIT ( msid , istatus , ierr ) else scr (:,:) = 0.0 end if ! add up the guard cells do j = 1 , nx1 do n = 1 , ndim f ( n , j , 1 ) = f ( n , j , 1 ) + scr ( n , j ) enddo enddo if ( kr < nvp ) then do j = 1 , nx1 do n = 1 , ndim f ( n , j , nyp + 1 ) = 0.0 enddo enddo end if end subroutine ! end module ufield2d_lib","tags":"","loc":"sourcefile/ufield2d_lib.f03.html"},{"title":"ufield3d_lib.f03 – QuickPIC","text":"Files dependent on this one sourcefile~~ufield3d_lib.f03~~AfferentGraph sourcefile~ufield3d_lib.f03 ufield3d_lib.f03 sourcefile~ufield3d_class.f03 ufield3d_class.f03 sourcefile~ufield3d_class.f03->sourcefile~ufield3d_lib.f03 sourcefile~fdist3d_class.f03 fdist3d_class.f03 sourcefile~fdist3d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~field3d_class.f03 field3d_class.f03 sourcefile~field3d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~field2d_class.f03 field2d_class.f03 sourcefile~field2d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~field2d_class.f03->sourcefile~field3d_class.f03 sourcefile~part3d_class.f03 part3d_class.f03 sourcefile~part3d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~part3d_class.f03->sourcefile~fdist3d_class.f03 sourcefile~simulation_class.f03 simulation_class.f03 sourcefile~simulation_class.f03->sourcefile~fdist3d_class.f03 sourcefile~simulation_class.f03->sourcefile~field3d_class.f03 sourcefile~simulation_class.f03->sourcefile~field2d_class.f03 sourcefile~species2d_class.f03 species2d_class.f03 sourcefile~simulation_class.f03->sourcefile~species2d_class.f03 sourcefile~beam3d_class.f03 beam3d_class.f03 sourcefile~simulation_class.f03->sourcefile~beam3d_class.f03 sourcefile~species2d_class.f03->sourcefile~field3d_class.f03 sourcefile~species2d_class.f03->sourcefile~field2d_class.f03 sourcefile~beam3d_class.f03->sourcefile~fdist3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~field3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~field2d_class.f03 sourcefile~beam3d_class.f03->sourcefile~part3d_class.f03 sourcefile~main.f03 main.f03 sourcefile~main.f03->sourcefile~simulation_class.f03 var pansourcefileufield3d_libf03AfferentGraph = svgPanZoom('#sourcefileufield3d_libf03AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules ufield3d_lib Source Code ufield3d_lib.f03 Source Code ! ufield3d_lib module for QuickPIC Open Source 1.0 ! update: 04/18/2016 module ufield3d_lib implicit none ! interface subroutine PCGUARD32L ( f , scs , kstrt , nvpy , nvpz , nxv , nypmx , nzpmx , mbl & & ok , nblok , kyp , kzp , ngds , tag1 , tag2 , rid , sid , ierr ) implicit none integer , intent ( in ) :: kstrt , nvpy , nvpz , nxv , nypmx , nzpmx , mb & & lok , nblok , ngds , kyp , kzp , tag1 , tag2 real , intent ( inout ) :: f , scs integer , intent ( inout ) :: rid , sid , ierr dimension f ( nxv , nypmx , nzpmx ) dimension scs ( nxv , nzpmx , 2 * ngds ) end subroutine end interface ! interface subroutine PACGUARD32L ( f , scs , kstrt , nvpy , nvpz , nx , nxv , nypmx , nzpmx & &, mblok , nblok , kyp , kzp , ngds ) implicit none integer , intent ( in ) :: kstrt , nvpy , nvpz , nx , nxv , nypmx , nzpmx & &, mblok , nblok , ngds , kyp , kzp real , intent ( inout ) :: f , scs dimension f ( 3 , nxv , nypmx , nzpmx , mblok * nblok ) dimension scs ( 3 , nxv , nzpmx , 2 * ngds , mblok * nblok ) end subroutine end interface ! interface subroutine PAGUARD32L ( f , scs , scr , kstrt , nvpy , nvpz , nx , nxv , nypmx , nz & & pmx , mblok , nblok , kyp , kzp , ngds , tag1 , tag2 , id , ierr ) implicit none integer , intent ( in ) :: kstrt , nvpy , nvpz , nx , nxv , nypmx , nzpmx & &, mblok , nblok , ngds , kyp , kzp , tag1 , tag2 integer , intent ( inout ) :: id , ierr real , intent ( inout ) :: f , scs , scr dimension f ( nxv , nypmx , nzpmx , mblok * nblok ) dimension scs ( nxv , nzpmx , 2 * ngds , mblok * nblok ) dimension scr ( nxv , nypmx , ngds , mblok * nblok ) end subroutine end interface ! end module ufield3d_lib","tags":"","loc":"sourcefile/ufield3d_lib.f03.html"},{"title":"part3d_lib77.f – QuickPIC","text":"Contents Functions ranorm Subroutines PRVDIST32_RANDOM PGPOST32L PGBPUSH32L_QP PMOVE32 Source Code part3d_lib77.f Source Code c----------------------------------------------------------------------- subroutine PRVDIST32_RANDOM ( part , qm , edges , npp , nps , vtx , vty , vtz , vdx , 1 vdy , vdz , npx , npy , npz , nx , ny , nz , ipbc , idimp , npmax , mblok , nblok , idps , sig 1 x , sigy , sigz , x0 , y0 , z0 , cx , cy , lquiet , ierr ) c old quiet start c keep 1 + p&#94;2 = gamma c for 3d code, this subroutine calculates initial particle co-ordinates c and velocities with tri-gaussian density and maxwellian velocity with c drift for distributed data with 2D spatial decomposition c part(1,n,m) = position x of particle n in partition m c part(2,n,m) = position y of particle n in partition m c part(3,n,m) = position z of particle n in partition m c part(4,n,m) = velocity vx of particle n in partition m c part(5,n,m) = velocity vy of particle n in partition m c part(6,n,m) = velocity vz of particle n in partition m c edges(1,m) = lower boundary in y of particle partition m c edges(2,m) = upper boundary in y of particle partition m c edges(3,m) = lower boundary in z of particle partition m c edges(4,m) = upper boundary in z of particle partition m c npp(m) = number of particles in partition m c nps(m) = starting address of particles in partition m c vtx/vty/vtz = thermal velocity of electrons in x/y/z direction c vdx/vdy/vdz = drift velocity of beam electrons in x/y/z direction c npx/npy/npz = initial number of particles distributed in x/y/z c direction c nx/ny/nz = system length in x/y/z direction c idimp = size of phase space = 6 c npmax = maximum number of particles in each partition c mblok/nblok = number of particle partitions in y/z c idps = number of partition boundaries c ipbc = particle boundary condition = (0,1,2,3) = c (none,xy periodic,xy reflecting, x reflecting/y periodic) c ierr = (0,1) = (no,yes) error condition exists c ranorm = gaussian random number with zero mean and unit variance implicit none integer nps , npp , npmax , nblok , npx , npy , npz , idimp , nx , ny , nz , idps , ierr integer mblok , ipbc real qm , sigx , sigy , sigz , x0 , y0 , z0 real cx , cy double precision random , ranorm real part , edges , vtx , vty , vtz , vdx , vdy , vdz dimension part ( idimp , npmax , nblok ) dimension edges ( idps , nblok ), npp ( nblok ), nps ( nblok ) dimension cx ( 0 : 2 ), cy ( 0 : 2 ) logical lquiet c local variables integer j , k , l , m , my , mz , moff , mnblok , k1 , npt real tempx , tempy , tempxx , tempyy , x2 , y2 , tempz , tvtx , tvty , tvtz c borderlx(yz), lower bound; borderx(yz), upper bound. real borderlx , borderly , borderlz , borderx , bordery , borderz ierr = 0 npt = 1 x2 = 2.0 * x0 y2 = 2.0 * y0 borderlx = max (( x0 - 5.0 * sigx ), 1.0 ) borderly = max (( y0 - 5.0 * sigy ), 1.0 ) borderlz = max (( z0 - 5.0 * sigz ), 1.0 ) borderx = min (( x0 + 5.0 * sigx ), float ( nx - 1 )) bordery = min (( y0 + 5.0 * sigy ), float ( ny - 1 )) borderz = min (( z0 + 5.0 * sigz ), float ( nz - 1 )) j = 0 l = npz do while ( j < npx ) k = 0 do while ( k < npy ) l = l - npz do while ( l < npz ) 10 tempz = z0 + sigz * ranorm () if ( tempz >= ( borderz ) . or . tempz <= borderlz ) goto 10 20 tempx = x0 + sigx * ranorm () if ( tempx >= ( borderx ) . or . tempx <= borderlx ) goto 20 30 tempy = y0 + sigy * ranorm () if ( tempy >= ( bordery ) . or . tempy <= borderly ) goto 30 c  generate velocity tvtx = vtx * ranorm () + vdx tvty = vty * ranorm () + vdy tvtz = vtz * ranorm () + vdz tvtz = sqrt ( tvtz * tvtz - 1 - tvtx * tvtx - tvty * tvty ) do 110 mz = 1 , nblok moff = mblok * ( mz - 1 ) do 100 my = 1 , mblok m = my + moff c  check if particle belongs to this partition if (( tempy . ge . edges ( 1 , m )) . and . ( tempy . lt . edges ( 2 , m )) . and . & & ( tempz . ge . edges ( 3 , m )) . and . ( tempz . lt . edges ( 4 , m )) ) then if ( npt . lt . npmax ) then npt = npp ( m ) + 1 part ( 3 , npt , m ) = tempz c calculate offset in x tempxx = - cx ( 0 ) * ( part ( 3 , npt , m ) - z0 ) ** 2 - cx ( 1 ) * ( part ( 3 , npt , m ) & & - z0 ) - cx ( 2 ) part ( 1 , npt , m ) = tempx + tempxx c calculate offset in y tempyy = - cy ( 2 ) * ( part ( 3 , npt , m ) - z0 ) ** 2 - cy ( 1 ) * ( part ( 3 , npt , m ) & & - z0 ) - cy ( 2 ) part ( 2 , npt , m ) = tempy + tempyy part ( 4 , npt , m ) = tvtx part ( 5 , npt , m ) = tvty part ( 6 , npt , m ) = tvtz part ( 7 , npt , m ) = qm npp ( m ) = npt else ierr = ierr + 1 endif c quiet start if ( lquiet ) then if ( npt . lt . npmax ) then npt = npp ( m ) + 1 part ( 3 , npt , m ) = tempz part ( 1 , npt , m ) = x2 - tempx + tempxx part ( 2 , npt , m ) = y2 - tempy + tempyy part ( 4 , npt , m ) = - tvtx part ( 5 , npt , m ) = - tvty part ( 6 , npt , m ) = tvtz part ( 7 , npt , m ) = qm npp ( m ) = npt else ierr = ierr + 1 endif endif endif 100 continue 110 continue l = l + 1 if ( lquiet ) l = l + 1 enddo k = k + 1 enddo j = j + 1 enddo return end c----------------------------------------------------------------------- subroutine PGPOST32L ( part , q , npp , noff , idimp , npmax , mnblok , nxv , nypmx , 1 nzpmx , idds ) c for 3d code, this subroutine calculates particle charge density c using first-order linear interpolation, and distributed data c with 2D spatial decomposition c scalar version using guard cells, for distributed data c 33 flops/particle, 11 loads, 8 stores c input: all, output: q c charge density is approximated by values at the nearest grid points c q(n,m,l)=qm*(1.-dx)*(1.-dy)*(1.-dz) c q(n+1,m,l)=qm*dx*(1.-dy)*(1.-dz) c q(n,m+1,l)=qm*(1.-dx)*dy*(1.-dz) c q(n+1,m+1,l)=qm*dx*dy*(1.-dz) c q(n,m,l+1)=qm*(1.-dx)*(1.-dy)*dz c q(n+1,m,l+1)=qm*dx*(1.-dy)*dz c q(n,m+1,l+1)=qm*(1.-dx)*dy*dz c q(n+1,m+1,l+1)=qm*dx*dy*dz c where n,m,l = nearest grid points and dx = x-n, dy = y-m, dz = z-l c part(1,n,m) = position x of particle n in partition m c part(2,n,m) = position y of particle n in partition m c part(3,n,m) = position z of particle n in partition m c q(j,k,l,m) = charge density at grid point (j,kk,ll), c where kk = k + noff(1,m) - 1, and ll = l + noff(2,m) - 1 c npp(m) = number of particles in partition m c noff(1,m) = lowermost global gridpoint in y in particle partition m c noff(2,m) = backmost global gridpoint in z in particle partition m c qm = charge on particle, in units of e c idimp = size of phase space = 6 c npmax = maximum number of particles in each partition c mnblok = number of particle partitions. c nxv = first dimension of charge array, must be >= nx+1 c nypmx = maximum size of particle partition in y, including guard cells c nzpmx = maximum size of particle partition in z, including guard cells c idds = dimensionality of domain decomposition dimension part ( idimp , npmax , mnblok ), q ( nxv , nypmx , nzpmx , mnblok ) dimension npp ( mnblok ), noff ( idds , mnblok ) real qm do 20 m = 1 , mnblok mnoff = noff ( 1 , m ) - 1 lnoff = noff ( 2 , m ) - 1 c find interpolation weights do 10 j = 1 , npp ( m ) nn = part ( 1 , j , m ) mm = part ( 2 , j , m ) ll = part ( 3 , j , m ) qm = part ( 7 , j , m ) dxp = qm * ( part ( 1 , j , m ) - float ( nn )) dyp = part ( 2 , j , m ) - float ( mm ) dzp = part ( 3 , j , m ) - float ( ll ) nn = nn + 1 amx = qm - dxp amy = 1. - dyp np = nn + 1 mm = mm - mnoff dx1 = dxp * dyp dyp = amx * dyp mp = mm + 1 amx = amx * amy amz = 1. - dzp ll = ll - lnoff amy = dxp * amy lp = ll + 1 c deposit charge q ( nn , mm , ll , m ) = q ( nn , mm , ll , m ) + amx * amz q ( np , mm , ll , m ) = q ( np , mm , ll , m ) + amy * amz q ( nn , mp , ll , m ) = q ( nn , mp , ll , m ) + dyp * amz q ( np , mp , ll , m ) = q ( np , mp , ll , m ) + dx1 * amz q ( nn , mm , lp , m ) = q ( nn , mm , lp , m ) + amx * dzp q ( np , mm , lp , m ) = q ( np , mm , lp , m ) + amy * dzp q ( nn , mp , lp , m ) = q ( nn , mp , lp , m ) + dyp * dzp q ( np , mp , lp , m ) = q ( np , mp , lp , m ) + dx1 * dzp 10 continue 20 continue return end c----------------------------------------------------------------------- subroutine PGBPUSH32L_QP ( part , fxyz , bxyz , npp , noff , qbm , dt , dtc , ek , nx , 1 ny , nz , idimp , npmax , mnblok , nxv , nypmx , nzpmx , idds , ipbc , deltax , deltaz , 2 cofd ) double precision sum1 dimension part ( idimp , npmax , mnblok ) dimension fxyz ( 3 , nxv , nypmx , nzpmx , mnblok ) dimension bxyz ( 3 , nxv , nypmx , nzpmx , mnblok ) dimension npp ( mnblok ), noff ( idds , mnblok ) real qtmg , dtgx , dtgy , cofd real delx , dely , delz , ngamma real p2t , p2l , cofd1 real dtc_over_deltax , dtc_over_deltaz real one_minus_vz0 , one_minus_vz qtmh = qbm * dt sum1 = 0.0d0 dtc_over_deltax = dtc / deltax dtc_over_deltaz = dtc / deltaz one_minus_vz0 = 0. cofd1 = cofd / dt c set boundary values if ( ipbc . eq . 1 ) then edgelx = 1. edgely = 1. edgelz = 1. edgerx = float ( nx - 1 ) edgery = float ( ny - 1 ) edgerz = float ( nz - 1 ) endif do 20 m = 1 , mnblok mnoff = noff ( 1 , m ) - 1 lnoff = noff ( 2 , m ) - 1 c find interpolation weights inpp = npp ( m ) do 10 j = 1 , npp ( m ) if ( j . gt . inpp ) exit 11 nn = part ( 1 , j , m ) mm = part ( 2 , j , m ) ll = part ( 3 , j , m ) dxp = part ( 1 , j , m ) - float ( nn ) dyp = part ( 2 , j , m ) - float ( mm ) dzp = part ( 3 , j , m ) - float ( ll ) nn = nn + 1 amx = 1. - dxp amy = 1. - dyp np = nn + 1 mm = mm - mnoff dx1 = dxp * dyp dyp = amx * dyp mp = mm + 1 amx = amx * amy amz = 1. - dzp ll = ll - lnoff amy = dxp * amy lp = ll + 1 c find electric field dx = amz * ( amx * fxyz ( 1 , nn , mm , ll , m ) + amy * fxyz ( 1 , np , mm , ll , m ) + dyp * fx 1 yz ( 1 , nn , mp , ll , m ) + dx1 * fxyz ( 1 , np , mp , ll , m )) + dzp * ( amx * fxyz ( 1 , nn , mm 2 , lp , m ) + amy * fxyz ( 1 , np , mm , lp , m ) + dyp * fxyz ( 1 , nn , mp , lp , m ) + dx1 * fxy 3 z ( 1 , np , mp , lp , m )) dy = amz * ( amx * fxyz ( 2 , nn , mm , ll , m ) + amy * fxyz ( 2 , np , mm , ll , m ) + dyp * fx 1 yz ( 2 , nn , mp , ll , m ) + dx1 * fxyz ( 2 , np , mp , ll , m )) + dzp * ( amx * fxyz ( 2 , nn , mm 2 , lp , m ) + amy * fxyz ( 2 , np , mm , lp , m ) + dyp * fxyz ( 2 , nn , mp , lp , m ) + dx1 * fxy 3 z ( 2 , np , mp , lp , m )) dz = amz * ( amx * fxyz ( 3 , nn , mm , ll , m ) + amy * fxyz ( 3 , np , mm , ll , m ) + dyp * fx 1 yz ( 3 , nn , mp , ll , m ) + dx1 * fxyz ( 3 , np , mp , ll , m )) + dzp * ( amx * fxyz ( 3 , nn , mm 2 , lp , m ) + amy * fxyz ( 3 , np , mm , lp , m ) + dyp * fxyz ( 3 , nn , mp , lp , m ) + dx1 * fxy 3 z ( 3 , np , mp , lp , m )) c find magnetic field ox = amz * ( amx * bxyz ( 1 , nn , mm , ll , m ) + amy * bxyz ( 1 , np , mm , ll , m ) + dyp * bx 1 yz ( 1 , nn , mp , ll , m ) + dx1 * bxyz ( 1 , np , mp , ll , m )) + dzp * ( amx * bxyz ( 1 , nn , mm 2 , lp , m ) + amy * bxyz ( 1 , np , mm , lp , m ) + dyp * bxyz ( 1 , nn , mp , lp , m ) + dx1 * bxy 3 z ( 1 , np , mp , lp , m )) oy = amz * ( amx * bxyz ( 2 , nn , mm , ll , m ) + amy * bxyz ( 2 , np , mm , ll , m ) + dyp * bx 1 yz ( 2 , nn , mp , ll , m ) + dx1 * bxyz ( 2 , np , mp , ll , m )) + dzp * ( amx * bxyz ( 2 , nn , mm 2 , lp , m ) + amy * bxyz ( 2 , np , mm , lp , m ) + dyp * bxyz ( 2 , nn , mp , lp , m ) + dx1 * bxy 3 z ( 2 , np , mp , lp , m )) dx = dx - oy dy = dy + ox delx = qtmh * dx dely = qtmh * dy delz = qtmh * dz c half acceleration c momentums are normalized to c temporarily dx = part ( 4 , j , m ) + delx dy = part ( 5 , j , m ) + dely dz = part ( 6 , j , m ) + delz part ( 4 , j , m ) = dx part ( 5 , j , m ) = dy c update gamma and inverse gamma p2t = dx * dx + dy * dy p2l = dz * dz p2 = p2t + p2l ngamma = sqrt ( 1.0 + p2 ) dtgx = dtc_over_deltax / ngamma dtgy = dtc_over_deltax / ngamma one_minus_vz = ( 1.0 + p2t ) / ( dz * ( dz + ngamma )) c include radiation damping in the z direction c note: this is not time-centered c      print *,\"cofd1,ngamma,dz,delx,dely=\",cofd1,ngamma, dz, delx, dely,& c     &cofd1*ngamma*((delx*delx+dely*dely)*dz-delz*(delx*dx+dely*dy)) dz = dz - cofd1 * ngamma * (( delx * delx + dely * dely ) * dz - delz * ( delx * dx + del & & y * dy )) c comment this line to shut off longitudinal push part ( 6 , j , m ) = dz c new position in grid unit dx = part ( 1 , j , m ) + dx * dtgx dy = part ( 2 , j , m ) + dy * dtgy c      dz = part(3,j,m) + (one_minus_vz - one_minus_vz0)*dtc_over_deltaz dz = part ( 3 , j , m ) + one_minus_vz * dtc_over_deltaz c dropping boundary conditions in x and y if ( ipbc . eq . 1 ) then if (( dx . lt . edgelx ). or .( dx . ge . edgerx )) then if ( j . eq . inpp ) then inpp = inpp - 1 exit end if part (:, j , m ) = part (:, inpp , m ) inpp = inpp - 1 goto 11 endif if (( dy . lt . edgely ). or .( dy . ge . edgery )) then if ( j . eq . inpp ) then inpp = inpp - 1 exit end if part (:, j , m ) = part (:, inpp , m ) inpp = inpp - 1 goto 11 endif if (( dz . lt . edgelz ). or .( dz . ge . edgerz )) then if ( j . eq . inpp ) then inpp = inpp - 1 exit end if part (:, j , m ) = part (:, inpp , m ) inpp = inpp - 1 goto 11 endif endif c set new position part ( 1 , j , m ) = dx part ( 2 , j , m ) = dy c comment this line to shut off longitudinal push part ( 3 , j , m ) = dz 10 continue npp ( m ) = inpp 20 continue return end c----------------------------------------------------------------------- subroutine PMOVE32 ( part , edges , npp , sbufr , sbufl , rbufr , rbufl , ihole , pb 1 uff , jsr , jsl , jss , ny , nz , kstrt , nvpy , nvpz , idimp , npmax , mblok , nblok , idps 2 , nbmax , idds , ntmax , tag1 , tag2 , id , info ) c modified version with particle moving in y only c this subroutine moves particles into appropriate spatial regions c periodic boundary conditions with 2D spatial decomposition c part(1,n,m) = position x of particle n in partition m c part(2,n,m) = position y of particle n in partition m c part(3,n,m) = position z of particle n in partition m c part(4,n,m) = velocity vx of particle n in partition m c part(5,n,m) = velocity vy of particle n in partition m c part(6,n,m) = velocity vz of particle n in partition m c edges(1,m) = lower boundary in y of particle partition m c edges(2,m) = upper boundary in y of particle partition m c edges(3,m) = back boundary in z of particle partition m c edges(4,m) = front boundary in z of particle partition m c npp(m) = number of particles in partition m c sbufl = buffer for particles being sent to back processor c sbufr = buffer for particles being sent to front processor c rbufl = buffer for particles being received from back processor c rbufr = buffer for particles being received from front processor c pbuff = buffer for particles being sent to next pipeline stage c ihole = location of holes left in particle arrays c jsl(idds,m) = number of particles going back in particle partition m c jsr(idds,m) = number of particles going front in particle partition m c jss(idds,m) = scratch array for particle partition m c ny/nz = system length in y/z direction c kstrt = starting data block number c nvpy/nvpz = number of real or virtual processors in y/z c idimp = size of phase space = 6 c npmax = maximum number of particles in each partition c mblok/nblok = number of particle partitions in y/z c idps = number of particle partition boundaries c nbmax =  size of buffers for passing particles between processors c idds = dimensionality of domain decomposition c ntmax =  size of hole array for particles leaving processors c info = status information c info(1) = ierr = (0,N) = (no,yes) error condition exists c info(2) = maximum number of particles per processor c info(3) = minimum number of particles per processor c info(4) = maximum number of buffer overflows in y c info(5) = maximum number of buffer overflows in z c info(6) = maximum number of particle passes required in y c info(7) = maximum number of particle passes required in z c info(8) = total number of particles on entry c info(9) = difference of total number of particles on exit implicit none include \"mpif.h\" real part , edges , sbufr , sbufl , rbufr , rbufl , pbuff integer npp , ihole , jsr , jsl , jss , info integer ny , nz , kstrt , nvpy , nvpz , idimp , npmax , mblok , nblok integer idps , nbmax , idds , ntmax , tag1 , tag2 , id dimension part ( idimp , npmax , mblok * nblok ) dimension edges ( idps , mblok * nblok ), npp ( mblok * nblok ) dimension sbufl ( idimp , nbmax , mblok * nblok ) dimension sbufr ( idimp , nbmax , mblok * nblok ) dimension rbufl ( idimp , nbmax , mblok * nblok ) dimension rbufr ( idimp , nbmax , mblok * nblok ) dimension pbuff ( idimp , nbmax ) dimension jsl ( idds , mblok * nblok ), jsr ( idds , mblok * nblok ) dimension jss ( idds , mblok * nblok ) dimension ihole ( ntmax , mblok * nblok ) dimension info ( 9 ) c common block for parallel processing integer nproc , lgrp , lstat , mreal , mint , mcplx , mdouble , lworld c lstat = length of status array parameter ( lstat = 10 ) c lgrp = current communicator c mint = default datatype for integers c mreal = default datatype for reals common / PPARMS / nproc , lgrp , mreal , mint , mcplx , mdouble , lworld c local data integer iy , iz parameter ( iy = 2 , iz = 3 ) integer ierr , ic , js , ks , mnblok , i , n , m , my , mz , moff , nvp , iter integer npr , nps , npt , kb , kl , kr , j , j1 , j2 , nbsize , nter , mter integer itermax integer msid , istatus integer ibflg , iwork double precision bflg , work real an , xt dimension msid ( 4 ), istatus ( lstat ) dimension ibflg ( 4 ), iwork ( 4 ) dimension bflg ( 2 ), work ( 2 ) dimension kb ( 2 ) ks = ( kstrt - 1 ) / nvpy js = kstrt - nvpy * ks - 2 ks = ks - 1 mnblok = mblok * nblok nbsize = idimp * nbmax do 5 j = 1 , 9 info ( j ) = 0 5 continue c buffer outgoing particles, first in y then in z direction ic = iz nvp = nvpy * nvpz an = float ( nz ) n = 2 kl = kstrt - nvpy if ( kl . lt . 1 ) go to 21 call MPI_IRECV ( rbufl , nbsize , mreal , kl - 1 , tag1 , lworld , msid ( 1 ), ierr ) call MPI_WAIT ( msid ( 1 ), istatus , ierr ) call MPI_GET_COUNT ( istatus , mreal , nps , ierr ) jsl ( 2 , 1 ) = nps / idimp jss ( 2 , 1 ) = npp ( 1 ) + jsl ( 2 , 1 ) if ( jss ( 2 , 1 ). le . npmax ) then do 11 j = 1 , jsl ( 2 , 1 ) do 8 i = 1 , idimp part ( i , j + npp ( 1 ), 1 ) = rbufl ( i , j , 1 ) 8 continue 11 continue npp ( 1 ) = jss ( 2 , 1 ) else write ( 2 , * ) 'particle overflow' , jss ( 2 , 1 ) info ( 1 ) = jss ( 2 , 1 ) return endif 21 iter = 2 nter = 0 mter = 0 do 61 mz = 1 , nblok moff = mblok * ( mz - 1 ) do 51 my = 1 , mblok m = my + moff jsl ( 1 , m ) = 0 jsr ( 1 , m ) = 0 jss ( 2 , m ) = 0 do 31 j = 1 , npp ( m ) xt = part ( ic , j , m ) c particles going backward, not going to happen if ( xt . lt . edges ( 2 * n - 1 , m )) then jss ( 2 , m ) = 1 write ( 2 , * ) 'Error: particles move to the previous stage' go to 41 c particles going forward else if ( xt . ge . edges ( 2 * n , m )) then if ( jsr ( 1 , m ). lt . nbmax ) then jsr ( 1 , m ) = jsr ( 1 , m ) + 1 do 28 i = 1 , idimp pbuff ( i , jsr ( 1 , m )) = part ( i , j , m ) 28 continue ihole ( jsr ( 1 , m ), m ) = j else jss ( 2 , m ) = 1 go to 41 endif endif 31 continue 41 jss ( 1 , m ) = jsl ( 1 , m ) + jsr ( 1 , m ) 51 continue 61 continue c check for full buffer condition nps = 0 do 101 m = 1 , mnblok nps = max0 ( nps , jss ( 2 , m )) 101 continue if ( nps . gt . 0 ) then info ( 1 ) = nps write ( 2 , * ) 'particle buffer full' return endif c copy particle buffers 111 iter = iter + 2 mter = mter + 1 do 151 mz = 1 , nblok moff = mblok * ( mz - 1 ) do 141 my = 1 , mblok m = my + moff kr = kstrt + nvpy if ( kr . gt . nvp ) go to 155 c send particles call MPI_ISEND ( pbuff , idimp * jsr ( 1 , m ), mreal , kr - 1 , tag2 , lworld , id , ierr 1 ) 141 continue 151 continue c fill the holes 155 npt = npp ( 1 ) do 291 j = 1 , jsr ( 1 , 1 ) j1 = ihole (( jsr ( 1 , 1 ) - j + 1 ), 1 ) if ( j1 . lt . npt ) then do 274 i = 1 , idimp part ( i , j1 , 1 ) = part ( i , npt , m ) 274 continue npt = npt - 1 else npt = npt - 1 endif 291 continue npp ( 1 ) = npt itermax = 20000 c buffer outgoing particles, first in y then in z direction do 300 n = 1 , 1 if ( n . eq . 1 ) then ic = iy nvp = nvpy an = float ( ny ) elseif ( n . eq . 2 ) then ic = iz nvp = nvpz an = float ( nz ) endif iter = 2 nter = 0 20 mter = 0 do 60 mz = 1 , nblok moff = mblok * ( mz - 1 ) kb ( 2 ) = mz + ks do 50 my = 1 , mblok m = my + moff kb ( 1 ) = my + js jsl ( 1 , m ) = 0 jsr ( 1 , m ) = 0 jss ( 2 , m ) = 0 do 30 j = 1 , npp ( m ) xt = part ( ic , j , m ) c particles going down or backward if ( xt . lt . edges ( 2 * n - 1 , m )) then if ( jsl ( 1 , m ). lt . nbmax ) then jsl ( 1 , m ) = jsl ( 1 , m ) + 1 if ( kb ( n ). eq . 0 ) xt = xt + an do 23 i = 1 , idimp sbufl ( i , jsl ( 1 , m ), m ) = part ( i , j , m ) 23 continue sbufl ( ic , jsl ( 1 , m ), m ) = xt ihole ( jsl ( 1 , m ) + jsr ( 1 , m ), m ) = j else jss ( 2 , m ) = 1 go to 40 endif c particles going up or forward else if ( xt . ge . edges ( 2 * n , m )) then if ( jsr ( 1 , m ). lt . nbmax ) then jsr ( 1 , m ) = jsr ( 1 , m ) + 1 if (( kb ( n ) + 1 ). eq . nvp ) xt = xt - an do 27 i = 1 , idimp sbufr ( i , jsr ( 1 , m ), m ) = part ( i , j , m ) 27 continue sbufr ( ic , jsr ( 1 , m ), m ) = xt ihole ( jsl ( 1 , m ) + jsr ( 1 , m ), m ) = j else jss ( 2 , m ) = 1 go to 40 endif endif 30 continue 40 jss ( 1 , m ) = jsl ( 1 , m ) + jsr ( 1 , m ) 50 continue 60 continue c check for full buffer condition nps = 0 do 100 m = 1 , mnblok nps = max0 ( nps , jss ( 2 , m )) 100 continue ibflg ( 3 ) = nps c copy particle buffers 110 iter = iter + 2 mter = mter + 1 do 150 mz = 1 , nblok moff = mblok * ( mz - 1 ) do 140 my = 1 , mblok m = my + moff kb ( 1 ) = my + js kb ( 2 ) = mz + ks c get particles from below and above or back and front kl = kb ( n ) kb ( n ) = kl + 1 if ( kb ( n ). ge . nvp ) kb ( n ) = kb ( n ) - nvp kr = kb ( 1 ) + nvpy * kb ( 2 ) + 1 kb ( n ) = kl - 1 if ( kb ( n ). lt . 0 ) kb ( n ) = kb ( n ) + nvp kl = kb ( 1 ) + nvpy * kb ( 2 ) + 1 c this segment is used for shared memory computers c     jsl(2,m) = jsr(1,kl) c     do 120 j = 1, jsl(2,m) c     do 115 i = 1, idimp c     rbufl(i,j,m) = sbufr(i,j,kl) c 115 continue c 120 continue c     jsr(2,m) = jsl(1,kr) c     do 130 j = 1, jsr(2,m) c     do 125 i = 1, idimp c     rbufr(i,j,m) = sbufl(i,j,kr) c 125 continue c 130 continue c this segment is used for mpi computers c post receive call MPI_IRECV ( rbufl , nbsize , mreal , kl - 1 , iter - 1 , lworld , msid ( 1 ), ierr ) call MPI_IRECV ( rbufr , nbsize , mreal , kr - 1 , iter , lworld , msid ( 2 ), ierr ) c send particles call MPI_ISEND ( sbufr , idimp * jsr ( 1 , m ), mreal , kr - 1 , iter - 1 , lworld , msid ( 1 3 ), ierr ) call MPI_ISEND ( sbufl , idimp * jsl ( 1 , m ), mreal , kl - 1 , iter , lworld , msid ( 4 ) 1 , ierr ) c wait for particles to arrive call MPI_WAIT ( msid ( 1 ), istatus , ierr ) call MPI_GET_COUNT ( istatus , mreal , nps , ierr ) jsl ( 2 , m ) = nps / idimp call MPI_WAIT ( msid ( 2 ), istatus , ierr ) call MPI_GET_COUNT ( istatus , mreal , nps , ierr ) jsr ( 2 , m ) = nps / idimp 140 continue 150 continue c check if particles must be passed further nps = 0 do 180 m = 1 , mnblok c check if any particles coming from above or front belong here jsl ( 1 , m ) = 0 jsr ( 1 , m ) = 0 jss ( 2 , m ) = 0 do 160 j = 1 , jsr ( 2 , m ) if ( rbufr ( ic , j , m ). lt . edges ( 2 * n - 1 , m )) jsl ( 1 , m ) = jsl ( 1 , m ) + 1 if ( rbufr ( ic , j , m ). ge . edges ( 2 * n , m )) jsr ( 1 , m ) = jsr ( 1 , m ) + 1 160 continue if ( jsr ( 1 , m ). ne . 0 ) then if ( n . eq . 1 ) then write ( 2 , * ) 'Info:' , jsr ( 1 , m ), ' particles returning above' elseif ( n . eq . 2 ) then write ( 2 , * ) 'Info:' , jsr ( 1 , m ), ' particles returning front' endif endif c check if any particles coming from below or back belong here do 170 j = 1 , jsl ( 2 , m ) if ( rbufl ( ic , j , m ). ge . edges ( 2 * n , m )) jsr ( 1 , m ) = jsr ( 1 , m ) + 1 if ( rbufl ( ic , j , m ). lt . edges ( 2 * n - 1 , m )) jss ( 2 , m ) = jss ( 2 , m ) + 1 170 continue if ( jss ( 2 , m ). ne . 0 ) then if ( n . eq . 1 ) then write ( 2 , * ) 'Info:' , jss ( 2 , m ), ' particles returning below' elseif ( n . eq . 2 ) then write ( 2 , * ) 'Info:' , jss ( 2 , m ), ' particles returning back' endif endif jsl ( 1 , m ) = jsl ( 1 , m ) + jss ( 2 , m ) nps = max0 ( nps , jsl ( 1 , m ) + jsr ( 1 , m )) 180 continue ibflg ( 2 ) = nps c make sure sbufr and sbufl have been sent call MPI_WAIT ( msid ( 3 ), istatus , ierr ) call MPI_WAIT ( msid ( 4 ), istatus , ierr ) if ( nps . eq . 0 ) go to 240 c remove particles which do not belong here do 230 mz = 1 , nblok moff = mblok * ( mz - 1 ) kb ( 2 ) = mz + ks do 220 my = 1 , mblok m = my + moff kb ( 1 ) = my + js c first check particles coming from above or front jsl ( 1 , m ) = 0 jsr ( 1 , m ) = 0 jss ( 2 , m ) = 0 do 190 j = 1 , jsr ( 2 , m ) xt = rbufr ( ic , j , m ) c particles going down or back if ( xt . lt . edges ( 2 * n - 1 , m )) then jsl ( 1 , m ) = jsl ( 1 , m ) + 1 if ( kb ( n ). eq . 0 ) xt = xt + an rbufr ( ic , j , m ) = xt do 183 i = 1 , idimp sbufl ( i , jsl ( 1 , m ), m ) = rbufr ( i , j , m ) 183 continue c particles going up or front, should not happen elseif ( xt . ge . edges ( 2 * n , m )) then jsr ( 1 , m ) = jsr ( 1 , m ) + 1 if (( kb ( n ) + 1 ). eq . nvp ) xt = xt - an rbufr ( ic , j , m ) = xt do 185 i = 1 , idimp sbufr ( i , jsr ( 1 , m ), m ) = rbufr ( i , j , m ) 185 continue c particles staying here else jss ( 2 , m ) = jss ( 2 , m ) + 1 do 187 i = 1 , idimp rbufr ( i , jss ( 2 , m ), m ) = rbufr ( i , j , m ) 187 continue endif 190 continue jsr ( 2 , m ) = jss ( 2 , m ) c next check particles coming from below or back jss ( 2 , m ) = 0 do 200 j = 1 , jsl ( 2 , m ) xt = rbufl ( ic , j , m ) c particles going up or front if ( xt . ge . edges ( 2 * n , m )) then if ( jsr ( 1 , m ). lt . nbmax ) then jsr ( 1 , m ) = jsr ( 1 , m ) + 1 if (( kb ( n ) + 1 ). eq . nvp ) xt = xt - an rbufl ( ic , j , m ) = xt do 193 i = 1 , idimp sbufr ( i , jsr ( 1 , m ), m ) = rbufl ( i , j , m ) 193 continue else jss ( 2 , m ) = 2 * npmax go to 210 endif c particles going down back, should not happen elseif ( xt . lt . edges ( 2 * n - 1 , m )) then if ( jsl ( 1 , m ). lt . nbmax ) then jsl ( 1 , m ) = jsl ( 1 , m ) + 1 if ( kb ( n ). eq . 0 ) xt = xt + an rbufl ( ic , j , m ) = xt do 195 i = 1 , idimp sbufl ( i , jsl ( 1 , m ), m ) = rbufl ( i , j , m ) 195 continue else jss ( 2 , m ) = 2 * npmax go to 210 endif c particles staying here else jss ( 2 , m ) = jss ( 2 , m ) + 1 do 197 i = 1 , idimp rbufl ( i , jss ( 2 , m ), m ) = rbufl ( i , j , m ) 197 continue endif 200 continue 210 jsl ( 2 , m ) = jss ( 2 , m ) 220 continue 230 continue c check if move would overflow particle array 240 nps = 0 npt = npmax do 250 m = 1 , mnblok jss ( 2 , m ) = npp ( m ) + jsl ( 2 , m ) + jsr ( 2 , m ) - jss ( 1 , m ) nps = max0 ( nps , jss ( 2 , m )) npt = min0 ( npt , jss ( 2 , m )) 250 continue ibflg ( 1 ) = nps ibflg ( 4 ) = - npt iwork = ibflg call MPI_ALLREDUCE ( iwork , ibflg , 4 , mint , MPI_MAX , lgrp , ierr ) info ( 2 ) = ibflg ( 1 ) info ( 3 ) = - ibflg ( 4 ) ierr = ibflg ( 1 ) - npmax if ( ierr . gt . 0 ) then write ( 2 , * ) 'particle overflow error, ierr = ' , ierr info ( 1 ) = ierr return endif c distribute incoming particles from buffers do 290 m = 1 , mnblok c distribute particles coming from below or back into holes jss ( 2 , m ) = min0 ( jss ( 1 , m ), jsl ( 2 , m )) do 260 j = 1 , jss ( 2 , m ) do 255 i = 1 , idimp part ( i , ihole ( j , m ), m ) = rbufl ( i , j , m ) 255 continue 260 continue if ( jss ( 1 , m ). gt . jsl ( 2 , m )) then jss ( 2 , m ) = min0 ( jss ( 1 , m ) - jsl ( 2 , m ), jsr ( 2 , m )) else jss ( 2 , m ) = jsl ( 2 , m ) - jss ( 1 , m ) endif do 270 j = 1 , jss ( 2 , m ) c no more particles coming from below or back c distribute particles coming from above or front into holes if ( jss ( 1 , m ). gt . jsl ( 2 , m )) then do 263 i = 1 , idimp part ( i , ihole ( j + jsl ( 2 , m ), m ), m ) = rbufr ( i , j , m ) 263 continue else c no more holes c distribute remaining particles from below or back into bottom do 267 i = 1 , idimp part ( i , j + npp ( m ), m ) = rbufl ( i , j + jss ( 1 , m ), m ) 267 continue endif 270 continue if ( jss ( 1 , m ). le . jsl ( 2 , m )) then npp ( m ) = npp ( m ) + ( jsl ( 2 , m ) - jss ( 1 , m )) jss ( 1 , m ) = jsl ( 2 , m ) endif jss ( 2 , m ) = jss ( 1 , m ) - ( jsl ( 2 , m ) + jsr ( 2 , m )) if ( jss ( 2 , m ). gt . 0 ) then jss ( 1 , m ) = ( jsl ( 2 , m ) + jsr ( 2 , m )) jsr ( 2 , m ) = jss ( 2 , m ) else jss ( 1 , m ) = jss ( 1 , m ) - jsl ( 2 , m ) jsr ( 2 , m ) = - jss ( 2 , m ) endif do 280 j = 1 , jsr ( 2 , m ) c holes left over c fill up remaining holes in particle array with particles from bottom if ( jss ( 2 , m ). gt . 0 ) then j1 = npp ( m ) - j + 1 j2 = jss ( 1 , m ) + jss ( 2 , m ) - j + 1 if ( j1 . gt . ihole ( j2 , m )) then c move particle only if it is below current hole do 273 i = 1 , idimp part ( i , ihole ( j2 , m ), m ) = part ( i , j1 , m ) 273 continue endif else c no more holes c distribute remaining particles from above or front into bottom do 277 i = 1 , idimp part ( i , j + npp ( m ), m ) = rbufr ( i , j + jss ( 1 , m ), m ) 277 continue endif 280 continue if ( jss ( 2 , m ). gt . 0 ) then npp ( m ) = npp ( m ) - jsr ( 2 , m ) else npp ( m ) = npp ( m ) + jsr ( 2 , m ) endif jss ( 1 , m ) = 0 290 continue c check if any particles have to be passed further info ( 5 + n ) = max0 ( info ( 5 + n ), mter ) if ( ibflg ( 2 ). gt . 0 ) then write ( 2 , * ) 'Info: particles being passed further = ' , ibflg ( 2 ) if ( ibflg ( 3 ). gt . 0 ) ibflg ( 3 ) = 1 if ( iter . lt . itermax ) go to 110 ierr = - (( iter - 2 ) / 2 ) write ( 2 , * ) 'Iteration overflow, iter = ' , ierr info ( 1 ) = ierr go to 320 endif c check if buffer overflowed and more particles remain to be checked if ( ibflg ( 3 ). gt . 0 ) then nter = nter + 1 info ( 3 + n ) = nter write ( 2 , * ) \"new loop, nter=\" , nter go to 20 endif 300 continue c information 320 if ( nter . gt . 0 ) then write ( 2 , * ) 'Info: ' , nter , ' buffer overflows, nbmax=' , nbmax endif return end c----------------------------------------------------------------------- function ranorm () c this program calculates a random number y from a gaussian distribution c with zero mean and unit variance, according to the method of c mueller and box: c    y(k) = (-2*ln(x(k)))**1/2*sin(2*pi*x(k+1)) c    y(k+1) = (-2*ln(x(k)))**1/2*cos(2*pi*x(k+1)), c where x is a random number uniformly distributed on (0,1). c written for the ibm by viktor k. decyk, ucla integer r1 , r2 , r4 , r5 double precision ranorm , h1l , h1u , h2l , r0 , r3 , asc , bsc , temp save iflg , r1 , r2 , r4 , r5 , h1l , h1u , h2l , r0 data r1 , r2 , r4 , r5 / 885098780 , 1824280461 , 1396483093 , 55318673 / data h1l , h1u , h2l / 6553 1.0d0 , 3276 7.0d0 , 6552 5.0d0 / data iflg , r0 / 0 , 0.0d0 / if ( iflg . eq . 0 ) go to 10 ranorm = r0 r0 = 0.0d0 iflg = 0 return 10 isc = 65536 asc = dble ( isc ) bsc = asc * asc i1 = r1 - ( r1 / isc ) * isc r3 = h1l * dble ( r1 ) + asc * h1u * dble ( i1 ) i1 = r3 / bsc r3 = r3 - dble ( i1 ) * bsc bsc = 0.5d0 * bsc i1 = r2 / isc isc = r2 - i1 * isc r0 = h1l * dble ( r2 ) + asc * h1u * dble ( isc ) asc = 1.0d0 / bsc isc = r0 * asc r2 = r0 - dble ( isc ) * bsc r3 = r3 + ( dble ( isc ) + 2.0d0 * h1u * dble ( i1 )) isc = r3 * asc r1 = r3 - dble ( isc ) * bsc temp = dsqrt ( - 2.0d0 * dlog (( dble ( r1 ) + dble ( r2 ) * asc ) * asc )) isc = 65536 asc = dble ( isc ) bsc = asc * asc i1 = r4 - ( r4 / isc ) * isc r3 = h2l * dble ( r4 ) + asc * h1u * dble ( i1 ) i1 = r3 / bsc r3 = r3 - dble ( i1 ) * bsc bsc = 0.5d0 * bsc i1 = r5 / isc isc = r5 - i1 * isc r0 = h2l * dble ( r5 ) + asc * h1u * dble ( isc ) asc = 1.0d0 / bsc isc = r0 * asc r5 = r0 - dble ( isc ) * bsc r3 = r3 + ( dble ( isc ) + 2.0d0 * h1u * dble ( i1 )) isc = r3 * asc r4 = r3 - dble ( isc ) * bsc r0 = 6.28318530717959d0 * (( dble ( r4 ) + dble ( r5 ) * asc ) * asc ) ranorm = temp * dsin ( r0 ) r0 = temp * dcos ( r0 ) iflg = 1 return end c-----------------------------------------------------------------------","tags":"","loc":"sourcefile/part3d_lib77.f.html"},{"title":"part2d_lib77.f – QuickPIC","text":"Contents Subroutines PPDBLKP2L PPPMOVIN2L PPPCHECK2L PPGPPOST2L PPGRDCJPPOST2L_QP PPGRBPPUSHF23L_QP PPPORDER2LA PPPORDERF2LA PPPORDER2LB WPGPSIPOST2L_QP PPPCOPYOUT2 Source Code part2d_lib77.f Source Code !----------------------------------------------------------------------- subroutine PPDBLKP2L ( part , kpic , npp , noff , nppmx , idimp , npmax , mx , my , 1 mx1 , mxyp1 , irc ) ! this subroutine finds the maximum number of particles in each tile of ! mx, my to calculate size of segmented particle array ppart ! linear interpolation, spatial decomposition in y direction ! input: all except kpic, nppmx, output: kpic, nppmx ! part = input particle array ! part(1,n) = position x of particle n in partition ! part(2,n) = position y of particle n in partition ! kpic = output number of particles per tile ! nppmx = return maximum number of particles in tile ! npp = number of particles in partition ! noff = backmost global gridpoint in particle partition ! idimp = size of phase space = 4 ! npmax = maximum number of particles in each partition ! mx/my = number of grids in sorting cell in x and y ! mx1 = (system length in x direction - 1)/mx + 1 ! mxyp1 = mx1*myp1, where myp1=(partition length in y direction-1)/my+1 ! irc = maximum overflow, returned only if error occurs, when irc > 0 implicit none integer nppmx , idimp , npmax , mx , my , mx1 , mxyp1 , irc integer kpic , npp , noff real part dimension part ( idimp , npmax ) dimension kpic ( mxyp1 ) ! local data integer j , k , n , m , mnoff , isum , ist , npx , ierr mnoff = noff ierr = 0 ! clear counter array do 10 k = 1 , mxyp1 kpic ( k ) = 0 10 continue ! find how many particles in each tile do 20 j = 1 , npp n = part ( 1 , j ) n = n / mx + 1 m = part ( 2 , j ) m = ( m - mnoff ) / my m = n + mx1 * m if ( m . le . mxyp1 ) then kpic ( m ) = kpic ( m ) + 1 else ierr = max ( ierr , m - mxyp1 ) endif 20 continue ! find maximum isum = 0 npx = 0 do 30 k = 1 , mxyp1 ist = kpic ( k ) npx = max ( npx , ist ) isum = isum + ist 30 continue nppmx = npx ! check for errors if ( ierr . gt . 0 ) then irc = ierr else if ( isum . ne . npp ) then irc = isum endif return end !----------------------------------------------------------------------- subroutine PPPMOVIN2L ( part , ppart , kpic , npp , noff , nppmx , idimp , npmax , 1 mx , my , mx1 , mxyp1 , irc ) ! this subroutine sorts particles by x,y grid in tiles of ! mx, my and copies to segmented array ppart ! linear interpolation, spatial decomposition in y direction ! input: all except ppart, kpic, output: ppart, kpic ! part/ppart = input/output particle arrays ! part(1,n) = position x of particle n in partition ! part(2,n) = position y of particle n in partition ! kpic = output number of particles per tile ! nppmx = maximum number of particles in tile ! npp = number of particles in partition ! noff = backmost global gridpoint in particle partition ! idimp = size of phase space = 4 ! npmax = maximum number of particles in each partition ! mx/my = number of grids in sorting cell in x and y ! mx1 = (system length in x direction - 1)/mx + 1 ! mxyp1 = mx1*myp1, where myp1=(partition length in y direction-1)/my+1 ! irc = maximum overflow, returned only if error occurs, when irc > 0 implicit none integer nppmx , idimp , npmax , mx , my , mx1 , mxyp1 , irc integer kpic , npp , noff real part , ppart dimension part ( idimp , npmax ), ppart ( idimp , nppmx , mxyp1 ) dimension kpic ( mxyp1 ) ! local data integer i , j , k , n , m , mnoff , ip , ierr mnoff = noff ierr = 0 ! clear counter array do 10 k = 1 , mxyp1 kpic ( k ) = 0 10 continue ! find addresses of particles at each tile and reorder particles do 30 j = 1 , npp n = part ( 1 , j ) n = n / mx + 1 m = part ( 2 , j ) m = ( m - mnoff ) / my m = n + mx1 * m ip = kpic ( m ) + 1 if ( ip . le . nppmx ) then do 20 i = 1 , idimp ppart ( i , ip , m ) = part ( i , j ) 20 continue else ierr = max ( ierr , ip - nppmx ) endif kpic ( m ) = ip 30 continue if ( ierr . gt . 0 ) irc = ierr return end !----------------------------------------------------------------------- subroutine PPPCHECK2L ( ppart , kpic , noff , nyp , idimp , nppmx , nx , mx , my , mx1 1 , myp1 , irc ) ! this subroutine performs a sanity check to make sure particles sorted ! by x,y grid in tiles of mx, my, are all within bounds. ! tiles are assumed to be arranged in 2D linear memory ! input: all except irc ! output: irc ! ppart(1,n,k) = position x of particle n in tile k ! ppart(2,n,k) = position y of particle n in tile k ! kpic(k) = number of reordered output particles in tile k ! noff = lowermost global gridpoint in particle partition. ! nyp = number of primary (complete) gridpoints in particle partition ! idimp = size of phase space = 4 ! nppmx = maximum number of particles in tile ! nx = system length in x direction ! mx/my = number of grids in sorting cell in x/y ! mx1 = (system length in x direction - 1)/mx + 1 ! myp1 = (partition length in y direction - 1)/my + 1 ! irc = particle error, returned only if error occurs, when irc > 0 implicit none integer noff , nyp , idimp , nppmx , nx , mx , my , mx1 , myp1 , irc real ppart integer kpic dimension ppart ( idimp , nppmx , mx1 * myp1 ) dimension kpic ( mx1 * myp1 ) ! local data integer mxyp1 , noffp , moffp , nppp , j , k , ist , nn , mm real edgelx , edgely , edgerx , edgery , dx , dy mxyp1 = mx1 * myp1 ! loop over tiles !$OMP PARALLEL DO !$OMP& PRIVATE(j,k,noffp,moffp,nppp,nn,mm,ist,edgelx,edgely,edgerx, !$OMP& edgery,dx,dy) do 20 k = 1 , mxyp1 noffp = ( k - 1 ) / mx1 moffp = my * noffp noffp = mx * ( k - mx1 * noffp - 1 ) nppp = kpic ( k ) nn = min ( mx , nx - noffp ) mm = min ( my , nyp - moffp ) edgelx = noffp edgerx = noffp + nn edgely = noff + moffp edgery = noff + moffp + mm ! loop over particles in tile do 10 j = 1 , nppp dx = ppart ( 1 , j , k ) dy = ppart ( 2 , j , k ) ! find particles going out of bounds ist = 0 if ( dx . lt . edgelx ) ist = 1 if ( dx . ge . edgerx ) ist = 2 if ( dy . lt . edgely ) ist = ist + 3 if ( dy . ge . edgery ) ist = ist + 6 if ( ist . gt . 0 ) irc = k 10 continue 20 continue !$OMP END PARALLEL DO return end !----------------------------------------------------------------------- subroutine PPGPPOST2L ( ppart , q , kpic , noff , idimp , nppmx , mx , my , nxv , nypm 1 x , mx1 , mxyp1 ) ! for 2d code, this subroutine calculates particle charge density ! using first-order linear interpolation, periodic boundaries ! OpenMP version using guard cells, for distributed data ! data deposited in tiles ! particles stored segmented array ! 17 flops/particle, 6 loads, 4 stores ! input: all, output: q ! charge density is approximated by values at the nearest grid points ! q(n,m)=qm*(1.-dx)*(1.-dy) ! q(n+1,m)=qm*dx*(1.-dy) ! q(n,m+1)=qm*(1.-dx)*dy ! q(n+1,m+1)=qm*dx*dy ! where n,m = leftmost grid points and dx = x-n, dy = y-m ! ppart(1,n,m) = position x of particle n in partition in tile m ! ppart(2,n,m) = position y of particle n in partition in tile m ! q(j,k) = charge density at grid point (j,kk), ! where kk = k + noff - 1 ! kpic = number of particles per tile ! noff = lowermost global gridpoint in particle partition. ! qm = charge on particle, in units of e ! idimp = size of phase space = 4 ! nppmx = maximum number of particles in tile ! mx/my = number of grids in sorting cell in x/y ! nxv = first dimension of charge array, must be >= nx+1 ! nypmx = maximum size of particle partition, including guard cells. ! mx1 = (system length in x direction - 1)/mx + 1 ! mxyp1 = mx1*myp1, where myp1=(partition length in y direction-1)/my+1 implicit none integer noff , idimp , nppmx , mx , my , nxv , nypmx , mx1 , mxyp1 real ppart , q integer kpic dimension ppart ( idimp , nppmx , mxyp1 ), q ( nxv , nypmx ), kpic ( mxyp1 ) ! local data !      integer MXV, MYV !      parameter(MXV=33,MYV=33) integer noffp , moffp , nppp integer mnoff , i , j , k , nn , mm real x , y , dxp , dyp , amx , amy real sq , qm !     dimension sq(MXV,MYV) dimension sq ( mx + 1 , my + 1 ) ! error if local array is too small !     if ((mx.ge.MXV).or.(my.ge.MYV)) return ! loop over tiles !$OMP PARALLEL DO !$OMP& PRIVATE(i,j,k,noffp,moffp,nppp,mnoff,nn,mm,x,y,dxp,dyp,amx,amy, !$OMP& sq,qm) do 80 k = 1 , mxyp1 noffp = ( k - 1 ) / mx1 moffp = my * noffp noffp = mx * ( k - mx1 * noffp - 1 ) nppp = kpic ( k ) mnoff = moffp + noff - 1 ! zero out local accumulator do 20 j = 1 , my + 1 do 10 i = 1 , mx + 1 sq ( i , j ) = 0.0 10 continue 20 continue ! loop over particles in tile do 30 j = 1 , nppp ! find interpolation weights x = ppart ( 1 , j , k ) y = ppart ( 2 , j , k ) qm = ppart ( 8 , j , k ) nn = x mm = y dxp = qm * ( x - real ( nn )) dyp = y - real ( mm ) nn = nn - noffp + 1 mm = mm - mnoff amx = qm - dxp amy = 1.0 - dyp ! deposit charge within tile to local accumulator x = sq ( nn , mm ) + amx * amy y = sq ( nn + 1 , mm ) + dxp * amy sq ( nn , mm ) = x sq ( nn + 1 , mm ) = y x = sq ( nn , mm + 1 ) + amx * dyp y = sq ( nn + 1 , mm + 1 ) + dxp * dyp sq ( nn , mm + 1 ) = x sq ( nn + 1 , mm + 1 ) = y 30 continue ! deposit charge to interior points in global array nn = min ( mx , nxv - noffp ) mm = min ( my , nypmx - moffp ) do 50 j = 2 , mm do 40 i = 2 , nn q ( i + noffp , j + moffp ) = q ( i + noffp , j + moffp ) + sq ( i , j ) 40 continue 50 continue ! deposit charge to edge points in global array mm = min ( my + 1 , nypmx - moffp ) do 60 i = 2 , nn !$OMP ATOMIC q ( i + noffp , 1 + moffp ) = q ( i + noffp , 1 + moffp ) + sq ( i , 1 ) if ( mm > my ) then !$OMP ATOMIC q ( i + noffp , mm + moffp ) = q ( i + noffp , mm + moffp ) + sq ( i , mm ) endif 60 continue nn = min ( mx + 1 , nxv - noffp ) do 70 j = 1 , mm !$OMP ATOMIC q ( 1 + noffp , j + moffp ) = q ( 1 + noffp , j + moffp ) + sq ( 1 , j ) if ( nn > mx ) then !$OMP ATOMIC q ( nn + noffp , j + moffp ) = q ( nn + noffp , j + moffp ) + sq ( nn , j ) endif 70 continue 80 continue !$OMP END PARALLEL DO return end !----------------------------------------------------------------------- subroutine PPGRDCJPPOST2L_QP ( ppart , fxy , bxy , psit , cu , dcu , amu , kpic , no 1 ff , nyp , qbm , dt , ci , idimp , nppmx , nx , mx , my , nxv , nypmx , mx1 , mxyp1 , dex ) ! for 2-1/2d code, this subroutine calculates particle momentum flux, ! acceleration density and current density using first-order spline ! interpolation for relativistic particles. ! OpenMP version using guard cells, for distributed data ! data read/written in tiles ! particles stored segmented array ! 241 flops/particle, 2 divide, 1 sqrt, 69 loads, 40 stores ! input: all, output: cu, dcu, amu ! current density is approximated by values at the nearest grid points ! cu(i,n,m)=qci*(1.-dx)*(1.-dy) ! cu(i,n+1,m)=qci*dx*(1.-dy) ! cu(i,n,m+1)=qci*(1.-dx)*dy ! cu(i,n+1,m+1)=qci*dx*dy ! and qci = qm*pj*gami, where j = x,y,z, for i = 1, 3 ! where pj = .5*(pj(t+dt/2)+pj(t-dt/2)) ! where gami = 1./sqrt(1.+sum(pi**2)*ci*ci) ! acceleration density is approximated by values at the nearest grid ! points ! dcu(i,n,m)=qci*(1.-dx)*(1.-dy) ! dcu(i,n+1,m)=qci*dx*(1.-dy) ! dcu(i,n,m+1)=qci*(1.-dx)*dy ! dcu(i,n+1,m+1)=qci*dx*dy ! and qci = qm*dvj*gami/dt, where j = x,y,z, for i = 1, 3 ! where dvj = dpj - pj*gami*dgamma, dpj = (pj(t+dt/2)-pj(t-dt/2)), ! pj = .5*(pj(t+dt/2)+pj(t-dt/2)), ! dgamma = (q/m)*ci*ci*gami*(sum(pj*Ej))*dt, ! and Ej = jth component of electric field ! momentum flux is approximated by values at the nearest grid points ! amu(i,n,m)=qci*(1.-dx)*(1.-dy) ! amu(i,n+1,m)=qci*dx*(1.-dy) ! amu(i,n,m+1)=qci*(1.-dx)*dy ! amu(i,n+1,m+1)=qci*dx*dy ! and qci = qm*pj*pk*gami**2, where jk = xx-yy,xy,zx,zy, for i = 1, 4 ! where pj = 0.5*(pj(t+dt/2)+pj(t-dt/2), ! and pk = 0.5*(pk(t+dt/2)+pk(t-dt/2)) ! where n,m = nearest grid points and dx = x-n, dy = y-m ! momentum equations at t=t+dt/2 are calculated from: ! px(t+dt/2) = rot(1)*(px(t-dt/2) + .5*(q/m)*fx(x(t),y(t))*dt) + !    rot(2)*(py(t-dt/2) + .5*(q/m)*fy(x(t),y(t))*dt) + !    rot(3)*(pz(t-dt/2) + .5*(q/m)*fz(x(t),y(t))*dt) + !    .5*(q/m)*fx(x(t),y(t))*dt) ! py(t+dt/2) = rot(4)*(px(t-dt/2) + .5*(q/m)*fx(x(t),y(t))*dt) + !    rot(5)*(py(t-dt/2) + .5*(q/m)*fy(x(t),y(t))*dt) + !    rot(6)*(pz(t-dt/2) + .5*(q/m)*fz(x(t),y(t))*dt) + !    .5*(q/m)*fy(x(t),y(t))*dt) ! pz(t+dt/2) = rot(7)*(px(t-dt/2) + .5*(q/m)*fx(x(t),y(t))*dt) + !    rot(8)*(py(t-dt/2) + .5*(q/m)*fy(x(t),y(t))*dt) + !    rot(9)*(pz(t-dt/2) + .5*(q/m)*fz(x(t),y(t))*dt) + !    .5*(q/m)*fz(x(t),y(t))*dt) ! where q/m is charge/mass, and the rotation matrix is given by: !    rot(1) = (1 - (om*dt/2)**2 + 2*(omx*dt/2)**2)/(1 + (om*dt/2)**2) !    rot(2) = 2*(omz*dt/2 + (omx*dt/2)*(omy*dt/2))/(1 + (om*dt/2)**2) !    rot(3) = 2*(-omy*dt/2 + (omx*dt/2)*(omz*dt/2))/(1 + (om*dt/2)**2) !    rot(4) = 2*(-omz*dt/2 + (omx*dt/2)*(omy*dt/2))/(1 + (om*dt/2)**2) !    rot(5) = (1 - (om*dt/2)**2 + 2*(omy*dt/2)**2)/(1 + (om*dt/2)**2) !    rot(6) = 2*(omx*dt/2 + (omy*dt/2)*(omz*dt/2))/(1 + (om*dt/2)**2) !    rot(7) = 2*(omy*dt/2 + (omx*dt/2)*(omz*dt/2))/(1 + (om*dt/2)**2) !    rot(8) = 2*(-omx*dt/2 + (omy*dt/2)*(omz*dt/2))/(1 + (om*dt/2)**2) !    rot(9) = (1 - (om*dt/2)**2 + 2*(omz*dt/2)**2)/(1 + (om*dt/2)**2) ! and om**2 = omx**2 + omy**2 + omz**2 ! the rotation matrix is determined by: ! omx = (q/m)*bx(x(t),y(t))*gami, omy = (q/m)*by(x(t),y(t))*gami, and ! omz = (q/m)*bz(x(t),y(t))*gami. ! fx(x(t),y(t)), fy(x(t),y(t)), and fz(x(t),y(t)) ! bx(x(t),y(t)), by(x(t),y(t)), and bz(x(t),y(t)) ! are approximated by interpolation from the nearest grid points: ! fx(x,y) = (1-dy)*((1-dx)*fx(n,m)+dx*fx(n+1,m)) + dy*((1-dx)*fx(n,m+1) !    + dx*fx(n+1,m+1)) ! where n,m = leftmost grid points and dx = x-n, dy = y-m ! similarly for fy(x,y), fz(x,y), bx(x,y), by(x,y), bz(x,y) ! ppart(1,n,m) = position x of particle n in partition in tile m at t ! ppart(2,n,m) = position y of particle n in partition in tile m at t ! ppart(3,n,m) = momentum px of particle n in partition in tile m ! at t - dt/2 ! ppart(4,n,m) = momentum py of particle n in partition in tile m ! at t - dt/2 ! ppart(5,n,m) = momentum pz of particle n in partition in tile m ! at t - dt/2 ! fxy(1,j,k) = x component of force/charge at grid (j,kk) ! fxy(2,j,k) = y component of force/charge at grid (j,kk) ! fxy(3,j,k) = z component of force/charge at grid (j,kk) ! that is, convolution of electric field over particle shape, ! where kk = k + noff - 1 ! bxy(1,j,k) = x component of magnetic field at grid (j,kk) ! bxy(2,j,k) = y component of magnetic field at grid (j,kk) ! bxy(3,j,k) = z component of magnetic field at grid (j,kk) ! that is, the convolution of magnetic field over particle shape, ! where kk = k + noff - 1 ! cu(i,j,k) = ith component of current density ! at grid point j,kk for i = 1, 3 ! dcu(i,j,k) = ith component of acceleration density ! at grid point j,kk for i = 1, 3 ! amu(i,j,k) = ith component of momentum flux ! at grid point j,kk for i = 1, 4 ! where kk = k + noff - 1 ! kpic = number of particles per tile ! noff = lowermost global gridpoint in particle partition. ! nyp = number of primary (complete) gridpoints in particle partition ! qm = charge on particle, in units of e ! qbm = particle charge/mass ratio ! dt = time interval between successive calculations ! ci = reciprical of velocity of light ! idimp = size of phase space = 5 ! nppmx = maximum number of particles in tile ! nx = system length in x direction ! mx/my = number of grids in sorting cell in x/y ! nxv = second dimension of field arrays, must be >= nx+1 ! nypmx = maximum size of particle partition, including guard cells. ! mx1 = (system length in x direction - 1)/mx + 1 ! mxyp1 = mx1*myp1, where myp1=(partition length in y direction-1)/my+1 implicit none integer noff , nyp , idimp , nppmx , nx , mx , my , nxv , nypmx integer mx1 , mxyp1 real qbm , dt , ci , dex real ppart , fxy , bxy , cu , dcu , amu , psit integer kpic dimension ppart ( idimp , nppmx , mxyp1 ) dimension fxy ( 2 , nxv , nypmx ), bxy ( 3 , nxv , nypmx ), psit ( nxv , nypmx ) dimension cu ( 3 , nxv , nypmx ), dcu ( 2 , nxv , nypmx ), amu ( 3 , nxv , nypmx ) dimension kpic ( mxyp1 ) ! local data !      integer MXV, MYV !      parameter(MXV=33,MYV=33) integer noffp , moffp , nppp integer mnoff , i , j , k , nn , mm real qtmh , dti , ci2 , gami , qtmg , gh , dxp , dyp , amx , amy real dx , dy , dz , ox , oy , oz , qm real acx , acy , acz , omxt , omyt , omzt , omt , anorm real rot1 , rot2 , rot3 , rot4 , rot5 , rot6 , rot7 , rot8 , rot9 real x , y , vx , vy , vz , p2 , v1 , v2 , v3 , v4 real sfxy , sbxy , scu , sdcu , samu , spsit dimension sfxy ( 2 , mx + 1 , my + 1 ), sbxy ( 3 , mx + 1 , my + 1 ) dimension spsit ( mx + 1 , my + 1 ) dimension scu ( 3 , mx + 1 , my + 1 ), sdcu ( 2 , mx + 1 , my + 1 ), samu ( 3 , mx + 1 , my + 1 ) !      dimension sfxy(2,MXV,MYV), sbxy(3,MXV,MYV) !      dimension spsit(MXV,MYV) !      dimension scu(3,MXV,MYV), sdcu(2,MXV,MYV), samu(3,MXV,MYV) real qm1 , qtmh1 , qtmh2 , idex , inv_part_7 , ddx , ddy , p6 , p7 !     dimension sfxy(3,mx+1,my+1), sbxy(3,mx+1,my+1) !     dimension scu(3,mx+1,my+1,), sdcu(3,mx+1,my+1), samu(4,mx+1,my+1) qtmh = 0.5 * qbm * dt dti = 1.0 / dt ci2 = ci * ci idex = 1.0 / dex ! error if local array is too small !     if ((mx.ge.MXV).or.(my.ge.MYV)) return ! loop over tiles !$OMP PARALLEL DO !$OMP& PRIVATE(i,j,k,noffp,moffp,nppp,nn,mm,mnoff,x,y,vx,vy,v1,v2,v3, !$OMP& dxp,dyp,amx,amy,dx,dy,dz,ox,oy,oz,acx,acy,acz,omzt, !$OMP& omt,anorm,rot1,rot2,spsit, !$OMP& sfxy,sbxy,scu,sdcu,samu,qm1,qtmh1,qtmh2,inv_part_7,ddx, !$OMP& ddy,p6,p7,qm) do 120 k = 1 , mxyp1 noffp = ( k - 1 ) / mx1 moffp = my * noffp noffp = mx * ( k - mx1 * noffp - 1 ) nppp = kpic ( k ) mnoff = moffp + noff - 1 ! load local fields from global arrays nn = min ( mx , nx - noffp ) + 1 mm = min ( my , nyp - moffp ) + 1 do 20 j = 1 , mm do 10 i = 1 , nn sfxy ( 1 , i , j ) = fxy ( 1 , i + noffp , j + moffp ) sfxy ( 2 , i , j ) = fxy ( 2 , i + noffp , j + moffp ) 10 continue 20 continue do 40 j = 1 , mm do 30 i = 1 , nn sbxy ( 1 , i , j ) = bxy ( 1 , i + noffp , j + moffp ) sbxy ( 2 , i , j ) = bxy ( 2 , i + noffp , j + moffp ) sbxy ( 3 , i , j ) = bxy ( 3 , i + noffp , j + moffp ) 30 continue 40 continue do 46 j = 1 , mm do 42 i = 1 , nn spsit ( i , j ) = psit ( i + noffp , j + moffp ) 42 continue 46 continue ! zero out local accumulators do 60 j = 1 , my + 1 do 50 i = 1 , mx + 1 samu ( 1 , i , j ) = 0.0 samu ( 2 , i , j ) = 0.0 samu ( 3 , i , j ) = 0.0 sdcu ( 1 , i , j ) = 0.0 sdcu ( 2 , i , j ) = 0.0 scu ( 1 , i , j ) = 0.0 scu ( 2 , i , j ) = 0.0 scu ( 3 , i , j ) = 0.0 50 continue 60 continue ! loop over particles in tile do 70 j = 1 , nppp ! find interpolation weights x = ppart ( 1 , j , k ) y = ppart ( 2 , j , k ) p6 = ppart ( 6 , j , k ) p7 = ppart ( 7 , j , k ) qm = ppart ( 8 , j , k ) nn = x mm = y dxp = x - real ( nn ) dyp = y - real ( mm ) nn = nn - noffp + 1 mm = mm - mnoff amx = 1.0 - dxp amy = 1.0 - dyp inv_part_7 = 1.0 / p7 qtmh1 = qtmh * inv_part_7 qtmh2 = qtmh1 * p6 ! find electric field dx = amx * sfxy ( 1 , nn , mm ) dy = amx * sfxy ( 2 , nn , mm ) dz = amx * spsit ( nn , mm ) dx = amy * ( dxp * sfxy ( 1 , nn + 1 , mm ) + dx ) dy = amy * ( dxp * sfxy ( 2 , nn + 1 , mm ) + dy ) dz = amy * ( dxp * spsit ( nn + 1 , mm ) + dz ) acx = amx * sfxy ( 1 , nn , mm + 1 ) acy = amx * sfxy ( 2 , nn , mm + 1 ) acz = amx * spsit ( nn , mm + 1 ) dx = dx + dyp * ( dxp * sfxy ( 1 , nn + 1 , mm + 1 ) + acx ) dy = dy + dyp * ( dxp * sfxy ( 2 , nn + 1 , mm + 1 ) + acy ) dz = dz + dyp * ( dxp * spsit ( nn + 1 , mm + 1 ) + acz ) ! find magnetic field ox = amx * sbxy ( 1 , nn , mm ) oy = amx * sbxy ( 2 , nn , mm ) oz = amx * sbxy ( 3 , nn , mm ) ox = amy * ( dxp * sbxy ( 1 , nn + 1 , mm ) + ox ) oy = amy * ( dxp * sbxy ( 2 , nn + 1 , mm ) + oy ) oz = amy * ( dxp * sbxy ( 3 , nn + 1 , mm ) + oz ) acx = amx * sbxy ( 1 , nn , mm + 1 ) acy = amx * sbxy ( 2 , nn , mm + 1 ) acz = amx * sbxy ( 3 , nn , mm + 1 ) ox = ox + dyp * ( dxp * sbxy ( 1 , nn + 1 , mm + 1 ) + acx ) oy = oy + dyp * ( dxp * sbxy ( 2 , nn + 1 , mm + 1 ) + acy ) oz = oz + dyp * ( dxp * sbxy ( 3 , nn + 1 , mm + 1 ) + acz ) ! calculate half impulse ddx = ( - 1.0 ) * qtmh2 * dx + qtmh * oy ddy = ( - 1.0 ) * qtmh2 * dy - qtmh * ox ! half acceleration vx = ppart ( 3 , j , k ) vy = ppart ( 4 , j , k ) acx = vx + ddx acy = vy + ddy ! find inverse gamma ! renormalize magnetic field ! calculate cyclotron frequency omzt = qtmh1 * oz ! calculate rotation matrix omt = omzt * omzt anorm = 2.0 / ( 1.0 + omt ) rot1 = 0.5 * ( 1.0 - omt ) rot2 = omzt ! new momentum v1 = ( rot1 * acx + rot2 * acy ) * anorm + ddx v2 = ( rot1 * acy - rot2 * acx ) * anorm + ddy ! deposit momentum flux, acceleration density, and current density qm1 = qm * inv_part_7 amx = qm1 * amx dxp = qm1 * dxp ox = 0.5 * ( v1 + vx ) oy = 0.5 * ( v2 + vy ) oz = 0.5 * ( 1.0 + dex * dex * ( ox * ox + oy * oy )) * inv_part_7 - 0.5 * p7 ppart ( 6 , j , k ) = p7 + oz oz = oz * idex vx = ( v1 - vx ) * dti vy = ( v2 - vy ) * dti dz = qbm * ( dz + ( dx * ox + dy * oy ) * dex * dex * inv_part_7 ) dx = amx * amy dy = dxp * amy v1 = ox * ox * inv_part_7 v2 = oy * oy * inv_part_7 v3 = ox * oy * inv_part_7 vx = vx + ox * dz * inv_part_7 vy = vy + oy * dz * inv_part_7 samu ( 1 , nn , mm ) = samu ( 1 , nn , mm ) + v1 * dx samu ( 2 , nn , mm ) = samu ( 2 , nn , mm ) + v2 * dx samu ( 3 , nn , mm ) = samu ( 3 , nn , mm ) + v3 * dx sdcu ( 1 , nn , mm ) = sdcu ( 1 , nn , mm ) + vx * dx sdcu ( 2 , nn , mm ) = sdcu ( 2 , nn , mm ) + vy * dx scu ( 1 , nn , mm ) = scu ( 1 , nn , mm ) + ox * dx scu ( 2 , nn , mm ) = scu ( 2 , nn , mm ) + oy * dx scu ( 3 , nn , mm ) = scu ( 3 , nn , mm ) + oz * dx dx = amx * dyp samu ( 1 , nn + 1 , mm ) = samu ( 1 , nn + 1 , mm ) + v1 * dy samu ( 2 , nn + 1 , mm ) = samu ( 2 , nn + 1 , mm ) + v2 * dy samu ( 3 , nn + 1 , mm ) = samu ( 3 , nn + 1 , mm ) + v3 * dy sdcu ( 1 , nn + 1 , mm ) = sdcu ( 1 , nn + 1 , mm ) + vx * dy sdcu ( 2 , nn + 1 , mm ) = sdcu ( 2 , nn + 1 , mm ) + vy * dy scu ( 1 , nn + 1 , mm ) = scu ( 1 , nn + 1 , mm ) + ox * dy scu ( 2 , nn + 1 , mm ) = scu ( 2 , nn + 1 , mm ) + oy * dy scu ( 3 , nn + 1 , mm ) = scu ( 3 , nn + 1 , mm ) + oz * dy dy = dxp * dyp samu ( 1 , nn , mm + 1 ) = samu ( 1 , nn , mm + 1 ) + v1 * dx samu ( 2 , nn , mm + 1 ) = samu ( 2 , nn , mm + 1 ) + v2 * dx samu ( 3 , nn , mm + 1 ) = samu ( 3 , nn , mm + 1 ) + v3 * dx sdcu ( 1 , nn , mm + 1 ) = sdcu ( 1 , nn , mm + 1 ) + vx * dx sdcu ( 2 , nn , mm + 1 ) = sdcu ( 2 , nn , mm + 1 ) + vy * dx scu ( 1 , nn , mm + 1 ) = scu ( 1 , nn , mm + 1 ) + ox * dx scu ( 2 , nn , mm + 1 ) = scu ( 2 , nn , mm + 1 ) + oy * dx scu ( 3 , nn , mm + 1 ) = scu ( 3 , nn , mm + 1 ) + oz * dx samu ( 1 , nn + 1 , mm + 1 ) = samu ( 1 , nn + 1 , mm + 1 ) + v1 * dy samu ( 2 , nn + 1 , mm + 1 ) = samu ( 2 , nn + 1 , mm + 1 ) + v2 * dy samu ( 3 , nn + 1 , mm + 1 ) = samu ( 3 , nn + 1 , mm + 1 ) + v3 * dy sdcu ( 1 , nn + 1 , mm + 1 ) = sdcu ( 1 , nn + 1 , mm + 1 ) + vx * dy sdcu ( 2 , nn + 1 , mm + 1 ) = sdcu ( 2 , nn + 1 , mm + 1 ) + vy * dy scu ( 1 , nn + 1 , mm + 1 ) = scu ( 1 , nn + 1 , mm + 1 ) + ox * dy scu ( 2 , nn + 1 , mm + 1 ) = scu ( 2 , nn + 1 , mm + 1 ) + oy * dy scu ( 3 , nn + 1 , mm + 1 ) = scu ( 3 , nn + 1 , mm + 1 ) + oz * dy 70 continue ! deposit currents to interior points in global array nn = min ( mx , nxv - noffp ) mm = min ( my , nypmx - moffp ) do 90 j = 2 , mm do 80 i = 2 , nn amu ( 1 , i + noffp , j + moffp ) = amu ( 1 , i + noffp , j + moffp ) + samu ( 1 , i , j ) amu ( 2 , i + noffp , j + moffp ) = amu ( 2 , i + noffp , j + moffp ) + samu ( 2 , i , j ) amu ( 3 , i + noffp , j + moffp ) = amu ( 3 , i + noffp , j + moffp ) + samu ( 3 , i , j ) dcu ( 1 , i + noffp , j + moffp ) = dcu ( 1 , i + noffp , j + moffp ) + sdcu ( 1 , i , j ) dcu ( 2 , i + noffp , j + moffp ) = dcu ( 2 , i + noffp , j + moffp ) + sdcu ( 2 , i , j ) cu ( 1 , i + noffp , j + moffp ) = cu ( 1 , i + noffp , j + moffp ) + scu ( 1 , i , j ) cu ( 2 , i + noffp , j + moffp ) = cu ( 2 , i + noffp , j + moffp ) + scu ( 2 , i , j ) cu ( 3 , i + noffp , j + moffp ) = cu ( 3 , i + noffp , j + moffp ) + scu ( 3 , i , j ) 80 continue 90 continue ! deposit currents to edge points in global array mm = min ( my + 1 , nypmx - moffp ) do 100 i = 2 , nn !$OMP ATOMIC amu ( 1 , i + noffp , 1 + moffp ) = amu ( 1 , i + noffp , 1 + moffp ) + samu ( 1 , i , 1 ) !$OMP ATOMIC amu ( 2 , i + noffp , 1 + moffp ) = amu ( 2 , i + noffp , 1 + moffp ) + samu ( 2 , i , 1 ) !$OMP ATOMIC amu ( 3 , i + noffp , 1 + moffp ) = amu ( 3 , i + noffp , 1 + moffp ) + samu ( 3 , i , 1 ) !$OMP ATOMIC dcu ( 1 , i + noffp , 1 + moffp ) = dcu ( 1 , i + noffp , 1 + moffp ) + sdcu ( 1 , i , 1 ) !$OMP ATOMIC dcu ( 2 , i + noffp , 1 + moffp ) = dcu ( 2 , i + noffp , 1 + moffp ) + sdcu ( 2 , i , 1 ) !$OMP ATOMIC cu ( 1 , i + noffp , 1 + moffp ) = cu ( 1 , i + noffp , 1 + moffp ) + scu ( 1 , i , 1 ) !$OMP ATOMIC cu ( 2 , i + noffp , 1 + moffp ) = cu ( 2 , i + noffp , 1 + moffp ) + scu ( 2 , i , 1 ) !$OMP ATOMIC cu ( 3 , i + noffp , 1 + moffp ) = cu ( 3 , i + noffp , 1 + moffp ) + scu ( 3 , i , 1 ) if ( mm > my ) then !$OMP ATOMIC amu ( 1 , i + noffp , mm + moffp ) = amu ( 1 , i + noffp , mm + moffp ) & & + samu ( 1 , i , mm ) !$OMP ATOMIC amu ( 2 , i + noffp , mm + moffp ) = amu ( 2 , i + noffp , mm + moffp ) & & + samu ( 2 , i , mm ) !$OMP ATOMIC amu ( 3 , i + noffp , mm + moffp ) = amu ( 3 , i + noffp , mm + moffp ) & & + samu ( 3 , i , mm ) !$OMP ATOMIC dcu ( 1 , i + noffp , mm + moffp ) = dcu ( 1 , i + noffp , mm + moffp ) & & + sdcu ( 1 , i , mm ) !$OMP ATOMIC dcu ( 2 , i + noffp , mm + moffp ) = dcu ( 2 , i + noffp , mm + moffp ) & & + sdcu ( 2 , i , mm ) !$OMP ATOMIC cu ( 1 , i + noffp , mm + moffp ) = cu ( 1 , i + noffp , mm + moffp ) + scu ( 1 , i , mm ) !$OMP ATOMIC cu ( 2 , i + noffp , mm + moffp ) = cu ( 2 , i + noffp , mm + moffp ) + scu ( 2 , i , mm ) !$OMP ATOMIC cu ( 3 , i + noffp , mm + moffp ) = cu ( 3 , i + noffp , mm + moffp ) + scu ( 3 , i , mm ) endif 100 continue nn = min ( mx + 1 , nxv - noffp ) do 110 j = 1 , mm !$OMP ATOMIC amu ( 1 , 1 + noffp , j + moffp ) = amu ( 1 , 1 + noffp , j + moffp ) + samu ( 1 , 1 , j ) !$OMP ATOMIC amu ( 2 , 1 + noffp , j + moffp ) = amu ( 2 , 1 + noffp , j + moffp ) + samu ( 2 , 1 , j ) !$OMP ATOMIC amu ( 3 , 1 + noffp , j + moffp ) = amu ( 3 , 1 + noffp , j + moffp ) + samu ( 3 , 1 , j ) !$OMP ATOMIC dcu ( 1 , 1 + noffp , j + moffp ) = dcu ( 1 , 1 + noffp , j + moffp ) + sdcu ( 1 , 1 , j ) !$OMP ATOMIC dcu ( 2 , 1 + noffp , j + moffp ) = dcu ( 2 , 1 + noffp , j + moffp ) + sdcu ( 2 , 1 , j ) !$OMP ATOMIC cu ( 1 , 1 + noffp , j + moffp ) = cu ( 1 , 1 + noffp , j + moffp ) + scu ( 1 , 1 , j ) !$OMP ATOMIC cu ( 2 , 1 + noffp , j + moffp ) = cu ( 2 , 1 + noffp , j + moffp ) + scu ( 2 , 1 , j ) !$OMP ATOMIC cu ( 3 , 1 + noffp , j + moffp ) = cu ( 3 , 1 + noffp , j + moffp ) + scu ( 3 , 1 , j ) if ( nn > mx ) then !$OMP ATOMIC amu ( 1 , nn + noffp , j + moffp ) = amu ( 1 , nn + noffp , j + moffp ) & & + samu ( 1 , nn , j ) !$OMP ATOMIC amu ( 2 , nn + noffp , j + moffp ) = amu ( 2 , nn + noffp , j + moffp ) & & + samu ( 2 , nn , j ) !$OMP ATOMIC amu ( 3 , nn + noffp , j + moffp ) = amu ( 3 , nn + noffp , j + moffp ) & & + samu ( 3 , nn , j ) !$OMP ATOMIC dcu ( 1 , nn + noffp , j + moffp ) = dcu ( 1 , nn + noffp , j + moffp ) & & + sdcu ( 1 , nn , j ) !$OMP ATOMIC dcu ( 2 , nn + noffp , j + moffp ) = dcu ( 2 , nn + noffp , j + moffp ) & & + sdcu ( 2 , nn , j ) !$OMP ATOMIC cu ( 1 , nn + noffp , j + moffp ) = cu ( 1 , nn + noffp , j + moffp ) + scu ( 1 , nn , j ) !$OMP ATOMIC cu ( 2 , nn + noffp , j + moffp ) = cu ( 2 , nn + noffp , j + moffp ) + scu ( 2 , nn , j ) !$OMP ATOMIC cu ( 3 , nn + noffp , j + moffp ) = cu ( 3 , nn + noffp , j + moffp ) + scu ( 3 , nn , j ) endif 110 continue 120 continue !$OMP END PARALLEL DO return end !----------------------------------------------------------------------- subroutine PPGRBPPUSHF23L_QP ( ppart , fxy , bxy , psit , kpic , ncl , ihole , nof & & f , nyp , qbm , dt , dtc , ci , ek , idimp , nppmx , nx , ny , mx , my , nxv , nypmx , mx1 , mxyp1 & & , ntmax , irc , dex ) ! for 2-1/2d code, this subroutine updates particle co-ordinates and ! velocities using leap-frog scheme in time and first-order linear ! interpolation in space, for relativistic particles with magnetic field ! Using the Boris Mover. ! with periodic boundary conditions. ! also determines list of particles which are leaving this tile ! OpenMP version using guard cells, for distributed data ! data read in tiles ! particles stored segmented array ! 131 flops/particle, 4 divides, 2 sqrts, 25 loads, 5 stores ! input: all except ncl, ihole, irc, output: ppart, ncl, ihole, ek, irc ! momentum equations used are: ! px(t+dt/2) = rot(1)*(px(t-dt/2) + .5*(q/m)*fx(x(t),y(t))*dt) + !    rot(2)*(py(t-dt/2) + .5*(q/m)*fy(x(t),y(t))*dt) + !    rot(3)*(pz(t-dt/2) + .5*(q/m)*fz(x(t),y(t))*dt) + !    .5*(q/m)*fx(x(t),y(t))*dt) ! py(t+dt/2) = rot(4)*(px(t-dt/2) + .5*(q/m)*fx(x(t),y(t))*dt) + !    rot(5)*(py(t-dt/2) + .5*(q/m)*fy(x(t),y(t))*dt) + !    rot(6)*(pz(t-dt/2) + .5*(q/m)*fz(x(t),y(t))*dt) + !    .5*(q/m)*fy(x(t),y(t))*dt) ! pz(t+dt/2) = rot(7)*(px(t-dt/2) + .5*(q/m)*fx(x(t),y(t))*dt) + !    rot(8)*(py(t-dt/2) + .5*(q/m)*fy(x(t),y(t))*dt) + !    rot(9)*(pz(t-dt/2) + .5*(q/m)*fz(x(t),y(t))*dt) + !    .5*(q/m)*fz(x(t),y(t))*dt) ! where q/m is charge/mass, and the rotation matrix is given by: !    rot(1) = (1 - (om*dt/2)**2 + 2*(omx*dt/2)**2)/(1 + (om*dt/2)**2) !    rot(2) = 2*(omz*dt/2 + (omx*dt/2)*(omy*dt/2))/(1 + (om*dt/2)**2) !    rot(3) = 2*(-omy*dt/2 + (omx*dt/2)*(omz*dt/2))/(1 + (om*dt/2)**2) !    rot(4) = 2*(-omz*dt/2 + (omx*dt/2)*(omy*dt/2))/(1 + (om*dt/2)**2) !    rot(5) = (1 - (om*dt/2)**2 + 2*(omy*dt/2)**2)/(1 + (om*dt/2)**2) !    rot(6) = 2*(omx*dt/2 + (omy*dt/2)*(omz*dt/2))/(1 + (om*dt/2)**2) !    rot(7) = 2*(omy*dt/2 + (omx*dt/2)*(omz*dt/2))/(1 + (om*dt/2)**2) !    rot(8) = 2*(-omx*dt/2 + (omy*dt/2)*(omz*dt/2))/(1 + (om*dt/2)**2) !    rot(9) = (1 - (om*dt/2)**2 + 2*(omz*dt/2)**2)/(1 + (om*dt/2)**2) ! and om**2 = omx**2 + omy**2 + omz**2 ! the rotation matrix is determined by: ! omx = (q/m)*bx(x(t),y(t))*gami, omy = (q/m)*by(x(t),y(t))*gami, and ! omz = (q/m)*bz(x(t),y(t))*gami, ! where gami = 1./sqrt(1.+(px(t)*px(t)+py(t)*py(t)+pz(t)*pz(t))*ci*ci) ! position equations used are: ! x(t+dt) = x(t) + px(t+dt/2)*dtg ! y(t+dt) = y(t) + py(t+dt/2)*dtg ! where dtg = dtc/sqrt(1.+(px(t+dt/2)*px(t+dt/2)+py(t+dt/2)*py(t+dt/2)+ ! pz(t+dt/2)*pz(t+dt/2))*ci*ci) ! fx(x(t),y(t)), fy(x(t),y(t)), and fz(x(t),y(t)) ! bx(x(t),y(t)), by(x(t),y(t)), and bz(x(t),y(t)) ! are approximated by interpolation from the nearest grid points: ! fx(x,y) = (1-dy)*((1-dx)*fx(n,m)+dx*fx(n+1,m)) + dy*((1-dx)*fx(n,m+1) !    + dx*fx(n+1,m+1)) ! where n,m = leftmost grid points and dx = x-n, dy = y-m ! similarly for fy(x,y), fz(x,y), bx(x,y), by(x,y), bz(x,y) ! ppart(1,n,m) = position x of particle n in partition in tile m ! ppart(2,n,m) = position y of particle n in partition in tile m ! ppart(3,n,m) = momentum vx of particle n in partition in tile m ! ppart(4,n,m) = momentum vy of particle n in partition in tile m ! ppart(5,n,m) = momentum vz of particle n in partition in tile m ! fxy(1,j,k) = x component of force/charge at grid (j,kk) ! fxy(2,j,k) = y component of force/charge at grid (j,kk) ! fxy(3,j,k) = z component of force/charge at grid (j,kk) ! that is, convolution of electric field over particle shape, ! where kk = k + noff - 1 ! bxy(1,j,k) = x component of magnetic field at grid (j,kk) ! bxy(2,j,k) = y component of magnetic field at grid (j,kk) ! bxy(3,j,k) = z component of magnetic field at grid (j,kk) ! that is, the convolution of magnetic field over particle shape, ! where kk = k + noff - 1 ! kpic(k) = number of particles in tile k ! ncl(i,k) = number of particles going to destination i, tile k ! ihole(1,:,k) = location of hole in array left by departing particle ! ihole(2,:,k) = destination of particle leaving hole ! ihole(1,1,k) = ih, number of holes left (error, if negative) ! noff = lowermost global gridpoint in particle partition. ! nyp = number of primary (complete) gridpoints in particle partition ! qbm = particle charge/mass ratio ! dt = time interval between successive calculations ! dtc = time interval between successive co-ordinate calculations ! ci = reciprical of velocity of light ! kinetic energy/mass at time t is also calculated, using ! ek = gami*sum((px(t-dt/2) + .5*(q/m)*fx(x(t),y(t))*dt)**2 + !      (py(t-dt/2) + .5*(q/m)*fy(x(t),y(t))*dt)**2 + !      (pz(t-dt/2) + .5*(q/m)*fz(x(t),y(t))*dt)**2)/(1. + gami) ! idimp = size of phase space = 5 ! nppmx = maximum number of particles in tile ! nx/ny = system length in x/y direction ! mx/my = number of grids in sorting cell in x/y ! nxv = first dimension of field arrays, must be >= nx+1 ! nypmx = maximum size of particle partition, including guard cells. ! mx1 = (system length in x direction - 1)/mx + 1 ! mxyp1 = mx1*myp1, where myp1=(partition length in y direction-1)/my+1 ! ntmax = size of hole array for particles leaving tiles ! irc = maximum overflow, returned only if error occurs, when irc > 0 ! optimized version implicit none integer noff , nyp , idimp , nppmx , nx , ny , mx , my , nxv , nypmx integer mx1 , mxyp1 , ntmax , irc real qbm , dt , dtc , ci , ek , dex real ppart , fxy , bxy , psit integer kpic , ncl , ihole dimension ppart ( idimp , nppmx , mxyp1 ) dimension fxy ( 2 , nxv , nypmx ), bxy ( 3 , nxv , nypmx ) dimension psit ( nxv , nypmx ) dimension kpic ( mxyp1 ), ncl ( 8 , mxyp1 ) dimension ihole ( 2 , ntmax + 1 , mxyp1 ) ! local data !      integer MXV, MYV !      parameter(MXV=33,MYV=33) integer noffp , moffp , nppp integer mnoff , i , j , k , ih , nh , nn , mm real qtmh , ci2 , dxp , dyp , amx , amy real dx , dy , dz , ox , oy , oz , acx , acy , acz , p2 , gami , qtmg , dtg real omxt , omyt , omzt , omt , anorm real rot1 , rot2 , rot3 , rot4 , rot5 , rot6 , rot7 , rot8 , rot9 real anx , any , edgelx , edgely , edgerx , edgery real x , y real sfxy , sbxy , spsit dimension sfxy ( 2 , mx + 1 , my + 1 ), sbxy ( 3 , mx + 1 , my + 1 ), spsit ( mx + 1 , my + 1 ) !     dimension sfxy(3,mx+1,my+1), sbxy(3,mx+1,my+1) double precision sum1 , sum2 real idex , dtc1 , ddx , ddy , ddz , qtmh1 , qtmh2 , p6 , p7 idex = 1.0 / dex qtmh = 0.5 * qbm * dt ci2 = ci * ci anx = real ( nx ) any = real ( ny ) sum2 = 0.0d0 ! error if local array is too small !     if ((mx.ge.MXV).or.(my.ge.MYV)) return ! loop over tiles !$OMP PARALLEL DO !$OMP& PRIVATE(i,j,k,noffp,moffp,nppp,nn,mm,ih,nh,mnoff,x,y,dxp,dyp,amx, !$OMP& amy,dx,dy,dz,ox,oy,oz,acx,acy,acz,omxt,omyt,omzt,omt,anorm,rot1, !$OMP& rot2,rot3,rot4,rot5,rot6,rot7,rot8,rot9,edgelx,edgely,edgerx, !$OMP& edgery,sum1,sfxy,sbxy,spsit, !$OMP& ddx,ddy,ddz,qtmh1,qtmh2,p6,p7,dtc1) !$OMP& REDUCTION(+:sum2) do 70 k = 1 , mxyp1 noffp = ( k - 1 ) / mx1 moffp = my * noffp noffp = mx * ( k - mx1 * noffp - 1 ) nppp = kpic ( k ) nn = min ( mx , nx - noffp ) mm = min ( my , nyp - moffp ) edgelx = noffp edgerx = noffp + nn edgely = noff + moffp edgery = noff + moffp + mm ih = 0 nh = 0 mnoff = moffp + noff - 1 ! load local fields from global arrays do 20 j = 1 , mm + 1 do 10 i = 1 , nn + 1 sfxy ( 1 , i , j ) = fxy ( 1 , i + noffp , j + moffp ) sfxy ( 2 , i , j ) = fxy ( 2 , i + noffp , j + moffp ) 10 continue 20 continue do 40 j = 1 , mm + 1 do 30 i = 1 , nn + 1 sbxy ( 1 , i , j ) = bxy ( 1 , i + noffp , j + moffp ) sbxy ( 2 , i , j ) = bxy ( 2 , i + noffp , j + moffp ) sbxy ( 3 , i , j ) = bxy ( 3 , i + noffp , j + moffp ) 30 continue 40 continue do 46 j = 1 , mm + 1 do 42 i = 1 , nn + 1 spsit ( i , j ) = psit ( i + noffp , j + moffp ) 42 continue 46 continue ! clear counters do 50 j = 1 , 8 ncl ( j , k ) = 0 50 continue sum1 = 0.0d0 ! loop over particles in tile do 60 j = 1 , nppp ! find interpolation weights x = ppart ( 1 , j , k ) y = ppart ( 2 , j , k ) nn = x mm = y p6 = ppart ( 6 , j , k ) p7 = ppart ( 7 , j , k ) qtmh1 = qtmh / p7 qtmh2 = qtmh1 * p6 dxp = x - real ( nn ) dyp = y - real ( mm ) nn = nn - noffp + 1 mm = mm - mnoff amx = 1.0 - dxp amy = 1.0 - dyp ! find electric field dx = amx * sfxy ( 1 , nn , mm ) dy = amx * sfxy ( 2 , nn , mm ) dz = amx * spsit ( nn , mm ) dx = amy * ( dxp * sfxy ( 1 , nn + 1 , mm ) + dx ) dy = amy * ( dxp * sfxy ( 2 , nn + 1 , mm ) + dy ) dz = amy * ( dxp * spsit ( nn + 1 , mm ) + dz ) acx = amx * sfxy ( 1 , nn , mm + 1 ) acy = amx * sfxy ( 2 , nn , mm + 1 ) acz = amx * spsit ( nn , mm + 1 ) dx = dx + dyp * ( dxp * sfxy ( 1 , nn + 1 , mm + 1 ) + acx ) dy = dy + dyp * ( dxp * sfxy ( 2 , nn + 1 , mm + 1 ) + acy ) dz = dz + dyp * ( dxp * spsit ( nn + 1 , mm + 1 ) + acz ) dz = dz * idex ! find magnetic field ox = amx * sbxy ( 1 , nn , mm ) oy = amx * sbxy ( 2 , nn , mm ) oz = amx * sbxy ( 3 , nn , mm ) ox = amy * ( dxp * sbxy ( 1 , nn + 1 , mm ) + ox ) oy = amy * ( dxp * sbxy ( 2 , nn + 1 , mm ) + oy ) oz = amy * ( dxp * sbxy ( 3 , nn + 1 , mm ) + oz ) acx = amx * sbxy ( 1 , nn , mm + 1 ) acy = amx * sbxy ( 2 , nn , mm + 1 ) acz = amx * sbxy ( 3 , nn , mm + 1 ) ox = ox + dyp * ( dxp * sbxy ( 1 , nn + 1 , mm + 1 ) + acx ) oy = oy + dyp * ( dxp * sbxy ( 2 , nn + 1 , mm + 1 ) + acy ) oz = oz + dyp * ( dxp * sbxy ( 3 , nn + 1 , mm + 1 ) + acz ) ox = ox * dex oy = oy * dex ! calculate half impulse dx = qtmh2 * dx dy = qtmh2 * dy dz = qtmh2 * dz ! half acceleration acx = ppart ( 3 , j , k ) + dx acy = ppart ( 4 , j , k ) + dy acz = ppart ( 5 , j , k ) + dz ! find inverse gamma !      p2 = acx*acx + acy*acy + acz*acz !      gami = 1.0/sqrt(1.0 + p2*ci2) ! renormalize magnetic field !      qtmg = qtmh*gami ! time-centered kinetic energy !      sum1 = sum1 + gami*p2/(1.0 + gami) ! calculate cyclotron frequency omxt = qtmh1 * ox omyt = qtmh1 * oy omzt = qtmh1 * oz ! calculate rotation matrix omt = omxt * omxt + omyt * omyt + omzt * omzt anorm = 2.0 / ( 1.0 + omt ) omt = 0.5 * ( 1.0 - omt ) rot4 = omxt * omyt rot7 = omxt * omzt rot8 = omyt * omzt rot1 = omt + omxt * omxt rot5 = omt + omyt * omyt rot9 = omt + omzt * omzt rot2 = omzt + rot4 rot4 = - omzt + rot4 rot3 = - omyt + rot7 rot7 = omyt + rot7 rot6 = omxt + rot8 rot8 = - omxt + rot8 ! new momentum dx = ( rot1 * acx + rot2 * acy + rot3 * acz ) * anorm + dx dy = ( rot4 * acx + rot5 * acy + rot6 * acz ) * anorm + dy dz = ( rot7 * acx + rot8 * acy + rot9 * acz ) * anorm + dz ppart ( 3 , j , k ) = dx ppart ( 4 , j , k ) = dy ppart ( 5 , j , k ) = dz ! update inverse gamma dtc1 = dt / ( sqrt ( 1 + ( dx * dx + dy * dy + dz * dz ) * dex * dex ) - dz * dex ) !      p2 = dx*dx + dy*dy + dz*dz !      dtg = dtc/sqrt(1.0 + p2*ci2) ! new position dx = x + dx * dtc1 dy = y + dy * dtc1 ! find particles going out of bounds mm = 0 ! count how many particles are going in each direction in ncl ! save their address and destination in ihole ! use periodic boundary conditions and check for roundoff error ! mm = direction particle is going if ( dx . ge . edgerx ) then if ( dx . ge . anx ) dx = dx - anx mm = 2 else if ( dx . lt . edgelx ) then if ( dx . lt . 0.0 ) then dx = dx + anx if ( dx . lt . anx ) then mm = 1 else dx = 0.0 endif else mm = 1 endif endif if ( dy . ge . edgery ) then if ( dy . ge . any ) dy = dy - any mm = mm + 6 else if ( dy . lt . edgely ) then if ( dy . lt . 0.0 ) then dy = dy + any if ( dy . lt . any ) then mm = mm + 3 else dy = 0.0 endif else mm = mm + 3 endif endif ! set new position ppart ( 1 , j , k ) = dx ppart ( 2 , j , k ) = dy ! increment counters if ( mm . gt . 0 ) then ncl ( mm , k ) = ncl ( mm , k ) + 1 ih = ih + 1 if ( ih . le . ntmax ) then ihole ( 1 , ih + 1 , k ) = j ihole ( 2 , ih + 1 , k ) = mm else nh = 1 endif endif 60 continue sum2 = sum2 + sum1 ! set error and end of file flag ! ihole overflow if ( nh . gt . 0 ) then irc = ih ih = - ih endif ihole ( 1 , 1 , k ) = ih 70 continue !$OMP END PARALLEL DO ! normalize kinetic energy ek = ek + sum2 return end !----------------------------------------------------------------------- subroutine PPPORDER2LA ( ppart , ppbuff , sbufl , sbufr , kpic , ncl , ihole , & & ncll , nclr , noff , nyp , idimp , nppmx , nx , ny , mx , my , mx1 , myp1 , npbmx , ntmax , & & nbmax , irc ) ! this subroutine performs first part of a particle sort by x,y grid ! in tiles of mx, my ! linear interpolation, with periodic boundary conditions ! for distributed data, with 1d domain decomposition in y. ! tiles are assumed to be arranged in 2D linear memory ! this part of the algorithm has 3 steps.  first, one finds particles ! leaving tile and stores their number in each directon, location, and ! destination in ncl and ihole.  then, a prefix scan of ncl is performed ! and departing particles are buffered in ppbuff in direction order. ! finally, we buffer particles leaving the processor in sbufl and sbufr, ! and store particle number offsets in ncll and nclr. ! input: all except ppbuff, sbufl, sbufr, ncl, ihole, ncll, nclr, irc ! output: ppart, ppbuff, sbufl, sbufr, ncl, ihole, ncll, nclr, irc ! ppart(1,n,k) = position x of particle n in tile k ! ppart(2,n,k) = position y of particle n in tile k ! ppbuff(i,n,k) = i co-ordinate of particle n in tile k ! sbufl = buffer for particles being sent to lower processor ! sbufr = buffer for particles being sent to upper processor ! kpic(k) = number of particles in tile k ! ncl(i,k) = number of particles going to destination i, tile k ! ihole(1,:,k) = location of hole in array left by departing particle ! ihole(2,:,k) = direction destination of particle leaving hole ! all for tile k ! ihole(1,1,k) = ih, number of holes left (error, if negative) ! ncll = number offset being sent to lower processor ! nclr = number offset being sent to upper processor ! noff = lowermost global gridpoint in particle partition. ! nyp = number of primary (complete) gridpoints in particle partition ! idimp = size of phase space = 4 ! nppmx = maximum number of particles in tile ! nx/ny = system length in x/y direction ! mx/my = number of grids in sorting cell in x/y ! mx1 = (system length in x direction - 1)/mx + 1 ! myp1 = (partition length in y direction - 1)/my + 1 ! npbmx = size of buffer array ppbuff ! ntmax = size of hole array for particles leaving tiles ! nbmax =  size of buffers for passing particles between processors ! irc = maximum overflow, returned only if error occurs, when irc > 0 implicit none integer noff , nyp , idimp , nppmx , nx , ny , mx , my , mx1 , myp1 , npbmx integer ntmax , nbmax , irc real ppart , ppbuff , sbufl , sbufr integer kpic , ncl , ihole , ncll , nclr dimension ppart ( idimp , nppmx , mx1 * myp1 ) dimension ppbuff ( idimp , npbmx , mx1 * myp1 ) dimension sbufl ( idimp , nbmax ), sbufr ( idimp , nbmax ) dimension kpic ( mx1 * myp1 ), ncl ( 8 , mx1 * myp1 ) dimension ihole ( 2 , ntmax + 1 , mx1 * myp1 ) dimension ncll ( 3 , mx1 ), nclr ( 3 , mx1 ) ! local data integer mxyp1 , noffp , moffp , nppp integer i , j , k , ii , ih , nh , ist , nn , mm , isum , ip , j1 , kk real anx , any , edgelx , edgely , edgerx , edgery , dx , dy mxyp1 = mx1 * myp1 anx = real ( nx ) any = real ( ny ) ! find and count particles leaving tiles and determine destination ! update ppart, ihole, ncl ! loop over tiles !$OMP PARALLEL DO !$OMP& PRIVATE(j,k,noffp,moffp,nppp,nn,mm,ih,nh,ist,dx,dy,edgelx,edgely, !$OMP& edgerx,edgery) do 30 k = 1 , mxyp1 noffp = ( k - 1 ) / mx1 moffp = my * noffp noffp = mx * ( k - mx1 * noffp - 1 ) nppp = kpic ( k ) nn = min ( mx , nx - noffp ) mm = min ( my , nyp - moffp ) ih = 0 nh = 0 edgelx = noffp edgerx = noffp + nn edgely = noff + moffp edgery = noff + moffp + mm ! clear counters do 10 j = 1 , 8 ncl ( j , k ) = 0 10 continue ! loop over particles in tile do 20 j = 1 , nppp dx = ppart ( 1 , j , k ) dy = ppart ( 2 , j , k ) ! find particles going out of bounds ist = 0 ! count how many particles are going in each direction in ncl ! save their address and destination in ihole ! use periodic boundary conditions and check for roundoff error ! ist = direction particle is going if ( dx . ge . edgerx ) then if ( dx . ge . anx ) ppart ( 1 , j , k ) = dx - anx ist = 2 else if ( dx . lt . edgelx ) then if ( dx . lt . 0.0 ) then dx = dx + anx if ( dx . lt . anx ) then ist = 1 else dx = 0.0 endif ppart ( 1 , j , k ) = dx else ist = 1 endif endif if ( dy . ge . edgery ) then if ( dy . ge . any ) ppart ( 2 , j , k ) = dy - any ist = ist + 6 else if ( dy . lt . edgely ) then if ( dy . lt . 0.0 ) then dy = dy + any if ( dy . lt . any ) then ist = ist + 3 else dy = 0.0 endif ppart ( 2 , j , k ) = dy else ist = ist + 3 endif endif if ( ist . gt . 0 ) then ncl ( ist , k ) = ncl ( ist , k ) + 1 ih = ih + 1 if ( ih . le . ntmax ) then ihole ( 1 , ih + 1 , k ) = j ihole ( 2 , ih + 1 , k ) = ist else nh = 1 endif endif 20 continue ! set error and end of file flag if ( nh . gt . 0 ) then irc = ih ih = - ih endif ihole ( 1 , 1 , k ) = ih 30 continue !$OMP END PARALLEL DO ! ihole overflow if ( irc . gt . 0 ) return ! ! buffer particles that are leaving tile: update ppbuff, ncl ! loop over tiles !$OMP PARALLEL DO !$OMP& PRIVATE(i,j,k,isum,ist,nh,ip,j1,ii) do 70 k = 1 , mxyp1 ! find address offset for ordered ppbuff array isum = 0 do 40 j = 1 , 8 ist = ncl ( j , k ) ncl ( j , k ) = isum isum = isum + ist 40 continue nh = ihole ( 1 , 1 , k ) ip = 0 ! loop over particles leaving tile do 60 j = 1 , nh ! buffer particles that are leaving tile, in direction order j1 = ihole ( 1 , j + 1 , k ) ist = ihole ( 2 , j + 1 , k ) ii = ncl ( ist , k ) + 1 if ( ii . le . npbmx ) then do 50 i = 1 , idimp ppbuff ( i , ii , k ) = ppart ( i , j1 , k ) 50 continue else ip = 1 endif ncl ( ist , k ) = ii 60 continue ! set error if ( ip . gt . 0 ) irc = ncl ( 8 , k ) 70 continue !$OMP END PARALLEL DO ! ppbuff overflow if ( irc . gt . 0 ) return ! ! buffer particles and their number leaving the node: ! update sbufl, sbufr, ncll, nclr kk = mx1 * ( myp1 - 1 ) !$OMP PARALLEL DO PRIVATE(k) do 80 k = 1 , mx1 ncll ( 1 , k ) = ncl ( 5 , k ) - ncl ( 2 , k ) nclr ( 1 , k ) = ncl ( 8 , k + kk ) - ncl ( 5 , k + kk ) 80 continue !$OMP END PARALLEL DO ! perform prefix scan kk = 1 90 if ( kk . ge . mx1 ) go to 110 !$OMP PARALLEL DO PRIVATE(k,ii,nn,mm) do 100 k = 1 , mx1 ii = ( k - 1 ) / kk nn = kk * ii mm = 2 * nn + kk - 1 nn = nn + k + kk if ( nn . le . mx1 ) then ncll ( 1 , nn ) = ncll ( 1 , nn ) + ncll ( 1 , mm + 1 ) nclr ( 1 , nn ) = nclr ( 1 , nn ) + nclr ( 1 , mm + 1 ) endif 100 continue !$OMP END PARALLEL DO kk = kk + kk go to 90 110 kk = mx1 * ( myp1 - 1 ) !$OMP PARALLEL DO PRIVATE(i,j,k,ii,nn,mm) do 180 k = 1 , mx1 ii = ncl ( 5 , k ) - ncl ( 2 , k ) nn = ncll ( 1 , k ) - ii do 130 j = 1 , min ( ii , nbmax - nn ) do 120 i = 1 , idimp sbufl ( i , j + nn ) = ppbuff ( i , j + ncl ( 2 , k ), k ) 120 continue 130 continue do 140 i = 1 , 3 ncll ( i , k ) = ncl ( i + 2 , k ) - ncl ( 2 , k ) + nn 140 continue ii = ncl ( 8 , k + kk ) - ncl ( 5 , k + kk ) mm = nclr ( 1 , k ) - ii do 160 j = 1 , min ( ii , nbmax - mm ) do 150 i = 1 , idimp sbufr ( i , j + mm ) = ppbuff ( i , j + ncl ( 5 , k + kk ), k + kk ) 150 continue 160 continue do 170 i = 1 , 3 nclr ( i , k ) = ncl ( i + 5 , k + kk ) - ncl ( 5 , k + kk ) + mm 170 continue 180 continue !$OMP END PARALLEL DO ! sbufl or sbufr overflow ii = max ( ncll ( 3 , mx1 ), nclr ( 3 , mx1 )) if ( ii . gt . nbmax ) then irc = ii endif return end !----------------------------------------------------------------------- subroutine PPPORDERF2LA ( ppart , ppbuff , sbufl , sbufr , ncl , ihole , ncll , & & nclr , idimp , nppmx , mx1 , myp1 , npbmx , ntmax , nbmax , irc ) ! this subroutine performs first part of a particle sort by x,y grid ! in tiles of mx, my ! linear interpolation, with periodic boundary conditions ! for distributed data, with 1d domain decomposition in y. ! tiles are assumed to be arranged in 2D linear memory ! this part of the algorithm has 2 steps.  first, a prefix scan of ncl ! is performed and departing particles are buffered in ppbuff in ! direction order. then, we buffer particles leaving the processor in ! sbufl and sbufr, and store particle number offsets in ncll and nclr. ! it assumes that the number, location, and destination of particles ! leaving a tile have been previously stored in ncl and ihole by the ! PPGPPUSHF2L subroutine. ! input: all except ppbuff, sbufl, sbufr, ncll, nclr, irc ! output: ppart, ppbuff, sbufl, sbufr, ncl, ncll, nclr, irc ! ppart(1,n,k) = position x of particle n in tile k ! ppart(2,n,k) = position y of particle n in tile k ! ppbuff(i,n,k) = i co-ordinate of particle n in tile k ! sbufl = buffer for particles being sent to lower processor ! sbufr = buffer for particles being sent to upper processor ! ncl(i,k) = number of particles going to destination i, tile k ! ihole(1,:,k) = location of hole in array left by departing particle ! ihole(2,:,k) = direction destination of particle leaving hole ! all for tile k ! ihole(1,1,k) = ih, number of holes left (error, if negative) ! ncll = number offset being sent to lower processor ! nclr = number offset being sent to upper processor ! idimp = size of phase space = 4 ! nppmx = maximum number of particles in tile ! mx1 = (system length in x direction - 1)/mx + 1 ! myp1 = (partition length in y direction - 1)/my + 1 ! npbmx = size of buffer array ppbuff ! ntmax = size of hole array for particles leaving tiles ! nbmax =  size of buffers for passing particles between processors ! irc = maximum overflow, returned only if error occurs, when irc > 0 implicit none integer idimp , nppmx , mx1 , myp1 , npbmx , ntmax , nbmax , irc real ppart , ppbuff , sbufl , sbufr integer ncl , ihole , ncll , nclr dimension ppart ( idimp , nppmx , mx1 * myp1 ) dimension ppbuff ( idimp , npbmx , mx1 * myp1 ) dimension sbufl ( idimp , nbmax ), sbufr ( idimp , nbmax ) dimension ncl ( 8 , mx1 * myp1 ) dimension ihole ( 2 , ntmax + 1 , mx1 * myp1 ) dimension ncll ( 3 , mx1 ), nclr ( 3 , mx1 ) ! local data integer mxyp1 integer i , j , k , ii , nh , ist , nn , mm , isum , ip , j1 , kk mxyp1 = mx1 * myp1 ! buffer particles that are leaving tile: update ppbuff, ncl ! loop over tiles !$OMP PARALLEL DO !$OMP& PRIVATE(i,j,k,isum,ist,nh,ip,j1,ii) do 40 k = 1 , mxyp1 ! find address offset for ordered ppbuff array isum = 0 do 10 j = 1 , 8 ist = ncl ( j , k ) ncl ( j , k ) = isum isum = isum + ist 10 continue nh = ihole ( 1 , 1 , k ) ip = 0 ! loop over particles leaving tile do 30 j = 1 , nh ! buffer particles that are leaving tile, in direction order j1 = ihole ( 1 , j + 1 , k ) ist = ihole ( 2 , j + 1 , k ) ii = ncl ( ist , k ) + 1 if ( ii . le . npbmx ) then do 20 i = 1 , idimp ppbuff ( i , ii , k ) = ppart ( i , j1 , k ) 20 continue else ip = 1 endif ncl ( ist , k ) = ii 30 continue ! set error if ( ip . gt . 0 ) irc = ncl ( 8 , k ) 40 continue !$OMP END PARALLEL DO ! ppbuff overflow if ( irc . gt . 0 ) return ! ! buffer particles and their number leaving the node: ! update sbufl, sbufr, ncll, nclr kk = mx1 * ( myp1 - 1 ) !$OMP PARALLEL DO PRIVATE(k) do 50 k = 1 , mx1 ncll ( 1 , k ) = ncl ( 5 , k ) - ncl ( 2 , k ) nclr ( 1 , k ) = ncl ( 8 , k + kk ) - ncl ( 5 , k + kk ) 50 continue !$OMP END PARALLEL DO ! perform prefix scan kk = 1 60 if ( kk . ge . mx1 ) go to 80 !$OMP PARALLEL DO PRIVATE(k,ii,nn,mm) do 70 k = 1 , mx1 ii = ( k - 1 ) / kk nn = kk * ii mm = 2 * nn + kk - 1 nn = nn + k + kk if ( nn . le . mx1 ) then ncll ( 1 , nn ) = ncll ( 1 , nn ) + ncll ( 1 , mm + 1 ) nclr ( 1 , nn ) = nclr ( 1 , nn ) + nclr ( 1 , mm + 1 ) endif 70 continue !$OMP END PARALLEL DO kk = kk + kk go to 60 80 kk = mx1 * ( myp1 - 1 ) !$OMP PARALLEL DO PRIVATE(i,j,k,ii,nn,mm) do 150 k = 1 , mx1 ii = ncl ( 5 , k ) - ncl ( 2 , k ) nn = ncll ( 1 , k ) - ii do 100 j = 1 , min ( ii , nbmax - nn ) do 90 i = 1 , idimp sbufl ( i , j + nn ) = ppbuff ( i , j + ncl ( 2 , k ), k ) 90 continue 100 continue do 110 i = 1 , 3 ncll ( i , k ) = ncl ( i + 2 , k ) - ncl ( 2 , k ) + nn 110 continue ii = ncl ( 8 , k + kk ) - ncl ( 5 , k + kk ) mm = nclr ( 1 , k ) - ii do 130 j = 1 , min ( ii , nbmax - mm ) do 120 i = 1 , idimp sbufr ( i , j + mm ) = ppbuff ( i , j + ncl ( 5 , k + kk ), k + kk ) 120 continue 130 continue do 140 i = 1 , 3 nclr ( i , k ) = ncl ( i + 5 , k + kk ) - ncl ( 5 , k + kk ) + mm 140 continue 150 continue !$OMP END PARALLEL DO ! sbufl or sbufr overflow ii = max ( ncll ( 3 , mx1 ), nclr ( 3 , mx1 )) if ( ii . gt . nbmax ) then irc = ii endif return end !----------------------------------------------------------------------- subroutine PPPORDER2LB ( ppart , ppbuff , rbufl , rbufr , kpic , ncl , ihole , & & mcll , mclr , idimp , nppmx , mx1 , myp1 , npbmx , ntmax , nbmax , irc ) ! this subroutine performs second part of a particle sort by x,y grid ! in tiles of mx, my ! linear interpolation, with periodic boundary conditions ! for distributed data, with 1d domain decomposition in y. ! tiles are assumed to be arranged in 2D linear memory ! incoming particles from other tiles are copied from ppbuff, rbufl, and ! rbufr into ppart ! input: all except ppart, kpic, irc ! output: ppart, kpic, irc ! ppart(1,n,k) = position x of particle n in tile k ! ppart(2,n,k) = position y of particle n in tile k ! ppbuff(i,n,k) = i co-ordinate of particle n in tile k ! rbufl = buffer for particles being received from lower processor ! rbufr = buffer for particles being received from upper processor ! kpic(k) = number of particles in tile k ! ncl(i,k) = number of particles going to destination i, tile k ! ihole(1,:,k) = location of hole in array left by departing particle ! ihole(2,:,k) = direction destination of particle leaving hole ! all for tile k ! ihole(1,1,k) = ih, number of holes left (error, if negative) ! mcll = number offset being received from lower processor ! mclr = number offset being received from upper processor ! idimp = size of phase space = 4 ! nppmx = maximum number of particles in tile ! mx1 = (system length in x direction - 1)/mx + 1 ! myp1 = (partition length in y direction - 1)/my + 1 ! npbmx = size of buffer array ppbuff ! ntmax = size of hole array for particles leaving tiles ! nbmax =  size of buffers for passing particles between processors ! irc = maximum overflow, returned only if error occurs, when irc > 0 implicit none integer idimp , nppmx , mx1 , myp1 , npbmx integer ntmax , nbmax , irc real ppart , ppbuff , rbufl , rbufr integer kpic , ncl , ihole , mcll , mclr dimension ppart ( idimp , nppmx , mx1 * myp1 ) dimension ppbuff ( idimp , npbmx , mx1 * myp1 ) dimension rbufl ( idimp , nbmax ), rbufr ( idimp , nbmax ) dimension kpic ( mx1 * myp1 ), ncl ( 8 , mx1 * myp1 ) dimension ihole ( 2 , ntmax + 1 , mx1 * myp1 ) dimension mcll ( 3 , mx1 ), mclr ( 3 , mx1 ) ! local data integer mxyp1 , nppp , ncoff , noff , moff integer i , j , k , ii , kx , ky , ih , nh , ist integer ip , j1 , j2 , kxl , kxr , kk , kl , kr integer ks dimension ks ( 8 ) mxyp1 = mx1 * myp1 ! copy incoming particles from buffer into ppart: update ppart, kpic ! loop over tiles !$OMP PARALLEL DO !$OMP& PRIVATE(i,j,k,ii,kk,nppp,kx,ky,kl,kr,kxl,kxr,ih,nh,ncoff,noff, !$OMP& moff,ist,j1,j2,ip,ks) do 200 k = 1 , mxyp1 nppp = kpic ( k ) ky = ( k - 1 ) / mx1 + 1 ! loop over tiles in y kk = ( ky - 1 ) * mx1 ! find tile above kl = ( ky - 2 ) * mx1 ! find tile below kr = ky * mx1 ! loop over tiles in x, assume periodic boundary conditions kx = k - ( ky - 1 ) * mx1 kxl = kx - 1 if ( kxl . lt . 1 ) kxl = kxl + mx1 kxr = kx + 1 if ( kxr . gt . mx1 ) kxr = kxr - mx1 ! find tile number for different directions ks ( 1 ) = kxr + kk ks ( 2 ) = kxl + kk ks ( 3 ) = kx + kr ks ( 4 ) = kxr + kr ks ( 5 ) = kxl + kr ks ( 6 ) = kx + kl ks ( 7 ) = kxr + kl ks ( 8 ) = kxl + kl ! loop over directions nh = ihole ( 1 , 1 , k ) noff = 0 moff = 0 if ( ky . eq . 1 ) then if ( kx . gt . 1 ) noff = mcll ( 3 , kx - 1 ) endif if ( ky . eq . myp1 ) then if ( kx . gt . 1 ) moff = mclr ( 3 , kx - 1 ) endif ncoff = 0 ih = 0 ist = 0 j1 = 0 do 170 ii = 1 , 8 ! ip = number of particles coming from direction ii if ( ks ( ii ). le . 0 ) then if ( ii . gt . 6 ) noff = mcll ( ii - 6 , ks ( ii ) + mx1 ) ip = mcll ( ii - 5 , ks ( ii ) + mx1 ) - noff else if ( ks ( ii ). gt . mxyp1 ) then if ( ii . gt . 3 ) moff = mclr ( ii - 3 , ks ( ii ) - mxyp1 ) ip = mclr ( ii - 2 , ks ( ii ) - mxyp1 ) - moff else if ( ii . gt . 1 ) ncoff = ncl ( ii - 1 , ks ( ii )) ip = ncl ( ii , ks ( ii )) - ncoff endif do 160 j = 1 , ip ih = ih + 1 ! insert incoming particles into holes if ( ih . le . nh ) then j1 = ihole ( 1 , ih + 1 , k ) ! place overflow at end of array else j1 = nppp + 1 nppp = j1 endif if ( j1 . le . nppmx ) then if ( ks ( ii ). le . 0 ) then do 130 i = 1 , idimp ppart ( i , j1 , k ) = rbufl ( i , j + noff ) 130 continue else if ( ks ( ii ). gt . mxyp1 ) then do 140 i = 1 , idimp ppart ( i , j1 , k ) = rbufr ( i , j + moff ) 140 continue else do 150 i = 1 , idimp ppart ( i , j1 , k ) = ppbuff ( i , j + ncoff , ks ( ii )) 150 continue endif else ist = 1 endif 160 continue 170 continue ! set error if ( ist . gt . 0 ) irc = j1 ! fill up remaining holes in particle array with particles from bottom if ( ih . lt . nh ) then ip = nh - ih do 190 j = 1 , ip j1 = nppp - j + 1 j2 = ihole ( 1 , nh - j + 2 , k ) if ( j1 . gt . j2 ) then ! move particle only if it is below current hole do 180 i = 1 , idimp ppart ( i , j2 , k ) = ppart ( i , j1 , k ) 180 continue endif 190 continue nppp = nppp - ip endif kpic ( k ) = nppp 200 continue !$OMP END PARALLEL DO return end !----------------------------------------------------------------------- !-deposit psi on particles subroutine WPGPSIPOST2L_QP ( ppart , psi , kpic , qbm , noff , nyp , idimp , nppmx 1 , nx , mx , my , nxv , nypmx , mx1 , mxyp1 , dex ) implicit none integer noff , nyp , idimp , nppmx , nx , mx , my , nxv , nypmx integer mx1 , mxyp1 real dex , qbm real ppart , psi integer kpic dimension ppart ( idimp , nppmx , mxyp1 ) dimension psi ( nxv , nypmx ) dimension kpic ( mxyp1 ) ! local data !      integer MXV, MYV !      parameter(MXV=33,MYV=33) integer noffp , moffp , nppp integer mnoff , i , j , k , nn , mm real dxp , dyp , amx , amy , acx real dx , dy , dz real x , y , vx , vy , vz real spsi dimension spsi ( mx + 1 , my + 1 ) real dx2 !     dimension sfxy(3,mx+1,my+1), sbxy(3,mx+1,my+1) !     dimension scu(3,mx+1,my+1,), sdcu(3,mx+1,my+1), samu(4,mx+1,my+1) dx2 = dex * dex ! error if local array is too small !     if ((mx.ge.MXV).or.(my.ge.MYV)) return ! loop over tiles !$OMP PARALLEL DO !$OMP& PRIVATE(i,j,k,noffp,moffp,nppp,nn,mm,mnoff,x,y,vx,vy, !$OMP& dxp,dyp,amx,amy,dx,acx,spsi) do 120 k = 1 , mxyp1 noffp = ( k - 1 ) / mx1 moffp = my * noffp noffp = mx * ( k - mx1 * noffp - 1 ) nppp = kpic ( k ) mnoff = moffp + noff - 1 ! load local fields from global arrays nn = min ( mx , nx - noffp ) + 1 mm = min ( my , nyp - moffp ) + 1 do 20 j = 1 , mm do 10 i = 1 , nn spsi ( i , j ) = psi ( i + noffp , j + moffp ) 10 continue 20 continue ! loop over particles in tile do 70 j = 1 , nppp ! find interpolation weights x = ppart ( 1 , j , k ) y = ppart ( 2 , j , k ) vx = ppart ( 3 , j , k ) vy = ppart ( 4 , j , k ) nn = x mm = y dxp = x - real ( nn ) dyp = y - real ( mm ) nn = nn - noffp + 1 mm = mm - mnoff amx = 1.0 - dxp amy = 1.0 - dyp ! find electric field dx = amx * spsi ( nn , mm ) dx = amy * ( dxp * spsi ( nn + 1 , mm ) + dx ) acx = amx * spsi ( nn , mm + 1 ) dx = dx + dyp * ( dxp * spsi ( nn + 1 , mm + 1 ) + acx ) dx = - dx * dx2 * qbm ppart ( 7 , j , k ) = 1.0 + dx ppart ( 6 , j , k ) = dx + ( dx2 * ( vx ** 2 + vy ** 2 ) - dx ** 2 - 2. * dx ) / ( 2. * ( 1. + dx )) + 1.0 70 continue 120 continue !$OMP END PARALLEL DO return end !----------------------------------------------------------------------- subroutine PPPCOPYOUT2 ( part , ppart , kpic , npp , npmax , nppmx , idimp , mxyp1 & & , irc ) ! for 2d code, this subroutine copies segmented particle data ppart to ! the array part with original tiled layout ! spatial decomposition in y direction ! input: all except part, npp, irc, output: part, npp, irc ! part(i,j) = i-th coordinate for particle j in partition ! ppart(i,j,k) = i-th coordinate for particle j in partition in tile k ! kpic = number of particles per tile ! npp = number of particles in partition ! npmax = maximum number of particles in each partition ! nppmx = maximum number of particles in tile ! idimp = size of phase space = 5 ! mxyp1 = total number of tiles in partition ! irc = maximum overflow, returned only if error occurs, when irc > 0 implicit none integer npp , npmax , nppmx , idimp , mxyp1 , irc real part , ppart integer kpic dimension part ( idimp , npmax ), ppart ( idimp , nppmx , mxyp1 ) dimension kpic ( mxyp1 ) ! local data integer i , j , k , npoff , nppp , ne , ierr npoff = 0 ierr = 0 ! loop over tiles do 30 k = 1 , mxyp1 nppp = kpic ( k ) ne = nppp + npoff if ( ne . gt . npmax ) ierr = max ( ierr , ne - npmax ) if ( ierr . gt . 0 ) nppp = 0 ! loop over particles in tile do 20 j = 1 , nppp do 10 i = 1 , idimp part ( i , j + npoff ) = ppart ( i , j , k ) 10 continue 20 continue npoff = npoff + nppp 30 continue npp = npoff if ( ierr . gt . 0 ) irc = ierr return end !-----------------------------------------------------------------------","tags":"","loc":"sourcefile/part2d_lib77.f.html"},{"title":"fdist2d_class.f03 – QuickPIC","text":"This file depends on sourcefile~~fdist2d_class.f03~~EfferentGraph sourcefile~fdist2d_class.f03 fdist2d_class.f03 sourcefile~parallel_pipe_class.f03 parallel_pipe_class.f03 sourcefile~fdist2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~perrors_class.f03 perrors_class.f03 sourcefile~fdist2d_class.f03->sourcefile~perrors_class.f03 sourcefile~ufield2d_class.f03 ufield2d_class.f03 sourcefile~fdist2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~spect2d_class.f03 spect2d_class.f03 sourcefile~fdist2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~input_class.f03 input_class.f03 sourcefile~fdist2d_class.f03->sourcefile~input_class.f03 sourcefile~parallel_class.f03 parallel_class.f03 sourcefile~parallel_pipe_class.f03->sourcefile~parallel_class.f03 sourcefile~perrors_class.f03->sourcefile~parallel_class.f03 sourcefile~ufield2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~ufield2d_class.f03->sourcefile~perrors_class.f03 sourcefile~ufield2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~ufield2d_lib.f03 ufield2d_lib.f03 sourcefile~ufield2d_class.f03->sourcefile~ufield2d_lib.f03 sourcefile~hdf5io_class.f03 hdf5io_class.f03 sourcefile~ufield2d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~spect2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~spect2d_class.f03->sourcefile~perrors_class.f03 sourcefile~input_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~input_class.f03->sourcefile~perrors_class.f03 sourcefile~input_class.f03->sourcefile~parallel_class.f03 sourcefile~spect3d_class.f03 spect3d_class.f03 sourcefile~input_class.f03->sourcefile~spect3d_class.f03 sourcefile~hdf5io_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~hdf5io_class.f03->sourcefile~perrors_class.f03 sourcefile~spect3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~spect3d_class.f03->sourcefile~perrors_class.f03 sourcefile~spect3d_class.f03->sourcefile~spect2d_class.f03 var pansourcefilefdist2d_classf03EfferentGraph = svgPanZoom('#sourcefilefdist2d_classf03EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~fdist2d_class.f03~~AfferentGraph sourcefile~fdist2d_class.f03 fdist2d_class.f03 sourcefile~simulation_class.f03 simulation_class.f03 sourcefile~simulation_class.f03->sourcefile~fdist2d_class.f03 sourcefile~species2d_class.f03 species2d_class.f03 sourcefile~simulation_class.f03->sourcefile~species2d_class.f03 sourcefile~part2d_class.f03 part2d_class.f03 sourcefile~part2d_class.f03->sourcefile~fdist2d_class.f03 sourcefile~species2d_class.f03->sourcefile~fdist2d_class.f03 sourcefile~species2d_class.f03->sourcefile~part2d_class.f03 sourcefile~main.f03 main.f03 sourcefile~main.f03->sourcefile~simulation_class.f03 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules fdist2d_class Source Code fdist2d_class.f03 Source Code ! fdist2d class for QuickPIC Open Source 1.0 ! update: 04/18/2016 module fdist2d_class use perrors_class use parallel_pipe_class use spect2d_class use ufield2d_class use input_class implicit none private public :: fdist2d , fdist2d_000 type , abstract :: fdist2d private class ( spect2d ), pointer , public :: sp => null () class ( perrors ), pointer , public :: err => null () class ( parallel_pipe ), pointer , public :: p => null () ! ! ndprof = profile type integer :: npf , npmax contains generic :: new => init_fdist2d generic :: del => end_fdist2d generic :: dist => dist2d procedure ( ab_init_fdist2d ), deferred , private :: init_fdist2d procedure , private :: end_fdist2d procedure ( ab_dist2d ), deferred , private :: dist2d procedure :: getnpf , getnpmax end type fdist2d abstract interface ! subroutine ab_dist2d ( this , part2d , npp , fd , s ) import fdist2d import ufield2d implicit none class ( fdist2d ), intent ( inout ) :: this real , dimension (:,:), pointer , intent ( inout ) :: part2d integer , intent ( inout ) :: npp class ( ufield2d ), intent ( in ), pointer :: fd real , intent ( in ) :: s end subroutine ab_dist2d ! subroutine ab_init_fdist2d ( this , input , i ) import fdist2d import input_json implicit none class ( fdist2d ), intent ( inout ) :: this type ( input_json ), intent ( inout ), pointer :: input integer , intent ( in ) :: i end subroutine ab_init_fdist2d ! end interface type , extends ( fdist2d ) :: fdist2d_000 private ! xppc, yppc = particle per cell in x and y directions integer :: xppc , yppc real :: qm , den character ( len = :), allocatable :: long_prof real , dimension (:), allocatable :: s , fs contains procedure , private :: init_fdist2d => init_fdist2d_000 procedure , private :: dist2d => dist2d_000 end type fdist2d_000 character ( len = 10 ), save :: class = 'fdist2d:' character ( len = 128 ), save :: erstr contains ! function getnpf ( this ) implicit none class ( fdist2d ), intent ( in ) :: this integer :: getnpf getnpf = this % npf end function getnpf ! function getnpmax ( this ) implicit none class ( fdist2d ), intent ( in ) :: this integer :: getnpmax getnpmax = this % npmax end function getnpmax ! subroutine end_fdist2d ( this ) implicit none class ( fdist2d ), intent ( inout ) :: this character ( len = 18 ), save :: sname = 'end_fdist2d:' call this % err % werrfl2 ( class // sname // ' started' ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine end_fdist2d ! subroutine init_fdist2d_000 ( this , input , i ) implicit none class ( fdist2d_000 ), intent ( inout ) :: this type ( input_json ), intent ( inout ), pointer :: input integer , intent ( in ) :: i ! local data integer :: npf , xppc , yppc , npmax , indx , indy real :: qm , den character ( len = 20 ) :: sn , s1 character ( len = 18 ), save :: sname = 'init_fdist2d_000:' this % sp => input % sp this % err => input % err this % p => input % pp call this % err % werrfl2 ( class // sname // ' started' ) write ( sn , '(I3.3)' ) i s1 = 'species(' // trim ( sn ) // ')' call input % get ( 'simulation.indx' , indx ) call input % get ( 'simulation.indy' , indy ) call input % get ( trim ( s1 ) // '.profile' , npf ) call input % get ( trim ( s1 ) // '.ppc(1)' , xppc ) call input % get ( trim ( s1 ) // '.ppc(2)' , yppc ) call input % get ( trim ( s1 ) // '.q' , qm ) call input % get ( trim ( s1 ) // '.density' , den ) npmax = xppc * yppc * ( 2 ** indx ) * ( 2 ** indy ) / this % p % getlnvp () * 4 call input % get ( trim ( s1 ) // '.longitudinal_profile' , this % long_prof ) if ( trim ( this % long_prof ) == 'piecewise' ) then call input % get ( trim ( s1 ) // '.piecewise_density' , this % fs ) call input % get ( trim ( s1 ) // '.piecewise_s' , this % s ) end if this % npf = npf this % xppc = xppc this % yppc = yppc this % qm = qm this % den = den this % npmax = npmax call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine init_fdist2d_000 ! subroutine dist2d_000 ( this , part2d , npp , fd , s ) implicit none class ( fdist2d_000 ), intent ( inout ) :: this real , dimension (:,:), pointer , intent ( inout ) :: part2d integer , intent ( inout ) :: npp class ( ufield2d ), intent ( in ), pointer :: fd real , intent ( in ) :: s ! local data character ( len = 18 ), save :: sname = 'dist2d_000:' real , dimension (:,:), pointer :: pt => null () integer :: nps , nx , ny , noff , xppc , yppc , i , j integer :: ix , iy real :: qm , den_temp integer :: prof_l call this % err % werrfl2 ( class // sname // ' started' ) nx = fd % getnd1p (); ny = fd % getnd2p (); noff = fd % getnoff () xppc = this % xppc ; yppc = this % yppc den_temp = 1.0 if ( trim ( this % long_prof ) == 'piecewise' ) then prof_l = size ( this % fs ) if ( s < this % s ( 1 ) . or . s > this % s ( prof_l )) then write ( erstr , * ) 'The s is out of the bound!' call this % err % equit ( class // sname // erstr ) return end if do i = 2 , prof_l if ( this % s ( i ) < this % s ( i - 1 )) then write ( erstr , * ) 's is not monotonically increasing!' call this % err % equit ( class // sname // erstr ) return end if if ( s <= this % s ( i )) then den_temp = this % fs ( i - 1 ) + ( this % fs ( i ) - this % fs ( i - 1 )) / & &( this % s ( i ) - this % s ( i - 1 )) * ( s - this % s ( i - 1 )) exit end if end do end if qm = den_temp * this % den * this % qm / abs ( this % qm ) / real ( xppc ) / real ( yppc ) nps = 1 pt => part2d ! initialize the particle positions if ( noff < ny ) then do i = 2 , nx - 1 do j = 2 , ny do ix = 0 , xppc - 1 do iy = 0 , yppc - 1 pt ( 1 , nps ) = ( ix + 0.5 ) / xppc + i - 1 pt ( 2 , nps ) = ( iy + 0.5 ) / yppc + j - 1 + noff pt ( 3 , nps ) = 0.0 pt ( 4 , nps ) = 0.0 pt ( 5 , nps ) = 0.0 pt ( 6 , nps ) = 1.0 pt ( 7 , nps ) = 1.0 pt ( 8 , nps ) = qm nps = nps + 1 enddo enddo enddo enddo else if ( noff > ( nx - ny - 1 )) then do i = 2 , nx - 1 do j = 1 , ny - 1 do ix = 0 , xppc - 1 do iy = 0 , yppc - 1 pt ( 1 , nps ) = ( ix + 0.5 ) / xppc + i - 1 pt ( 2 , nps ) = ( iy + 0.5 ) / yppc + j - 1 + noff pt ( 3 , nps ) = 0.0 pt ( 4 , nps ) = 0.0 pt ( 5 , nps ) = 0.0 pt ( 6 , nps ) = 1.0 pt ( 7 , nps ) = 1.0 pt ( 8 , nps ) = qm nps = nps + 1 enddo enddo enddo enddo else do i = 2 , nx - 1 do j = 1 , ny do ix = 0 , xppc - 1 do iy = 0 , yppc - 1 pt ( 1 , nps ) = ( ix + 0.5 ) / xppc + i - 1 pt ( 2 , nps ) = ( iy + 0.5 ) / yppc + j - 1 + noff pt ( 3 , nps ) = 0.0 pt ( 4 , nps ) = 0.0 pt ( 5 , nps ) = 0.0 pt ( 6 , nps ) = 1.0 pt ( 7 , nps ) = 1.0 pt ( 8 , nps ) = qm nps = nps + 1 enddo enddo enddo enddo endif npp = nps - 1 call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine dist2d_000 ! end module fdist2d_class","tags":"","loc":"sourcefile/fdist2d_class.f03.html"},{"title":"hdf5io_class.f03 – QuickPIC","text":"This file depends on sourcefile~~hdf5io_class.f03~~EfferentGraph sourcefile~hdf5io_class.f03 hdf5io_class.f03 sourcefile~parallel_pipe_class.f03 parallel_pipe_class.f03 sourcefile~hdf5io_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~perrors_class.f03 perrors_class.f03 sourcefile~hdf5io_class.f03->sourcefile~perrors_class.f03 sourcefile~parallel_class.f03 parallel_class.f03 sourcefile~parallel_pipe_class.f03->sourcefile~parallel_class.f03 sourcefile~perrors_class.f03->sourcefile~parallel_class.f03 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~hdf5io_class.f03~~AfferentGraph sourcefile~hdf5io_class.f03 hdf5io_class.f03 sourcefile~field3d_class.f03 field3d_class.f03 sourcefile~field3d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~ufield3d_class.f03 ufield3d_class.f03 sourcefile~field3d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~ufield3d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~ufield2d_class.f03 ufield2d_class.f03 sourcefile~ufield3d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~part2d_class.f03 part2d_class.f03 sourcefile~part2d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~part2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~fdist2d_class.f03 fdist2d_class.f03 sourcefile~part2d_class.f03->sourcefile~fdist2d_class.f03 sourcefile~part3d_class.f03 part3d_class.f03 sourcefile~part3d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~part3d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~fdist3d_class.f03 fdist3d_class.f03 sourcefile~part3d_class.f03->sourcefile~fdist3d_class.f03 sourcefile~simulation_class.f03 simulation_class.f03 sourcefile~simulation_class.f03->sourcefile~hdf5io_class.f03 sourcefile~simulation_class.f03->sourcefile~field3d_class.f03 sourcefile~field2d_class.f03 field2d_class.f03 sourcefile~simulation_class.f03->sourcefile~field2d_class.f03 sourcefile~species2d_class.f03 species2d_class.f03 sourcefile~simulation_class.f03->sourcefile~species2d_class.f03 sourcefile~beam3d_class.f03 beam3d_class.f03 sourcefile~simulation_class.f03->sourcefile~beam3d_class.f03 sourcefile~simulation_class.f03->sourcefile~fdist3d_class.f03 sourcefile~simulation_class.f03->sourcefile~fdist2d_class.f03 sourcefile~ufield2d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~field2d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~field2d_class.f03->sourcefile~field3d_class.f03 sourcefile~field2d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~field2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~fpois2d_class.f03 fpois2d_class.f03 sourcefile~field2d_class.f03->sourcefile~fpois2d_class.f03 sourcefile~fft2d_class.f03 fft2d_class.f03 sourcefile~field2d_class.f03->sourcefile~fft2d_class.f03 sourcefile~species2d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~species2d_class.f03->sourcefile~field3d_class.f03 sourcefile~species2d_class.f03->sourcefile~part2d_class.f03 sourcefile~species2d_class.f03->sourcefile~field2d_class.f03 sourcefile~species2d_class.f03->sourcefile~fdist2d_class.f03 sourcefile~beam3d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~beam3d_class.f03->sourcefile~field3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~part3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~field2d_class.f03 sourcefile~beam3d_class.f03->sourcefile~fdist3d_class.f03 sourcefile~fdist3d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~main.f03 main.f03 sourcefile~main.f03->sourcefile~simulation_class.f03 sourcefile~fpois2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~fdist2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~fft2d_class.f03->sourcefile~ufield2d_class.f03 var pansourcefilehdf5io_classf03AfferentGraph = svgPanZoom('#sourcefilehdf5io_classf03AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules hdf5io_class Source Code hdf5io_class.f03 Source Code ! hdf5io module for QuickPIC Open Source 1.0 ! update: 04/18/2016 module hdf5io_class use perrors_class use parallel_pipe_class use HDF5 use mpi implicit none private public :: hdf5file , pwfield , pwfield_pipe , wfield_pipe , pwpart_pipe , pwpart ,& & wpart , rpart type hdf5file private character ( len = 100 ) :: filename = 'file.h5' , timeunits = 'a.u.' ,& & dataname = 'Data' , units = 'a.u.' , label = 'Data' character ( len = 100 ) :: ty = 'grid' integer :: n = 1 , rank = 2 real :: t = 1.0 , dt = 1.0 character ( len = 100 ), dimension ( 3 ) :: axisname = ( / 'x1' , 'x2' , 'x3' / ),& & axislabel = ( / 'x1' , 'x2' , 'x3' / ), axisunits = ( / 'a.u.' , 'a.u.' , 'a.u.' / ) real , dimension ( 3 ) :: axismax = ( / 1.0 , 1.0 , 1.0 / ), axismin = ( / 0.0 , 0.0 , 0.0 / ) contains generic :: new => init_hdf5file procedure , private :: init_hdf5file end type interface add_h5_atribute module procedure add_h5_atribute_str module procedure add_h5_atribute_str_v1 module procedure add_h5_atribute_single module procedure add_h5_atribute_v1_single module procedure add_h5_atribute_int module procedure add_h5_atribute_v1_int end interface interface pwfield module procedure pwfield_3d module procedure pwfield_2d end interface interface pwfield_pipe module procedure pwfield_3d_pipe module procedure pwfield_2d_pipe end interface interface wfield_pipe module procedure wfield_2d_pipe end interface interface pwpart_pipe module procedure pwpart_3d_pipe end interface interface pwpart module procedure pwpart_2d end interface contains subroutine init_hdf5file ( this , filename , timeunits , ty , n , t , dt , axisname ,& & axislabel , axisunits , axismax , axismin , dataname , units , label , rank ) implicit none class ( hdf5file ), intent ( inout ) :: this character ( len =* ), intent ( in ), optional :: filename , timeunits character ( len =* ), intent ( in ), optional :: ty , dataname , units , label integer , intent ( in ), optional :: n , rank real , intent ( in ), optional :: t , dt character ( len =* ), dimension ( 3 ), intent ( in ), optional :: axisname , & & axislabel , axisunits real , dimension ( 3 ), intent ( in ), optional :: axismax , axismin if ( present ( filename )) then this % filename = filename end if if ( present ( dataname )) then this % dataname = dataname end if if ( present ( units )) then this % units = units end if if ( present ( label )) then this % label = label end if if ( present ( timeunits )) then this % timeunits = timeunits end if if ( present ( ty )) then this % ty = ty end if if ( present ( n )) then this % n = n end if if ( present ( rank )) then this % rank = rank end if if ( present ( t )) then this % t = t end if if ( present ( dt )) then this % dt = dt end if if ( present ( axisname )) then this % axisname = axisname end if if ( present ( axislabel )) then this % axislabel = axislabel end if if ( present ( axisunits )) then this % axisunits = axisunits end if if ( present ( axismax )) then this % axismax = axismax end if if ( present ( axismin )) then this % axismin = axismin end if end subroutine init_hdf5file ! subroutine add_h5_atribute_str ( objID , name , attribute ) implicit none integer ( hid_t ), intent ( in ) :: objID character ( len = * ), intent ( in ) :: name character ( len = * ), intent ( in ) :: attribute integer ( hid_t ) :: dataspaceID , typeID , attrID integer ( hsize_t ), dimension ( 1 ) :: dims integer ( size_t ) :: size integer :: ierr dims ( 1 ) = 1 call h5screate_simple_f ( 1 , dims , dataspaceID , ierr ) call h5tcopy_f ( H5T_NATIVE_CHARACTER , typeID , ierr ) size = len ( attribute ) call h5tset_size_f ( typeID , size , ierr ) call h5acreate_f ( objID , name , typeID , dataspaceID , attrID , ierr ) call h5awrite_f ( attrID , typeID , attribute , dims , ierr ) call h5aclose_f ( attrID , ierr ) call h5tclose_f ( typeID , ierr ) call h5sclose_f ( dataspaceID , ierr ) end subroutine add_h5_atribute_str ! subroutine add_h5_atribute_str_v1 ( objID , name , attribute ) implicit none integer ( hid_t ), intent ( in ) :: objID character ( len = * ), intent ( in ) :: name character ( len = * ), dimension (:), intent ( in ) :: attribute integer ( hid_t ) :: dataspaceID , typeID , attrID integer ( hsize_t ), dimension ( 1 ) :: dims integer ( size_t ) :: maxlen integer :: i , ierr dims ( 1 ) = size ( attribute ) call h5screate_simple_f ( 1 , dims , dataspaceID , ierr ) maxlen = 0 do i = 1 , size ( attribute ) - 1 if ( len ( attribute ( i )) > maxlen ) maxlen = len ( attribute ( i )) enddo call h5tcopy_f ( H5T_NATIVE_CHARACTER , typeID , ierr ) call h5tset_size_f ( typeID , maxlen , ierr ) call h5acreate_f ( objID , name , typeID , dataspaceID , attrID , ierr ) call h5awrite_f ( attrID , typeID , attribute , dims , ierr ) call h5aclose_f ( attrID , ierr ) call h5tclose_f ( typeID , ierr ) call h5sclose_f ( dataspaceID , ierr ) end subroutine add_h5_atribute_str_v1 ! subroutine add_h5_atribute_single ( objID , name , attribute ) implicit none integer ( hid_t ), intent ( in ) :: objID character ( len = * ), intent ( in ) :: name real , intent ( in ) :: attribute integer ( hid_t ) :: dataspaceID , attrID integer ( hid_t ) :: d_float integer ( hsize_t ), dimension ( 1 ) :: dims integer :: ierr d_float = detect_precision () dims ( 1 ) = 1 call h5screate_simple_f ( 1 , dims , dataspaceID , ierr ) call h5acreate_f ( objID , name , d_float , dataspaceID , attrID , ierr ) call h5awrite_f ( attrID , d_float , attribute , dims , ierr ) call h5aclose_f ( attrID , ierr ) call h5sclose_f ( dataspaceID , ierr ) end subroutine add_h5_atribute_single ! subroutine add_h5_atribute_v1_single ( objID , name , attribute ) implicit none integer ( hid_t ), intent ( in ) :: objID character ( len = * ), intent ( in ) :: name real , dimension (:), intent ( in ) :: attribute integer ( hid_t ) :: dataspaceID , attrID integer ( hid_t ) :: d_float integer ( hsize_t ), dimension ( 1 ) :: dims integer :: ierr d_float = detect_precision () dims ( 1 ) = size ( attribute ) call h5screate_simple_f ( 1 , dims , dataspaceID , ierr ) call h5acreate_f ( objID , name , d_float , dataspaceID , attrID , ierr ) call h5awrite_f ( attrID , d_float , attribute , dims , ierr ) call h5aclose_f ( attrID , ierr ) call h5sclose_f ( dataspaceID , ierr ) end subroutine add_h5_atribute_v1_single ! subroutine add_h5_atribute_int ( objID , name , attribute ) implicit none integer ( hid_t ), intent ( in ) :: objID character ( len = * ), intent ( in ) :: name integer , intent ( in ) :: attribute integer ( hid_t ) :: dataspaceID , attrID integer ( hsize_t ), dimension ( 1 ) :: dims integer :: ierr dims ( 1 ) = 1 call h5screate_simple_f ( 1 , dims , dataspaceID , ierr ) call h5acreate_f ( objID , name , H5T_NATIVE_INTEGER , dataspaceID ,& & attrID , ierr ) call h5awrite_f ( attrID , H5T_NATIVE_INTEGER , attribute , dims , ierr ) call h5aclose_f ( attrID , ierr ) call h5sclose_f ( dataspaceID , ierr ) end subroutine add_h5_atribute_int ! subroutine add_h5_atribute_v1_int ( objID , name , attribute ) implicit none integer ( hid_t ), intent ( in ) :: objID character ( len = * ), intent ( in ) :: name integer , dimension (:), intent ( in ) :: attribute integer ( hid_t ) :: dataspaceID , attrID integer ( hsize_t ), dimension ( 1 ) :: dims integer :: ierr dims ( 1 ) = size ( attribute ) call h5screate_simple_f ( 1 , dims , dataspaceID , ierr ) call h5acreate_f ( objID , name , H5T_NATIVE_INTEGER , dataspaceID ,& & attrID , ierr ) call h5awrite_f ( attrID , H5T_NATIVE_INTEGER , attribute , dims , ierr ) call h5aclose_f ( attrID , ierr ) call h5sclose_f ( dataspaceID , ierr ) end subroutine add_h5_atribute_v1_int ! subroutine wrattr_file ( this , file_id , xferID ) implicit none class ( hdf5file ), intent ( in ) :: this integer ( hid_t ), intent ( in ) :: file_id ! local data integer ( hid_t ) :: rootID , aid , dspace_id , dset_id , treal , xferID integer ( hsize_t ), dimension ( 1 ) :: dims integer , parameter :: zero = ichar ( '0' ) integer :: i , ierr treal = detect_precision () call h5gopen_f ( file_id , '/' , rootID , ierr ) call add_h5_atribute ( rootID , 'NAME' , this % dataname ) call add_h5_atribute ( rootID , 'TYPE' , this % ty ) call add_h5_atribute ( rootID , 'TIME' , this % t ) call add_h5_atribute ( rootID , 'ITER' , this % n ) call add_h5_atribute ( rootID , 'DT' , this % dt ) call add_h5_atribute ( rootID , 'TIME UNITS' , this % timeunits ) if ( this % ty == 'grid' ) then call h5gcreate_f ( rootID , 'AXIS' , aid , ierr ) dims ( 1 ) = 2 call h5screate_simple_f ( 1 , dims , dspace_id , ierr ) do i = 1 , this % rank call h5dcreate_f ( aid , 'AXIS' // char ( zero + i ), treal , dspace_id ,& & dset_id , ierr ) call add_h5_atribute ( dset_id , 'TYPE' , 'linear' ) call add_h5_atribute ( dset_id , 'UNITS' , trim ( this % axisunits ( i ))) call add_h5_atribute ( dset_id , 'NAME' , trim ( this % axisname ( i ))) call add_h5_atribute ( dset_id , 'LONG_NAME' , trim ( this % axislabel ( i ))) call h5dwrite_f ( dset_id , treal , ( / this % axismin ( i ), this % axismax ( i ) / ),& & dims , ierr , xfer_prp = xferID ) call h5dclose_f ( dset_id , ierr ) enddo call h5sclose_f ( dspace_id , ierr ) call h5gclose_f ( aid , ierr ) endif call h5gclose_f ( rootID , ierr ) end subroutine wrattr_file ! subroutine wrattr_dataset ( this , dset_id , unit , name ) implicit none class ( hdf5file ), intent ( in ) :: this integer ( hid_t ), intent ( in ) :: dset_id character ( len =* ), intent ( in ), optional :: unit , name if ( present ( unit )) then call add_h5_atribute ( dset_id , 'UNITS' , unit ) else call add_h5_atribute ( dset_id , 'UNITS' , this % units ) endif if ( present ( name )) then call add_h5_atribute ( dset_id , 'LONG_NAME' , name ) else call add_h5_atribute ( dset_id , 'LONG_NAME' , this % label ) endif end subroutine wrattr_dataset ! subroutine pwfield_3d ( pp , perr , file , fd , gs , ls , noff , ierr ) implicit none class ( perrors ), intent ( in ), pointer :: perr class ( parallel_pipe ), intent ( in ), pointer :: pp class ( hdf5file ), intent ( in ) :: file real , dimension (:,:,:), intent ( in ) :: fd integer , dimension ( 3 ), intent ( in ) :: gs , ls integer , dimension ( 2 ), intent ( in ) :: noff integer , intent ( inout ) :: ierr ! local data integer ( hid_t ) :: treal , flplID , xferID , dcplID , memspaceID integer ( hid_t ) :: file_id , rootID , dset_id , dspace_id integer ( hsize_t ), dimension ( 3 ) :: start integer ( hsize_t ), dimension ( 3 ) :: gsize , lsize integer ( hsize_t ), dimension ( 2 ) :: lnoff integer :: info character ( len = :), allocatable :: filename character ( len = 8 ) :: st allocate ( character ( len ( trim ( file % filename )) + len ( trim ( file % dataname )) + 11 ) :: filename ) write ( st , '(I8.8)' ) file % n filename = trim ( file % filename ) // trim ( file % dataname ) // '_' // st // '.h5' ierr = 0 gsize = gs lsize = ls lnoff = noff call h5open_f ( ierr ) treal = detect_precision () call h5pcreate_f ( H5P_FILE_ACCESS_F , flplID , ierr ) call h5pcreate_f ( H5P_DATASET_CREATE_F , dcplID , ierr ) call h5pcreate_f ( H5P_DATASET_XFER_F , xferID , ierr ) info = MPI_INFO_NULL call h5pset_fapl_mpio_f ( flplID , pp % getlgrp (), info , ierr ) call h5pset_dxpl_mpio_f ( xferID , H5FD_MPIO_COLLECTIVE_F , ierr ) call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , file_id , ierr ,& & access_prp = flplID ) call wrattr_file ( file , file_id , xferID ) call h5screate_simple_f ( 3 , gsize , dspace_id , ierr ) call h5screate_simple_f ( 3 , lsize , memspaceID , ierr ) call h5gopen_f ( file_id , '/' , rootID , ierr ) call h5dcreate_f ( rootID , file % dataname , treal , dspace_id , dset_id ,& & ierr , dcplID ) start ( 1 ) = 0 start ( 2 ) = lnoff ( 1 ) start ( 3 ) = lnoff ( 2 ) call h5sselect_hyperslab_f ( dspace_id , H5S_SELECT_SET_F , start , lsize ,& & ierr ) call h5dwrite_f ( dset_id , treal , fd ( 1 : lsize ( 1 ), 1 : lsize ( 2 ), 1 : lsize ( 3 )),& & lsize , ierr , memspaceID , dspace_id , xfer_prp = xferID ) call wrattr_dataset ( file , dset_id ) call h5sclose_f ( memspaceID , ierr ) call h5sclose_f ( dspace_id , ierr ) call h5pclose_f ( xferID , ierr ) call h5pclose_f ( dcplID , ierr ) call h5pclose_f ( flplID , ierr ) call h5gclose_f ( rootID , ierr ) call h5dclose_f ( dset_id , ierr ) call h5fclose_f ( file_id , ierr ) call h5close_f ( ierr ) end subroutine pwfield_3d ! subroutine pwfield_2d ( pp , perr , file , fd , gs , ls , noff , ierr ) implicit none class ( perrors ), intent ( in ), pointer :: perr class ( parallel_pipe ), intent ( in ), pointer :: pp class ( hdf5file ), intent ( in ) :: file real , dimension (:,:), intent ( in ) :: fd integer , dimension ( 2 ), intent ( in ) :: gs , ls integer , intent ( in ) :: noff integer , intent ( inout ) :: ierr ! local data integer ( hid_t ) :: treal , flplID , xferID , dcplID , memspaceID integer ( hid_t ) :: file_id , rootID , dset_id , dspace_id integer ( hsize_t ), dimension ( 2 ) :: start integer ( hsize_t ), dimension ( 2 ) :: gsize , lsize integer ( hsize_t ) :: lnoff integer :: info character ( len = :), allocatable :: filename character ( len = 8 ) :: st allocate ( character ( len ( trim ( file % filename )) + len ( trim ( file % dataname )) + 11 ) :: filename ) write ( st , '(I8.8)' ) file % n filename = trim ( file % filename ) // trim ( file % dataname ) // '_' // st // '.h5' ierr = 0 gsize = gs lsize = ls lnoff = noff call h5open_f ( ierr ) treal = detect_precision () call h5pcreate_f ( H5P_FILE_ACCESS_F , flplID , ierr ) call h5pcreate_f ( H5P_DATASET_CREATE_F , dcplID , ierr ) call h5pcreate_f ( H5P_DATASET_XFER_F , xferID , ierr ) info = MPI_INFO_NULL call h5pset_fapl_mpio_f ( flplID , pp % getlgrp (), info , ierr ) call h5pset_dxpl_mpio_f ( xferID , H5FD_MPIO_COLLECTIVE_F , ierr ) call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , file_id , ierr ,& & access_prp = flplID ) call wrattr_file ( file , file_id , xferID ) call h5screate_simple_f ( 2 , gsize , dspace_id , ierr ) call h5screate_simple_f ( 2 , lsize , memspaceID , ierr ) call h5gopen_f ( file_id , '/' , rootID , ierr ) call h5dcreate_f ( rootID , file % dataname , treal , dspace_id , dset_id ,& & ierr , dcplID ) start ( 1 ) = 0 start ( 2 ) = lnoff call h5sselect_hyperslab_f ( dspace_id , H5S_SELECT_SET_F , start , lsize ,& & ierr ) call h5dwrite_f ( dset_id , treal , fd ( 1 : lsize ( 1 ), 1 : lsize ( 2 )), lsize , ierr ,& & memspaceID , dspace_id , xfer_prp = xferID ) call wrattr_dataset ( file , dset_id ) call h5sclose_f ( memspaceID , ierr ) call h5sclose_f ( dspace_id , ierr ) call h5pclose_f ( xferID , ierr ) call h5pclose_f ( dcplID , ierr ) call h5pclose_f ( flplID , ierr ) call h5gclose_f ( rootID , ierr ) call h5dclose_f ( dset_id , ierr ) call h5fclose_f ( file_id , ierr ) call h5close_f ( ierr ) end subroutine pwfield_2d ! subroutine pwfield_3d_pipe ( pp , perr , file , fd , gs , ls , noff , rtag ,& & stag , id , ierr ) implicit none class ( perrors ), intent ( in ), pointer :: perr class ( parallel_pipe ), intent ( in ), pointer :: pp class ( hdf5file ), intent ( in ) :: file real , dimension (:,:,:), intent ( in ) :: fd integer , dimension ( 3 ), intent ( in ) :: gs , ls integer , dimension ( 2 ), intent ( in ) :: noff integer , intent ( in ) :: rtag , stag integer , intent ( inout ) :: id , ierr ! local data integer ( hid_t ) :: treal , flplID , xferID , dcplID , memspaceID integer ( hid_t ) :: file_id , rootID , dset_id , dspace_id , aid integer ( hid_t ) :: tstring integer ( hsize_t ), dimension ( 3 ) :: gsize , lsize integer ( hsize_t ), dimension ( 2 ) :: lnoff character ( len = 80 ) :: string integer ( hsize_t ) :: lstr integer ( hsize_t ), dimension ( 3 ) :: start integer :: ori , des , nvyp , stageid , mid , message , info integer , dimension ( 10 ) :: istat integer ( hsize_t ), dimension ( 1 ) :: dims character ( len = :), allocatable :: filename character ( len = 8 ) :: st allocate ( character ( len ( trim ( file % filename )) + len ( trim ( file % dataname )) + 11 ) :: filename ) write ( st , '(I8.8)' ) file % n filename = trim ( file % filename ) // trim ( file % dataname ) // '_' // st // '.h5' ierr = 0 gsize = gs lsize = ls lnoff = noff nvyp = pp % getlnvp () ori = pp % getkstrt () - nvyp - 1 des = pp % getkstrt () + nvyp - 1 dims = 1 if ( ori >= 0 ) then call MPI_IRECV ( message , 1 , pp % getmint (), ori , rtag , pp % getlworld (),& & mid , ierr ) call MPI_WAIT ( mid , istat , ierr ) endif call h5open_f ( ierr ) treal = detect_precision () call h5pcreate_f ( H5P_FILE_ACCESS_F , flplID , ierr ) call h5pcreate_f ( H5P_DATASET_CREATE_F , dcplID , ierr ) call h5pcreate_f ( H5P_DATASET_XFER_F , xferID , ierr ) info = MPI_INFO_NULL call h5pset_fapl_mpio_f ( flplID , pp % getlgrp (), info , ierr ) call h5pset_dxpl_mpio_f ( xferID , H5FD_MPIO_COLLECTIVE_F , ierr ) if ( ori >= 0 ) then call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , ierr ,& & access_prp = flplID ) call h5aopen_by_name_f ( file_id , \"/\" , \"NAME\" , aid , ierr ) lstr = len ( string ) call h5tcopy_f ( H5T_NATIVE_CHARACTER , tstring , ierr ) call h5tset_size_f ( tstring , lstr , ierr ) call h5aread_f ( aid , tstring , string , dims , ierr ) call h5dopen_f ( file_id , string , dset_id , ierr , H5P_DEFAULT_F ) call h5aclose_f ( aid , ierr ) call h5tclose_f ( tstring , ierr ) else call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , file_id , ierr ,& & access_prp = flplID ) call wrattr_file ( file , file_id , xferID ) endif call h5screate_simple_f ( 3 , gsize , dspace_id , ierr ) call h5screate_simple_f ( 3 , lsize , memspaceID , ierr ) call h5gopen_f ( file_id , '/' , rootID , ierr ) if ( ori < 0 ) then call h5dcreate_f ( rootID , file % dataname , treal , dspace_id , dset_id ,& & ierr , dcplID ) call wrattr_dataset ( file , dset_id ) endif start ( 1 ) = 0 start ( 2 ) = lnoff ( 1 ) start ( 3 ) = lnoff ( 2 ) call h5sselect_hyperslab_f ( dspace_id , H5S_SELECT_SET_F , start , lsize ,& & ierr ) call h5dwrite_f ( dset_id , treal , fd ( 1 : lsize ( 1 ), 1 : lsize ( 2 ), 1 : lsize ( 3 )),& & lsize , ierr , memspaceID , dspace_id , xfer_prp = xferID ) call h5sclose_f ( memspaceID , ierr ) call h5sclose_f ( dspace_id , ierr ) call h5pclose_f ( xferID , ierr ) call h5pclose_f ( dcplID , ierr ) call h5pclose_f ( flplID , ierr ) call h5gclose_f ( rootID , ierr ) call h5dclose_f ( dset_id , ierr ) call h5fclose_f ( file_id , ierr ) call h5close_f ( ierr ) if ( des < pp % getnvp ()) then call MPI_ISEND ( message , 1 , pp % getmint (), des , stag , pp % getlworld (),& & id , ierr ) else id = MPI_REQUEST_NULL endif end subroutine pwfield_3d_pipe ! subroutine pwfield_2d_pipe ( pp , perr , file , fd , gs , ls , noff , rtag ,& & stag , id , ierr ) implicit none class ( perrors ), intent ( in ), pointer :: perr class ( parallel_pipe ), intent ( in ), pointer :: pp class ( hdf5file ), intent ( in ) :: file real , dimension (:,:), intent ( in ) :: fd integer , dimension ( 2 ), intent ( in ) :: gs , ls integer , dimension ( 2 ), intent ( in ) :: noff integer , intent ( in ) :: rtag , stag integer , intent ( inout ) :: id , ierr ! local data integer ( hid_t ) :: treal , flplID , xferID , dcplID , memspaceID integer ( hid_t ) :: file_id , rootID , dset_id , dspace_id , aid integer ( hid_t ) :: tstring integer ( hsize_t ), dimension ( 2 ) :: gsize , lsize integer ( hsize_t ), dimension ( 2 ) :: lnoff character ( len = 80 ) :: string integer ( hsize_t ) :: lstr integer ( hsize_t ), dimension ( 2 ) :: start integer :: ori , des , nvyp , stageid , mid , message , info integer , dimension ( 10 ) :: istat integer ( hsize_t ), dimension ( 1 ) :: dims character ( len = :), allocatable :: filename character ( len = 8 ) :: st allocate ( character ( len ( trim ( file % filename )) + len ( trim ( file % dataname )) + 11 ) :: filename ) write ( st , '(I8.8)' ) file % n filename = trim ( file % filename ) // trim ( file % dataname ) // '_' // st // '.h5' ierr = 0 gsize = gs lsize = ls lnoff = noff nvyp = pp % getlnvp () ori = pp % getkstrt () - nvyp - 1 des = pp % getkstrt () + nvyp - 1 dims = 1 if ( ori >= 0 ) then call MPI_IRECV ( message , 1 , pp % getmint (), ori , rtag , pp % getlworld (),& & mid , ierr ) call MPI_WAIT ( mid , istat , ierr ) endif call h5open_f ( ierr ) treal = detect_precision () call h5pcreate_f ( H5P_FILE_ACCESS_F , flplID , ierr ) call h5pcreate_f ( H5P_DATASET_CREATE_F , dcplID , ierr ) call h5pcreate_f ( H5P_DATASET_XFER_F , xferID , ierr ) info = MPI_INFO_NULL call h5pset_fapl_mpio_f ( flplID , pp % getlgrp (), info , ierr ) call h5pset_dxpl_mpio_f ( xferID , H5FD_MPIO_COLLECTIVE_F , ierr ) if ( ori >= 0 ) then call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , ierr ,& & access_prp = flplID ) call h5aopen_by_name_f ( file_id , \"/\" , \"NAME\" , aid , ierr ) lstr = len ( string ) call h5tcopy_f ( H5T_NATIVE_CHARACTER , tstring , ierr ) call h5tset_size_f ( tstring , lstr , ierr ) call h5aread_f ( aid , tstring , string , dims , ierr ) call h5dopen_f ( file_id , string , dset_id , ierr , H5P_DEFAULT_F ) call h5aclose_f ( aid , ierr ) call h5tclose_f ( tstring , ierr ) else call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , file_id , ierr ,& & access_prp = flplID ) call wrattr_file ( file , file_id , xferID ) endif call h5screate_simple_f ( 2 , gsize , dspace_id , ierr ) call h5screate_simple_f ( 2 , lsize , memspaceID , ierr ) call h5gopen_f ( file_id , '/' , rootID , ierr ) if ( ori < 0 ) then call h5dcreate_f ( rootID , file % dataname , treal , dspace_id , dset_id ,& & ierr , dcplID ) call wrattr_dataset ( file , dset_id ) endif start = lnoff call h5sselect_hyperslab_f ( dspace_id , H5S_SELECT_SET_F , start , lsize ,& & ierr ) call h5dwrite_f ( dset_id , treal , fd ( 1 : lsize ( 1 ), 1 : lsize ( 2 )),& & lsize , ierr , memspaceID , dspace_id , xfer_prp = xferID ) call h5sclose_f ( memspaceID , ierr ) call h5sclose_f ( dspace_id , ierr ) call h5pclose_f ( xferID , ierr ) call h5pclose_f ( dcplID , ierr ) call h5pclose_f ( flplID , ierr ) call h5gclose_f ( rootID , ierr ) call h5dclose_f ( dset_id , ierr ) call h5fclose_f ( file_id , ierr ) call h5close_f ( ierr ) if ( des < pp % getnvp ()) then call MPI_ISEND ( message , 1 , pp % getmint (), des , stag , pp % getlworld (),& & id , ierr ) else id = MPI_REQUEST_NULL endif end subroutine pwfield_2d_pipe ! subroutine wfield_2d_pipe ( pp , perr , file , fd , gs , ls , noff , rtag ,& & stag , id , ierr ) implicit none class ( perrors ), intent ( in ), pointer :: perr class ( parallel_pipe ), intent ( in ), pointer :: pp class ( hdf5file ), intent ( in ) :: file real , dimension (:,:), intent ( in ) :: fd integer , dimension ( 2 ), intent ( in ) :: gs , ls integer , dimension ( 2 ), intent ( in ) :: noff integer , intent ( in ) :: rtag , stag integer , intent ( inout ) :: id , ierr ! local data integer ( hid_t ) :: treal , memspaceID integer ( hid_t ) :: file_id , rootID , dset_id , dspace_id , aid integer ( hid_t ) :: tstring integer ( hsize_t ), dimension ( 2 ) :: gsize , lsize integer ( hsize_t ), dimension ( 2 ) :: lnoff character ( len = 80 ) :: string integer ( hsize_t ) :: lstr integer ( hsize_t ), dimension ( 2 ) :: start integer :: ori , des , nvyp , stageid , mid , message , info integer , dimension ( 10 ) :: istat integer ( hsize_t ), dimension ( 1 ) :: dims character ( len = :), allocatable :: filename character ( len = 8 ) :: st allocate ( character ( len ( trim ( file % filename )) + len ( trim ( file % dataname )) + 11 ) :: filename ) write ( st , '(I8.8)' ) file % n filename = trim ( file % filename ) // trim ( file % dataname ) // '_' // st // '.h5' ierr = 0 gsize = gs lsize = ls lnoff = noff nvyp = pp % getlnvp () ori = pp % getkstrt () - nvyp - 1 des = pp % getkstrt () + nvyp - 1 dims = 1 if ( ori >= 0 ) then call MPI_IRECV ( message , 1 , pp % getmint (), ori , rtag , pp % getlworld (),& & mid , ierr ) call MPI_WAIT ( mid , istat , ierr ) endif call h5open_f ( ierr ) treal = detect_precision () info = MPI_INFO_NULL if ( ori >= 0 ) then call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , ierr ) call h5aopen_by_name_f ( file_id , \"/\" , \"NAME\" , aid , ierr ) lstr = len ( string ) call h5tcopy_f ( H5T_NATIVE_CHARACTER , tstring , ierr ) call h5tset_size_f ( tstring , lstr , ierr ) call h5aread_f ( aid , tstring , string , dims , ierr ) call h5dopen_f ( file_id , string , dset_id , ierr , H5P_DEFAULT_F ) call h5aclose_f ( aid , ierr ) call h5tclose_f ( tstring , ierr ) else call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , file_id , ierr ) call wrattr_file ( file , file_id , H5P_DEFAULT_F ) endif call h5screate_simple_f ( 2 , gsize , dspace_id , ierr ) call h5screate_simple_f ( 2 , lsize , memspaceID , ierr ) call h5gopen_f ( file_id , '/' , rootID , ierr ) if ( ori < 0 ) then call h5dcreate_f ( rootID , file % dataname , treal , dspace_id , dset_id ,& & ierr ) call wrattr_dataset ( file , dset_id ) endif start ( 1 ) = 0 start ( 2 ) = lnoff ( 2 ) call h5sselect_hyperslab_f ( dspace_id , H5S_SELECT_SET_F , start , lsize ,& & ierr ) call h5dwrite_f ( dset_id , treal , fd ( 1 : lsize ( 1 ), 1 : lsize ( 2 )),& & lsize , ierr , memspaceID , dspace_id ) call h5sclose_f ( memspaceID , ierr ) call h5sclose_f ( dspace_id , ierr ) call h5gclose_f ( rootID , ierr ) call h5dclose_f ( dset_id , ierr ) call h5fclose_f ( file_id , ierr ) call h5close_f ( ierr ) if ( des < pp % getnvp ()) then call MPI_ISEND ( message , 1 , pp % getmint (), des , stag , pp % getlworld (),& & id , ierr ) else id = MPI_REQUEST_NULL endif end subroutine wfield_2d_pipe ! subroutine pwpart_2d ( pp , perr , file , part , npp , dspl , delta , ierr ) implicit none class ( perrors ), intent ( in ), pointer :: perr class ( parallel_pipe ), intent ( in ), pointer :: pp class ( hdf5file ), intent ( in ) :: file real , dimension (:,:), intent ( in ) :: part real , dimension ( 2 ), intent ( in ) :: delta integer , intent ( in ) :: npp , dspl integer , intent ( inout ) :: ierr ! local data integer :: tnpp , tp , color , pgrp , pid , pnvp , i , j integer ( hsize_t ), dimension ( 1 ) :: ldim integer , dimension (:), pointer :: np integer , dimension (:,:), pointer :: dims real , dimension (:), pointer :: buff integer ( hsize_t ), dimension ( 1 ) :: start , maxdim integer ( hid_t ) :: treal integer ( hid_t ) :: flplID , xferID , memspaceID , aid integer ( hid_t ) :: file_id , rootID , dset_id , dspace_id , aspace_id integer :: info integer , dimension ( 10 ) :: istat character ( len = :), allocatable :: filename character ( len = 8 ) :: st allocate ( character ( len ( trim ( file % filename )) + len ( trim ( file % dataname )) + 11 ) :: filename ) write ( st , '(I8.8)' ) file % n filename = trim ( file % filename ) // trim ( file % dataname ) // '_' // st // '.h5' ierr = 0 ldim ( 1 ) = 1 call h5open_f ( ierr ) treal = detect_precision () tnpp = int ( npp / dspl ) tp = 0 call MPI_ALLREDUCE ( tnpp , tp , 1 , MPI_INTEGER , MPI_SUM , pp % getlgrp (), ierr ) if ( tp == 0 ) then call h5pcreate_f ( H5P_FILE_ACCESS_F , flplID , ierr ) call h5pcreate_f ( H5P_DATASET_XFER_F , xferID , ierr ) info = MPI_INFO_NULL call h5pset_fapl_mpio_f ( flplID , pp % getlgrp (), info , ierr ) call h5pset_dxpl_mpio_f ( xferID , H5FD_MPIO_COLLECTIVE_F , ierr ) call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , file_id , ierr ,& & access_prp = flplID ) call wrattr_file ( file , file_id , xferID ) call h5gopen_f ( file_id , '/' , rootID , ierr ) call h5screate_simple_f ( 1 , ldim , aspace_id , ierr ) call h5acreate_f ( rootID , 'tp' , H5T_NATIVE_INTEGER , aspace_id ,& & aid , ierr ) call h5awrite_f ( aid , H5T_NATIVE_INTEGER , tp , ldim , ierr ) call h5aclose_f ( aid , ierr ) call h5sclose_f ( aspace_id , ierr ) call h5pclose_f ( xferID , ierr ) call h5pclose_f ( flplID , ierr ) call h5gclose_f ( rootID , ierr ) call h5fclose_f ( file_id , ierr ) call h5close_f ( ierr ) return else if ( tnpp > 0 ) then color = 1 else color = MPI_UNDEFINED endif call MPI_COMM_SPLIT ( pp % getlgrp (), color , 0 , pgrp , ierr ) if ( tnpp > 0 ) then call MPI_COMM_RANK ( pgrp , pid , ierr ) call MPI_COMM_SIZE ( pgrp , pnvp , ierr ) allocate ( np ( pnvp ), dims ( 2 , pnvp ), stat = ierr ) call MPI_ALLGATHER ( tnpp , 1 , MPI_INTEGER , np , 1 , MPI_INTEGER ,& & pgrp , ierr ) dims ( 1 , 1 ) = 1 dims ( 2 , 1 ) = np ( 1 ) do i = 2 , pnvp dims ( 1 , i ) = dims ( 2 , i - 1 ) + 1 dims ( 2 , i ) = dims ( 1 , i ) + np ( i ) - 1 enddo allocate ( buff ( tnpp ), stat = ierr ) call h5pcreate_f ( H5P_FILE_ACCESS_F , flplID , ierr ) call h5pcreate_f ( H5P_DATASET_XFER_F , xferID , ierr ) info = MPI_INFO_NULL call h5pset_fapl_mpio_f ( flplID , pgrp , info , ierr ) call h5pset_dxpl_mpio_f ( xferID , H5FD_MPIO_COLLECTIVE_F , ierr ) call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , file_id , ierr ,& & access_prp = flplID ) call wrattr_file ( file , file_id , xferID ) call h5gopen_f ( file_id , '/' , rootID , ierr ) call h5screate_simple_f ( 1 , ldim , aspace_id , ierr ) call h5acreate_f ( rootID , 'tp' , H5T_NATIVE_INTEGER , aspace_id ,& & aid , ierr ) call h5awrite_f ( aid , H5T_NATIVE_INTEGER , tp , ldim , ierr ) call h5aclose_f ( aid , ierr ) call h5sclose_f ( aspace_id , ierr ) do i = 1 , 2 buff ( 1 : tnpp ) = part ( i , 1 :( 1 + ( tnpp - 1 ) * dspl ): dspl ) * delta ( i ) ldim ( 1 ) = tp call h5screate_simple_f ( 1 , ldim , dspace_id , ierr ) call h5dcreate_f ( rootID , 'x' // char ( iachar ( '0' ) + i ), treal ,& & dspace_id , dset_id , ierr ) ldim ( 1 ) = tnpp call h5screate_simple_f ( 1 , ldim , memspaceID , ierr ) start = dims ( 1 , pid + 1 ) - 1 call h5sselect_hyperslab_f ( dspace_id , H5S_SELECT_SET_F , start ,& & ldim , ierr ) call h5dwrite_f ( dset_id , treal , buff , ldim , ierr , memspaceID ,& & dspace_id , xfer_prp = xferID ) call wrattr_dataset ( file , dset_id , unit = 'c/\\omega_p' ,& & name = 'x_' // char ( iachar ( '0' ) + i )) call h5sclose_f ( memspaceID , ierr ) call h5sclose_f ( dspace_id , ierr ) call h5dclose_f ( dset_id , ierr ) enddo do i = 1 , 3 buff ( 1 : tnpp ) = part (( i + 2 ), 1 :( 1 + ( tnpp - 1 ) * dspl ): dspl ) ldim ( 1 ) = tp call h5screate_simple_f ( 1 , ldim , dspace_id , ierr ) call h5dcreate_f ( rootID , 'p' // char ( iachar ( '0' ) + i ), treal ,& & dspace_id , dset_id , ierr ) ldim ( 1 ) = tnpp call h5screate_simple_f ( 1 , ldim , memspaceID , ierr ) start = dims ( 1 , pid + 1 ) - 1 call h5sselect_hyperslab_f ( dspace_id , H5S_SELECT_SET_F , start ,& & ldim , ierr ) call h5dwrite_f ( dset_id , treal , buff , ldim , ierr , memspaceID ,& & dspace_id , xfer_prp = xferID ) call wrattr_dataset ( file , dset_id , unit = 'c/\\omega_p' ,& & name = 'p_' // char ( iachar ( '0' ) + i )) call h5sclose_f ( memspaceID , ierr ) call h5sclose_f ( dspace_id , ierr ) call h5dclose_f ( dset_id , ierr ) enddo buff ( 1 : tnpp ) = part (( i + 2 ), 1 :( 1 + ( tnpp - 1 ) * dspl ): dspl ) ldim ( 1 ) = tp call h5screate_simple_f ( 1 , ldim , dspace_id , ierr ) call h5dcreate_f ( rootID , 'q' , treal ,& & dspace_id , dset_id , ierr ) ldim ( 1 ) = tnpp call h5screate_simple_f ( 1 , ldim , memspaceID , ierr ) start = dims ( 1 , pid + 1 ) - 1 call h5sselect_hyperslab_f ( dspace_id , H5S_SELECT_SET_F , start ,& & ldim , ierr ) call h5dwrite_f ( dset_id , treal , buff , ldim , ierr , memspaceID ,& & dspace_id , xfer_prp = xferID ) call wrattr_dataset ( file , dset_id , unit = 'a.u.' ,& & name = 'q' ) call h5sclose_f ( memspaceID , ierr ) call h5sclose_f ( dspace_id , ierr ) call h5dclose_f ( dset_id , ierr ) call h5pclose_f ( xferID , ierr ) call h5pclose_f ( flplID , ierr ) call h5gclose_f ( rootID , ierr ) call h5fclose_f ( file_id , ierr ) deallocate ( np , dims , buff ) endif if ( pgrp /= MPI_COMM_NULL ) then call MPI_COMM_FREE ( pgrp , ierr ) endif call h5close_f ( ierr ) endif end subroutine pwpart_2d ! subroutine pwpart_3d_pipe ( pp , perr , file , part , npp , dspl , delta , rtag , stag ,& & id , ierr ) implicit none class ( perrors ), intent ( in ), pointer :: perr class ( parallel_pipe ), intent ( in ), pointer :: pp class ( hdf5file ), intent ( in ) :: file real , dimension (:,:), intent ( in ) :: part real , dimension ( 3 ), intent ( in ) :: delta integer , intent ( in ) :: npp , dspl integer , intent ( in ) :: rtag , stag integer , intent ( inout ) :: id , ierr ! local data integer :: tnpp , tp , tpo , color , pgrp , pid , pnvp , i , j integer ( hsize_t ), dimension ( 1 ) :: ldim integer , dimension (:), pointer :: np integer , dimension (:,:), pointer :: dims real , dimension (:), pointer :: buff integer ( hsize_t ), dimension ( 1 ) :: start , maxdim integer ( hid_t ) :: treal integer ( hid_t ) :: flplID , xferID , dcplID , memspaceID , aid integer ( hid_t ) :: file_id , rootID , dset_id , dspace_id , aspace_id integer :: ori , des , nvyp , stageid , mid , message , info integer , dimension ( 10 ) :: istat character ( len = :), allocatable :: filename character ( len = 8 ) :: st allocate ( character ( len ( trim ( file % filename )) + len ( trim ( file % dataname )) + 11 ) :: filename ) write ( st , '(I8.8)' ) file % n filename = trim ( file % filename ) // trim ( file % dataname ) // '_' // st // '.h5' ierr = 0 tpo = 0 ldim ( 1 ) = 1 call h5open_f ( ierr ) treal = detect_precision () tnpp = int ( npp / dspl ) nvyp = pp % getlnvp () ori = pp % getkstrt () - nvyp - 1 des = pp % getkstrt () + nvyp - 1 if ( ori >= 0 ) then call MPI_IRECV ( message , 1 , pp % getmint (), ori , rtag , pp % getlworld (),& & mid , ierr ) call MPI_WAIT ( mid , istat , ierr ) endif call MPI_ALLREDUCE ( tnpp , tp , 1 , MPI_INTEGER , MPI_SUM , pp % getlgrp (), ierr ) if ( tp == 0 ) then if ( ori < 0 ) then call h5pcreate_f ( H5P_FILE_ACCESS_F , flplID , ierr ) call h5pcreate_f ( H5P_DATASET_XFER_F , xferID , ierr ) info = MPI_INFO_NULL call h5pset_fapl_mpio_f ( flplID , pp % getlgrp (), info , ierr ) call h5pset_dxpl_mpio_f ( xferID , H5FD_MPIO_COLLECTIVE_F , ierr ) call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , file_id , ierr ,& & access_prp = flplID ) call wrattr_file ( file , file_id , xferID ) call h5gopen_f ( file_id , '/' , rootID , ierr ) call h5screate_simple_f ( 1 , ldim , aspace_id , ierr ) call h5acreate_f ( rootID , 'tp' , H5T_NATIVE_INTEGER , aspace_id ,& & aid , ierr ) call h5awrite_f ( aid , H5T_NATIVE_INTEGER , tp , ldim , ierr ) call h5aclose_f ( aid , ierr ) call h5sclose_f ( aspace_id , ierr ) call h5pclose_f ( xferID , ierr ) call h5pclose_f ( flplID , ierr ) call h5gclose_f ( rootID , ierr ) call h5fclose_f ( file_id , ierr ) endif if ( des < pp % getnvp ()) then call MPI_ISEND ( message , 1 , pp % getmint (), des , stag , pp % getlworld (),& & id , ierr ) else id = MPI_REQUEST_NULL endif call h5close_f ( ierr ) return else if ( tnpp > 0 ) then color = 1 else color = MPI_UNDEFINED endif call MPI_COMM_SPLIT ( pp % getlgrp (), color , 0 , pgrp , ierr ) if ( tnpp > 0 ) then call MPI_COMM_RANK ( pgrp , pid , ierr ) call MPI_COMM_SIZE ( pgrp , pnvp , ierr ) allocate ( np ( pnvp ), dims ( 2 , pnvp ), stat = ierr ) call MPI_ALLGATHER ( tnpp , 1 , MPI_INTEGER , np , 1 , MPI_INTEGER ,& & pgrp , ierr ) dims ( 1 , 1 ) = 1 dims ( 2 , 1 ) = np ( 1 ) do i = 2 , pnvp dims ( 1 , i ) = dims ( 2 , i - 1 ) + 1 dims ( 2 , i ) = dims ( 1 , i ) + np ( i ) - 1 enddo allocate ( buff ( tnpp ), stat = ierr ) call h5pcreate_f ( H5P_FILE_ACCESS_F , flplID , ierr ) call h5pcreate_f ( H5P_DATASET_XFER_F , xferID , ierr ) info = MPI_INFO_NULL call h5pset_fapl_mpio_f ( flplID , pgrp , info , ierr ) call h5pset_dxpl_mpio_f ( xferID , H5FD_MPIO_COLLECTIVE_F , ierr ) if ( ori < 0 ) then call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , file_id , ierr ,& & access_prp = flplID ) call wrattr_file ( file , file_id , xferID ) call h5gopen_f ( file_id , '/' , rootID , ierr ) call h5screate_simple_f ( 1 , ldim , aspace_id , ierr ) call h5acreate_f ( rootID , 'tp' , H5T_NATIVE_INTEGER , aspace_id ,& & aid , ierr ) call h5awrite_f ( aid , H5T_NATIVE_INTEGER , tp , ldim , ierr ) call h5aclose_f ( aid , ierr ) call h5sclose_f ( aspace_id , ierr ) else call h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , ierr ,& & access_prp = flplID ) call h5gopen_f ( file_id , '/' , rootID , ierr ) call h5aopen_f ( rootID , 'tp' , aid , ierr ) call h5aread_f ( aid , H5T_NATIVE_INTEGER , tpo , ldim , ierr ) tp = tp + tpo call h5awrite_f ( aid , H5T_NATIVE_INTEGER , tp , ldim , ierr ) call h5aclose_f ( aid , ierr ) endif do i = 1 , 3 buff ( 1 : tnpp ) = part ( i , 1 :(( tnpp - 1 ) * dspl + 1 ): dspl ) * delta ( i ) if ( ori >= 0 . and . tpo /= 0 ) then call h5dopen_f ( rootID , 'x' // char ( iachar ( '0' ) + i ), dset_id , ierr ) ldim ( 1 ) = tp call h5dextend_f ( dset_id , ldim , ierr ) call h5screate_simple_f ( 1 , ldim , dspace_id , ierr ) ldim ( 1 ) = tnpp call h5screate_simple_f ( 1 , ldim , memspaceID , ierr ) start = tpo + dims ( 1 , pid + 1 ) - 1 call h5sselect_hyperslab_f ( dspace_id , H5S_SELECT_SET_F , start ,& & ldim , ierr ) call h5dwrite_f ( dset_id , treal , buff , ldim , ierr , memspaceID ,& & dspace_id , xfer_prp = xferID ) else maxdim = ( / H5S_UNLIMITED_F / ) ldim ( 1 ) = 1 call h5screate_simple_f ( 1 , ldim , dspace_id , ierr , maxdim ) call h5pcreate_f ( H5P_DATASET_CREATE_F , dcplID , ierr ) ldim ( 1 ) = tp call h5pset_chunk_f ( dcplID , 1 , ldim , ierr ) call h5dcreate_f ( rootID , 'x' // char ( iachar ( '0' ) + i ), treal ,& & dspace_id , dset_id , ierr , dcplID ) ldim ( 1 ) = tp call h5dextend_f ( dset_id , ldim , ierr ) call h5sclose_f ( dspace_id , ierr ) call h5screate_simple_f ( 1 , ldim , dspace_id , ierr ) ldim ( 1 ) = tnpp call h5screate_simple_f ( 1 , ldim , memspaceID , ierr ) start = tpo + dims ( 1 , pid + 1 ) - 1 call h5sselect_hyperslab_f ( dspace_id , H5S_SELECT_SET_F , start ,& & ldim , ierr ) call h5dwrite_f ( dset_id , treal , buff , ldim , ierr , memspaceID ,& & dspace_id , xfer_prp = xferID ) call wrattr_dataset ( file , dset_id , unit = 'c/\\omega_p' ,& & name = 'x_' // char ( iachar ( '0' ) + i )) call h5pclose_f ( dcplID , ierr ) endif call h5sclose_f ( memspaceID , ierr ) call h5sclose_f ( dspace_id , ierr ) call h5dclose_f ( dset_id , ierr ) enddo do i = 1 , 3 buff ( 1 : tnpp ) = part (( i + 3 ), 1 :(( tnpp - 1 ) * dspl + 1 ): dspl ) if ( ori >= 0 . and . tpo /= 0 ) then call h5dopen_f ( rootID , 'p' // char ( iachar ( '0' ) + i ), dset_id , ierr ) ldim ( 1 ) = tp call h5dextend_f ( dset_id , ldim , ierr ) call h5screate_simple_f ( 1 , ldim , dspace_id , ierr ) ldim ( 1 ) = tnpp call h5screate_simple_f ( 1 , ldim , memspaceID , ierr ) start = tpo + dims ( 1 , pid + 1 ) - 1 call h5sselect_hyperslab_f ( dspace_id , H5S_SELECT_SET_F , start ,& & ldim , ierr ) call h5dwrite_f ( dset_id , treal , buff , ldim , ierr , memspaceID ,& & dspace_id , xfer_prp = xferID ) else maxdim = ( / H5S_UNLIMITED_F / ) ldim ( 1 ) = 1 call h5screate_simple_f ( 1 , ldim , dspace_id , ierr , maxdim ) call h5pcreate_f ( H5P_DATASET_CREATE_F , dcplID , ierr ) ldim ( 1 ) = tp call h5pset_chunk_f ( dcplID , 1 , ldim , ierr ) call h5dcreate_f ( rootID , 'p' // char ( iachar ( '0' ) + i ), treal ,& & dspace_id , dset_id , ierr , dcplID ) ldim ( 1 ) = tp call h5dextend_f ( dset_id , ldim , ierr ) call h5sclose_f ( dspace_id , ierr ) call h5screate_simple_f ( 1 , ldim , dspace_id , ierr ) ldim ( 1 ) = tnpp call h5screate_simple_f ( 1 , ldim , memspaceID , ierr ) start = tpo + dims ( 1 , pid + 1 ) - 1 call h5sselect_hyperslab_f ( dspace_id , H5S_SELECT_SET_F , start ,& & ldim , ierr ) call h5dwrite_f ( dset_id , treal , buff , ldim , ierr , memspaceID ,& & dspace_id , xfer_prp = xferID ) call wrattr_dataset ( file , dset_id , unit = 'c/\\omega_p' ,& & name = 'p_' // char ( iachar ( '0' ) + i )) call h5pclose_f ( dcplID , ierr ) endif call h5sclose_f ( memspaceID , ierr ) call h5sclose_f ( dspace_id , ierr ) call h5dclose_f ( dset_id , ierr ) enddo buff ( 1 : tnpp ) = part ( 7 , 1 :(( tnpp - 1 ) * dspl + 1 ): dspl ) if ( ori >= 0 . and . tpo /= 0 ) then call h5dopen_f ( rootID , 'q' , dset_id , ierr ) ldim ( 1 ) = tp call h5dextend_f ( dset_id , ldim , ierr ) call h5screate_simple_f ( 1 , ldim , dspace_id , ierr ) ldim ( 1 ) = tnpp call h5screate_simple_f ( 1 , ldim , memspaceID , ierr ) start = tpo + dims ( 1 , pid + 1 ) - 1 call h5sselect_hyperslab_f ( dspace_id , H5S_SELECT_SET_F , start ,& & ldim , ierr ) call h5dwrite_f ( dset_id , treal , buff , ldim , ierr , memspaceID ,& & dspace_id , xfer_prp = xferID ) else maxdim = ( / H5S_UNLIMITED_F / ) ldim ( 1 ) = 1 call h5screate_simple_f ( 1 , ldim , dspace_id , ierr , maxdim ) call h5pcreate_f ( H5P_DATASET_CREATE_F , dcplID , ierr ) ldim ( 1 ) = tp call h5pset_chunk_f ( dcplID , 1 , ldim , ierr ) call h5dcreate_f ( rootID , 'q' , treal ,& & dspace_id , dset_id , ierr , dcplID ) ldim ( 1 ) = tp call h5dextend_f ( dset_id , ldim , ierr ) call h5sclose_f ( dspace_id , ierr ) call h5screate_simple_f ( 1 , ldim , dspace_id , ierr ) ldim ( 1 ) = tnpp call h5screate_simple_f ( 1 , ldim , memspaceID , ierr ) start = tpo + dims ( 1 , pid + 1 ) - 1 call h5sselect_hyperslab_f ( dspace_id , H5S_SELECT_SET_F , start ,& & ldim , ierr ) call h5dwrite_f ( dset_id , treal , buff , ldim , ierr , memspaceID ,& & dspace_id , xfer_prp = xferID ) call wrattr_dataset ( file , dset_id , unit = 'a.u.' ,& & name = 'q' ) call h5pclose_f ( dcplID , ierr ) endif call h5sclose_f ( memspaceID , ierr ) call h5sclose_f ( dspace_id , ierr ) call h5dclose_f ( dset_id , ierr ) call h5pclose_f ( xferID , ierr ) call h5pclose_f ( flplID , ierr ) call h5gclose_f ( rootID , ierr ) call h5fclose_f ( file_id , ierr ) deallocate ( np , dims , buff ) endif endif if ( des < pp % getnvp ()) then call MPI_ISEND ( message , 1 , pp % getmint (), des , stag , pp % getlworld (),& & id , ierr ) else id = MPI_REQUEST_NULL endif if ( pgrp /= MPI_COMM_NULL ) then call MPI_COMM_FREE ( pgrp , ierr ) endif call h5close_f ( ierr ) end subroutine pwpart_3d_pipe ! subroutine wpart ( pp , perr , file , part , npp , dspl , ierr ) implicit none class ( perrors ), intent ( in ), pointer :: perr class ( parallel_pipe ), intent ( in ), pointer :: pp class ( hdf5file ), intent ( in ) :: file real , dimension (:,:), intent ( in ) :: part integer , intent ( in ) :: npp , dspl integer , intent ( inout ) :: ierr ! local data integer :: tp integer ( hsize_t ), dimension ( 1 ) :: ldim integer ( hsize_t ), dimension ( 2 ) :: dim integer ( hid_t ) :: treal integer ( hid_t ) :: file_id , rootID , dset_id , dspace_id , aspace_id integer ( hid_t ) :: memspaceID , aid character ( len = :), allocatable :: filename character ( len = 8 ) :: st allocate ( character ( len ( trim ( file % filename )) + len ( trim ( file % dataname )) + 11 ) :: filename ) write ( st , '(I8.8)' ) file % n filename = trim ( file % filename ) // trim ( file % dataname ) // '_' // st // '.h5' ierr = 0 ldim ( 1 ) = 1 call h5open_f ( ierr ) treal = detect_precision () tp = int ( npp / dspl ) call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , file_id , ierr ) call wrattr_file ( file , file_id , H5P_DEFAULT_F ) call h5gopen_f ( file_id , '/' , rootID , ierr ) call h5screate_simple_f ( 1 , ldim , aspace_id , ierr ) call h5acreate_f ( rootID , 'tp' , H5T_NATIVE_INTEGER , aspace_id ,& & aid , ierr ) call h5awrite_f ( aid , H5T_NATIVE_INTEGER , tp , ldim , ierr ) call h5aclose_f ( aid , ierr ) call h5sclose_f ( aspace_id , ierr ) if ( tp == 0 ) then call h5gclose_f ( rootID , ierr ) call h5fclose_f ( file_id , ierr ) call h5close_f ( ierr ) else dim ( 1 ) = size ( part , 1 ) dim ( 2 ) = tp call h5screate_simple_f ( 2 , dim , dspace_id , ierr ) call h5screate_simple_f ( 2 , dim , memspaceID , ierr ) call h5dcreate_f ( rootID , file % dataname , treal , dspace_id , dset_id ,& & ierr ) call wrattr_dataset ( file , dset_id ) call h5dwrite_f ( dset_id , treal , part (:, 1 :( 1 + ( tp - 1 ) * dspl ): dspl ),& & dim , ierr , memspaceID , dspace_id ) call h5sclose_f ( memspaceID , ierr ) call h5sclose_f ( dspace_id , ierr ) call h5gclose_f ( rootID , ierr ) call h5dclose_f ( dset_id , ierr ) call h5fclose_f ( file_id , ierr ) call h5close_f ( ierr ) end if end subroutine wpart ! subroutine rpart ( pp , perr , file , part , npp , ierr ) implicit none class ( perrors ), intent ( in ), pointer :: perr class ( parallel_pipe ), intent ( in ), pointer :: pp class ( hdf5file ), intent ( in ) :: file real , dimension (:,:), intent ( inout ) :: part integer , intent ( out ) :: npp integer , intent ( inout ) :: ierr ! local data integer :: tp integer ( hsize_t ), dimension ( 1 ) :: ldim integer ( hsize_t ), dimension ( 2 ) :: dim integer ( hid_t ) :: treal integer ( hid_t ) :: file_id , rootID , dset_id , dspace_id , aspace_id integer ( hid_t ) :: memspaceID , aid character ( len = :), allocatable :: filename character ( len = 8 ) :: st allocate ( character ( len ( trim ( file % filename )) + len ( trim ( file % dataname )) + 11 ) :: filename ) write ( st , '(I8.8)' ) file % n filename = trim ( file % filename ) // trim ( file % dataname ) // '_' // st // '.h5' ierr = 0 ldim ( 1 ) = 1 call h5open_f ( ierr ) treal = detect_precision () call h5fopen_f ( filename , H5F_ACC_RDONLY_F , file_id , ierr ) call h5gopen_f ( file_id , '/' , rootID , ierr ) call h5aopen_f ( rootID , 'tp' , aid , ierr ) call h5aread_f ( aid , H5T_NATIVE_INTEGER , tp , ldim , ierr ) call h5aclose_f ( aid , ierr ) npp = tp if ( tp == 0 ) then call h5gclose_f ( rootID , ierr ) call h5fclose_f ( file_id , ierr ) call h5close_f ( ierr ) else dim ( 1 ) = size ( part , 1 ) dim ( 2 ) = tp call h5screate_simple_f ( 2 , dim , dspace_id , ierr ) call h5screate_simple_f ( 2 , dim , memspaceID , ierr ) call h5dopen_f ( rootID , file % dataname , dset_id , ierr ) call h5dread_f ( dset_id , treal , part ,& & dim , ierr , memspaceID , dspace_id ) call h5sclose_f ( memspaceID , ierr ) call h5sclose_f ( dspace_id , ierr ) call h5gclose_f ( rootID , ierr ) call h5dclose_f ( dset_id , ierr ) call h5fclose_f ( file_id , ierr ) call h5close_f ( ierr ) end if end subroutine rpart ! function detect_precision () integer ( hid_t ) :: detect_precision ! local data real :: small small = 1.0e-12 small = 1.0 + small if ( small > 1.0 ) then detect_precision = H5T_NATIVE_DOUBLE else detect_precision = H5T_NATIVE_REAL endif end function detect_precision ! end module hdf5io_class","tags":"","loc":"sourcefile/hdf5io_class.f03.html"},{"title":"fpois2d_lib.f03 – QuickPIC","text":"Files dependent on this one sourcefile~~fpois2d_lib.f03~~AfferentGraph sourcefile~fpois2d_lib.f03 fpois2d_lib.f03 sourcefile~fpois2d_class.f03 fpois2d_class.f03 sourcefile~fpois2d_class.f03->sourcefile~fpois2d_lib.f03 sourcefile~field2d_class.f03 field2d_class.f03 sourcefile~field2d_class.f03->sourcefile~fpois2d_class.f03 sourcefile~simulation_class.f03 simulation_class.f03 sourcefile~simulation_class.f03->sourcefile~field2d_class.f03 sourcefile~species2d_class.f03 species2d_class.f03 sourcefile~simulation_class.f03->sourcefile~species2d_class.f03 sourcefile~beam3d_class.f03 beam3d_class.f03 sourcefile~simulation_class.f03->sourcefile~beam3d_class.f03 sourcefile~species2d_class.f03->sourcefile~field2d_class.f03 sourcefile~beam3d_class.f03->sourcefile~field2d_class.f03 sourcefile~main.f03 main.f03 sourcefile~main.f03->sourcefile~simulation_class.f03 var pansourcefilefpois2d_libf03AfferentGraph = svgPanZoom('#sourcefilefpois2d_libf03AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules fpois2d_lib Source Code fpois2d_lib.f03 Source Code module fpois2d_lib ! interface subroutine PPOISDX2 ( q , fx , fy , isign , ffd , ax , ay , affp , we , nx , ny , kstrt & &, ny2d , kxp2 , j2blok , nyd ) implicit none real , intent ( in ) :: ax , ay , affp , we integer , intent ( in ) :: isign , nx , ny , kstrt , ny2d , kxp2 , j2blok , nyd complex , dimension ( ny2d , kxp2 , j2blok ), intent ( inout ) :: q , fx , fy complex , dimension ( nyd , kxp2 , j2blok ), intent ( inout ) :: ffd end subroutine end interface ! interface subroutine PPOISD2 ( q , fx , fy , isign , ffd , ax , ay , affp , we , nx , ny , kstrt ,& & nyv , kxp2 , j2blok , nyd ) implicit none real , intent ( in ) :: ax , ay , affp , we integer , intent ( in ) :: isign , nx , ny , kstrt , nyv , kxp2 , j2blok , nyd real , dimension ( nyv , kxp2 + 1 , j2blok ), intent ( inout ) :: q , fx , fy complex , dimension ( nyd , kxp2 , j2blok ), intent ( in ) :: ffd end subroutine end interface ! interface subroutine PPOISD22 ( q , fxy , isign , ffd , ax , ay , affp , we , nx , ny , kstrt , n & & yv , kxp2 , j2blok , nyd ) implicit none real , intent ( in ) :: ax , ay , affp , we integer , intent ( in ) :: isign , nx , ny , kstrt , nyv , kxp2 , j2blok , nyd real , dimension ( nyv , kxp2 + 1 , j2blok ), intent ( inout ) :: q real , dimension ( 2 , nyv , kxp2 + 1 , j2blok ), intent ( inout ) :: fxy complex , dimension ( nyd , kxp2 , j2blok ), intent ( in ) :: ffd end subroutine end interface ! interface subroutine PPOISD23 ( q , fxy , isign , ffd , ax , ay , affp , we , nx , ny , kstrt , n & & yv , kxp2 , j2blok , nyd ) implicit none real , intent ( in ) :: ax , ay , affp , we integer , intent ( in ) :: isign , nx , ny , kstrt , nyv , kxp2 , j2blok , nyd real , dimension ( nyv , kxp2 + 1 , j2blok ), intent ( inout ) :: q real , dimension ( 3 , nyv , kxp2 + 1 , j2blok ), intent ( inout ) :: fxy complex , dimension ( nyd , kxp2 , j2blok ), intent ( in ) :: ffd end subroutine end interface ! interface subroutine PBPOISD22 ( cu , bxy , bz , isign , ffd , ax , ay , affp , ci , wm , nx , ny & &, kstrt , nyv , kxp2 , j2blok , nyd ) implicit none real , intent ( in ) :: ax , ay , affp , ci , wm integer , intent ( in ) :: isign , nx , ny , kstrt , nyv , kxp2 , j2blok , nyd real , dimension ( 2 , nyv , kxp2 + 1 , j2blok ), intent ( inout ) :: cu , bxy real , dimension ( nyv , kxp2 + 1 , j2blok ), intent ( inout ) :: bz complex , dimension ( nyd , kxp2 , j2blok ), intent ( in ) :: ffd end subroutine end interface ! interface subroutine PBPOISD23 ( cu , bxy , isign , ffd , ax , ay , affp , ci , wm , nx , ny , ks & & trt , nyv , kxp2 , j2blok , nyd ) implicit none real , intent ( in ) :: ax , ay , affp , ci , wm integer , intent ( in ) :: isign , nx , ny , kstrt , nyv , kxp2 , j2blok , nyd real , dimension ( 3 , nyv , kxp2 + 1 , j2blok ), intent ( inout ) :: cu , bxy complex , dimension ( nyd , kxp2 , j2blok ), intent ( in ) :: ffd end subroutine end interface ! interface subroutine PBPOISD22N_QP ( cu , dcu , amu , bxy , bz , isign , ffd , ax , ay , affp & &, ci , wm , nx , ny , kstrt , nyv , kxp2 , j2blok , nyd , aa , dex ) implicit none real , intent ( in ) :: ax , ay , affp , ci , wm , aa , dex integer , intent ( in ) :: isign , nx , ny , kstrt , nyv , kxp2 , j2blok , nyd real , dimension ( 2 , nyv , kxp2 + 1 , j2blok ), intent ( inout ) :: dcu , bxy real , dimension ( 3 , nyv , kxp2 + 1 , j2blok ), intent ( inout ) :: cu , amu real , dimension ( nyv , kxp2 + 1 , j2blok ), intent ( inout ) :: bz complex , dimension ( nyd , kxp2 , j2blok ), intent ( in ) :: ffd end subroutine end interface ! interface subroutine MPPOISD22 ( q , fxy , isign , ffd , ax , ay , affp , we , nx , ny , kstrt ,& & nyv , kxp2 , nyd ) implicit none integer , intent ( in ) :: isign , nx , ny , kstrt , nyv , kxp2 , nyd real , intent ( in ) :: ax , ay , affp real , intent ( inout ) :: we real , dimension ( nyv , kxp2 + 1 ), intent ( in ) :: q real , dimension ( 2 , nyv , kxp2 + 1 ), intent ( inout ) :: fxy complex , dimension ( nyd , kxp2 ), intent ( inout ) :: ffd end subroutine end interface ! interface subroutine MPPOISD23 ( q , fxy , isign , ffd , ax , ay , affp , we , nx , ny , kstrt ,& & nyv , kxp2 , nyd ) implicit none integer , intent ( in ) :: isign , nx , ny , kstrt , nyv , kxp2 , nyd real , intent ( in ) :: ax , ay , affp real , intent ( inout ) :: we real , dimension ( nyv , kxp2 + 1 ), intent ( in ) :: q real , dimension ( 3 , nyv , kxp2 + 1 ), intent ( inout ) :: fxy complex , dimension ( nyd , kxp2 ), intent ( inout ) :: ffd end subroutine end interface ! interface subroutine MPPOTPD2 ( q , pot , ffd , we , nx , ny , kstrt , nyv , kxp2 , nyd ) implicit none integer , intent ( in ) :: nx , ny , kstrt , nyv , kxp2 , nyd real , intent ( inout ) :: we real , dimension ( nyv , kxp2 + 1 ), intent ( in ) :: q real , dimension ( nyv , kxp2 + 1 ), intent ( inout ) :: pot complex , dimension ( nyd , kxp2 ), intent ( in ) :: ffd end subroutine end interface ! interface subroutine MPPSMOOTHD2 ( q , qs , ffd , nx , ny , kstrt , nyv , kxp2 , nyd ) implicit none integer , intent ( in ) :: nx , ny , kstrt , nyv , kxp2 , nyd real , dimension ( nyv , kxp2 + 1 ), intent ( in ) :: q real , dimension ( nyv , kxp2 + 1 ), intent ( inout ) :: qs complex , dimension ( nyd , kxp2 ), intent ( in ) :: ffd end subroutine end interface ! interface subroutine MPPBBPOISD23 ( cu , bxy , ffd , ci , wm , nx , ny , kstrt , nyv , kxp2 , & & nyd ) implicit none integer , intent ( in ) :: nx , ny , kstrt , nyv , kxp2 , nyd real , intent ( in ) :: ci real , intent ( inout ) :: wm real , dimension ( 3 , nyv , kxp2 + 1 ), intent ( in ) :: cu real , dimension ( 3 , nyv , kxp2 + 1 ), intent ( inout ) :: bxy complex , dimension ( nyd , kxp2 ), intent ( in ) :: ffd end subroutine end interface ! end module fpois2d_lib","tags":"","loc":"sourcefile/fpois2d_lib.f03.html"},{"title":"beam3d_class.f03 – QuickPIC","text":"This file depends on sourcefile~~beam3d_class.f03~~EfferentGraph sourcefile~beam3d_class.f03 beam3d_class.f03 sourcefile~parallel_pipe_class.f03 parallel_pipe_class.f03 sourcefile~beam3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~fdist3d_class.f03 fdist3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~fdist3d_class.f03 sourcefile~field3d_class.f03 field3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~field3d_class.f03 sourcefile~hdf5io_class.f03 hdf5io_class.f03 sourcefile~beam3d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~spect3d_class.f03 spect3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~part3d_class.f03 part3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~part3d_class.f03 sourcefile~perrors_class.f03 perrors_class.f03 sourcefile~beam3d_class.f03->sourcefile~perrors_class.f03 sourcefile~field2d_class.f03 field2d_class.f03 sourcefile~beam3d_class.f03->sourcefile~field2d_class.f03 sourcefile~parallel_class.f03 parallel_class.f03 sourcefile~parallel_pipe_class.f03->sourcefile~parallel_class.f03 sourcefile~fdist3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~fdist3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~fdist3d_class.f03->sourcefile~perrors_class.f03 sourcefile~ufield3d_class.f03 ufield3d_class.f03 sourcefile~fdist3d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~part3d_lib.f03 part3d_lib.f03 sourcefile~fdist3d_class.f03->sourcefile~part3d_lib.f03 sourcefile~input_class.f03 input_class.f03 sourcefile~fdist3d_class.f03->sourcefile~input_class.f03 sourcefile~field3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field3d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~field3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~field3d_class.f03->sourcefile~perrors_class.f03 sourcefile~field3d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~hdf5io_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~hdf5io_class.f03->sourcefile~perrors_class.f03 sourcefile~spect3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~spect3d_class.f03->sourcefile~perrors_class.f03 sourcefile~spect2d_class.f03 spect2d_class.f03 sourcefile~spect3d_class.f03->sourcefile~spect2d_class.f03 sourcefile~part3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~part3d_class.f03->sourcefile~fdist3d_class.f03 sourcefile~part3d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~part3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~part3d_class.f03->sourcefile~perrors_class.f03 sourcefile~part3d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~part3d_class.f03->sourcefile~part3d_lib.f03 sourcefile~perrors_class.f03->sourcefile~parallel_class.f03 sourcefile~field2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field2d_class.f03->sourcefile~field3d_class.f03 sourcefile~field2d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~field2d_class.f03->sourcefile~perrors_class.f03 sourcefile~field2d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~ufield2d_class.f03 ufield2d_class.f03 sourcefile~field2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~field2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~fpois2d_class.f03 fpois2d_class.f03 sourcefile~field2d_class.f03->sourcefile~fpois2d_class.f03 sourcefile~fft2d_class.f03 fft2d_class.f03 sourcefile~field2d_class.f03->sourcefile~fft2d_class.f03 sourcefile~ufield3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~ufield3d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~ufield3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~ufield3d_class.f03->sourcefile~perrors_class.f03 sourcefile~ufield3d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~ufield3d_lib.f03 ufield3d_lib.f03 sourcefile~ufield3d_class.f03->sourcefile~ufield3d_lib.f03 sourcefile~ufield2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~ufield2d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~ufield2d_class.f03->sourcefile~perrors_class.f03 sourcefile~ufield2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~ufield2d_lib.f03 ufield2d_lib.f03 sourcefile~ufield2d_class.f03->sourcefile~ufield2d_lib.f03 sourcefile~spect2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~spect2d_class.f03->sourcefile~perrors_class.f03 sourcefile~input_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~input_class.f03->sourcefile~spect3d_class.f03 sourcefile~input_class.f03->sourcefile~perrors_class.f03 sourcefile~input_class.f03->sourcefile~parallel_class.f03 sourcefile~fpois2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~fpois2d_class.f03->sourcefile~perrors_class.f03 sourcefile~fpois2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~fpois2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~fpois2d_lib.f03 fpois2d_lib.f03 sourcefile~fpois2d_class.f03->sourcefile~fpois2d_lib.f03 sourcefile~fft2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~fft2d_class.f03->sourcefile~perrors_class.f03 sourcefile~fft2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~fft2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~fft2d_lib.f03 fft2d_lib.f03 sourcefile~fft2d_class.f03->sourcefile~fft2d_lib.f03 var pansourcefilebeam3d_classf03EfferentGraph = svgPanZoom('#sourcefilebeam3d_classf03EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~beam3d_class.f03~~AfferentGraph sourcefile~beam3d_class.f03 beam3d_class.f03 sourcefile~simulation_class.f03 simulation_class.f03 sourcefile~simulation_class.f03->sourcefile~beam3d_class.f03 sourcefile~main.f03 main.f03 sourcefile~main.f03->sourcefile~simulation_class.f03 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules beam3d_class Source Code beam3d_class.f03 Source Code ! beam3d class for QuickPIC Open Source 1.0 ! update: 04/18/2016 module beam3d_class use perrors_class use parallel_pipe_class use spect3d_class use fdist3d_class use field3d_class use field2d_class use part3d_class use hdf5io_class use mpi implicit none private public :: beam3d type beam3d private class ( spect3d ), pointer , public :: sp => null () class ( perrors ), pointer , public :: err => null () class ( parallel_pipe ), pointer , public :: p => null () class ( part3d ), pointer :: pd class ( field3d ), pointer :: q => null () class ( fdist3d ), pointer :: pf => null () contains generic :: new => init_beam3d generic :: del => end_beam3d generic :: push => push_beam3d generic :: pmv => pmove_beam3d generic :: qdp => qdeposit_beam3d , qdpcopy_beam3d generic :: wr => writehdf5_beam3d generic :: wrq => writeq_beam3d , writeqslice_beam3d generic :: wrst => writerst_beam3d generic :: rrst => readrst_beam3d procedure , private :: init_beam3d procedure , private :: end_beam3d procedure , private :: push_beam3d procedure , private :: pmove_beam3d procedure , private :: qdeposit_beam3d , writehdf5_beam3d procedure , private :: writerst_beam3d , readrst_beam3d procedure , private :: writeq_beam3d , writeqslice_beam3d procedure , private :: qdpcopy_beam3d end type save character ( len = 10 ) :: class = 'beam3d:' character ( len = 128 ) :: erstr contains ! subroutine init_beam3d ( this , pp , perr , psp , pf , qbm , dt , ci , xdim ) implicit none class ( beam3d ), intent ( inout ) :: this class ( spect3d ), intent ( in ), pointer :: psp class ( perrors ), intent ( in ), pointer :: perr class ( parallel_pipe ), intent ( in ), pointer :: pp class ( fdist3d ), intent ( inout ), target :: pf real , intent ( in ) :: qbm , dt , ci integer , intent ( in ) :: xdim ! local data character ( len = 18 ), save :: sname = 'init_beam3d:' integer :: id , ierr integer , dimension ( 10 ) :: istat this % sp => psp this % err => perr this % p => pp this % pf => pf call this % err % werrfl2 ( class // sname // ' started' ) allocate ( this % pd , this % q ) call this % q % new ( this % p , this % err , this % sp , dim = 1 ) call this % pd % new ( pp , perr , psp , pf , this % q % getrs (), qbm , dt , ci , xdim ) call this % pmv ( this % q , 1 , 1 , id ) call MPI_WAIT ( id , istat , ierr ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine init_beam3d ! subroutine end_beam3d ( this ) implicit none class ( beam3d ), intent ( inout ) :: this character ( len = 18 ), save :: sname = 'end_beam3d:' call this % err % werrfl2 ( class // sname // ' started' ) call this % pd % del () call this % q % del () call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine end_beam3d ! subroutine qdeposit_beam3d ( this , id1 , id2 , id3 , tag1 , tag2 ) ! deposit the charge density implicit none class ( beam3d ), intent ( inout ) :: this integer , intent ( inout ) :: id1 , id2 , id3 , tag1 , tag2 ! local data character ( len = 18 ), save :: sname = 'qdeposit_beam3d:' integer , dimension ( 10 ) :: istat integer :: ierr call this % err % werrfl2 ( class // sname // ' started' ) call this % q % as ( 0.0 ) call MPI_WAIT ( id1 , istat , ierr ) call MPI_WAIT ( id3 , istat , ierr ) call this % pd % qdp ( this % q % getrs ()) call this % q % ag ( tag1 , tag1 , id1 ) call this % q % pcg ( tag2 , tag2 , id2 , id3 ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine qdeposit_beam3d ! subroutine qdpcopy_beam3d ( this , q , slice ) ! copy and add the charge density to a 2d slice implicit none class ( beam3d ), intent ( inout ) :: this class ( field2d ), intent ( inout ) :: q integer , intent ( in ) :: slice ! local data character ( len = 18 ), save :: sname = 'qdpcopy_beam3d:' call this % err % werrfl2 ( class // sname // ' started' ) call q % ca ( this % q , slice ,( / 1 / ),( / 1 / )) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine qdpcopy_beam3d ! subroutine push_beam3d ( this , ef , bf , dex , dez , rtag , stag , sid ) implicit none class ( beam3d ), intent ( inout ) :: this class ( field3d ), intent ( in ) :: ef , bf real , intent ( in ) :: dex , dez integer , intent ( in ) :: rtag , stag integer , intent ( inout ) :: sid ! local data character ( len = 18 ), save :: sname = 'partpush' call this % err % werrfl2 ( class // sname // ' started' ) call this % pd % push ( ef % getrs (), bf % getrs (), dex , dez ) call this % pmv ( ef , rtag , stag , sid ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine push_beam3d ! subroutine pmove_beam3d ( this , fd , rtag , stag , sid ) implicit none class ( beam3d ), intent ( inout ) :: this class ( field3d ), intent ( in ) :: fd integer , intent ( in ) :: rtag , stag integer , intent ( inout ) :: sid ! local data character ( len = 18 ), save :: sname = 'pmove:' call this % err % werrfl2 ( class // sname // ' started' ) call this % pd % pmv ( fd % getrs (), rtag , stag , sid ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine pmove_beam3d ! subroutine writehdf5_beam3d ( this , file , dspl , delta , rtag , stag , id ) implicit none class ( beam3d ), intent ( inout ) :: this class ( hdf5file ), intent ( in ) :: file real , dimension ( 3 ), intent ( in ) :: delta integer , intent ( in ) :: dspl , rtag , stag integer , intent ( inout ) :: id ! local data character ( len = 18 ), save :: sname = 'writehdf5_beam3d:' call this % err % werrfl2 ( class // sname // ' started' ) call this % pd % wr ( file , dspl , delta , rtag , stag , id ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine writehdf5_beam3d ! subroutine writerst_beam3d ( this , file ) implicit none class ( beam3d ), intent ( inout ) :: this class ( hdf5file ), intent ( in ) :: file ! local data character ( len = 18 ), save :: sname = 'writerst_beam3d:' call this % err % werrfl2 ( class // sname // ' started' ) call this % pd % wrst ( file ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine writerst_beam3d ! subroutine writeq_beam3d ( this , file , rtag , stag , id ) implicit none class ( beam3d ), intent ( inout ) :: this class ( hdf5file ), intent ( in ) :: file integer , intent ( in ) :: rtag , stag integer , intent ( inout ) :: id ! local data character ( len = 18 ), save :: sname = 'writeq_beam3d:' call this % err % werrfl2 ( class // sname // ' started' ) call this % q % wr ( file , 1 , rtag , stag , id ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine writeq_beam3d ! subroutine writeqslice_beam3d ( this , file , slice , spos , rtag , stag , id ) implicit none class ( beam3d ), intent ( inout ) :: this class ( hdf5file ), intent ( in ) :: file integer , intent ( in ) :: rtag , stag , slice , spos integer , intent ( inout ) :: id ! local data character ( len = 18 ), save :: sname = 'writeqslice_beam3d:' call this % err % werrfl2 ( class // sname // ' started' ) call this % q % wr ( file , 1 , slice , spos , rtag , stag , id ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine writeqslice_beam3d ! subroutine readrst_beam3d ( this , file ) implicit none class ( beam3d ), intent ( inout ) :: this class ( hdf5file ), intent ( in ) :: file ! local data character ( len = 18 ), save :: sname = 'readrst_beam3d:' call this % err % werrfl2 ( class // sname // ' started' ) call this % pd % rrst ( file ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine readrst_beam3d ! end module beam3d_class","tags":"","loc":"sourcefile/beam3d_class.f03.html"},{"title":"species2d_class.f03 – QuickPIC","text":"This file depends on sourcefile~~species2d_class.f03~~EfferentGraph sourcefile~species2d_class.f03 species2d_class.f03 sourcefile~parallel_pipe_class.f03 parallel_pipe_class.f03 sourcefile~species2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field3d_class.f03 field3d_class.f03 sourcefile~species2d_class.f03->sourcefile~field3d_class.f03 sourcefile~hdf5io_class.f03 hdf5io_class.f03 sourcefile~species2d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~part2d_class.f03 part2d_class.f03 sourcefile~species2d_class.f03->sourcefile~part2d_class.f03 sourcefile~spect3d_class.f03 spect3d_class.f03 sourcefile~species2d_class.f03->sourcefile~spect3d_class.f03 sourcefile~perrors_class.f03 perrors_class.f03 sourcefile~species2d_class.f03->sourcefile~perrors_class.f03 sourcefile~spect2d_class.f03 spect2d_class.f03 sourcefile~species2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~fdist2d_class.f03 fdist2d_class.f03 sourcefile~species2d_class.f03->sourcefile~fdist2d_class.f03 sourcefile~field2d_class.f03 field2d_class.f03 sourcefile~species2d_class.f03->sourcefile~field2d_class.f03 sourcefile~parallel_class.f03 parallel_class.f03 sourcefile~parallel_pipe_class.f03->sourcefile~parallel_class.f03 sourcefile~field3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field3d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~field3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~field3d_class.f03->sourcefile~perrors_class.f03 sourcefile~ufield3d_class.f03 ufield3d_class.f03 sourcefile~field3d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~hdf5io_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~hdf5io_class.f03->sourcefile~perrors_class.f03 sourcefile~part2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~part2d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~part2d_class.f03->sourcefile~perrors_class.f03 sourcefile~part2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~part2d_class.f03->sourcefile~fdist2d_class.f03 sourcefile~ufield2d_class.f03 ufield2d_class.f03 sourcefile~part2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~part2d_lib.f03 part2d_lib.f03 sourcefile~part2d_class.f03->sourcefile~part2d_lib.f03 sourcefile~spect3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~spect3d_class.f03->sourcefile~perrors_class.f03 sourcefile~spect3d_class.f03->sourcefile~spect2d_class.f03 sourcefile~perrors_class.f03->sourcefile~parallel_class.f03 sourcefile~spect2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~spect2d_class.f03->sourcefile~perrors_class.f03 sourcefile~fdist2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~fdist2d_class.f03->sourcefile~perrors_class.f03 sourcefile~fdist2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~fdist2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~input_class.f03 input_class.f03 sourcefile~fdist2d_class.f03->sourcefile~input_class.f03 sourcefile~field2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field2d_class.f03->sourcefile~field3d_class.f03 sourcefile~field2d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~field2d_class.f03->sourcefile~perrors_class.f03 sourcefile~field2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~field2d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~field2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~fpois2d_class.f03 fpois2d_class.f03 sourcefile~field2d_class.f03->sourcefile~fpois2d_class.f03 sourcefile~fft2d_class.f03 fft2d_class.f03 sourcefile~field2d_class.f03->sourcefile~fft2d_class.f03 sourcefile~ufield3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~ufield3d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~ufield3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~ufield3d_class.f03->sourcefile~perrors_class.f03 sourcefile~ufield3d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~ufield3d_lib.f03 ufield3d_lib.f03 sourcefile~ufield3d_class.f03->sourcefile~ufield3d_lib.f03 sourcefile~ufield2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~ufield2d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~ufield2d_class.f03->sourcefile~perrors_class.f03 sourcefile~ufield2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~ufield2d_lib.f03 ufield2d_lib.f03 sourcefile~ufield2d_class.f03->sourcefile~ufield2d_lib.f03 sourcefile~input_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~input_class.f03->sourcefile~spect3d_class.f03 sourcefile~input_class.f03->sourcefile~perrors_class.f03 sourcefile~input_class.f03->sourcefile~parallel_class.f03 sourcefile~fpois2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~fpois2d_class.f03->sourcefile~perrors_class.f03 sourcefile~fpois2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~fpois2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~fpois2d_lib.f03 fpois2d_lib.f03 sourcefile~fpois2d_class.f03->sourcefile~fpois2d_lib.f03 sourcefile~fft2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~fft2d_class.f03->sourcefile~perrors_class.f03 sourcefile~fft2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~fft2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~fft2d_lib.f03 fft2d_lib.f03 sourcefile~fft2d_class.f03->sourcefile~fft2d_lib.f03 var pansourcefilespecies2d_classf03EfferentGraph = svgPanZoom('#sourcefilespecies2d_classf03EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~species2d_class.f03~~AfferentGraph sourcefile~species2d_class.f03 species2d_class.f03 sourcefile~simulation_class.f03 simulation_class.f03 sourcefile~simulation_class.f03->sourcefile~species2d_class.f03 sourcefile~main.f03 main.f03 sourcefile~main.f03->sourcefile~simulation_class.f03 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules species2d_class Source Code species2d_class.f03 Source Code ! species2d class for QuickPIC Open Source 1.0 ! update: 04/18/2016 module species2d_class use perrors_class use parallel_pipe_class use spect2d_class use spect3d_class use fdist2d_class use field2d_class use field3d_class use part2d_class use hdf5io_class implicit none private public :: species2d type species2d private class ( spect2d ), pointer , public :: sp => null () class ( perrors ), pointer , public :: err => null () class ( parallel_pipe ), pointer , public :: p => null () class ( part2d ), pointer :: pd => null () class ( field2d ), pointer :: q => null (), qn => null (), cu => null () class ( field2d ), pointer :: amu => null (), dcu => null () class ( field3d ), pointer :: q3 => null () class ( fdist2d ), pointer :: pf => null () contains generic :: new => init_species2d generic :: renew => renew_species2d generic :: del => end_species2d generic :: qdp => qdp_species2d generic :: amjdp => amjdp_species2d generic :: push => push_species2d generic :: pmv => pmove_species2d generic :: extpsi => extpsi_species2d generic :: pcp => pcp_species2d generic :: pcb => pcb_species2d generic :: psend => psend_species2d generic :: precv => precv_species2d generic :: wr => writehdf5_species2d generic :: wrq => writeq_species2d , writeqslice_species2d generic :: cbq => cbq_species2d procedure , private :: init_species2d , renew_species2d procedure , private :: end_species2d procedure , private :: qdp_species2d procedure , private :: amjdp_species2d procedure , private :: push_species2d procedure , private :: pmove_species2d procedure , private :: extpsi_species2d procedure , private :: pcp_species2d procedure , private :: pcb_species2d procedure , private :: psend_species2d procedure , private :: precv_species2d , writehdf5_species2d procedure , private :: cbq_species2d , writeq_species2d , writeqslice_species2d end type save character ( len = 10 ) :: class = 'species2d:' character ( len = 128 ) :: erstr contains ! subroutine init_species2d ( this , pp , perr , psp , pf , qbm , dt , ci , xdim , s ) implicit none class ( species2d ), intent ( inout ) :: this class ( spect3d ), intent ( in ), pointer :: psp class ( perrors ), intent ( in ), pointer :: perr class ( parallel_pipe ), intent ( in ), pointer :: pp class ( fdist2d ), intent ( inout ), target :: pf real , intent ( in ) :: qbm , dt , ci , s integer , intent ( in ) :: xdim ! local data character ( len = 18 ), save :: sname = 'init_species2d:' this % sp => psp this % err => perr this % p => pp this % pf => pf call this % err % werrfl2 ( class // sname // ' started' ) allocate ( this % pd , this % q , this % qn , this % cu , this % amu , this % dcu , this % q3 ) call this % q % new ( this % p , this % err , this % sp , dim = 1 , fftflag = . true .) call this % q3 % new ( this % p , this % err , psp , dim = 1 ) call this % qn % new ( this % p , this % err , this % sp , dim = 1 , fftflag = . false .) call this % cu % new ( this % p , this % err , this % sp , dim = 3 , fftflag = . false .) call this % dcu % new ( this % p , this % err , this % sp , dim = 2 , fftflag = . false .) call this % amu % new ( this % p , this % err , this % sp , dim = 3 , fftflag = . false .) call this % pd % new ( pp , perr , this % sp , pf , this % q % getrs (), qbm , dt , ci , xdim , s ) call this % qn % as ( 0.0 ) call this % cu % as ( 0.0 ) call this % pd % qdp ( this % qn % getrs ()) call this % qn % ag () call this % q % as ( this % qn ) if ( this % p % getstageid () == 0 ) then call this % q % fftrk ( 1 ) call this % q % smooth ( this % q ) call this % q % fftkr ( 1 ) call this % q % cb ( this % q3 , 1 ,( / 1 / ),( / 1 / )) end if call this % qn % mult ( this % qn , - 1.0 ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine init_species2d ! subroutine end_species2d ( this ) implicit none class ( species2d ), intent ( inout ) :: this character ( len = 18 ), save :: sname = 'end_species2d:' call this % err % werrfl2 ( class // sname // ' started' ) call this % pd % del () call this % q % del () call this % qn % del () call this % cu % del () call this % dcu % del () call this % amu % del () call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine end_species2d ! subroutine renew_species2d ( this , s ) implicit none class ( species2d ), intent ( inout ) :: this real , intent ( in ) :: s ! local data character ( len = 18 ), save :: sname = 'renew_species2d:' call this % err % werrfl2 ( class // sname // ' started' ) call this % pd % renew ( this % pf , this % qn % getrs (), s ) call this % qn % as ( 0.0 ) call this % pd % qdp ( this % qn % getrs ()) call this % qn % ag () call this % q % as ( this % qn ) if ( this % p % getstageid () == 0 ) then call this % q % fftrk ( 1 ) call this % q % smooth ( this % q ) call this % q % fftkr ( 1 ) call this % q % cb ( this % q3 , 1 ,( / 1 / ),( / 1 / )) end if call this % qn % mult ( this % qn , - 1.0 ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine renew_species2d ! subroutine qdp_species2d ( this , q ) ! deposit the charge density implicit none class ( species2d ), intent ( in ) :: this class ( field2d ), intent ( inout ) :: q ! local data character ( len = 18 ), save :: sname = 'qdp_species2d:' call this % err % werrfl2 ( class // sname // ' started' ) call this % q % as ( 0.0 ) call this % pd % qdp ( this % q % getrs ()) call this % q % ag () call q % add ( this % q , q ) call q % add ( this % qn , q ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine qdp_species2d ! subroutine amjdp_species2d ( this , ef , bf , psit , cu , amu , dcu , dex ) ! deposit the current, acceleration and momentum flux implicit none class ( species2d ), intent ( inout ) :: this class ( field2d ), intent ( inout ) :: cu , amu , dcu class ( field2d ), intent ( in ) :: ef , bf , psit real , intent ( in ) :: dex ! local data character ( len = 18 ), save :: sname = 'amjdp_species2d' call this % err % werrfl2 ( class // sname // ' started' ) call this % cu % as ( 0.0 ) call this % dcu % as ( 0.0 ) call this % amu % as ( 0.0 ) call this % pd % amjdp ( ef % getrs (), bf % getrs (), psit % getrs (), this % cu % getrs (),& & this % amu % getrs (), this % dcu % getrs (), dex ) call this % cu % ag () call this % dcu % ag () call this % amu % ag () call cu % add ( this % cu , cu ) call dcu % add ( this % dcu , dcu ) call amu % add ( this % amu , amu ) call this % cu % mult ( this % cu , dex ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine amjdp_species2d ! subroutine push_species2d ( this , ef , bf , psit , dex ) implicit none class ( species2d ), intent ( inout ) :: this class ( field2d ), intent ( in ) :: ef , bf , psit real , intent ( in ) :: dex ! local data character ( len = 18 ), save :: sname = 'push_species2d' call this % err % werrfl2 ( class // sname // ' started' ) call this % pd % push ( ef % getrs (), bf % getrs (), psit % getrs (), dex ) call this % pmv ( psit ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine push_species2d ! subroutine pmove_species2d ( this , fd ) implicit none class ( species2d ), intent ( inout ) :: this class ( field2d ), intent ( in ) :: fd ! local data character ( len = 18 ), save :: sname = 'pmove_species2d:' call this % err % werrfl2 ( class // sname // ' started' ) call this % pd % pmv ( this % q % getrs ()) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine pmove_species2d ! subroutine extpsi_species2d ( this , psi , dex ) implicit none class ( species2d ), intent ( inout ) :: this class ( field2d ), intent ( in ) :: psi real , intent ( in ) :: dex ! local data character ( len = 18 ), save :: sname = 'extpsi_species2d:' call this % err % werrfl2 ( class // sname // ' started' ) call this % pd % extpsi ( psi % getrs (), dex ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine extpsi_species2d ! subroutine pcp_species2d ( this , fd ) implicit none class ( species2d ), intent ( inout ) :: this class ( field2d ), intent ( in ) :: fd ! local data character ( len = 18 ), save :: sname = 'pcp_species2d:' call this % err % werrfl2 ( class // sname // ' started' ) call this % pd % pcp ( fd % getrs ()) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine pcp_species2d ! subroutine pcb_species2d ( this ) implicit none class ( species2d ), intent ( inout ) :: this ! local data character ( len = 18 ), save :: sname = 'pcb_species2d:' call this % err % werrfl2 ( class // sname // ' started' ) call this % pd % pcb () call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine pcb_species2d ! subroutine psend_species2d ( this , tag , id ) implicit none class ( species2d ), intent ( inout ) :: this integer , intent ( in ) :: tag integer , intent ( inout ) :: id ! local data character ( len = 18 ), save :: sname = 'pipesend_part2d:' call this % err % werrfl2 ( class // sname // ' started' ) call this % pd % psend ( tag , id ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine psend_species2d ! subroutine precv_species2d ( this , tag ) implicit none class ( species2d ), intent ( inout ) :: this integer , intent ( in ) :: tag ! local data character ( len = 18 ), save :: sname = 'precv_species2d:' call this % err % werrfl2 ( class // sname // ' started' ) call this % pd % precv ( this % q % getrs (), tag ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine precv_species2d ! subroutine writehdf5_species2d ( this , file , delta ) implicit none class ( species2d ), intent ( inout ) :: this class ( hdf5file ), intent ( in ) :: file real , dimension ( 2 ), intent ( in ) :: delta ! local data character ( len = 18 ), save :: sname = 'writehdf5_species2d:' call this % err % werrfl2 ( class // sname // ' started' ) call this % pd % wr ( file , delta ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine writehdf5_species2d ! subroutine writeq_species2d ( this , file , rtag , stag , id ) implicit none class ( species2d ), intent ( inout ) :: this class ( hdf5file ), intent ( in ) :: file integer , intent ( in ) :: rtag , stag integer , intent ( inout ) :: id ! local data character ( len = 18 ), save :: sname = 'writeq_species2d:' call this % err % werrfl2 ( class // sname // ' started' ) call this % q3 % wr ( file , 1 , rtag , stag , id ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine writeq_species2d ! subroutine writeqslice_species2d ( this , file , slice , spos , rtag , stag , id ) implicit none class ( species2d ), intent ( inout ) :: this class ( hdf5file ), intent ( in ) :: file integer , intent ( in ) :: rtag , stag , slice , spos integer , intent ( inout ) :: id ! local data character ( len = 18 ), save :: sname = 'writeqslice_species2d:' call this % err % werrfl2 ( class // sname // ' started' ) call this % q3 % wr ( file , 1 , slice , spos , rtag , stag , id ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine writeqslice_species2d ! subroutine cbq_species2d ( this , pos ) implicit none class ( species2d ), intent ( inout ) :: this integer , intent ( in ) :: pos ! local data character ( len = 18 ), save :: sname = 'cpq_species2d:' call this % err % werrfl2 ( class // sname // ' started' ) call this % q % add ( this % q , this % cu ,( / 1 / ),( / 1 / ),( / 3 / )) call this % q % fftrk ( 1 ) call this % q % smooth ( this % q ) call this % q % fftkr ( 1 ) call this % q % cb ( this % q3 , pos ,( / 1 / ),( / 1 / )) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine cbq_species2d ! end module species2d_class","tags":"","loc":"sourcefile/species2d_class.f03.html"},{"title":"parallel_pipe_class.f03 – QuickPIC","text":"This file depends on sourcefile~~parallel_pipe_class.f03~~EfferentGraph sourcefile~parallel_pipe_class.f03 parallel_pipe_class.f03 sourcefile~parallel_class.f03 parallel_class.f03 sourcefile~parallel_pipe_class.f03->sourcefile~parallel_class.f03 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~parallel_pipe_class.f03~~AfferentGraph sourcefile~parallel_pipe_class.f03 parallel_pipe_class.f03 sourcefile~fdist3d_class.f03 fdist3d_class.f03 sourcefile~fdist3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~spect3d_class.f03 spect3d_class.f03 sourcefile~fdist3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~ufield3d_class.f03 ufield3d_class.f03 sourcefile~fdist3d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~input_class.f03 input_class.f03 sourcefile~fdist3d_class.f03->sourcefile~input_class.f03 sourcefile~field3d_class.f03 field3d_class.f03 sourcefile~field3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~hdf5io_class.f03 hdf5io_class.f03 sourcefile~field3d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~field3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~field3d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~hdf5io_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~spect3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~spect2d_class.f03 spect2d_class.f03 sourcefile~spect3d_class.f03->sourcefile~spect2d_class.f03 sourcefile~simulation_class.f03 simulation_class.f03 sourcefile~simulation_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~simulation_class.f03->sourcefile~fdist3d_class.f03 sourcefile~simulation_class.f03->sourcefile~field3d_class.f03 sourcefile~simulation_class.f03->sourcefile~hdf5io_class.f03 sourcefile~simulation_class.f03->sourcefile~spect3d_class.f03 sourcefile~simulation_class.f03->sourcefile~spect2d_class.f03 sourcefile~simulation_class.f03->sourcefile~input_class.f03 sourcefile~fdist2d_class.f03 fdist2d_class.f03 sourcefile~simulation_class.f03->sourcefile~fdist2d_class.f03 sourcefile~field2d_class.f03 field2d_class.f03 sourcefile~simulation_class.f03->sourcefile~field2d_class.f03 sourcefile~species2d_class.f03 species2d_class.f03 sourcefile~simulation_class.f03->sourcefile~species2d_class.f03 sourcefile~beam3d_class.f03 beam3d_class.f03 sourcefile~simulation_class.f03->sourcefile~beam3d_class.f03 sourcefile~ufield3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~ufield3d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~ufield3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~ufield2d_class.f03 ufield2d_class.f03 sourcefile~ufield3d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~part3d_class.f03 part3d_class.f03 sourcefile~part3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~part3d_class.f03->sourcefile~fdist3d_class.f03 sourcefile~part3d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~part3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~part3d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~part2d_class.f03 part2d_class.f03 sourcefile~part2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~part2d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~part2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~part2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~part2d_class.f03->sourcefile~fdist2d_class.f03 sourcefile~ufield2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~ufield2d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~ufield2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~spect2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~input_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~input_class.f03->sourcefile~spect3d_class.f03 sourcefile~fpois2d_class.f03 fpois2d_class.f03 sourcefile~fpois2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~fpois2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~fpois2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~fdist2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~fdist2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~fdist2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~fdist2d_class.f03->sourcefile~input_class.f03 sourcefile~field2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~field2d_class.f03->sourcefile~field3d_class.f03 sourcefile~field2d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~field2d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~field2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~field2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~field2d_class.f03->sourcefile~fpois2d_class.f03 sourcefile~fft2d_class.f03 fft2d_class.f03 sourcefile~field2d_class.f03->sourcefile~fft2d_class.f03 sourcefile~species2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~species2d_class.f03->sourcefile~field3d_class.f03 sourcefile~species2d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~species2d_class.f03->sourcefile~spect3d_class.f03 sourcefile~species2d_class.f03->sourcefile~part2d_class.f03 sourcefile~species2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~species2d_class.f03->sourcefile~fdist2d_class.f03 sourcefile~species2d_class.f03->sourcefile~field2d_class.f03 sourcefile~beam3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~beam3d_class.f03->sourcefile~fdist3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~field3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~beam3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~part3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~field2d_class.f03 sourcefile~fft2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~fft2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~fft2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~main.f03 main.f03 sourcefile~main.f03->sourcefile~simulation_class.f03 var pansourcefileparallel_pipe_classf03AfferentGraph = svgPanZoom('#sourcefileparallel_pipe_classf03AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules parallel_pipe_class Source Code parallel_pipe_class.f03 Source Code ! Parallel class with pipelines for QuickPIC Open Source 1.0 ! update: 04/18/2016 module parallel_pipe_class use mpi use parallel_class implicit none private public :: parallel_pipe type , extends ( parallel ) :: parallel_pipe private ! nstage: number of pipeline stages ! stageid: pipeline stage id ! lidproc: local processor id ! lkstrt: idproc+1 ! lgrp = local pipeline stage communicator ! lnvp = number of MPI nodes in the local pipeline stage integer :: nstage = 1 integer :: stageid = 0 integer :: lidproc integer :: lkstrt integer :: lgrp integer :: lnvp contains procedure :: getnstage procedure :: getstageid procedure :: getlidproc procedure :: getlkstrt procedure :: getlgrp procedure :: getlnvp procedure , private :: init_parallel_pipe generic :: new => init_parallel_pipe end type parallel_pipe ! used by f77 subroutines integer :: nproc , lgrp , mreal , mint , mcplx , mdouble , lworld common / PPARMS / nproc , lgrp , mreal , mint , mcplx , mdouble , lworld contains ! function getlidproc ( this ) implicit none class ( parallel_pipe ), intent ( in ) :: this integer :: getlidproc getlidproc = this % lidproc end function getlidproc ! function getlkstrt ( this ) implicit none class ( parallel_pipe ), intent ( in ) :: this integer :: getlkstrt getlkstrt = this % lkstrt end function getlkstrt ! function getlgrp ( this ) implicit none class ( parallel_pipe ), intent ( in ) :: this integer :: getlgrp getlgrp = this % lgrp end function getlgrp ! function getlnvp ( this ) implicit none class ( parallel_pipe ), intent ( in ) :: this integer :: getlnvp getlnvp = this % lnvp end function getlnvp ! function getnstage ( this ) implicit none class ( parallel_pipe ), intent ( in ) :: this integer :: getnstage getnstage = this % nstage end function getnstage ! function getstageid ( this ) implicit none class ( parallel_pipe ), intent ( in ) :: this integer :: getstageid getstageid = this % stageid end function getstageid ! subroutine init_parallel_pipe ( this , nst ) implicit none class ( parallel_pipe ), intent ( inout ) :: this integer , intent ( in ) :: nst ! local data integer :: ierror integer :: idproc , llworld , nvp integer :: lnvp , stageid , lidproc , llgrp call this % parallel % new idproc = this % getidproc () llworld = this % getlworld () nvp = this % getnvp () lnvp = nvp / nst this % nstage = nst lidproc = mod ( idproc , lnvp ) stageid = int ( idproc / lnvp ) call MPI_COMM_SPLIT ( llworld , stageid , lidproc , llgrp , ierror ) call MPI_COMM_RANK ( llgrp , this % lidproc , ierror ) call MPI_COMM_SIZE ( llgrp , this % lnvp , ierror ) this % stageid = stageid this % lgrp = llgrp this % lkstrt = this % lidproc + 1 nproc = lnvp lgrp = llgrp lworld = llworld mreal = this % getmreal () mint = this % getmint () mcplx = this % getmcplx () mdouble = this % getmdouble () end subroutine init_parallel_pipe ! end module parallel_pipe_class","tags":"","loc":"sourcefile/parallel_pipe_class.f03.html"},{"title":"ufield2d_class.f03 – QuickPIC","text":"This file depends on sourcefile~~ufield2d_class.f03~~EfferentGraph sourcefile~ufield2d_class.f03 ufield2d_class.f03 sourcefile~parallel_pipe_class.f03 parallel_pipe_class.f03 sourcefile~ufield2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~ufield2d_lib.f03 ufield2d_lib.f03 sourcefile~ufield2d_class.f03->sourcefile~ufield2d_lib.f03 sourcefile~hdf5io_class.f03 hdf5io_class.f03 sourcefile~ufield2d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~perrors_class.f03 perrors_class.f03 sourcefile~ufield2d_class.f03->sourcefile~perrors_class.f03 sourcefile~spect2d_class.f03 spect2d_class.f03 sourcefile~ufield2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~parallel_class.f03 parallel_class.f03 sourcefile~parallel_pipe_class.f03->sourcefile~parallel_class.f03 sourcefile~hdf5io_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~hdf5io_class.f03->sourcefile~perrors_class.f03 sourcefile~perrors_class.f03->sourcefile~parallel_class.f03 sourcefile~spect2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~spect2d_class.f03->sourcefile~perrors_class.f03 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~ufield2d_class.f03~~AfferentGraph sourcefile~ufield2d_class.f03 ufield2d_class.f03 sourcefile~ufield3d_class.f03 ufield3d_class.f03 sourcefile~ufield3d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~part2d_class.f03 part2d_class.f03 sourcefile~part2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~fdist2d_class.f03 fdist2d_class.f03 sourcefile~part2d_class.f03->sourcefile~fdist2d_class.f03 sourcefile~fpois2d_class.f03 fpois2d_class.f03 sourcefile~fpois2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~fdist2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~field2d_class.f03 field2d_class.f03 sourcefile~field2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~field2d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~field2d_class.f03->sourcefile~fpois2d_class.f03 sourcefile~fft2d_class.f03 fft2d_class.f03 sourcefile~field2d_class.f03->sourcefile~fft2d_class.f03 sourcefile~field3d_class.f03 field3d_class.f03 sourcefile~field2d_class.f03->sourcefile~field3d_class.f03 sourcefile~fft2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~fdist3d_class.f03 fdist3d_class.f03 sourcefile~fdist3d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~field3d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~simulation_class.f03 simulation_class.f03 sourcefile~simulation_class.f03->sourcefile~fdist2d_class.f03 sourcefile~simulation_class.f03->sourcefile~field2d_class.f03 sourcefile~simulation_class.f03->sourcefile~fdist3d_class.f03 sourcefile~simulation_class.f03->sourcefile~field3d_class.f03 sourcefile~species2d_class.f03 species2d_class.f03 sourcefile~simulation_class.f03->sourcefile~species2d_class.f03 sourcefile~beam3d_class.f03 beam3d_class.f03 sourcefile~simulation_class.f03->sourcefile~beam3d_class.f03 sourcefile~part3d_class.f03 part3d_class.f03 sourcefile~part3d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~part3d_class.f03->sourcefile~fdist3d_class.f03 sourcefile~species2d_class.f03->sourcefile~part2d_class.f03 sourcefile~species2d_class.f03->sourcefile~fdist2d_class.f03 sourcefile~species2d_class.f03->sourcefile~field2d_class.f03 sourcefile~species2d_class.f03->sourcefile~field3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~field2d_class.f03 sourcefile~beam3d_class.f03->sourcefile~fdist3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~field3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~part3d_class.f03 sourcefile~main.f03 main.f03 sourcefile~main.f03->sourcefile~simulation_class.f03 var pansourcefileufield2d_classf03AfferentGraph = svgPanZoom('#sourcefileufield2d_classf03AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules ufield2d_class Source Code ufield2d_class.f03 Source Code ! ufield2d class for QuickPIC Open Source 1.0 ! update: 04/18/2016 module ufield2d_class use perrors_class use parallel_pipe_class use spect2d_class use ufield2d_lib use hdf5io_class use mpi implicit none private public :: ufield2d type ufield2d private ! layout values: XLOCAL = xy = 0, YLOCAL = yx = 1 ! dim = dimension of the field ! nd1, nd2 = size of global array data in each dimension ! nvpx, nvpy = number of processors in each dimension ! nd1p, nd2p = size of local array data in each dimension (without guardcell) ! rf = pointer of the local 2d field array ! noff = smallest global gridpoint in y ! class ( spect2d ), pointer , public :: sp => null () class ( perrors ), pointer , public :: err => null () class ( parallel_pipe ), pointer , public :: p => null () integer :: layout , dim , noff integer :: nd1 , nvpx , nd1p integer :: nd2 , nvpy , nd2p real , dimension (:,:,:), pointer :: rf => null (), buff => null () contains generic :: new => init_ufield2d , init_ufield2d_k generic :: del => end_ufield2d generic :: cg => copyguard generic :: ag => acopyguard generic :: wr => writehdf5 generic :: psend => pipesend_ufield2d generic :: precv => piperecv_ufield2d !         generic :: assignment(=) => asc,asa !         generic :: operator(+) => add !         generic :: operator(*) => mult1 generic :: as => asc , asa generic :: add => sum1 , sum2 generic :: sub => minus1 , minus2 generic :: mult => multiply1 , multiply2 final :: final_ufield2d procedure , private :: init_ufield2d procedure , private :: init_ufield2d_k procedure , private :: end_ufield2d procedure :: getlayout , getdim procedure :: getnd1 , getnvpx , getnd1p procedure :: getnd2 , getnvpy , getnd2p procedure :: getrf , getnoff procedure , private :: copyguard , acopyguard , writehdf5 procedure , private :: pipesend_ufield2d , piperecv_ufield2d procedure , private :: asc , asa , sum1 , multiply1 , multiply2 , minus1 procedure , private :: sum2 , minus2 !         procedure, private :: asc,asa,add,mult1 end type character ( len = 10 ), save :: class = 'ufield2d:' character ( len = 128 ), save :: erstr ! scr = guard cell buffer received from nearby processors real , dimension (:), allocatable , save :: scr integer , save :: szscr = 0 contains ! subroutine init_ufield2d ( this , pp , perr , psp , dim , layout , nvpx , nvpy ) implicit none class ( ufield2d ), intent ( inout ) :: this integer , intent ( in ) :: layout , dim integer , intent ( in ) :: nvpx , nvpy class ( spect2d ), intent ( in ), pointer :: psp class ( perrors ), intent ( in ), pointer :: perr class ( parallel_pipe ), intent ( in ), pointer :: pp ! local data character ( len = 18 ), save :: sname = 'init_ufield2d:' integer :: nd1 , nd2 call perr % werrfl2 ( class // sname // ' started' ) this % sp => psp this % err => perr this % p => pp this % layout = layout this % dim = dim nd1 = 2 ** psp % getindx () nd2 = 2 ** psp % getindy () select case ( layout ) case ( 0 ) this % nd1 = nd1 this % nd2 = nd2 case ( 1 ) this % nd1 = nd2 this % nd2 = nd1 case default write ( erstr , * ) 'invalid layout = ' , layout call this % err % equit ( class // sname // erstr ) return end select ! make sure data is a multiple of the number of processors if (((( this % nd2 / nvpy ) * nvpy ) /= this % nd2 ) . and . ((( nvpy / this % nd2 ) * & & this % nd2 ) /= nvpy )) then write ( erstr , * ) 'data, proc number not multiples:' , this % nd2 & &, nvpy call this % err % equit ( class // sname // erstr ) return endif ! save number of processors in each dimension this % nvpx = 0 this % nvpy = nvpy select case ( layout ) case ( 0 ) this % nd1p = nd1 this % nd2p = nd2 / nvpy this % noff = ( pp % getlkstrt () - 1 ) * nd2 / nvpy allocate ( this % rf ( dim , this % nd1p + 2 , this % nd2p * 2 + psp % getinorder ())) this % rf (:,:,:) = 0.0 case ( 1 ) this % nd1p = nd2 / nvpy this % nd2p = nd1 this % noff = ( pp % getlkstrt () - 1 ) * nd2 / nvpy allocate ( this % rf ( dim , this % nd2p , this % nd1p + psp % getinorder ())) this % rf (:,:,:) = 0.0 case default write ( erstr , * ) 'invalid layout = ' , layout call this % err % equit ( class // sname // erstr ) return end select call perr % werrfl2 ( class // sname // ' ended' ) end subroutine init_ufield2d ! subroutine init_ufield2d_k ( this , pp , perr , psp , dim , layout , nd1 , nd2 , nvpx , nvpy ) implicit none class ( ufield2d ), intent ( inout ) :: this integer , intent ( in ) :: layout , dim integer , intent ( in ) :: nvpx , nvpy class ( spect2d ), intent ( in ), pointer :: psp class ( perrors ), intent ( in ), pointer :: perr class ( parallel_pipe ), intent ( in ), pointer :: pp integer , intent ( in ) :: nd1 , nd2 ! local data character ( len = 18 ), save :: sname = 'init_ufield2d_k:' call perr % werrfl2 ( class // sname // ' started' ) this % sp => psp this % err => perr this % p => pp this % layout = layout this % dim = dim select case ( layout ) case ( 0 ) this % nd1 = nd1 this % nd2 = nd2 case ( 1 ) this % nd1 = nd2 this % nd2 = nd1 case default write ( erstr , * ) 'invalid layout = ' , layout call this % err % equit ( class // sname // erstr ) return end select ! make sure data is a multiple of the number of processors if (((( this % nd2 / nvpy ) * nvpy ) /= this % nd2 ) . and . ((( nvpy / this % nd2 ) * & & this % nd2 ) /= nvpy )) then write ( erstr , * ) 'data, proc number not multiples:' , this % nd2 & &, nvpy call this % err % equit ( class // sname // erstr ) return endif ! save number of processors in each dimension this % nvpx = 0 this % nvpy = nvpy select case ( layout ) case ( 0 ) this % nd1p = nd1 this % nd2p = nd2 / nvpy allocate ( this % rf ( dim , this % nd1p , this % nd2p )) this % rf (:,:,:) = 0.0 case ( 1 ) this % nd1p = nd2 this % nd2p = ( nd1 - 1 ) / nvpy + 1 allocate ( this % rf ( dim , this % nd1p + 1 , this % nd2p + 1 )) this % rf (:,:,:) = 0.0 case default write ( erstr , * ) 'invalid layout = ' , layout call this % err % equit ( class // sname // erstr ) return end select call perr % werrfl2 ( class // sname // ' ended' ) end subroutine init_ufield2d_k ! subroutine end_ufield2d ( this ) implicit none class ( ufield2d ), intent ( inout ) :: this ! local data character ( len = 18 ), save :: sname = 'end_ufield2d:' call this % err % werrfl2 ( class // sname // ' started' ) if ( associated ( this % rf )) deallocate ( this % rf ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine end_ufield2d ! subroutine final_ufield2d ( this ) implicit none type ( ufield2d ), intent ( inout ) :: this ! local data character ( len = 18 ), save :: sname = 'final_ufield2d:' call this % err % werrfl2 ( class // sname // ' started' ) if ( associated ( this % rf )) deallocate ( this % rf ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine final_ufield2d ! function getlayout ( this ) implicit none class ( ufield2d ), intent ( in ) :: this integer :: getlayout getlayout = this % layout end function getlayout ! function getnvpy ( this ) implicit none class ( ufield2d ), intent ( in ) :: this integer :: getnvpy getnvpy = this % nvpy end function getnvpy ! function getnvpx ( this ) implicit none class ( ufield2d ), intent ( in ) :: this integer :: getnvpx getnvpx = this % nvpx end function getnvpx ! function getnd2 ( this ) implicit none class ( ufield2d ), intent ( in ) :: this integer :: getnd2 getnd2 = this % nd2 end function getnd2 ! function getnd1 ( this ) implicit none class ( ufield2d ), intent ( in ) :: this integer :: getnd1 getnd1 = this % nd1 end function getnd1 ! function getnd2p ( this ) implicit none class ( ufield2d ), intent ( in ) :: this integer :: getnd2p getnd2p = this % nd2p end function getnd2p ! function getnd1p ( this ) implicit none class ( ufield2d ), intent ( in ) :: this integer :: getnd1p getnd1p = this % nd1p end function getnd1p ! function getdim ( this ) implicit none class ( ufield2d ), intent ( in ) :: this integer :: getdim getdim = this % dim end function getdim ! function getnoff ( this ) implicit none class ( ufield2d ), intent ( in ) :: this integer :: getnoff getnoff = this % noff end function getnoff ! function getrf ( this ) implicit none class ( ufield2d ), intent ( in ) :: this real , dimension (:,:,:), pointer :: getrf getrf => this % rf end function getrf ! subroutine copyguard ( this ) implicit none class ( ufield2d ), intent ( inout ) :: this character ( len = 18 ), save :: sname = 'copyguard' ! local data integer :: nxv , nypmx , nyp call this % err % werrfl2 ( class // sname // ' started' ) nxv = size ( this % rf , 1 ) * size ( this % rf , 2 ) nypmx = size ( this % rf , 3 ) nyp = this % nd2p if ( this % layout /= 0 ) then write ( erstr , * ) 'invalid layout = ' , this % layout call this % err % equit ( class // sname // erstr ); return endif select case ( this % sp % getpsolver ()) case ( 1 ) select case ( this % sp % getinorder ()) case ( 1 ) ! copy data to guard cells in distributed direction call PPNCGUARD2L ( this % rf , nyp , this % p % getlkstrt (), this % p % getlnvp (),& & nxv , nypmx , this % p % getlgrp (), this % p % getmreal ()) case default call PPNCGUARD2L ( this % rf , nyp , this % p % getlkstrt (), this % p % getlnvp (),& & nxv , nypmx , this % p % getlgrp (), this % p % getmreal ()) end select case default call PPNCGUARD2L ( this % rf , nyp , this % p % getlkstrt (), this % p % getlnvp (),& & nxv , nypmx , this % p % getlgrp (), this % p % getmreal ()) end select call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine copyguard ! subroutine acopyguard ( this ) implicit none class ( ufield2d ), intent ( inout ) :: this character ( len = 18 ), save :: sname = 'acopyguard' ! local data integer :: ndim , nxv , nypmx , nyp , nx call this % err % werrfl2 ( class // sname // ' started' ) ndim = size ( this % rf , 1 ) nxv = size ( this % rf , 2 ) nypmx = size ( this % rf , 3 ) nyp = this % nd2p nx = this % nd1 if ( szscr < ndim * nxv ) then if ( szscr /= 0 ) deallocate ( scr ) ! allocate new buffer allocate ( scr ( ndim * nxv )) szscr = ndim * nxv endif if ( this % layout /= 0 ) then write ( erstr , * ) 'invalid layout = ' , this % layout call this % err % equit ( class // sname // erstr ); return endif select case ( this % sp % getpsolver ()) case ( 1 ) select case ( this % sp % getinorder ()) case ( 1 ) ! copy data to guard cells in distributed direction call PPNACGUARD2L ( this % rf , scr , nyp , nx , ndim , this % p % getlkstrt (),& & this % p % getlnvp (), nxv , nypmx , this % p % getlgrp (), this % p % getmreal ()) case default call PPNACGUARD2L ( this % rf , scr , nyp , nx , ndim , this % p % getlkstrt (),& & this % p % getlnvp (), nxv , nypmx , this % p % getlgrp (), this % p % getmreal ()) end select case default call PPNACGUARD2L ( this % rf , scr , nyp , nx , ndim , this % p % getlkstrt (),& & this % p % getlnvp (), nxv , nypmx , this % p % getlgrp (), this % p % getmreal ()) end select call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine acopyguard ! subroutine writehdf5 ( this , file , dim ) implicit none class ( ufield2d ), intent ( inout ) :: this class ( hdf5file ), intent ( in ) :: file integer , intent ( in ) :: dim ! local data integer , dimension ( 2 ) :: gsize , lsize integer :: noff integer :: ierr real , dimension (:,:), pointer :: fdata character ( len = 10 ), save :: sname = 'writehdf5:' call this % err % werrfl2 ( class // sname // ' started' ) noff = this % noff gsize = ( / this % nd1 , this % nd2 / ) lsize = ( / this % nd1p , this % nd2p / ) call pwfield ( this % p , this % err , file , this % rf ( dim ,:,:), gsize , lsize ,& & noff , ierr ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine writehdf5 ! subroutine pipesend_ufield2d ( this , stag , id ) implicit none class ( ufield2d ), intent ( inout ) :: this integer , intent ( in ) :: stag integer , intent ( inout ) :: id ! local data character ( len = 18 ), save :: sname = 'pipesend_ufield2d:' integer :: bsize , i , j , k , des , ierr call this % err % werrfl2 ( class // sname // ' started' ) des = this % p % getidproc () + this % p % getlnvp () if ( des >= this % p % getnvp ()) then id = MPI_REQUEST_NULL call this % err % werrfl2 ( class // sname // ' ended' ) return endif if (. not . associated ( this % buff )) then select case ( this % layout ) case ( 0 ) allocate ( this % buff ( this % dim , this % nd1p + 2 , this % nd2p + this % sp % getinorder ())) case ( 1 ) allocate ( this % buff ( this % dim , this % nd1p + 1 , this % nd2p + 1 )) end select endif bsize = size ( this % buff ) !$OMP PARALLEL DO PRIVATE(i,j,k) do i = 1 , size ( this % buff , 1 ) do j = 1 , size ( this % buff , 2 ) do k = 1 , size ( this % buff , 3 ) this % buff ( i , j , k ) = this % rf ( i , j , k ) enddo enddo enddo !$OMP END PARALLEL DO call MPI_ISEND ( this % buff , bsize , this % p % getmreal (), des ,& & stag , this % p % getlworld (), id , ierr ) ! check for errors if ( ierr /= 0 ) then write ( erstr , * ) 'MPI_ISEND failed' call this % err % equit ( class // sname // erstr ); return endif call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine pipesend_ufield2d ! subroutine piperecv_ufield2d ( this , rtag ) implicit none class ( ufield2d ), intent ( inout ) :: this integer , intent ( in ) :: rtag ! local data character ( len = 18 ), save :: sname = 'piperecv_ufield2d:' integer , dimension ( 10 ) :: istat integer :: bsize , id , i , j , k , des , ierr call this % err % werrfl2 ( class // sname // ' started' ) des = this % p % getidproc () - this % p % getlnvp () if ( des < 0 ) then this % rf (:,:,:) = 0.0 call this % err % werrfl2 ( class // sname // ' ended' ) return endif !         if (.not.associated(this%buff)) then !            select case (this%layout) !            case (0) !               allocate(this%buff(this%dim,this%nd1p+2,this%nd2p+this%sp%getinorder())) !            case (1) !               allocate(this%buff(this%dim,this%nd2p,this%nd1p+this%sp%getinorder())) !            end select !         endif call MPI_IRECV ( this % rf , size ( this % rf ), this % p % getmreal (), des ,& & rtag , this % p % getlworld (), id , ierr ) call MPI_WAIT ( id , istat , ierr ) ! check for errors if ( ierr /= 0 ) then write ( erstr , * ) 'MPI failed' call this % err % equit ( class // sname // erstr ); return endif call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine piperecv_ufield2d ! subroutine sum1 ( this , a1 , a2 ) implicit none class ( ufield2d ), intent ( inout ) :: this class ( ufield2d ), target , intent ( in ) :: a1 , a2 ! local data character ( len = 18 ), save :: sname = 'sum1:' integer :: i , j , k real , dimension (:,:,:), pointer :: rf1 => null (), rf2 => null (),& & rf3 => null () call this % err % werrfl2 ( class // sname // ' started' ) rf1 => this % rf rf2 => a1 % rf rf3 => a2 % rf !$OMP PARALLEL DO PRIVATE(i,j,k) do k = 1 , size ( rf1 , 3 ) do j = 1 , size ( rf1 , 2 ) do i = 1 , size ( rf1 , 1 ) rf1 ( i , j , k ) = rf2 ( i , j , k ) + rf3 ( i , j , k ) enddo enddo enddo !$OMP END PARALLEL DO call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine sum1 ! subroutine sum2 ( this , a1 , a2 , dim , dim1 , dim2 ) implicit none class ( ufield2d ), intent ( inout ) :: this class ( ufield2d ), target , intent ( in ) :: a1 , a2 integer , dimension (:), intent ( in ) :: dim , dim1 , dim2 ! local data character ( len = 18 ), save :: sname = 'sum2:' integer :: i , j , k real , dimension (:,:,:), pointer :: rf1 => null (), rf2 => null (),& & rf3 => null () call this % err % werrfl2 ( class // sname // ' started' ) rf1 => this % rf rf2 => a1 % rf rf3 => a2 % rf !$OMP PARALLEL DO PRIVATE(i,j,k) do k = 1 , size ( rf1 , 3 ) do j = 1 , size ( rf1 , 2 ) do i = 1 , size ( dim1 ) rf1 ( dim ( i ), j , k ) = rf2 ( dim1 ( i ), j , k ) + rf3 ( dim2 ( i ), j , k ) enddo enddo enddo !$OMP END PARALLEL DO call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine sum2 ! subroutine minus1 ( this , a1 , a2 ) implicit none class ( ufield2d ), intent ( inout ) :: this class ( ufield2d ), target , intent ( in ) :: a1 , a2 ! local data character ( len = 18 ), save :: sname = 'minus1:' integer :: i , j , k real , dimension (:,:,:), pointer :: rf1 => null (), rf2 => null (),& & rf3 => null () call this % err % werrfl2 ( class // sname // ' started' ) rf1 => this % rf rf2 => a1 % rf rf3 => a2 % rf !$OMP PARALLEL DO PRIVATE(i,j,k) do k = 1 , size ( rf1 , 3 ) do j = 1 , size ( rf1 , 2 ) do i = 1 , size ( rf1 , 1 ) rf1 ( i , j , k ) = rf2 ( i , j , k ) - rf3 ( i , j , k ) enddo enddo enddo !$OMP END PARALLEL DO call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine minus1 ! subroutine minus2 ( this , a1 , a2 , dim , dim1 , dim2 ) implicit none class ( ufield2d ), intent ( inout ) :: this class ( ufield2d ), target , intent ( in ) :: a1 , a2 integer , dimension (:), intent ( in ) :: dim , dim1 , dim2 ! local data character ( len = 18 ), save :: sname = 'minus1:' integer :: i , j , k real , dimension (:,:,:), pointer :: rf1 => null (), rf2 => null (),& & rf3 => null () call this % err % werrfl2 ( class // sname // ' started' ) rf1 => this % rf rf2 => a1 % rf rf3 => a2 % rf !$OMP PARALLEL DO PRIVATE(i,j,k) do k = 1 , size ( rf1 , 3 ) do j = 1 , size ( rf1 , 2 ) do i = 1 , size ( dim1 ) rf1 ( dim ( i ), j , k ) = rf2 ( dim1 ( i ), j , k ) - rf3 ( dim2 ( i ), j , k ) enddo enddo enddo !$OMP END PARALLEL DO call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine minus2 ! subroutine multiply1 ( this , a1 , value ) implicit none class ( ufield2d ), intent ( inout ) :: this class ( ufield2d ), target , intent ( in ) :: a1 real , intent ( in ) :: value ! local data character ( len = 18 ), save :: sname = 'multiply1:' integer :: i , j , k real , dimension (:,:,:), pointer :: rf1 => null (), rf2 => null () call this % err % werrfl2 ( class // sname // ' started' ) rf1 => this % rf rf2 => a1 % rf !$OMP PARALLEL DO PRIVATE(i,j,k) do k = 1 , size ( rf1 , 3 ) do j = 1 , size ( rf1 , 2 ) do i = 1 , size ( rf1 , 1 ) rf1 ( i , j , k ) = rf2 ( i , j , k ) * value enddo enddo enddo !$OMP END PARALLEL DO call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine multiply1 ! subroutine multiply2 ( this , a1 , dim , dim1 , value ) implicit none class ( ufield2d ), intent ( inout ) :: this class ( ufield2d ), target , intent ( in ) :: a1 integer , dimension (:), intent ( in ) :: dim , dim1 real , dimension (:), intent ( in ) :: value ! local data character ( len = 18 ), save :: sname = 'multiply2:' integer :: i , j , k real , dimension (:,:,:), pointer :: rf1 => null (), rf2 => null () call this % err % werrfl2 ( class // sname // ' started' ) rf1 => this % rf rf2 => a1 % rf !$OMP PARALLEL DO PRIVATE(i,j,k) do k = 1 , size ( rf1 , 3 ) do j = 1 , size ( rf1 , 2 ) do i = 1 , size ( dim , 1 ) rf1 ( dim ( i ), j , k ) = rf2 ( dim1 ( i ), j , k ) * value ( i ) enddo enddo enddo !$OMP END PARALLEL DO call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine multiply2 ! subroutine asc ( this , value ) implicit none class ( ufield2d ), intent ( inout ) :: this real , intent ( in ) :: value ! local data character ( len = 18 ), save :: sname = 'asc:' integer :: i , j , k real , dimension (:,:,:), pointer :: rf => null () call this % err % werrfl2 ( class // sname // ' started' ) rf => this % rf !$OMP PARALLEL DO PRIVATE(i,j,k) do k = 1 , size ( rf , 3 ) do j = 1 , size ( rf , 2 ) do i = 1 , size ( rf , 1 ) rf ( i , j , k ) = value enddo enddo enddo !$OMP END PARALLEL DO call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine asc ! subroutine asa ( this , that ) implicit none class ( ufield2d ), intent ( inout ) :: this class ( ufield2d ), target , intent ( in ) :: that ! local data character ( len = 18 ), save :: sname = 'asa:' integer :: i , j , k real , dimension (:,:,:), pointer :: rf1 => null (), rf2 => null () call this % err % werrfl2 ( class // sname // ' started' ) rf1 => this % rf rf2 => that % rf !$OMP PARALLEL DO PRIVATE(i,j,k) do k = 1 , size ( rf1 , 3 ) do j = 1 , size ( rf1 , 2 ) do i = 1 , size ( rf1 , 1 ) rf1 ( i , j , k ) = rf2 ( i , j , k ) enddo enddo enddo !$OMP END PARALLEL DO !         deallocate(rf2) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine asa ! function add ( this , that ) implicit none class ( ufield2d ), intent ( in ) :: this , that class ( ufield2d ), allocatable :: add ! local data character ( len = 18 ), save :: sname = 'add:' integer :: i , j , k real , dimension (:,:,:), pointer :: rf1 => null (), rf2 => null (),& & rf3 => null () call this % err % werrfl2 ( class // sname // ' started' ) allocate ( add , source = this ) rf2 => this % rf rf3 => that % rf allocate ( add % rf ( size ( rf2 , 1 ), size ( rf2 , 2 ), size ( rf2 , 3 ))) rf1 => add % rf !$OMP PARALLEL DO PRIVATE(i,j,k) do k = 1 , size ( rf1 , 3 ) do j = 1 , size ( rf1 , 2 ) do i = 1 , size ( rf1 , 1 ) rf1 ( i , j , k ) = rf2 ( i , j , k ) + rf3 ( i , j , k ) enddo enddo enddo !$OMP END PARALLEL DO !         deallocate(add%rf) call this % err % werrfl2 ( class // sname // ' ended' ) end function add ! function mult1 ( this , value ) implicit none class ( ufield2d ), intent ( in ) :: this real , intent ( in ) :: value class ( ufield2d ), allocatable :: mult1 ! local data character ( len = 18 ), save :: sname = 'mult1:' integer :: i , j , k real , dimension (:,:,:), pointer :: rf1 => null (), rf2 => null () call this % err % werrfl2 ( class // sname // ' started' ) allocate ( mult1 , source = this ) rf2 => this % rf allocate ( mult1 % rf ( size ( rf2 , 1 ), size ( rf2 , 2 ), size ( rf2 , 3 ))) rf1 => mult1 % rf !$OMP PARALLEL DO PRIVATE(i,j,k) do k = 1 , size ( rf1 , 3 ) do j = 1 , size ( rf1 , 2 ) do i = 1 , size ( rf1 , 1 ) rf1 ( i , j , k ) = rf2 ( i , j , k ) * value enddo enddo enddo !$OMP END PARALLEL DO call this % err % werrfl2 ( class // sname // ' ended' ) end function mult1 ! function mult2 ( value , this ) implicit none class ( ufield2d ), intent ( in ) :: this real , intent ( in ) :: value class ( ufield2d ), allocatable :: mult2 ! local data character ( len = 18 ), save :: sname = 'mult2:' integer :: i , j , k real , dimension (:,:,:), pointer :: rf1 => null (), rf2 => null () call this % err % werrfl2 ( class // sname // ' started' ) allocate ( mult2 , source = this ) rf2 => this % rf allocate ( mult2 % rf ( size ( rf2 , 1 ), size ( rf2 , 2 ), size ( rf2 , 3 ))) rf1 => mult2 % rf !$OMP PARALLEL DO PRIVATE(i,j,k) do k = 1 , size ( rf1 , 3 ) do j = 1 , size ( rf1 , 2 ) do i = 1 , size ( rf1 , 1 ) rf1 ( i , j , k ) = rf2 ( i , j , k ) * value enddo enddo enddo !$OMP END PARALLEL DO call this % err % werrfl2 ( class // sname // ' ended' ) end function mult2 ! end module ufield2d_class","tags":"","loc":"sourcefile/ufield2d_class.f03.html"},{"title":"field3d_class.f03 – QuickPIC","text":"This file depends on sourcefile~~field3d_class.f03~~EfferentGraph sourcefile~field3d_class.f03 field3d_class.f03 sourcefile~parallel_pipe_class.f03 parallel_pipe_class.f03 sourcefile~field3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~ufield3d_class.f03 ufield3d_class.f03 sourcefile~field3d_class.f03->sourcefile~ufield3d_class.f03 sourcefile~hdf5io_class.f03 hdf5io_class.f03 sourcefile~field3d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~spect3d_class.f03 spect3d_class.f03 sourcefile~field3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~perrors_class.f03 perrors_class.f03 sourcefile~field3d_class.f03->sourcefile~perrors_class.f03 sourcefile~parallel_class.f03 parallel_class.f03 sourcefile~parallel_pipe_class.f03->sourcefile~parallel_class.f03 sourcefile~ufield3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~ufield3d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~ufield3d_class.f03->sourcefile~spect3d_class.f03 sourcefile~ufield3d_class.f03->sourcefile~perrors_class.f03 sourcefile~ufield2d_class.f03 ufield2d_class.f03 sourcefile~ufield3d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~ufield3d_lib.f03 ufield3d_lib.f03 sourcefile~ufield3d_class.f03->sourcefile~ufield3d_lib.f03 sourcefile~hdf5io_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~hdf5io_class.f03->sourcefile~perrors_class.f03 sourcefile~spect3d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~spect3d_class.f03->sourcefile~perrors_class.f03 sourcefile~spect2d_class.f03 spect2d_class.f03 sourcefile~spect3d_class.f03->sourcefile~spect2d_class.f03 sourcefile~perrors_class.f03->sourcefile~parallel_class.f03 sourcefile~ufield2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~ufield2d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~ufield2d_class.f03->sourcefile~perrors_class.f03 sourcefile~ufield2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~ufield2d_lib.f03 ufield2d_lib.f03 sourcefile~ufield2d_class.f03->sourcefile~ufield2d_lib.f03 sourcefile~spect2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~spect2d_class.f03->sourcefile~perrors_class.f03 var pansourcefilefield3d_classf03EfferentGraph = svgPanZoom('#sourcefilefield3d_classf03EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~field3d_class.f03~~AfferentGraph sourcefile~field3d_class.f03 field3d_class.f03 sourcefile~field2d_class.f03 field2d_class.f03 sourcefile~field2d_class.f03->sourcefile~field3d_class.f03 sourcefile~simulation_class.f03 simulation_class.f03 sourcefile~simulation_class.f03->sourcefile~field3d_class.f03 sourcefile~simulation_class.f03->sourcefile~field2d_class.f03 sourcefile~species2d_class.f03 species2d_class.f03 sourcefile~simulation_class.f03->sourcefile~species2d_class.f03 sourcefile~beam3d_class.f03 beam3d_class.f03 sourcefile~simulation_class.f03->sourcefile~beam3d_class.f03 sourcefile~species2d_class.f03->sourcefile~field3d_class.f03 sourcefile~species2d_class.f03->sourcefile~field2d_class.f03 sourcefile~beam3d_class.f03->sourcefile~field3d_class.f03 sourcefile~beam3d_class.f03->sourcefile~field2d_class.f03 sourcefile~main.f03 main.f03 sourcefile~main.f03->sourcefile~simulation_class.f03 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules field3d_class Source Code field3d_class.f03 Source Code ! field3d class for QuickPIC Open Source 1.0 ! update: 04/18/2016 module field3d_class use perrors_class use parallel_pipe_class use spect3d_class use ufield3d_class use hdf5io_class implicit none private public :: field3d type field3d ! gcells = (0,1) = (no, yes) guard cell processing is performed private class ( spect3d ), pointer , public :: sp => null () class ( perrors ), pointer , public :: err => null () class ( parallel_pipe ), pointer , public :: p => null () class ( ufield3d ), pointer :: rs => null () integer :: gcells contains generic :: new => init_field3d generic :: del => end_field3d generic :: pcg => pipecg_field3d generic :: ag => acopyguard_field3d generic :: wr => writehdf5_3d , writehdf5_2dslice generic :: as => asc , asa generic :: add => sum generic :: sub => minus generic :: mult => multiply procedure , private :: init_field3d procedure , private :: end_field3d procedure , private :: pipecg_field3d , acopyguard_field3d procedure , private :: writehdf5_3d , writehdf5_2dslice procedure , private :: asc , asa , sum , minus , multiply procedure :: getgcells , getrs end type character ( len = 10 ), save :: class = 'field3d:' character ( len = 128 ), save :: erstr contains ! subroutine init_field3d ( this , pp , perr , psp , dim ) implicit none class ( field3d ), intent ( inout ) :: this class ( spect3d ), intent ( in ), pointer :: psp class ( perrors ), intent ( in ), pointer :: perr class ( parallel_pipe ), intent ( in ), pointer :: pp integer , intent ( in ) :: dim ! local data character ( len = 18 ), save :: sname = 'init_field3d:' this % sp => psp this % err => perr this % p => pp call this % err % werrfl2 ( class // sname // ' started' ) allocate ( this % rs ) this % gcells = 0 call this % rs % new ( pp , perr , psp , dim , 0 , pp % getlnvp (), pp % getnstage ()) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine init_field3d ! subroutine end_field3d ( this ) implicit none class ( field3d ), intent ( inout ) :: this character ( len = 18 ), save :: sname = 'end_field3d:' call this % err % werrfl2 ( class // sname // ' started' ) call this % rs % del () deallocate ( this % rs ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine end_field3d ! subroutine pipecg_field3d ( this , rtag , stag , rid , sid ) implicit none class ( field3d ), intent ( inout ) :: this integer , intent ( in ) :: rtag , stag integer , intent ( inout ) :: rid , sid character ( len = 18 ), save :: sname = 'pipecg_field3d:' call this % err % werrfl2 ( class // sname // ' started' ) call this % rs % pcg ( rtag , stag , rid , sid ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine pipecg_field3d ! subroutine acopyguard_field3d ( this , rtag , stag , id ) implicit none class ( field3d ), intent ( inout ) :: this integer , intent ( in ) :: rtag , stag integer , intent ( inout ) :: id character ( len = 20 ), save :: sname = 'acopyguard_field3d:' call this % err % werrfl2 ( class // sname // ' started' ) call this % rs % ag ( rtag , stag , id ) this % gcells = 1 call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine acopyguard_field3d ! subroutine writehdf5_3d ( this , file , dim , rtag , stag , id ) implicit none class ( field3d ), intent ( inout ) :: this class ( hdf5file ), intent ( in ) :: file integer , intent ( in ) :: dim , rtag , stag integer , intent ( inout ) :: id character ( len = 20 ), save :: sname = 'writehdf5_3d:' call this % err % werrfl2 ( class // sname // ' started' ) call this % rs % wr ( file , dim , rtag , stag , id ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine writehdf5_3d ! subroutine writehdf5_2dslice ( this , file , dim , slice , spos , rtag , stag , id ) implicit none class ( field3d ), intent ( inout ) :: this class ( hdf5file ), intent ( in ) :: file integer , intent ( in ) :: dim , rtag , stag , slice , spos integer , intent ( inout ) :: id character ( len = 20 ), save :: sname = 'writehdf5_2dslice:' call this % err % werrfl2 ( class // sname // ' started' ) call this % rs % wr ( file , dim , slice , spos , rtag , stag , id ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine writehdf5_2dslice ! subroutine asc ( this , value ) implicit none class ( field3d ), intent ( inout ) :: this real , intent ( in ) :: value character ( len = 18 ), save :: sname = 'asc:' call this % err % werrfl2 ( class // sname // ' started' ) call this % rs % as ( value ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine asc ! subroutine asa ( this , that ) implicit none class ( field3d ), intent ( inout ) :: this , that character ( len = 18 ), save :: sname = 'asc:' call this % err % werrfl2 ( class // sname // ' started' ) call this % rs % as ( that % rs ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine asa ! subroutine sum ( this , a1 , a2 ) implicit none class ( field3d ), intent ( inout ) :: this class ( field3d ), intent ( in ) :: a1 , a2 character ( len = 18 ), save :: sname = 'sum:' call this % err % werrfl2 ( class // sname // ' started' ) call this % rs % add ( a1 % rs , a2 % rs ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine sum ! subroutine minus ( this , a1 , a2 ) implicit none class ( field3d ), intent ( inout ) :: this class ( field3d ), intent ( in ) :: a1 , a2 character ( len = 18 ), save :: sname = 'minus:' call this % err % werrfl2 ( class // sname // ' started' ) call this % rs % sub ( a1 % rs , a2 % rs ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine minus ! subroutine multiply ( this , a1 , value ) implicit none class ( field3d ), intent ( inout ) :: this class ( field3d ), intent ( in ) :: a1 real , intent ( in ) :: value character ( len = 18 ), save :: sname = 'multiply:' call this % err % werrfl2 ( class // sname // ' started' ) call this % rs % mult ( a1 % rs , value ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine multiply ! function getgcells ( this ) implicit none class ( field3d ), intent ( in ) :: this integer :: getgcells getgcells = this % gcells end function getgcells ! function getrs ( this ) implicit none class ( field3d ), intent ( in ) :: this class ( ufield3d ), pointer :: getrs getrs => this % rs end function getrs ! end module field3d_class","tags":"","loc":"sourcefile/field3d_class.f03.html"},{"title":"fpois2d_class.f03 – QuickPIC","text":"This file depends on sourcefile~~fpois2d_class.f03~~EfferentGraph sourcefile~fpois2d_class.f03 fpois2d_class.f03 sourcefile~parallel_pipe_class.f03 parallel_pipe_class.f03 sourcefile~fpois2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~fpois2d_lib.f03 fpois2d_lib.f03 sourcefile~fpois2d_class.f03->sourcefile~fpois2d_lib.f03 sourcefile~perrors_class.f03 perrors_class.f03 sourcefile~fpois2d_class.f03->sourcefile~perrors_class.f03 sourcefile~ufield2d_class.f03 ufield2d_class.f03 sourcefile~fpois2d_class.f03->sourcefile~ufield2d_class.f03 sourcefile~spect2d_class.f03 spect2d_class.f03 sourcefile~fpois2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~parallel_class.f03 parallel_class.f03 sourcefile~parallel_pipe_class.f03->sourcefile~parallel_class.f03 sourcefile~perrors_class.f03->sourcefile~parallel_class.f03 sourcefile~ufield2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~ufield2d_class.f03->sourcefile~perrors_class.f03 sourcefile~ufield2d_class.f03->sourcefile~spect2d_class.f03 sourcefile~ufield2d_lib.f03 ufield2d_lib.f03 sourcefile~ufield2d_class.f03->sourcefile~ufield2d_lib.f03 sourcefile~hdf5io_class.f03 hdf5io_class.f03 sourcefile~ufield2d_class.f03->sourcefile~hdf5io_class.f03 sourcefile~spect2d_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~spect2d_class.f03->sourcefile~perrors_class.f03 sourcefile~hdf5io_class.f03->sourcefile~parallel_pipe_class.f03 sourcefile~hdf5io_class.f03->sourcefile~perrors_class.f03 var pansourcefilefpois2d_classf03EfferentGraph = svgPanZoom('#sourcefilefpois2d_classf03EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~fpois2d_class.f03~~AfferentGraph sourcefile~fpois2d_class.f03 fpois2d_class.f03 sourcefile~field2d_class.f03 field2d_class.f03 sourcefile~field2d_class.f03->sourcefile~fpois2d_class.f03 sourcefile~simulation_class.f03 simulation_class.f03 sourcefile~simulation_class.f03->sourcefile~field2d_class.f03 sourcefile~species2d_class.f03 species2d_class.f03 sourcefile~simulation_class.f03->sourcefile~species2d_class.f03 sourcefile~beam3d_class.f03 beam3d_class.f03 sourcefile~simulation_class.f03->sourcefile~beam3d_class.f03 sourcefile~species2d_class.f03->sourcefile~field2d_class.f03 sourcefile~beam3d_class.f03->sourcefile~field2d_class.f03 sourcefile~main.f03 main.f03 sourcefile~main.f03->sourcefile~simulation_class.f03 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules fpois2d_class Source Code fpois2d_class.f03 Source Code ! fpois2d class for QuickPIC Open Source 1.0 ! update: 04/18/2016 module fpois2d_class use perrors_class use parallel_pipe_class use spect2d_class use ufield2d_class use fpois2d_lib implicit none private public :: fpois2d , get_pois2table type fpois2d private ! nd = system length in each direction ! a = half-width of particle in each direction ! anorm = normalization constant for poisson solver ! ffc = complex table for poisson solver ! ffg = real table for poisson solver class ( spect2d ), pointer , public :: sp => null () class ( perrors ), pointer , public :: err => null () class ( parallel_pipe ), pointer , public :: p => null () integer , dimension ( 2 ) :: nd real , dimension ( 2 ) :: a real :: anorm complex , dimension (:,:), pointer :: ffc => null () real , dimension (:,:,:), pointer :: ffg => null () contains generic :: new => init_fpois2d generic :: del => end_fpois2d generic :: potential => ipotd2 generic :: smoothf => ismoothfd2 generic :: elfield => ippoisd23 generic :: bfield => ibfieldd2 generic :: bfield_qp => jpbpoisd23n_qp procedure , private :: init_fpois2d procedure , private :: end_fpois2d procedure , private :: ipotd2 , ismoothfd2 , ippoisd23 , ibfieldd2 procedure , private :: jpbpoisd23n_qp end type ! type fpois2d_link type ( fpois2d_link ), pointer :: next => null () type ( fpois2d ), pointer :: table => null () integer :: refcount end type fpois2d_link ! character ( len = 10 ), save :: class = 'fpois2d:' character ( len = 128 ), save :: erstr ! link list for poisson tables integer , save :: numtables = 0 type ( fpois2d_link ), target , save :: table_list contains ! subroutine init_fpois2d ( this , pp , perr , psp , nx , ny , ax , ay , affp ) implicit none class ( fpois2d ), intent ( inout ) :: this class ( spect2d ), intent ( in ), pointer :: psp class ( perrors ), intent ( in ), pointer :: perr class ( parallel_pipe ), intent ( in ), pointer :: pp integer , intent ( in ) :: nx , ny real , intent ( in ) :: ax , ay , affp ! local data character ( len = 18 ), save :: sname = 'init_fpois2d:' this % sp => psp this % err => perr this % p => pp if (( ax < 0. ) . or . ( ay < 0. )) then write ( erstr , * ) 'invalid ax or ay=' , ax , ay call this % err % equit ( class // sname // erstr ) return endif call this % err % werrfl2 ( class // sname // ' started' ) select case ( this % sp % getpsolver ()) case ( 1 ) this % nd = ( / nx , ny / ); this % a = ( / ax , ay / ) this % anorm = affp allocate ( this % ffc ( ny ,( nx - 1 ) / this % p % getlnvp () + 1 )) call ippoisd2init ( this , ax , ay , affp , nx , ny , this % p % getlkstrt ()) case default this % nd = ( / nx , ny / ); this % a = ( / ax , ay / ) this % anorm = affp allocate ( this % ffc ( ny ,( nx - 1 ) / this % p % getlnvp () + 1 )) call ippoisd2init ( this , ax , ay , affp , nx , ny , this % p % getlkstrt ()) end select call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine init_fpois2d ! subroutine end_fpois2d ( this ) implicit none class ( fpois2d ), intent ( inout ) :: this character ( len = 18 ), save :: sname = 'end_fpois2d' call this % err % werrfl2 ( class // sname // ' started' ) if ( associated ( this % ffc )) deallocate ( this % ffc ) if ( associated ( this % ffg )) deallocate ( this % ffg ) call this % err % werrfl2 ( class // sname // ' ended' ) return end subroutine end_fpois2d ! subroutine ippoisd2init ( this , ax , ay , affp , nx , ny , kstrt ) ! this subroutine initializes ffd table implicit none class ( fpois2d ), intent ( in ) :: this integer , intent ( in ) :: nx , ny , kstrt real , intent ( in ) :: ax , ay , affp ! local data integer :: isign = 0 , nyv , kxp2 , nyd real :: we complex , dimension (:,:), pointer :: ffd real , dimension ( 1 , 1 ) :: q real , dimension ( 2 , 1 , 1 ) :: fxy character ( len = 14 ), save :: sname = 'ippoisd2init:' call this % err % werrfl2 ( class // sname // ' started' ) ffd => this % ffc nyv = size ( q , 1 ) nyd = size ( ffd , 1 ); kxp2 = size ( ffd , 2 ); call MPPOISD22 ( q , fxy , isign , ffd , ax , ay , affp , we , nx , ny , kstrt , nyv , kxp2 ,& & nyd ) call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine ippoisd2init ! subroutine ipotd2 ( this , q , fx , we ) ! this subroutine solves poisson's equation for potential with ! dirichlet (zero potential) boundary conditions and 1d partition ! this = fpois2d descriptor ! q = input charge density array, in fourier space ! fx = output potential array, in fourier space ! we = output potential energy implicit none class ( fpois2d ), intent ( in ) :: this real , intent ( inout ) :: we class ( ufield2d ), intent ( inout ) :: q , fx ! local data integer :: isign = 1 real , dimension (:,:,:), pointer :: pq => null (), pfx => null () character ( len = 8 ), save :: sname = 'ipotd2:' call this % err % werrfl2 ( class // sname // ' started' ) select case ( this % sp % getpsolver ()) case ( 1 ) pq => q % getrf (); pfx => fx % getrf () call ippoisd2 ( this , pq , pfx , isign , we ) case default pq => q % getrf (); pfx => fx % getrf () call ippoisd2 ( this , pq , pfx , isign , we ) end select call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine ipotd2 ! subroutine ippoisd2 ( this , q , fx , isign , we ) ! this subroutine solves poisson's equation for potential or smoothing ! with dirichlet (zero potential) boundary conditions and 1d partition ! this = poisson solver descriptor, includes table pointers ! q = input charge density array, in fourier space ! fx = output potential array, in fourier space ! isign = (1,2) = solve for (potential,smooth) ! we = output potential energy implicit none class ( fpois2d ), intent ( in ) :: this integer , intent ( in ) :: isign real , intent ( inout ) :: we real , dimension (:,:,:), pointer , intent ( inout ) :: q , fx ! local data integer :: nx , ny , nyv , kxp2 , nyd complex , dimension (:,:), pointer :: ffc character ( len = 10 ), save :: sname = 'ippoisd2:' call this % err % werrfl2 ( class // sname // ' started' ) ! unpack common arguments ffc => this % ffc nx = this % nd ( 1 ); ny = this % nd ( 2 ) nyv = size ( q , 2 ); nyd = size ( ffc , 1 ) kxp2 = size ( q , 3 ) - 1 ; if ( isign == 1 ) then call MPPOTPD2 ( q ( 1 ,:,:), fx ( 1 ,:,:), ffc , we , nx , ny , this % p % getlkstrt (),& & nyv , kxp2 , nyd ) else if ( isign == 2 ) then call MPPSMOOTHD2 ( q ( 1 ,:,:), fx ( 1 ,:,:), ffc , nx , ny , this % p % getlkstrt (),& & nyv , kxp2 , nyd ) endif call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine ippoisd2 ! subroutine ismoothfd2 ( this , f , fs ) ! this subroutine provides smoothing for fourier transformed data with ! 1d partition ! this = fpois2d descriptor ! f = input data, in fourier space ! fs = output data, in fourier space implicit none class ( fpois2d ), intent ( in ) :: this class ( ufield2d ), intent ( inout ) :: f , fs ! local data integer :: isign = 2 real :: we real , dimension (:,:,:), pointer :: pf , pfs character ( len = 12 ), save :: sname = 'ismoothfd2:' call this % err % werrfl2 ( class // sname // ' started' ) select case ( this % sp % getpsolver ()) case ( 1 ) pf => f % getrf (); pfs => fs % getrf () call ippoisd2 ( this , pf , pfs , isign , we ) case default pf => f % getrf (); pfs => fs % getrf () call ippoisd2 ( this , pf , pfs , isign , we ) end select call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine ismoothfd2 ! subroutine ippoisd23 ( this , q , fxy , we ) ! this subroutine solves poisson's equation for electric field ! with dirichlet (zero potential) boundary conditions and 1d partition ! this = fpois2d descriptor, includes table pointers ! q = input charge density array, in fourier space ! fxy = output electric field array, in fourier space ! we = output potential energy ! kstrt = starting data block number, a global variable implicit none class ( fpois2d ), intent ( in ) :: this class ( ufield2d ), intent ( inout ) :: q , fxy real , intent ( inout ) :: we ! local data integer :: isign = - 1 , nx , ny , nyv , kxp2 , nyd real :: ax , ay , affp real , dimension (:,:,:), pointer :: pq real , dimension (:,:,:), pointer :: pfxy complex , dimension (:,:), pointer :: ffc character ( len = 11 ), save :: sname = 'ippoisd23:' call this % err % werrfl2 ( class // sname // ' started' ) pq => q % getrf (); pfxy => fxy % getrf () if (( size ( pfxy , 1 ) < 2 ) . or . ( size ( pfxy , 1 ) > 3 )) then write ( erstr , * ) 'invalid vector size=' , size ( pfxy , 1 ) call this % err % equit ( class // sname // erstr ) return endif ! unpack common arguments ffc => this % ffc nx = this % nd ( 1 ); ny = this % nd ( 2 ) ! choose the proper solver select case ( this % sp % getpsolver ()) case ( 1 ) nyv = size ( pq , 2 ); nyd = size ( ffc , 1 ) kxp2 = size ( pq , 3 ) - 1 ; select case ( size ( pfxy , 1 )) case ( 2 ) call MPPOISD22 ( pq ( 1 ,:,:), pfxy , isign , ffc , ax , ay , affp , we , nx , ny ,& & this % p % getlkstrt (), nyv , kxp2 , nyd ) case ( 3 ) call MPPOISD23 ( pq ( 1 ,:,:), pfxy , isign , ffc , ax , ay , affp , we , nx , ny ,& & this % p % getlkstrt (), nyv , kxp2 , nyd ) end select case default nyv = size ( pq , 2 ); nyd = size ( ffc , 1 ) kxp2 = size ( ffc , 2 ); select case ( size ( pfxy , 1 )) case ( 2 ) call MPPOISD22 ( pq ( 1 ,:,:), pfxy , isign , ffc , ax , ay , affp , we , nx , ny ,& & this % p % getlkstrt (), nyv , kxp2 , nyd ) case ( 3 ) call MPPOISD23 ( pq ( 1 ,:,:), pfxy , isign , ffc , ax , ay , affp , we , nx , ny ,& & this % p % getlkstrt (), nyv , kxp2 , nyd ) end select end select call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine ippoisd23 ! subroutine ibfieldd2 ( this , cu , bxy , ci , wm ) ! this subroutine solves poisson's equation for magnetic field ! with dirichlet (zero potential) boundary conditions and 1d partition ! this = fpois2d descriptor, includes table pointers ! cu = input current density array, in fourier space ! bxy = output magnetic field array, in fourier space ! ci = reciprical of velocity of light ! wm = output magnetic energy implicit none class ( fpois2d ), intent ( in ) :: this real , intent ( in ) :: ci real , intent ( inout ) :: wm class ( ufield2d ), intent ( inout ) :: cu , bxy ! local data integer :: isign = - 1 real , dimension (:,:,:), pointer :: pcu , pbxy character ( len = 11 ), save :: sname = 'ibfieldd2:' call this % err % werrfl2 ( class // sname // ' started' ) select case ( this % sp % getpsolver ()) case ( 1 ) pcu => cu % getrf (); pbxy => bxy % getrf () call jpbpoisd23 ( this , pcu , pbxy , isign , ci , wm ) case default pcu => cu % getrf (); pbxy => bxy % getrf () call jpbpoisd23 ( this , pcu , pbxy , isign , ci , wm ) end select call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine ibfieldd2 ! subroutine jpbpoisd23 ( this , cu , bxy , isign , ci , wm ) ! this subroutine solves poisson's equation for magnetic field or ! vector potential or smoothing with dirichlet (zero potential) boundary ! conditions and 1d partition ! this = fpois2d descriptor, includes table pointers ! cu = input current density array, in fourier space ! bxy = output magnetic field array, in fourier space ! isign = (-1,1,2) = solve for (magnetic field,vector potential,smooth) ! ci = reciprical of velocity of light ! wm = output magnetic energy ! kstrt = starting data block number, a global variable implicit none class ( fpois2d ), intent ( in ) :: this integer , intent ( in ) :: isign real , intent ( in ) :: ci real , intent ( inout ) :: wm real , dimension (:,:,:), pointer , intent ( inout ) :: cu , bxy ! local data integer :: nx , ny , nyv , kxp2 , j2blok , nyd real :: ax , ay , affp real , dimension ( 1 , 1 , 1 ) :: dxy complex , dimension (:,:), pointer :: ffc character ( len = 12 ), save :: sname = 'jpbpoisd23:' call this % err % werrfl2 ( class // sname // ' started' ) if (( size ( cu , 1 ) < 2 ) . or . ( size ( cu , 1 ) > 3 )) then write ( erstr , * ) 'invalid cu vector size=' , size ( cu , 1 ) call this % err % equit ( class // sname // erstr ) return endif if ( size ( cu , 1 ) /= size ( bxy , 1 )) then if (( size ( cu , 1 ) == 2 ). and .(( size ( bxy , 1 ) /= 1 ). or .( isign /= ( - 1 ))))& & then write ( erstr , * ) 'invalid bxy vector size=' , size ( bxy , 1 ) call this % err % equit ( class // sname // erstr ) return endif endif ! unpack common arguments ffc => this % ffc nx = this % nd ( 1 ); ny = this % nd ( 2 ) nyv = size ( cu , 2 ); nyd = size ( ffc , 1 ) kxp2 = size ( cu , 3 ) - 1 ; select case ( size ( cu , 1 )) case ( 3 ) call MPPBBPOISD23 ( cu , bxy , ffc , ci , wm , nx , ny , this % p % getlkstrt (), nyv ,& & kxp2 , nyd ) end select call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine jpbpoisd23 ! subroutine jpbpoisd23n_qp ( this , cu , dcu , amu , bxy , ci , c , dex , wm ) ! this = poisson solver descriptor ! cu = input current density array, in fourier space ! bxy = output magnetic field array, in fourier space ! isign = (-1,1,2) = solve for (magnetic field,vector potential,smooth) ! ci = reciprical of velocity of light ! wm = output magnetic energy ! kstrt = starting data block number, a global variable implicit none class ( fpois2d ), intent ( in ) :: this real , intent ( in ) :: ci , c , dex real , intent ( inout ) :: wm class ( ufield2d ), intent ( inout ) :: cu , dcu , amu , bxy ! local data integer :: isign = 1 real , dimension (:,:,:), pointer :: pcu , pdcu , pamu , pbxy integer :: nx , ny , nyv , kxp2 , j2blok , nyd real :: ax , ay , affp real , dimension ( 1 , 1 , 1 ) :: dxy complex , dimension (:,:), pointer :: ffc character ( len = 20 ), save :: sname = 'jpbpoisd23n_qp:' call this % err % werrfl2 ( class // sname // ' started' ) pcu => cu % getrf () pdcu => dcu % getrf () pamu => amu % getrf () pbxy => bxy % getrf () if (( size ( pcu , 1 ) < 2 ) . or . ( size ( pcu , 1 ) > 3 )) then write ( erstr , * ) 'invalid cu vector size=' , size ( pcu , 1 ) call this % err % equit ( class // sname // erstr ) return endif ! unpack common arguments ffc => this % ffc nx = this % nd ( 1 ); ny = this % nd ( 2 ) ! choose the proper solver select case ( this % sp % getpsolver ()) case ( 1 ) nyv = size ( pcu , 2 ); nyd = size ( ffc , 1 ) kxp2 = size ( ffc , 2 ); j2blok = 1 call PBPOISD22N_QP ( pcu , pdcu , pamu , pbxy , dxy , isign , ffc , ax , ay ,& & affp , ci , wm , nx , ny , this % p % getlkstrt (), nyv , kxp2 , j2blok , nyd , c , dex ) case default nyv = size ( pcu , 2 ); nyd = size ( ffc , 1 ) kxp2 = size ( ffc , 2 ); j2blok = 1 call PBPOISD22N_QP ( pcu , pdcu , pamu , pbxy , dxy , isign , ffc , ax , ay ,& & affp , ci , wm , nx , ny , this % p % getlkstrt (), nyv , kxp2 , j2blok , nyd , c , dex ) end select call this % err % werrfl2 ( class // sname // ' ended' ) end subroutine jpbpoisd23n_qp ! function get_pois2table ( pp , perr , psp , ax , ay , affp ) result ( table ) implicit none class ( spect2d ), intent ( in ), pointer :: psp class ( perrors ), intent ( in ), pointer :: perr class ( parallel_pipe ), intent ( in ), pointer :: pp real , intent ( in ) :: ax , ay , affp type ( fpois2d ), pointer :: table ! local data type ( fpois2d_link ), pointer :: link => null () type ( fpois2d ), pointer :: ltable => null () integer :: nx , ny , ierr = 0 character ( len = 18 ), save :: sname = 'get_pois2table:' call perr % werrfl2 ( class // sname // ' started' ) nullify ( table ) if ( numtables == 0 ) then nullify ( table_list % next , table_list % table ) table_list % refcount = 0 endif nx = 2 ** psp % getindx () ny = 2 ** psp % getindy () link => table_list table => link % table ! search link list of table to see if required table already exists do while ( associated ( table )) ! found it if (( nx == table % nd ( 1 )). and .( ny == table % nd ( 2 )). and .( ax == table % a ( 1 ))& &. and .( ay == table % a ( 2 )). and .( affp == table % anorm ). and .( psp % getpsolver ()& & == table % sp % getpsolver ())) then link % refcount = link % refcount + 1 call perr % werrfl2 ( class // sname // ' ended' ) return ! check next table, create new empty table if end is reached else if ( associated ( link % next )) then link => link % next else allocate ( link % next ) link => link % next nullify ( link % next , link % table ) link % refcount = 0 endif table => link % table endif end do ! allocate table entries allocate ( ltable ) link % table => ltable table => link % table call table % new ( pp , perr , psp , nx , ny , ax , ay , affp ) link % refcount = 1 numtables = numtables + 1 call perr % werrfl2 ( class // sname // ' ended' ) end function get_pois2table ! end module fpois2d_class","tags":"","loc":"sourcefile/fpois2d_class.f03.html"},{"title":"fft2d_lib.f03 – QuickPIC","text":"Files dependent on this one sourcefile~~fft2d_lib.f03~~AfferentGraph sourcefile~fft2d_lib.f03 fft2d_lib.f03 sourcefile~fft2d_class.f03 fft2d_class.f03 sourcefile~fft2d_class.f03->sourcefile~fft2d_lib.f03 sourcefile~field2d_class.f03 field2d_class.f03 sourcefile~field2d_class.f03->sourcefile~fft2d_class.f03 sourcefile~simulation_class.f03 simulation_class.f03 sourcefile~simulation_class.f03->sourcefile~field2d_class.f03 sourcefile~species2d_class.f03 species2d_class.f03 sourcefile~simulation_class.f03->sourcefile~species2d_class.f03 sourcefile~beam3d_class.f03 beam3d_class.f03 sourcefile~simulation_class.f03->sourcefile~beam3d_class.f03 sourcefile~species2d_class.f03->sourcefile~field2d_class.f03 sourcefile~beam3d_class.f03->sourcefile~field2d_class.f03 sourcefile~main.f03 main.f03 sourcefile~main.f03->sourcefile~simulation_class.f03 var pansourcefilefft2d_libf03AfferentGraph = svgPanZoom('#sourcefilefft2d_libf03AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules fft2d_lib Subroutines PPRTPOSE PPRNTPOSE Source Code fft2d_lib.f03 Source Code module fft2d_lib use mpi implicit none public ! integer :: nproc , lgrp , mreal , mint , mcplx , mdouble , lworld common / PPARMS / nproc , lgrp , mreal , mint , mcplx , mdouble , lworld ! interface subroutine WPFST2RINIT ( mixup , sctd , indx , indy , nxhyd , nxyd ) implicit none integer , intent ( in ) :: indx , indy integer , intent ( in ) :: nxhyd , nxyd integer , dimension ( nxhyd ), intent ( inout ) :: mixup complex , dimension ( nxyd ), intent ( inout ) :: sctd end subroutine end interface ! interface subroutine WPFSST2R ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp , indx ,& & indy , kstrt , nxvh , nyv , kxp2 , kyp , kypd , kxp2d , jblok , kblok , nxhyd , nxyd ) implicit none integer , intent ( in ) :: isign , ntpose , indx , indy , kstrt , nxvh , nyv integer , intent ( in ) :: kxp2 , kyp , kypd , kxp2d , jblok , kblok , nxhyd , nxyd real , intent ( inout ) :: ttp real , intent ( inout ) :: f real , dimension ( nyv , kxp2d , jblok ), intent ( inout ) :: g real , dimension ( kxp2 + 1 , kyp + 1 , kblok ), intent ( inout ) :: bs real , dimension ( kxp2 + 1 , kyp + 1 , jblok ), intent ( inout ) :: br integer , dimension ( nxhyd ), intent ( in ) :: mixup complex , dimension ( nxyd ), intent ( in ) :: sctd end subroutine end interface ! interface subroutine WPFSCT2R ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp , indx ,& & indy , kstrt , nxvh , nyv , kxp2 , kyp , kypd , kxp2d , jblok , kblok , nxhyd , nxyd ) implicit none integer , intent ( in ) :: isign , ntpose , indx , indy , kstrt , nxvh , nyv integer , intent ( in ) :: kxp2 , kyp , kypd , kxp2d , jblok , kblok , nxhyd , nxyd real , intent ( inout ) :: ttp real , intent ( inout ) :: f real , dimension ( nyv , kxp2d , jblok ), intent ( inout ) :: g real , dimension ( kxp2 + 1 , kyp + 1 , kblok ), intent ( inout ) :: bs real , dimension ( kxp2 + 1 , kyp + 1 , jblok ), intent ( inout ) :: br integer , dimension ( nxhyd ), intent ( in ) :: mixup complex , dimension ( nxyd ), intent ( in ) :: sctd end subroutine end interface ! interface subroutine WPFCST2R ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp , indx ,& & indy , kstrt , nxvh , nyv , kxp2 , kyp , kypd , kxp2d , jblok , kblok , nxhyd , nxyd ) implicit none integer , intent ( in ) :: isign , ntpose , indx , indy , kstrt , nxvh , nyv integer , intent ( in ) :: kxp2 , kyp , kypd , kxp2d , jblok , kblok , nxhyd , nxyd real , intent ( inout ) :: ttp real , intent ( inout ) :: f real , dimension ( nyv , kxp2d , jblok ), intent ( inout ) :: g real , dimension ( kxp2 + 1 , kyp + 1 , kblok ), intent ( inout ) :: bs real , dimension ( kxp2 + 1 , kyp + 1 , jblok ), intent ( inout ) :: br integer , dimension ( nxhyd ), intent ( in ) :: mixup complex , dimension ( nxyd ), intent ( in ) :: sctd end subroutine end interface ! interface subroutine WPFCCT2R ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp , indx ,& & indy , kstrt , nxvh , nyv , kxp2 , kyp , kypd , kxp2d , jblok , kblok , nxhyd , nxyd ) implicit none integer , intent ( in ) :: isign , ntpose , indx , indy , kstrt , nxvh , nyv integer , intent ( in ) :: kxp2 , kyp , kypd , kxp2d , jblok , kblok , nxhyd , nxyd real , intent ( inout ) :: ttp real , intent ( inout ) :: f real , dimension ( nyv , kxp2d , jblok ), intent ( inout ) :: g real , dimension ( kxp2 + 1 , kyp + 1 , kblok ), intent ( inout ) :: bs real , dimension ( kxp2 + 1 , kyp + 1 , jblok ), intent ( inout ) :: br integer , dimension ( nxhyd ), intent ( in ) :: mixup complex , dimension ( nxyd ), intent ( in ) :: sctd end subroutine end interface ! interface subroutine WPFCST2R2 ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp , indx & &, indy , kstrt , nxvh , nyv , kxp2 , kyp , kypd , kxp2d , jblok , kblok , nxhyd , nxyd ) implicit none integer , intent ( in ) :: isign , ntpose , indx , indy , kstrt , nxvh , nyv integer , intent ( in ) :: kxp2 , kyp , kypd , kxp2d , jblok , kblok , nxhyd , nxyd real , intent ( inout ) :: ttp real , intent ( inout ) :: f real , dimension ( 2 , nyv , kxp2d , jblok ), intent ( inout ) :: g real , dimension ( 2 , kxp2 + 1 , kyp + 1 , kblok ), intent ( inout ) :: bs real , dimension ( 2 , kxp2 + 1 , kyp + 1 , jblok ), intent ( inout ) :: br integer , dimension ( nxhyd ), intent ( in ) :: mixup complex , dimension ( nxyd ), intent ( in ) :: sctd end subroutine end interface ! interface subroutine WPFSCT2R2 ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp , indx & &, indy , kstrt , nxvh , nyv , kxp2 , kyp , kypd , kxp2d , jblok , kblok , nxhyd , nxyd ) implicit none integer , intent ( in ) :: isign , ntpose , indx , indy , kstrt , nxvh , nyv integer , intent ( in ) :: kxp2 , kyp , kypd , kxp2d , jblok , kblok , nxhyd , nxyd real , intent ( inout ) :: ttp real , intent ( inout ) :: f real , dimension ( 2 , nyv , kxp2d , jblok ), intent ( inout ) :: g real , dimension ( 2 , kxp2 + 1 , kyp + 1 , kblok ), intent ( inout ) :: bs real , dimension ( 2 , kxp2 + 1 , kyp + 1 , jblok ), intent ( inout ) :: br integer , dimension ( nxhyd ), intent ( in ) :: mixup complex , dimension ( nxyd ), intent ( in ) :: sctd end subroutine end interface ! interface subroutine WPFCST2R3 ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp , indx & &, indy , kstrt , nxvh , nyv , kxp2 , kyp , kypd , kxp2d , jblok , kblok , nxhyd , nxyd ) implicit none integer , intent ( in ) :: isign , ntpose , indx , indy , kstrt , nxvh , nyv integer , intent ( in ) :: kxp2 , kyp , kypd , kxp2d , jblok , kblok , nxhyd , nxyd real , intent ( inout ) :: ttp real , intent ( inout ) :: f real , dimension ( 3 , nyv , kxp2d , jblok ), intent ( inout ) :: g real , dimension ( 3 , kxp2 + 1 , kyp + 1 , kblok ), intent ( inout ) :: bs real , dimension ( 3 , kxp2 + 1 , kyp + 1 , jblok ), intent ( inout ) :: br integer , dimension ( nxhyd ), intent ( in ) :: mixup complex , dimension ( nxyd ), intent ( in ) :: sctd end subroutine end interface ! interface subroutine WPFSCT2R3 ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp , indx & &, indy , kstrt , nxvh , nyv , kxp2 , kyp , kypd , kxp2d , jblok , kblok , nxhyd , nxyd ) implicit none integer , intent ( in ) :: isign , ntpose , indx , indy , kstrt , nxvh , nyv integer , intent ( in ) :: kxp2 , kyp , kypd , kxp2d , jblok , kblok , nxhyd , nxyd real , intent ( inout ) :: ttp real , intent ( inout ) :: f real , dimension ( 3 , nyv , kxp2d , jblok ), intent ( inout ) :: g real , dimension ( 3 , kxp2 + 1 , kyp + 1 , kblok ), intent ( inout ) :: bs real , dimension ( 3 , kxp2 + 1 , kyp + 1 , jblok ), intent ( inout ) :: br integer , dimension ( nxhyd ), intent ( in ) :: mixup complex , dimension ( nxyd ), intent ( in ) :: sctd end subroutine end interface ! interface subroutine WPFS3T2R3 ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp , indx & &, indy , kstrt , nxvh , nyv , kxp2 , kyp , kypd , kxp2d , jblok , kblok , nxhyd , nxyd ) implicit none integer , intent ( in ) :: isign , ntpose , indx , indy , kstrt , nxvh , nyv integer , intent ( in ) :: kxp2 , kyp , kypd , kxp2d , jblok , kblok , nxhyd , nxyd real , intent ( inout ) :: ttp real , intent ( inout ) :: f real , dimension ( 3 , nyv , kxp2d , jblok ), intent ( inout ) :: g real , dimension ( 3 , kxp2 + 1 , kyp + 1 , kblok ), intent ( inout ) :: bs real , dimension ( 3 , kxp2 + 1 , kyp + 1 , jblok ), intent ( inout ) :: br integer , dimension ( nxhyd ), intent ( in ) :: mixup complex , dimension ( nxyd ), intent ( in ) :: sctd end subroutine end interface ! interface subroutine PDIVFD2 ( f , df , nx , ny , kstrt , ndim , nyv , kxp2 , j2blok ) implicit none integer , intent ( in ) :: nx , ny , kstrt , ndim , nyv , kxp2 , j2blok real , dimension ( ndim , nyv , kxp2 + 1 , j2blok ), intent ( inout ) :: f real , dimension ( nyv , kxp2 + 1 , j2blok ), intent ( inout ) :: df end subroutine end interface ! interface subroutine PGRADFD2 ( df , f , nx , ny , kstrt , ndim , nyv , kxp2 , j2blok ) implicit none integer , intent ( in ) :: nx , ny , kstrt , ndim , nyv , kxp2 , j2blok real , dimension ( nyv , kxp2 + 1 , j2blok ), intent ( inout ) :: df real , dimension ( ndim , nyv , kxp2 + 1 , j2blok ), intent ( inout ) :: f end subroutine end interface ! interface subroutine PCURLFD2 ( f , g , nx , ny , kstrt , nyv , kxp2 , j2blok ) implicit none integer , intent ( in ) :: nx , ny , kstrt , nyv , kxp2 , j2blok real , dimension ( 3 , nyv , kxp2 + 1 , j2blok ), intent ( inout ) :: f , g end subroutine end interface ! interface subroutine PCURLFD22 ( f , g , nx , ny , kstrt , nyv , kxp2 , j2blok ) implicit none integer , intent ( in ) :: nx , ny , kstrt , nyv , kxp2 , j2blok real , dimension ( 2 , nyv , kxp2 + 1 , j2blok ), intent ( inout ) :: f real , dimension ( nyv , kxp2 + 1 , j2blok ), intent ( inout ) :: g end subroutine end interface ! interface subroutine WPPFSST2RM ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp , & & indx , indy , kstrt , nvp , nxvh , nyv , kxp2 , kyp , kypd , kxp2d , nxhyd , nxyd ) implicit none integer , intent ( in ) :: isign , ntpose , indx , indy , kstrt , nvp integer , intent ( in ) :: nxvh , nyv , kxp2 , kyp , kypd , kxp2d integer , intent ( in ) :: nxhyd , nxyd real , intent ( inout ) :: ttp real , dimension ( 2 * nxvh , kypd ), intent ( inout ) :: f real , dimension ( nyv , kxp2d ), intent ( inout ) :: g real , dimension ( kxp2 + 1 , kyp + 1 ), intent ( inout ) :: bs , br integer , dimension ( nxhyd ), intent ( in ) :: mixup complex , dimension ( nxyd ), intent ( in ) :: sctd end subroutine end interface ! interface subroutine WPPFSCT2RM ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp , & & indx , indy , kstrt , nvp , nxvh , nyv , kxp2 , kyp , kypd , kxp2d , nxhyd , nxyd ) implicit none integer , intent ( in ) :: isign , ntpose , indx , indy , kstrt , nvp integer , intent ( in ) :: nxvh , nyv , kxp2 , kyp , kypd , kxp2d integer , intent ( in ) :: nxhyd , nxyd real , intent ( inout ) :: ttp real , dimension ( 2 * nxvh , kypd ), intent ( inout ) :: f real , dimension ( nyv , kxp2d ), intent ( inout ) :: g real , dimension ( kxp2 + 1 , kyp + 1 ), intent ( inout ) :: bs , br integer , dimension ( nxhyd ), intent ( in ) :: mixup complex , dimension ( nxyd ), intent ( in ) :: sctd end subroutine end interface ! interface subroutine WPPFCST2RM ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp , & & indx , indy , kstrt , nvp , nxvh , nyv , kxp2 , kyp , kypd , kxp2d , nxhyd , nxyd ) implicit none integer , intent ( in ) :: isign , ntpose , indx , indy , kstrt , nvp integer , intent ( in ) :: nxvh , nyv , kxp2 , kyp , kypd , kxp2d integer , intent ( in ) :: nxhyd , nxyd real , intent ( inout ) :: ttp real , dimension ( 2 * nxvh , kypd ), intent ( inout ) :: f real , dimension ( nyv , kxp2d ), intent ( inout ) :: g real , dimension ( kxp2 + 1 , kyp + 1 ), intent ( inout ) :: bs , br integer , dimension ( nxhyd ), intent ( in ) :: mixup complex , dimension ( nxyd ), intent ( in ) :: sctd end subroutine end interface ! interface subroutine WPPFCCT2RM ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp , & & indx , indy , kstrt , nvp , nxvh , nyv , kxp2 , kyp , kypd , kxp2d , nxhyd , nxyd ) implicit none integer , intent ( in ) :: isign , ntpose , indx , indy , kstrt , nvp integer , intent ( in ) :: nxvh , nyv , kxp2 , kyp , kypd , kxp2d integer , intent ( in ) :: nxhyd , nxyd real , intent ( inout ) :: ttp real , dimension ( 2 * nxvh , kypd ), intent ( inout ) :: f real , dimension ( nyv , kxp2d ), intent ( inout ) :: g real , dimension ( kxp2 + 1 , kyp + 1 ), intent ( inout ) :: bs , br integer , dimension ( nxhyd ), intent ( in ) :: mixup complex , dimension ( nxyd ), intent ( in ) :: sctd end subroutine end interface ! interface subroutine PPFST2RMXX ( f , isign , mixup , sctd , indx , indy , kstrt , kypi , & & kypp , nxvh , kypd , nxhyd , nxyd ) implicit none integer , intent ( in ) :: isign , indx , indy , kstrt integer , intent ( in ) :: kypi , kypp , nxvh , kypd , nxhyd , nxyd real , dimension ( 2 * nxvh , kypd ), intent ( inout ) :: f integer , dimension ( nxhyd ), intent ( in ) :: mixup complex , dimension ( nxyd ), intent ( in ) :: sctd end subroutine end interface ! interface subroutine PPFCT2RMXX ( f , isign , mixup , sctd , indx , indy , kstrt , kypi , & & kypp , nxvh , kypd , nxhyd , nxyd ) implicit none integer , intent ( in ) :: isign , indx , indy , kstrt integer , intent ( in ) :: kypi , kypp , nxvh , kypd , nxhyd , nxyd real , dimension ( 2 * nxvh , kypd ), intent ( inout ) :: f integer , dimension ( nxhyd ), intent ( in ) :: mixup complex , dimension ( nxyd ), intent ( in ) :: sctd end subroutine end interface ! interface subroutine PPFST2RMXY ( g , isign , mixup , sctd , indx , indy , kstrt , kxpi , & & kxpp , nyv , kxpd , nxhyd , nxyd ) implicit none integer , intent ( in ) :: isign , indx , indy , kstrt integer , intent ( in ) :: kxpi , kxpp , nyv , kxpd , nxhyd , nxyd real , dimension ( nyv , kxpd ), intent ( inout ) :: g integer , dimension ( nxhyd ), intent ( in ) :: mixup complex , dimension ( nxyd ), intent ( in ) :: sctd end subroutine end interface ! interface subroutine PPFCT2RMXY ( g , isign , mixup , sctd , indx , indy , kstrt , kxpi , & & kxpp , nyv , kxpd , nxhyd , nxyd ) implicit none integer , intent ( in ) :: isign , indx , indy , kstrt integer , intent ( in ) :: kxpi , kxpp , nyv , kxpd , nxhyd , nxyd real , dimension ( nyv , kxpd ), intent ( inout ) :: g integer , dimension ( nxhyd ), intent ( in ) :: mixup complex , dimension ( nxyd ), intent ( in ) :: sctd end subroutine end interface ! interface subroutine WPPFCST2RM2 ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp , & & indx , indy , kstrt , nvp , nxvh , nyv , kxp2 , kyp , kypd , kxp2d , nxhyd , nxyd ) implicit none integer , intent ( in ) :: isign , ntpose , indx , indy , kstrt , nvp integer , intent ( in ) :: nxvh , nyv , kxp2 , kyp , kypd , kxp2d integer , intent ( in ) :: nxhyd , nxyd real , intent ( inout ) :: ttp real , dimension ( 2 , 2 * nxvh , kypd ), intent ( inout ) :: f real , dimension ( 2 , nyv , kxp2d ), intent ( inout ) :: g real , dimension ( 2 , kxp2 + 1 , kyp + 1 ), intent ( inout ) :: bs , br integer , dimension ( nxhyd ), intent ( in ) :: mixup complex , dimension ( nxyd ), intent ( in ) :: sctd end subroutine end interface ! interface subroutine WPPFSCT2RM2 ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp , & & indx , indy , kstrt , nvp , nxvh , nyv , kxp2 , kyp , kypd , kxp2d , nxhyd , nxyd ) implicit none integer , intent ( in ) :: isign , ntpose , indx , indy , kstrt , nvp integer , intent ( in ) :: nxvh , nyv , kxp2 , kyp , kypd , kxp2d integer , intent ( in ) :: nxhyd , nxyd real , intent ( inout ) :: ttp real , dimension ( 2 , 2 * nxvh , kypd ), intent ( inout ) :: f real , dimension ( 2 , nyv , kxp2d ), intent ( inout ) :: g real , dimension ( 2 , kxp2 + 1 , kyp + 1 ), intent ( inout ) :: bs , br integer , dimension ( nxhyd ), intent ( in ) :: mixup complex , dimension ( nxyd ), intent ( in ) :: sctd end subroutine end interface ! interface subroutine PPFCST2RM2X ( f , isign , mixup , sctd , indx , indy , kstrt , kypi ,& & kypp , nxvh , kypd , nxhyd , nxyd ) implicit none integer , intent ( in ) :: isign , indx , indy , kstrt integer , intent ( in ) :: kypi , kypp , nxvh , kypd , nxhyd , nxyd real , dimension ( 2 , 2 * nxvh , kypd ), intent ( inout ) :: f integer , dimension ( nxhyd ), intent ( in ) :: mixup complex , dimension ( nxyd ), intent ( in ) :: sctd end subroutine end interface ! interface subroutine PPFSCT2RM2X ( f , isign , mixup , sctd , indx , indy , kstrt , kypi ,& & kypp , nxvh , kypd , nxhyd , nxyd ) implicit none integer , intent ( in ) :: isign , indx , indy , kstrt integer , intent ( in ) :: kypi , kypp , nxvh , kypd , nxhyd , nxyd real , dimension ( 2 , 2 * nxvh , kypd ), intent ( inout ) :: f integer , dimension ( nxhyd ), intent ( in ) :: mixup complex , dimension ( nxyd ), intent ( in ) :: sctd end subroutine end interface ! interface subroutine PPFSCT2RM2Y ( g , isign , mixup , sctd , indx , indy , kstrt , kxpi ,& & kxpp , nyv , kxpd , nxhyd , nxyd ) implicit none integer , intent ( in ) :: isign , indx , indy , kstrt integer , intent ( in ) :: kxpi , kxpp , nyv , kxpd , nxhyd , nxyd real , dimension ( 2 , nyv , kxpd ), intent ( inout ) :: g integer , dimension ( nxhyd ), intent ( in ) :: mixup complex , dimension ( nxyd ), intent ( in ) :: sctd end subroutine end interface ! interface subroutine PPFCST2RM2Y ( g , isign , mixup , sctd , indx , indy , kstrt , kxpi ,& & kxpp , nyv , kxpd , nxhyd , nxyd ) implicit none integer , intent ( in ) :: isign , indx , indy , kstrt integer , intent ( in ) :: kxpi , kxpp , nyv , kxpd , nxhyd , nxyd real , dimension ( 2 , nyv , kxpd ), intent ( inout ) :: g integer , dimension ( nxhyd ), intent ( in ) :: mixup complex , dimension ( nxyd ), intent ( in ) :: sctd end subroutine end interface ! interface subroutine WPPFCST2RM3 ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp , & & indx , indy , kstrt , nvp , nxvh , nyv , kxp2 , kyp , kypd , kxp2d , nxhyd , nxyd ) implicit none integer , intent ( in ) :: isign , ntpose , indx , indy , kstrt , nvp integer , intent ( in ) :: nxvh , nyv , kxp2 , kyp , kypd , kxp2d integer , intent ( in ) :: nxhyd , nxyd real , intent ( inout ) :: ttp real , dimension ( 3 , 2 * nxvh , kypd ), intent ( inout ) :: f real , dimension ( 3 , nyv , kxp2d ), intent ( inout ) :: g real , dimension ( 3 , kxp2 + 1 , kyp + 1 ), intent ( inout ) :: bs , br integer , dimension ( nxhyd ), intent ( in ) :: mixup complex , dimension ( nxyd ), intent ( in ) :: sctd end subroutine end interface ! interface subroutine WPPFSCT2RM3 ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp , & & indx , indy , kstrt , nvp , nxvh , nyv , kxp2 , kyp , kypd , kxp2d , nxhyd , nxyd ) implicit none integer , intent ( in ) :: isign , ntpose , indx , indy , kstrt , nvp integer , intent ( in ) :: nxvh , nyv , kxp2 , kyp , kypd , kxp2d integer , intent ( in ) :: nxhyd , nxyd real , intent ( inout ) :: ttp real , dimension ( 3 , 2 * nxvh , kypd ), intent ( inout ) :: f real , dimension ( 3 , nyv , kxp2d ), intent ( inout ) :: g real , dimension ( 3 , kxp2 + 1 , kyp + 1 ), intent ( inout ) :: bs , br integer , dimension ( nxhyd ), intent ( in ) :: mixup complex , dimension ( nxyd ), intent ( in ) :: sctd end subroutine end interface ! interface subroutine PPFCSST2RM3X ( f , isign , mixup , sctd , indx , indy , kstrt , kypi & &, kypp , nxvh , kypd , nxhyd , nxyd ) implicit none integer , intent ( in ) :: isign , indx , indy , kstrt integer , intent ( in ) :: kypi , kypp , nxvh , kypd , nxhyd , nxyd real , dimension ( 3 , 2 * nxvh , kypd ), intent ( inout ) :: f integer , dimension ( nxhyd ), intent ( in ) :: mixup complex , dimension ( nxyd ), intent ( in ) :: sctd end subroutine end interface ! interface subroutine PPFSCCT2RM3X ( f , isign , mixup , sctd , indx , indy , kstrt , kypi & &, kypp , nxvh , kypd , nxhyd , nxyd ) implicit none integer , intent ( in ) :: isign , indx , indy , kstrt integer , intent ( in ) :: kypi , kypp , nxvh , kypd , nxhyd , nxyd real , dimension ( 3 , 2 * nxvh , kypd ), intent ( inout ) :: f integer , dimension ( nxhyd ), intent ( in ) :: mixup complex , dimension ( nxyd ), intent ( in ) :: sctd end subroutine end interface ! interface subroutine PPFSCST2RM3Y ( g , isign , mixup , sctd , indx , indy , kstrt , kxpi & &, kxpp , nyv , kxpd , nxhyd , nxyd ) implicit none integer , intent ( in ) :: isign , indx , indy , kstrt integer , intent ( in ) :: kxpi , kxpp , nyv , kxpd , nxhyd , nxyd real , dimension ( 3 , nyv , kxpd ), intent ( inout ) :: g integer , dimension ( nxhyd ), intent ( in ) :: mixup complex , dimension ( nxyd ), intent ( in ) :: sctd end subroutine end interface ! interface subroutine PPFCSCT2RM3Y ( g , isign , mixup , sctd , indx , indy , kstrt , kxpi & &, kxpp , nyv , kxpd , nxhyd , nxyd ) implicit none integer , intent ( in ) :: isign , indx , indy , kstrt integer , intent ( in ) :: kxpi , kxpp , nyv , kxpd , nxhyd , nxyd real , dimension ( 3 , nyv , kxpd ), intent ( inout ) :: g integer , dimension ( nxhyd ), intent ( in ) :: mixup complex , dimension ( nxyd ), intent ( in ) :: sctd end subroutine end interface ! interface subroutine WPPFSCT2RM4 ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp , & & indx , indy , kstrt , nvp , nxvh , nyv , kxp2 , kyp , kypd , kxp2d , nxhyd , nxyd ) implicit none integer , intent ( in ) :: isign , ntpose , indx , indy , kstrt , nvp integer , intent ( in ) :: nxvh , nyv , kxp2 , kyp , kypd , kxp2d integer , intent ( in ) :: nxhyd , nxyd real , intent ( inout ) :: ttp real , dimension ( 4 , 2 * nxvh , kypd ), intent ( inout ) :: f real , dimension ( 4 , nyv , kxp2d ), intent ( inout ) :: g real , dimension ( 4 , kxp2 + 1 , kyp + 1 ), intent ( inout ) :: bs , br integer , dimension ( nxhyd ), intent ( in ) :: mixup complex , dimension ( nxyd ), intent ( in ) :: sctd end subroutine end interface ! interface subroutine PPFSCCST2RM4X ( f , isign , mixup , sctd , indx , indy , kstrt , & & kypi , kypp , nxvh , kypd , nxhyd , nxyd ) implicit none integer , intent ( in ) :: isign , indx , indy , kstrt integer , intent ( in ) :: kypi , kypp , nxvh , kypd , nxhyd , nxyd real , dimension ( 4 , 2 * nxvh , kypd ), intent ( inout ) :: f integer , dimension ( nxhyd ), intent ( in ) :: mixup complex , dimension ( nxyd ), intent ( in ) :: sctd end subroutine end interface ! interface subroutine PPFSCSCT2RM4Y ( g , isign , mixup , sctd , indx , indy , kstrt , & & kxpi , kxpp , nyv , kxpd , nxhyd , nxyd ) implicit none integer , intent ( in ) :: isign , indx , indy , kstrt integer , intent ( in ) :: kxpi , kxpp , nyv , kxpd , nxhyd , nxyd real , dimension ( 4 , nyv , kxpd ), intent ( inout ) :: g integer , dimension ( nxhyd ), intent ( in ) :: mixup complex , dimension ( nxyd ), intent ( in ) :: sctd end subroutine end interface ! interface subroutine WPPFSCT2RM22 ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp , & & indx , indy , kstrt , nvp , nxvh , nyv , kxp2 , kyp , kypd , kxp2d , nxhyd , nxyd ) implicit none integer , intent ( in ) :: isign , ntpose , indx , indy , kstrt , nvp integer , intent ( in ) :: nxvh , nyv , kxp2 , kyp , kypd , kxp2d integer , intent ( in ) :: nxhyd , nxyd real , intent ( inout ) :: ttp real , dimension ( 2 , 2 * nxvh , kypd ), intent ( inout ) :: f real , dimension ( 2 , nyv , kxp2d ), intent ( inout ) :: g real , dimension ( 2 , kxp2 + 1 , kyp + 1 ), intent ( inout ) :: bs , br integer , dimension ( nxhyd ), intent ( in ) :: mixup complex , dimension ( nxyd ), intent ( in ) :: sctd end subroutine end interface ! interface subroutine PPFSCCST2RM22X ( f , isign , mixup , sctd , indx , indy , kstrt , & & kypi , kypp , nxvh , kypd , nxhyd , nxyd ) implicit none integer , intent ( in ) :: isign , indx , indy , kstrt integer , intent ( in ) :: kypi , kypp , nxvh , kypd , nxhyd , nxyd real , dimension ( 2 , 2 * nxvh , kypd ), intent ( inout ) :: f integer , dimension ( nxhyd ), intent ( in ) :: mixup complex , dimension ( nxyd ), intent ( in ) :: sctd end subroutine end interface ! interface subroutine PPFSCSCT2RM22Y ( g , isign , mixup , sctd , indx , indy , kstrt , & & kxpi , kxpp , nyv , kxpd , nxhyd , nxyd ) implicit none integer , intent ( in ) :: isign , indx , indy , kstrt integer , intent ( in ) :: kxpi , kxpp , nyv , kxpd , nxhyd , nxyd real , dimension ( 2 , nyv , kxpd ), intent ( inout ) :: g integer , dimension ( nxhyd ), intent ( in ) :: mixup complex , dimension ( nxyd ), intent ( in ) :: sctd end subroutine end interface ! interface subroutine WPPFSST2RM23 ( f , g , bs , br , isign , ntpose , mixup , sctd , ttp , & & indx , indy , kstrt , nvp , nxvh , nyv , kxp2 , kyp , kypd , kxp2d , nxhyd , nxyd ) implicit none integer , intent ( in ) :: isign , ntpose , indx , indy , kstrt , nvp integer , intent ( in ) :: nxvh , nyv , kxp2 , kyp , kypd , kxp2d integer , intent ( in ) :: nxhyd , nxyd real , intent ( inout ) :: ttp real , dimension ( 3 , 2 * nxvh , kypd ), intent ( inout ) :: f real , dimension ( 3 , nyv , kxp2d ), intent ( inout ) :: g real , dimension ( 3 , kxp2 + 1 , kyp + 1 ), intent ( inout ) :: bs , br integer , dimension ( nxhyd ), intent ( in ) :: mixup complex , dimension ( nxyd ), intent ( in ) :: sctd end subroutine end interface ! interface subroutine PPFSSCT2RM32X ( f , isign , mixup , sctd , indx , indy , kstrt , & & kypi , kypp , nxvh , kypd , nxhyd , nxyd ) implicit none integer , intent ( in ) :: isign , indx , indy , kstrt integer , intent ( in ) :: kypi , kypp , nxvh , kypd , nxhyd , nxyd real , dimension ( 3 , 2 * nxvh , kypd ), intent ( inout ) :: f integer , dimension ( nxhyd ), intent ( in ) :: mixup complex , dimension ( nxyd ), intent ( in ) :: sctd end subroutine end interface ! interface subroutine PPFSSCT2RM23Y ( g , isign , mixup , sctd , indx , indy , kstrt , & & kxpi , kxpp , nyv , kxpd , nxhyd , nxyd ) implicit none integer , intent ( in ) :: isign , indx , indy , kstrt integer , intent ( in ) :: kxpi , kxpp , nyv , kxpd , nxhyd , nxyd real , dimension ( 3 , nyv , kxpd ), intent ( inout ) :: g integer , dimension ( nxhyd ), intent ( in ) :: mixup complex , dimension ( nxyd ), intent ( in ) :: sctd end subroutine end interface ! interface subroutine MPPDIVFD2 ( f , df , nx , ny , kstrt , ndim , nyv , kxp2 ) implicit none integer , intent ( in ) :: nx , ny , kstrt , ndim , nyv , kxp2 real , dimension ( 3 , nyv , kxp2 + 1 ), intent ( in ) :: f real , dimension ( nyv , kxp2 + 1 ), intent ( inout ) :: df end subroutine end interface ! interface subroutine MPPGRADFD2 ( df , f , nx , ny , kstrt , ndim , nyv , kxp2 ) implicit none integer , intent ( in ) :: nx , ny , kstrt , ndim , nyv , kxp2 real , dimension ( nyv , kxp2 + 1 ), intent ( in ) :: df real , dimension ( 3 , nyv , kxp2 + 1 ), intent ( inout ) :: f end subroutine end interface ! interface subroutine MPPCURLFD2 ( f , g , nx , ny , kstrt , nyv , kxp2 ) implicit none integer , intent ( in ) :: nx , ny , kstrt , nyv , kxp2 real , dimension ( 3 , nyv , kxp2 + 1 ), intent ( in ) :: f real , dimension ( 3 , nyv , kxp2 + 1 ), intent ( inout ) :: g end subroutine end interface ! contains !----------------------------------------------------------------------- subroutine PPRTPOSE ( f , g , s , t , nx , ny , kxp , kyp , kstrt , nvp , nxv , nyv , kxpd , & & kypd ) ! this subroutine performs a transpose of a real matrix f, distributed ! in y, to a real matrix g, distributed in x, that is, ! g(k+kyp*(m-1),j,l) = f(j+kxp*(l-1),k,m), where ! 1 <= j <= kxp, 1 <= k <= kyp, 1 <= l <= nx/kxp, 1 <= m <= ny/kyp ! and where indices l and m can be distributed across processors. ! includes an extra guard cell for last row and column ! this subroutine sends and receives one message at a time, either ! synchronously or asynchronously. it uses a minimum of system resources ! f = real input array ! g = real output array ! s, t = real scratch arrays ! nx/ny = number of points in x/y ! kxp/kyp = number of data values per block in x/y ! kstrt = starting data block number ! nvp = number of real or virtual processors ! nxv = first dimension of f, nxv >= nx+1 ! nyv = first dimension of g, nyv >= ny+1 ! kypd = second dimension of f, kypd >= kyp+1 ! kxpd = second dimension of g, kxpd >= kxp+1 implicit none integer , intent ( in ) :: nx , ny , kxp , kyp , kstrt , nvp , nxv , nyv integer , intent ( in ) :: kxpd , kypd real , dimension ( nxv , kypd ), intent ( in ) :: f real , dimension ( nyv , kxpd ), intent ( inout ) :: g real , dimension (( kxp + 1 ) * ( kyp + 1 )), intent ( inout ) :: s , t ! lgrp = current communicator ! mreal = default datatype for reals ! local data integer :: n , j , k , ks , kxps , kyps , kxyp , id , joff , koff , ld integer :: nx1 , ny1 , kxb , kyb integer :: ierr , msid integer , dimension ( 10 ) :: istatus nx1 = nx + 1 ny1 = ny + 1 ! ks = processor id ks = kstrt - 1 ! kxps = actual size used in x direction kxps = min ( kxp , max ( 0 , nx - kxp * ks )) ! kyps = actual size used in y direction kyps = min ( kyp , max ( 0 , ny - kyp * ks )) ! kxb = minimum number of processors needed in x direction kxb = ( nx - 1 ) / kxp + 1 ! kyb = minimum number of processors needed in y direction kyb = ( ny - 1 ) / kyp + 1 ! add extra word for last processor in x if ( ks == ( kxb - 1 )) kxps = kxps + 1 ! add extra word for last processor in y if ( ks == ( kyb - 1 )) kyps = kyps + 1 ! kxyp = maximum amount of data to be received kxyp = ( kxp + 1 ) * ( kyp + 1 ) ! special case for one processor if ( nvp == 1 ) then !$OMP PARALLEL DO PRIVATE(j,k) do k = 1 , ny1 do j = 1 , nx1 g ( k , j ) = f ( j , k ) enddo enddo !$OMP END PARALLEL DO return endif ! this segment is used for shared memory computers !     do m = 1, min(ny,nvp) !        koff = kyp*(m - 1) !        kyps = min(kyp,max(0,ny-koff)) !        if (m==kyb) kyps = kyps + 1 !        do k = 1, kyps !           do l = 1, min(nx,nvp) !              joff = kxp*(l - 1) !              kxps = min(kxp,max(0,nx-joff)) !              if (l==kxb) kxps = kxps + 1 !              do j = 1, kxps !                 g(k+koff,j+joff) = f(j+joff,k+koff) !              enddo !           enddo !        enddo !     enddo ! this segment is used for mpi computers do n = 1 , nvp id = n - ks - 1 if ( id < 0 ) id = id + nvp ! extract data to send joff = kxp * id ld = min ( kxp , max ( 0 , nx - joff )) ! add extra word for last processor in x if ( id == ( kxb - 1 )) ld = ld + 1 !$OMP PARALLEL DO PRIVATE(j,k) do k = 1 , kyps do j = 1 , ld s ( j + ld * ( k - 1 )) = f ( j + joff , k ) enddo enddo !$OMP END PARALLEL DO ld = ld * kyps ! post receive call MPI_IRECV ( t , kxyp , mreal , id , n , lgrp , msid , ierr ) ! send data call MPI_SEND ( s , ld , mreal , id , n , lgrp , ierr ) ! receive data call MPI_WAIT ( msid , istatus , ierr ) ! insert data received koff = kyp * id ld = min ( kyp , max ( 0 , ny - koff )) ! add extra word for last processor in y if ( id == ( kyb - 1 )) ld = ld + 1 !$OMP PARALLEL DO PRIVATE(j,k) do k = 1 , ld do j = 1 , kxps g ( k + koff , j ) = t ( j + kxps * ( k - 1 )) enddo enddo !$OMP END PARALLEL DO enddo end subroutine ! !----------------------------------------------------------------------- subroutine PPRNTPOSE ( f , g , s , t , nx , ny , kxp , kyp , kstrt , nvp , ndim , nxv , nyv ,& & kxpd , kypd ) ! this subroutine performs a transpose of a real matrix f, distributed ! in y, to a real matrix g, distributed in x, that is, ! g(1:ndim,k+kyp*(m-1),j,l) = f(1:ndim,j+kxp*(l-1),k,m), where ! 1 <= j <= kxp, 1 <= k <= kyp, 1 <= l <= nx/kxp, 1 <= m <= ny/kyp ! and where indices l and m can be distributed across processors. ! includes an extra guard cell for last row and column ! this subroutine sends and receives one message at a time, either ! synchronously or asynchronously. it uses a minimum of system resources ! f = real input array ! g = real output array ! s, t = real scratch arrays ! nx/ny = number of points in x/y ! kxp/kyp = number of data values per block in x/y ! kstrt = starting data block number ! nvp = number of real or virtual processors ! ndim = leading dimension of arrays f and g ! nxv = second dimension of f, nxv >= nx+1 ! nyv = second dimension of g, nyv >= ny+1 ! kypd = third dimension of f, kypd >= kyp+1 ! kxpd = third dimension of g, kxpd >= kxp+1 implicit none integer , intent ( in ) :: nx , ny , kxp , kyp , kstrt , nvp , ndim integer , intent ( in ) :: nxv , nyv , kxpd , kypd real , dimension ( ndim , nxv , kypd ), intent ( in ) :: f real , dimension ( ndim , nyv , kxpd ), intent ( inout ) :: g real , dimension ( ndim ,( kxp + 1 ) * ( kyp + 1 )), intent ( inout ) :: s , t ! lgrp = current communicator ! mreal = default datatype for reals ! local data integer :: i , n , j , k , ks , kxps , kyps , kxyp , id , joff , koff , ld integer :: nx1 , ny1 , kxb , kyb integer :: ierr , msid integer , dimension ( 10 ) :: istatus nx1 = nx + 1 ny1 = ny + 1 ! ks = processor id ks = kstrt - 1 ! kxps = actual size used in x direction kxps = min ( kxp , max ( 0 , nx - kxp * ks )) ! kyps = actual size used in y direction kyps = min ( kyp , max ( 0 , ny - kyp * ks )) ! kxb = minimum number of processors needed in x direction kxb = ( nx - 1 ) / kxp + 1 ! kyb = minimum number of processors needed in y direction kyb = ( ny - 1 ) / kyp + 1 ! add extra word for last processor in x if ( ks == ( kxb - 1 )) kxps = kxps + 1 ! add extra word for last processor in y if ( ks == ( kyb - 1 )) kyps = kyps + 1 ! kxyp = maximum amount of data to be received kxyp = ndim * ( kxp + 1 ) * ( kyp + 1 ) ! special case for one processor if ( nvp == 1 ) then !$OMP PARALLEL DO PRIVATE(i,j,k) do k = 1 , ny1 do j = 1 , nx1 do i = 1 , ndim g ( i , k , j ) = f ( i , j , k ) enddo enddo enddo !$OMP END PARALLEL DO return endif ! this segment is used for shared memory computers !     do m = 1, min(ny,nvp) !        koff = kyp*(m - 1) !        kyps = min(kyp,max(0,ny-koff)) !        if (m==kyb) kyps = kyps + 1 !        do k = 1, kyps !           do l = 1, min(nx,nvp) !              joff = kxp*(l - 1) !              kxps = min(kxp,max(0,nx-joff)) !              if (l==kxb) kxps = kxps + 1 !              do j = 1, kxps !                 do i = 1, ndim !                    g(i,k+koff,j+joff) = f(i,j+joff,k+koff) !                 enddo !              enddo !           enddo !        enddo !     enddo ! this segment is used for mpi computers do n = 1 , nvp id = n - ks - 1 if ( id . lt . 0 ) id = id + nvp ! extract data to send joff = kxp * id ld = min ( kxp , max ( 0 , nx - joff )) ! add extra word for last processor in x if ( id == ( kxb - 1 )) ld = ld + 1 !$OMP PARALLEL DO PRIVATE(i,j,k) do k = 1 , kyps do j = 1 , ld do i = 1 , ndim s ( i , j + ld * ( k - 1 )) = f ( i , j + joff , k ) enddo enddo enddo !$OMP END PARALLEL DO ld = ndim * ld * kyps ! post receive call MPI_IRECV ( t , kxyp , mreal , id , n , lgrp , msid , ierr ) ! send data call MPI_SEND ( s , ld , mreal , id , n , lgrp , ierr ) ! receive data call MPI_WAIT ( msid , istatus , ierr ) ! insert data received koff = kyp * id ld = min ( kyp , max ( 0 , ny - koff )) ! add extra word for last processor in y if ( id == ( kyb - 1 )) ld = ld + 1 !$OMP PARALLEL DO PRIVATE(i,j,k) do k = 1 , ld do j = 1 , kxps do i = 1 , ndim g ( i , k + koff , j ) = t ( i , j + kxps * ( k - 1 )) enddo enddo enddo !$OMP END PARALLEL DO enddo end subroutine ! end module fft2d_lib !----------------------------------------------------------------------- subroutine PPRTPOSE ( f , g , s , t , nx , ny , kxp , kyp , kstrt , nvp , nxv , nyv , kxpd , & & kypd ) use fft2d_lib , only : SUB => PPRTPOSE implicit none integer , intent ( in ) :: nx , ny , kxp , kyp , kstrt , nvp , nxv , nyv integer , intent ( in ) :: kxpd , kypd real , dimension ( nxv , kypd ), intent ( in ) :: f real , dimension ( nyv , kxpd ), intent ( inout ) :: g real , dimension (( kxp + 1 ) * ( kyp + 1 )), intent ( inout ) :: s , t call SUB ( f , g , s , t , nx , ny , kxp , kyp , kstrt , nvp , nxv , nyv , kxpd , kypd ) end subroutine ! !----------------------------------------------------------------------- subroutine PPRNTPOSE ( f , g , s , t , nx , ny , kxp , kyp , kstrt , nvp , ndim , nxv , nyv ,& & kxpd , kypd ) use fft2d_lib , only : SUB => PPRNTPOSE implicit none integer , intent ( in ) :: nx , ny , kxp , kyp , kstrt , nvp , ndim integer , intent ( in ) :: nxv , nyv , kxpd , kypd real , dimension ( ndim , nxv , kypd ), intent ( in ) :: f real , dimension ( ndim , nyv , kxpd ), intent ( inout ) :: g real , dimension ( ndim , kxp * kyp ), intent ( inout ) :: s , t call SUB ( f , g , s , t , nx , ny , kxp , kyp , kstrt , nvp , ndim , nxv , nyv , kxpd , kypd ) end subroutine","tags":"","loc":"sourcefile/fft2d_lib.f03.html"},{"title":"perrors – QuickPIC ","text":"type, public :: perrors Inherits type~~perrors~~InheritsGraph type~perrors perrors type~parallel parallel type~perrors->type~parallel p Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~perrors~~InheritedByGraph type~perrors perrors type~fdist2d fdist2d type~fdist2d->type~perrors err type~spect2d spect2d type~fdist2d->type~spect2d sp type~simulation simulation type~simulation->type~perrors err type~simulation->type~spect2d sp2 type~sim_species sim_species type~simulation->type~sim_species species type~sim_beams sim_beams type~simulation->type~sim_beams beams type~sim_diag sim_diag type~simulation->type~sim_diag diag type~input_json input_json type~simulation->type~input_json in type~sim_fields sim_fields type~simulation->type~sim_fields fields type~spect3d spect3d type~simulation->type~spect3d sp3 type~ufield3d ufield3d type~ufield3d->type~perrors err type~ufield3d->type~spect3d sp type~field3d field3d type~field3d->type~perrors err type~field3d->type~ufield3d rs type~field3d->type~spect3d sp type~fdist3d fdist3d type~fdist3d->type~perrors err type~fdist3d->type~spect3d sp type~fft2d fft2d type~fft2d->type~perrors err type~fft2d->type~spect2d sp type~spect2d->type~perrors err type~beam3d beam3d type~beam3d->type~perrors err type~beam3d->type~field3d q type~beam3d->type~fdist3d pf type~part3d part3d type~beam3d->type~part3d pd type~beam3d->type~spect3d sp type~sim_species->type~perrors err type~sim_species->type~spect2d sp2 type~species2d species2d type~sim_species->type~species2d spe type~sim_species->type~spect3d sp3 type~fdist2d_wrap fdist2d_wrap type~sim_species->type~fdist2d_wrap pf type~species2d->type~perrors err type~species2d->type~fdist2d pf type~species2d->type~field3d q3 type~species2d->type~spect2d sp type~field2d field2d type~species2d->type~field2d q, qn, cu, amu, dcu type~part2d part2d type~species2d->type~part2d pd type~sim_beams->type~perrors err type~sim_beams->type~spect2d sp2 type~sim_beams->type~beam3d beam type~sim_beams->type~spect3d sp3 type~fdist3d_wrap fdist3d_wrap type~sim_beams->type~fdist3d_wrap pf type~field2d->type~perrors err type~field2d->type~fft2d ft type~field2d->type~spect2d sp type~fpois2d fpois2d type~field2d->type~fpois2d pt type~ufield2d ufield2d type~field2d->type~ufield2d rs, ks type~part3d->type~perrors err type~part3d->type~spect3d sp type~part2d->type~perrors err type~part2d->type~spect2d sp type~sim_diag->type~perrors err type~sim_diag->type~spect2d sp2 type~sim_diag->type~spect3d sp3 type~fpois2d->type~perrors err type~fpois2d->type~spect2d sp type~input_json->type~perrors err type~input_json->type~spect3d sp type~sim_fields->type~perrors err type~sim_fields->type~field3d bexyz, bbxyz, psi3d, cu3d type~sim_fields->type~spect2d sp2 type~sim_fields->type~field2d qb, qe, psit, psi, div_vpot, reg, fxy, bxyz, cu, dcu, amu, epw, epwb type~sim_fields->type~spect3d sp3 type~ufield2d->type~perrors err type~ufield2d->type~spect2d sp type~spect3d->type~spect2d type~fpois2d_link fpois2d_link type~fpois2d_link->type~fpois2d table type~fpois2d_link->type~fpois2d_link next type~fdist3d_000 fdist3d_000 type~fdist3d_000->type~fdist3d type~fdist3d_wrap->type~fdist3d p type~fdist2d_wrap->type~fdist2d p type~fdist2d_000 fdist2d_000 type~fdist2d_000->type~fdist2d type~fft2d_link fft2d_link type~fft2d_link->type~fft2d table type~fft2d_link->type~fft2d_link next var pantypeperrorsInheritedByGraph = svgPanZoom('#typeperrorsInheritedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables p eunit monitor Type-Bound Procedures new del init_perrors end_perrors equit werrfl0 werrfl1 werrfl2 setmonitor Components Type Visibility Attributes Name Initial class( parallel ), public, pointer :: p => null() integer, private :: eunit = 2 integer, private :: monitor = 0 Type-Bound Procedures generic, public :: new => init_perrors private subroutine init_perrors (this, prl, eunit, monitor) Arguments Type Intent Optional Attributes Name class( perrors ), intent(inout) :: this class( parallel ), intent(in), pointer :: prl integer, intent(in) :: eunit integer, intent(in) :: monitor generic, public :: del => end_perrors private subroutine end_perrors (this) Arguments Type Intent Optional Attributes Name class( perrors ), intent(inout) :: this procedure, private :: init_perrors private subroutine init_perrors (this, prl, eunit, monitor) Arguments Type Intent Optional Attributes Name class( perrors ), intent(inout) :: this class( parallel ), intent(in), pointer :: prl integer, intent(in) :: eunit integer, intent(in) :: monitor procedure, private :: end_perrors private subroutine end_perrors (this) Arguments Type Intent Optional Attributes Name class( perrors ), intent(inout) :: this procedure, public :: equit private subroutine equit (this, estr) Arguments Type Intent Optional Attributes Name class( perrors ), intent(in) :: this character(len=*), intent(in), optional :: estr procedure, public :: werrfl0 private subroutine werrfl0 (this, estr) Arguments Type Intent Optional Attributes Name class( perrors ), intent(in) :: this character(len=*), intent(in) :: estr procedure, public :: werrfl1 private subroutine werrfl1 (this, estr) Arguments Type Intent Optional Attributes Name class( perrors ), intent(in) :: this character(len=*), intent(in) :: estr procedure, public :: werrfl2 private subroutine werrfl2 (this, estr) Arguments Type Intent Optional Attributes Name class( perrors ), intent(in) :: this character(len=*), intent(in) :: estr procedure, public :: setmonitor private subroutine setmonitor (this, moniter) Arguments Type Intent Optional Attributes Name class( perrors ), intent(inout) :: this integer, intent(in) :: moniter","tags":"","loc":"type/perrors.html"},{"title":"spect2d – QuickPIC ","text":"type, public :: spect2d Inherits type~~spect2d~~InheritsGraph type~spect2d spect2d type~parallel_pipe parallel_pipe type~spect2d->type~parallel_pipe p type~perrors perrors type~spect2d->type~perrors err type~parallel parallel type~parallel_pipe->type~parallel type~perrors->type~parallel p Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~spect2d~~InheritedByGraph type~spect2d spect2d type~fdist2d fdist2d type~fdist2d->type~spect2d sp type~simulation simulation type~simulation->type~spect2d sp2 type~spect3d spect3d type~simulation->type~spect3d sp3 type~sim_species sim_species type~simulation->type~sim_species species type~sim_beams sim_beams type~simulation->type~sim_beams beams type~sim_diag sim_diag type~simulation->type~sim_diag diag type~sim_fields sim_fields type~simulation->type~sim_fields fields type~input_json input_json type~simulation->type~input_json in type~spect3d->type~spect2d type~fft2d fft2d type~fft2d->type~spect2d sp type~species2d species2d type~species2d->type~spect2d sp type~species2d->type~fdist2d pf type~part2d part2d type~species2d->type~part2d pd type~field2d field2d type~species2d->type~field2d q, qn, cu, amu, dcu type~field3d field3d type~species2d->type~field3d q3 type~sim_species->type~spect2d sp2 type~sim_species->type~spect3d sp3 type~sim_species->type~species2d spe type~fdist2d_wrap fdist2d_wrap type~sim_species->type~fdist2d_wrap pf type~part2d->type~spect2d sp type~sim_beams->type~spect2d sp2 type~sim_beams->type~spect3d sp3 type~beam3d beam3d type~sim_beams->type~beam3d beam type~fdist3d_wrap fdist3d_wrap type~sim_beams->type~fdist3d_wrap pf type~field2d->type~spect2d sp type~field2d->type~fft2d ft type~fpois2d fpois2d type~field2d->type~fpois2d pt type~ufield2d ufield2d type~field2d->type~ufield2d rs, ks type~sim_diag->type~spect2d sp2 type~sim_diag->type~spect3d sp3 type~fpois2d->type~spect2d sp type~sim_fields->type~spect2d sp2 type~sim_fields->type~spect3d sp3 type~sim_fields->type~field2d qb, qe, psit, psi, div_vpot, reg, fxy, bxyz, cu, dcu, amu, epw, epwb type~sim_fields->type~field3d bexyz, bbxyz, psi3d, cu3d type~ufield2d->type~spect2d sp type~ufield3d ufield3d type~ufield3d->type~spect3d sp type~field3d->type~spect3d sp type~field3d->type~ufield3d rs type~fpois2d_link fpois2d_link type~fpois2d_link->type~fpois2d table type~fpois2d_link->type~fpois2d_link next type~fdist3d fdist3d type~fdist3d->type~spect3d sp type~beam3d->type~spect3d sp type~beam3d->type~field3d q type~beam3d->type~fdist3d pf type~part3d part3d type~beam3d->type~part3d pd type~part3d->type~spect3d sp type~input_json->type~spect3d sp type~fdist2d_wrap->type~fdist2d p type~fdist2d_000 fdist2d_000 type~fdist2d_000->type~fdist2d type~fft2d_link fft2d_link type~fft2d_link->type~fft2d table type~fft2d_link->type~fft2d_link next type~fdist3d_000 fdist3d_000 type~fdist3d_000->type~fdist3d type~fdist3d_wrap->type~fdist3d p var pantypespect2dInheritedByGraph = svgPanZoom('#typespect2dInheritedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables indx indy psolver inorder err p Type-Bound Procedures init_spect2d end_spect2d new del getindx getindy getpsolver getinorder Components Type Visibility Attributes Name Initial integer, private :: indx integer, private :: indy integer, private :: psolver integer, private :: inorder class( perrors ), public, pointer :: err => null() class( parallel_pipe ), public, pointer :: p => null() Type-Bound Procedures procedure, private :: init_spect2d private subroutine init_spect2d (this, pp, perr, indx, indy, psolver, inorder) Arguments Type Intent Optional Attributes Name class( spect2d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: psolver integer, intent(in) :: inorder procedure, private :: end_spect2d private subroutine end_spect2d (this) Arguments Type Intent Optional Attributes Name class( spect2d ), intent(inout) :: this generic, public :: new => init_spect2d private subroutine init_spect2d (this, pp, perr, indx, indy, psolver, inorder) Arguments Type Intent Optional Attributes Name class( spect2d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: psolver integer, intent(in) :: inorder generic, public :: del => end_spect2d private subroutine end_spect3d (this) Arguments Type Intent Optional Attributes Name class( spect3d ), intent(inout) :: this procedure, public :: getindx private function getindx (this) Arguments Type Intent Optional Attributes Name class( spect2d ), intent(in) :: this Return Value integer procedure, public :: getindy private function getindy (this) Arguments Type Intent Optional Attributes Name class( spect2d ), intent(in) :: this Return Value integer procedure, public :: getpsolver private function getpsolver (this) Arguments Type Intent Optional Attributes Name class( spect2d ), intent(in) :: this Return Value integer procedure, public :: getinorder private function getinorder (this) Arguments Type Intent Optional Attributes Name class( spect2d ), intent(in) :: this Return Value integer","tags":"","loc":"type/spect2d.html"},{"title":"input_json – QuickPIC ","text":"type, public :: input_json Inherits type~~input_json~~InheritsGraph type~input_json input_json json_file json_file type~input_json->json_file input type~spect3d spect3d type~input_json->type~spect3d sp type~parallel parallel type~input_json->type~parallel p type~parallel_pipe parallel_pipe type~input_json->type~parallel_pipe pp type~perrors perrors type~input_json->type~perrors err type~spect2d spect2d type~spect3d->type~spect2d type~parallel_pipe->type~parallel type~perrors->type~parallel p type~spect2d->type~parallel_pipe p type~spect2d->type~perrors err Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~input_json~~InheritedByGraph type~input_json input_json type~simulation simulation type~simulation->type~input_json in Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables sp err p pp input Type-Bound Procedures new get info found read_input_json set_json_core_in_file initialize print_to_string load_file load_from_string json_file_get_root json_file_get_alloc_string_vec json_file_get_string_vec json_file_get_logical_vec json_file_get_double_vec json_file_get_integer_vec json_file_get_string json_file_get_logical json_file_get_double json_file_get_integer json_file_get_object json_file_variable_info Components Type Visibility Attributes Name Initial class( spect3d ), public, pointer :: sp => null() class( perrors ), public, pointer :: err => null() class( parallel ), public, pointer :: p => null() class( parallel_pipe ), public, pointer :: pp => null() type(json_file), private, pointer :: input => null() Type-Bound Procedures generic, public :: new => read_input_json private subroutine read_input_json (this) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this generic, public :: get => json_file_get_object , json_file_get_integer , json_file_get_double , json_file_get_logical , json_file_get_string , json_file_get_integer_vec , json_file_get_double_vec , json_file_get_logical_vec , json_file_get_string_vec , json_file_get_alloc_string_vec , json_file_get_root private subroutine json_file_get_object (this, path, p) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path type(json_value), intent(out), pointer :: p private subroutine json_file_get_integer (this, path, val) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path integer, intent(out) :: val private subroutine json_file_get_double (this, path, val) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path real, intent(out) :: val private subroutine json_file_get_logical (this, path, val) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path logical, intent(out) :: val private subroutine json_file_get_string (this, path, val) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path character(len=:), intent(out), allocatable :: val private subroutine json_file_get_integer_vec (this, path, vec) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path integer, intent(out), dimension(:), allocatable :: vec private subroutine json_file_get_double_vec (this, path, vec) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path real, intent(out), dimension(:), allocatable :: vec private subroutine json_file_get_logical_vec (this, path, vec) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path logical, intent(out), dimension(:), allocatable :: vec private subroutine json_file_get_string_vec (this, path, vec) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path character(len=*), intent(out), dimension(:), allocatable :: vec private subroutine json_file_get_alloc_string_vec (this, path, vec, ilen) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path character(len=:), intent(out), dimension(:), allocatable :: vec integer, intent(out), dimension(:), allocatable :: ilen private subroutine json_file_get_root (this, p) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this type(json_value), intent(out), pointer :: p generic, public :: info => json_file_variable_info private subroutine json_file_variable_info (this, path, n_children) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path integer, intent(out) :: n_children procedure, public :: found private function found (this, path) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path Return Value logical procedure, private :: read_input_json private subroutine read_input_json (this) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this procedure, private :: set_json_core_in_file private subroutine set_json_core_in_file (this, core) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this type(json_core), intent(in) :: core procedure, private :: initialize private subroutine initialize (this, verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys, no_whitespace, unescape_strings, comment_char, path_mode, path_separator, compress_vectors, allow_duplicate_keys) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this logical, intent(in), optional :: verbose logical, intent(in), optional :: compact_reals logical, intent(in), optional :: print_signs character(len=*), intent(in), optional :: real_format integer, intent(in), optional :: spaces_per_tab logical, intent(in), optional :: strict_type_checking logical, intent(in), optional :: trailing_spaces_significant logical, intent(in), optional :: case_sensitive_keys logical, intent(in), optional :: no_whitespace logical, intent(in), optional :: unescape_strings character(len=1), intent(in), optional :: comment_char integer, intent(in), optional :: path_mode character(len=1), intent(in), optional :: path_separator logical, intent(in), optional :: compress_vectors logical, intent(in), optional :: allow_duplicate_keys procedure, private :: print_to_string private subroutine print_to_string (this, str) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=:), intent(out), allocatable :: str procedure, private :: load_file private subroutine load_file (this, filename, unit) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: filename integer, intent(in), optional :: unit procedure, private :: load_from_string private subroutine load_from_string (this, str) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: str procedure, private :: json_file_get_root private subroutine json_file_get_root (this, p) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this type(json_value), intent(out), pointer :: p procedure, private :: json_file_get_alloc_string_vec private subroutine json_file_get_alloc_string_vec (this, path, vec, ilen) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path character(len=:), intent(out), dimension(:), allocatable :: vec integer, intent(out), dimension(:), allocatable :: ilen procedure, private :: json_file_get_string_vec private subroutine json_file_get_string_vec (this, path, vec) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path character(len=*), intent(out), dimension(:), allocatable :: vec procedure, private :: json_file_get_logical_vec private subroutine json_file_get_logical_vec (this, path, vec) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path logical, intent(out), dimension(:), allocatable :: vec procedure, private :: json_file_get_double_vec private subroutine json_file_get_double_vec (this, path, vec) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path real, intent(out), dimension(:), allocatable :: vec procedure, private :: json_file_get_integer_vec private subroutine json_file_get_integer_vec (this, path, vec) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path integer, intent(out), dimension(:), allocatable :: vec procedure, private :: json_file_get_string private subroutine json_file_get_string (this, path, val) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path character(len=:), intent(out), allocatable :: val procedure, private :: json_file_get_logical private subroutine json_file_get_logical (this, path, val) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path logical, intent(out) :: val procedure, private :: json_file_get_double private subroutine json_file_get_double (this, path, val) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path real, intent(out) :: val procedure, private :: json_file_get_integer private subroutine json_file_get_integer (this, path, val) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path integer, intent(out) :: val procedure, private :: json_file_get_object private subroutine json_file_get_object (this, path, p) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path type(json_value), intent(out), pointer :: p procedure, private :: json_file_variable_info private subroutine json_file_variable_info (this, path, n_children) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path integer, intent(out) :: n_children","tags":"","loc":"type/input_json.html"},{"title":"fft2d – QuickPIC ","text":"type, public :: fft2d Inherits type~~fft2d~~InheritsGraph type~fft2d fft2d type~spect2d spect2d type~fft2d->type~spect2d sp type~parallel_pipe parallel_pipe type~fft2d->type~parallel_pipe p type~perrors perrors type~fft2d->type~perrors err type~spect2d->type~parallel_pipe p type~spect2d->type~perrors err type~parallel parallel type~parallel_pipe->type~parallel type~perrors->type~parallel p Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~fft2d~~InheritedByGraph type~fft2d fft2d type~field2d field2d type~field2d->type~fft2d ft type~fft2d_link fft2d_link type~fft2d_link->type~fft2d table type~fft2d_link->type~fft2d_link next type~species2d species2d type~species2d->type~field2d q, qn, cu, amu, dcu type~sim_fields sim_fields type~sim_fields->type~field2d qb, qe, psit, psi, div_vpot, reg, fxy, bxyz, cu, dcu, amu, epw, epwb type~simulation simulation type~simulation->type~sim_fields fields type~sim_species sim_species type~simulation->type~sim_species species type~sim_species->type~species2d spe var pantypefft2dInheritedByGraph = svgPanZoom('#typefft2dInheritedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables sp err p ind nrc mixup sct Type-Bound Procedures new del fsst fcct fs3t divf gradf curlf init_fft2d end_fft2d iwpfs3t2r iwpfcct2r iwpfsst2r ipcurlfd2 ipgradfd2 ipdivfd2 Components Type Visibility Attributes Name Initial class( spect2d ), public, pointer :: sp => null() class( perrors ), public, pointer :: err => null() class( parallel_pipe ), public, pointer :: p => null() integer, private, dimension(2) :: ind integer, private :: nrc integer, private, dimension(:), pointer :: mixup complex, private, dimension(:), pointer :: sct Type-Bound Procedures generic, public :: new => init_fft2d private subroutine init_fft2d (this, pp, perr, psp, indx, indy, nrc) Arguments Type Intent Optional Attributes Name class( fft2d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( spect2d ), intent(in), pointer :: psp integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: nrc generic, public :: del => end_fft2d private subroutine end_fft2d (this) Arguments Type Intent Optional Attributes Name class( fft2d ), intent(inout) :: this generic, public :: fsst => iwpfsst2r private subroutine iwpfsst2r (this, rspace, krspace, isign) Arguments Type Intent Optional Attributes Name class( fft2d ), intent(in) :: this class( ufield2d ), intent(inout) :: rspace class( ufield2d ), intent(inout) :: krspace integer, intent(in) :: isign generic, public :: fcct => iwpfcct2r private subroutine iwpfcct2r (this, rspace, krspace, isign) Arguments Type Intent Optional Attributes Name class( fft2d ), intent(in) :: this class( ufield2d ), intent(inout) :: rspace class( ufield2d ), intent(inout) :: krspace integer, intent(in) :: isign generic, public :: fs3t => iwpfs3t2r private subroutine iwpfs3t2r (this, rspace, krspace, isign) Arguments Type Intent Optional Attributes Name class( fft2d ), intent(in) :: this class( ufield2d ), intent(inout) :: rspace class( ufield2d ), intent(inout) :: krspace integer, intent(in) :: isign generic, public :: divf => ipdivfd2 private subroutine ipdivfd2 (this, krspace, kdspace) Arguments Type Intent Optional Attributes Name class( fft2d ), intent(in) :: this class( ufield2d ), intent(inout) :: krspace class( ufield2d ), intent(inout) :: kdspace generic, public :: gradf => ipgradfd2 private subroutine ipgradfd2 (this, krspace, kdspace) Arguments Type Intent Optional Attributes Name class( fft2d ), intent(in) :: this class( ufield2d ), intent(inout) :: krspace class( ufield2d ), intent(inout) :: kdspace generic, public :: curlf => ipcurlfd2 private subroutine ipcurlfd2 (this, krspace, kdspace) Arguments Type Intent Optional Attributes Name class( fft2d ), intent(in) :: this class( ufield2d ), intent(inout) :: krspace class( ufield2d ), intent(inout) :: kdspace procedure, private :: init_fft2d private subroutine init_fft2d (this, pp, perr, psp, indx, indy, nrc) Arguments Type Intent Optional Attributes Name class( fft2d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( spect2d ), intent(in), pointer :: psp integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: nrc procedure, private :: end_fft2d private subroutine end_fft2d (this) Arguments Type Intent Optional Attributes Name class( fft2d ), intent(inout) :: this procedure, private :: iwpfs3t2r private subroutine iwpfs3t2r (this, rspace, krspace, isign) Arguments Type Intent Optional Attributes Name class( fft2d ), intent(in) :: this class( ufield2d ), intent(inout) :: rspace class( ufield2d ), intent(inout) :: krspace integer, intent(in) :: isign procedure, private :: iwpfcct2r private subroutine iwpfcct2r (this, rspace, krspace, isign) Arguments Type Intent Optional Attributes Name class( fft2d ), intent(in) :: this class( ufield2d ), intent(inout) :: rspace class( ufield2d ), intent(inout) :: krspace integer, intent(in) :: isign procedure, private :: iwpfsst2r private subroutine iwpfsst2r (this, rspace, krspace, isign) Arguments Type Intent Optional Attributes Name class( fft2d ), intent(in) :: this class( ufield2d ), intent(inout) :: rspace class( ufield2d ), intent(inout) :: krspace integer, intent(in) :: isign procedure, private :: ipcurlfd2 private subroutine ipcurlfd2 (this, krspace, kdspace) Arguments Type Intent Optional Attributes Name class( fft2d ), intent(in) :: this class( ufield2d ), intent(inout) :: krspace class( ufield2d ), intent(inout) :: kdspace procedure, private :: ipgradfd2 private subroutine ipgradfd2 (this, krspace, kdspace) Arguments Type Intent Optional Attributes Name class( fft2d ), intent(in) :: this class( ufield2d ), intent(inout) :: krspace class( ufield2d ), intent(inout) :: kdspace procedure, private :: ipdivfd2 private subroutine ipdivfd2 (this, krspace, kdspace) Arguments Type Intent Optional Attributes Name class( fft2d ), intent(in) :: this class( ufield2d ), intent(inout) :: krspace class( ufield2d ), intent(inout) :: kdspace","tags":"","loc":"type/fft2d.html"},{"title":"fft2d_link – QuickPIC ","text":"type, private :: fft2d_link Inherits type~~fft2d_link~~InheritsGraph type~fft2d_link fft2d_link type~fft2d_link->type~fft2d_link next type~fft2d fft2d type~fft2d_link->type~fft2d table type~spect2d spect2d type~fft2d->type~spect2d sp type~parallel_pipe parallel_pipe type~fft2d->type~parallel_pipe p type~perrors perrors type~fft2d->type~perrors err type~spect2d->type~parallel_pipe p type~spect2d->type~perrors err type~parallel parallel type~parallel_pipe->type~parallel type~perrors->type~parallel p Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables next table refcount Components Type Visibility Attributes Name Initial type( fft2d_link ), public, pointer :: next => null() type( fft2d ), public, pointer :: table => null() integer, public :: refcount","tags":"","loc":"type/fft2d_link.html"},{"title":"part3d – QuickPIC ","text":"type, public :: part3d Inherits type~~part3d~~InheritsGraph type~part3d part3d type~parallel_pipe parallel_pipe type~part3d->type~parallel_pipe p type~perrors perrors type~part3d->type~perrors err type~spect3d spect3d type~part3d->type~spect3d sp type~parallel parallel type~parallel_pipe->type~parallel type~perrors->type~parallel p type~spect2d spect2d type~spect3d->type~spect2d type~spect2d->type~parallel_pipe p type~spect2d->type~perrors err Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~part3d~~InheritedByGraph type~part3d part3d type~beam3d beam3d type~beam3d->type~part3d pd type~sim_beams sim_beams type~sim_beams->type~beam3d beam type~simulation simulation type~simulation->type~sim_beams beams Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables sp err p qbm dt ci npmax nbmax xdim npp part pbuff Type-Bound Procedures new del push pmv qdp wr wrst rrst init_part3d end_part3d partpush pmove writehdf5_part3d qdeposit readrst_part3d writerst_part3d getnpp Components Type Visibility Attributes Name Initial class( spect3d ), public, pointer :: sp => null() class( perrors ), public, pointer :: err => null() class( parallel_pipe ), public, pointer :: p => null() real, private :: qbm real, private :: dt real, private :: ci integer, private :: npmax integer, private :: nbmax integer, private :: xdim integer, private :: npp = 0 real, private, dimension(:,:), pointer :: part => null() real, private, dimension(:,:), pointer :: pbuff => null() Type-Bound Procedures generic, public :: new => init_part3d private subroutine init_part3d (this, pp, perr, psp, pf, fd, qbm, dt, ci, xdim) Arguments Type Intent Optional Attributes Name class( part3d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( spect3d ), intent(in), pointer :: psp class( fdist3d ), intent(inout) :: pf class( ufield3d ), intent(in), pointer :: fd real, intent(in) :: qbm real, intent(in) :: dt real, intent(in) :: ci integer, intent(in) :: xdim generic, public :: del => end_part3d private subroutine end_part3d (this) Arguments Type Intent Optional Attributes Name class( part3d ), intent(inout) :: this generic, public :: push => partpush private subroutine partpush (this, ef, bf, dex, dez) Arguments Type Intent Optional Attributes Name class( part3d ), intent(inout) :: this class( ufield3d ), intent(in), pointer :: ef class( ufield3d ), intent(in), pointer :: bf real, intent(in) :: dex real, intent(in) :: dez generic, public :: pmv => pmove private subroutine pmove (this, fd, rtag, stag, sid) Arguments Type Intent Optional Attributes Name class( part3d ), intent(inout) :: this class( ufield3d ), intent(in), pointer :: fd integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: sid generic, public :: qdp => qdeposit private subroutine qdeposit (this, q) Arguments Type Intent Optional Attributes Name class( part3d ), intent(in) :: this class( ufield3d ), intent(in), pointer :: q generic, public :: wr => writehdf5_part3d private subroutine writehdf5_part3d (this, file, dspl, delta, rtag, stag, id) Arguments Type Intent Optional Attributes Name class( part3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file integer, intent(in) :: dspl real, intent(in), dimension(3) :: delta integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id generic, public :: wrst => writerst_part3d private subroutine writerst_part3d (this, file) Arguments Type Intent Optional Attributes Name class( part3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file generic, public :: rrst => readrst_part3d private subroutine readrst_part3d (this, file) Arguments Type Intent Optional Attributes Name class( part3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file procedure, private :: init_part3d private subroutine init_part3d (this, pp, perr, psp, pf, fd, qbm, dt, ci, xdim) Arguments Type Intent Optional Attributes Name class( part3d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( spect3d ), intent(in), pointer :: psp class( fdist3d ), intent(inout) :: pf class( ufield3d ), intent(in), pointer :: fd real, intent(in) :: qbm real, intent(in) :: dt real, intent(in) :: ci integer, intent(in) :: xdim procedure, private :: end_part3d private subroutine end_part3d (this) Arguments Type Intent Optional Attributes Name class( part3d ), intent(inout) :: this procedure, private :: partpush private subroutine partpush (this, ef, bf, dex, dez) Arguments Type Intent Optional Attributes Name class( part3d ), intent(inout) :: this class( ufield3d ), intent(in), pointer :: ef class( ufield3d ), intent(in), pointer :: bf real, intent(in) :: dex real, intent(in) :: dez procedure, private :: pmove private subroutine pmove (this, fd, rtag, stag, sid) Arguments Type Intent Optional Attributes Name class( part3d ), intent(inout) :: this class( ufield3d ), intent(in), pointer :: fd integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: sid procedure, private :: writehdf5_part3d private subroutine writehdf5_part3d (this, file, dspl, delta, rtag, stag, id) Arguments Type Intent Optional Attributes Name class( part3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file integer, intent(in) :: dspl real, intent(in), dimension(3) :: delta integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id procedure, private :: qdeposit private subroutine qdeposit (this, q) Arguments Type Intent Optional Attributes Name class( part3d ), intent(in) :: this class( ufield3d ), intent(in), pointer :: q procedure, private :: readrst_part3d private subroutine readrst_part3d (this, file) Arguments Type Intent Optional Attributes Name class( part3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file procedure, private :: writerst_part3d private subroutine writerst_part3d (this, file) Arguments Type Intent Optional Attributes Name class( part3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file procedure, public :: getnpp private function getnpp (this) Arguments Type Intent Optional Attributes Name class( part3d ), intent(in) :: this Return Value integer","tags":"","loc":"type/part3d.html"},{"title":"fdist2d_wrap – QuickPIC ","text":"type, private :: fdist2d_wrap Inherits type~~fdist2d_wrap~~InheritsGraph type~fdist2d_wrap fdist2d_wrap type~fdist2d fdist2d type~fdist2d_wrap->type~fdist2d p type~spect2d spect2d type~fdist2d->type~spect2d sp type~parallel_pipe parallel_pipe type~fdist2d->type~parallel_pipe p type~perrors perrors type~fdist2d->type~perrors err type~spect2d->type~parallel_pipe p type~spect2d->type~perrors err type~parallel parallel type~parallel_pipe->type~parallel type~perrors->type~parallel p Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~fdist2d_wrap~~InheritedByGraph type~fdist2d_wrap fdist2d_wrap type~sim_species sim_species type~sim_species->type~fdist2d_wrap pf type~simulation simulation type~simulation->type~sim_species species Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables p Components Type Visibility Attributes Name Initial class( fdist2d ), public, allocatable :: p","tags":"","loc":"type/fdist2d_wrap.html"},{"title":"fdist3d_wrap – QuickPIC ","text":"type, private :: fdist3d_wrap Inherits type~~fdist3d_wrap~~InheritsGraph type~fdist3d_wrap fdist3d_wrap type~fdist3d fdist3d type~fdist3d_wrap->type~fdist3d p type~parallel_pipe parallel_pipe type~fdist3d->type~parallel_pipe p type~perrors perrors type~fdist3d->type~perrors err type~spect3d spect3d type~fdist3d->type~spect3d sp type~parallel parallel type~parallel_pipe->type~parallel type~perrors->type~parallel p type~spect2d spect2d type~spect3d->type~spect2d type~spect2d->type~parallel_pipe p type~spect2d->type~perrors err Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~fdist3d_wrap~~InheritedByGraph type~fdist3d_wrap fdist3d_wrap type~sim_beams sim_beams type~sim_beams->type~fdist3d_wrap pf type~simulation simulation type~simulation->type~sim_beams beams Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables p Components Type Visibility Attributes Name Initial class( fdist3d ), public, allocatable :: p","tags":"","loc":"type/fdist3d_wrap.html"},{"title":"sim_fields – QuickPIC ","text":"type, private :: sim_fields Inherits type~~sim_fields~~InheritsGraph type~sim_fields sim_fields type~field3d field3d type~sim_fields->type~field3d bexyz, bbxyz, psi3d, cu3d type~spect3d spect3d type~sim_fields->type~spect3d sp3 type~spect2d spect2d type~sim_fields->type~spect2d sp2 type~field2d field2d type~sim_fields->type~field2d qb, qe, psit, psi, div_vpot, reg, fxy, bxyz, cu, dcu, amu, epw, epwb type~parallel_pipe parallel_pipe type~sim_fields->type~parallel_pipe p type~perrors perrors type~sim_fields->type~perrors err type~field3d->type~spect3d sp type~field3d->type~parallel_pipe p type~field3d->type~perrors err type~ufield3d ufield3d type~field3d->type~ufield3d rs type~spect3d->type~spect2d type~spect2d->type~parallel_pipe p type~spect2d->type~perrors err type~field2d->type~spect2d sp type~field2d->type~parallel_pipe p type~field2d->type~perrors err type~fft2d fft2d type~field2d->type~fft2d ft type~fpois2d fpois2d type~field2d->type~fpois2d pt type~ufield2d ufield2d type~field2d->type~ufield2d rs, ks type~parallel parallel type~parallel_pipe->type~parallel type~perrors->type~parallel p type~ufield3d->type~spect3d sp type~ufield3d->type~parallel_pipe p type~ufield3d->type~perrors err type~fft2d->type~spect2d sp type~fft2d->type~parallel_pipe p type~fft2d->type~perrors err type~fpois2d->type~spect2d sp type~fpois2d->type~parallel_pipe p type~fpois2d->type~perrors err type~ufield2d->type~spect2d sp type~ufield2d->type~parallel_pipe p type~ufield2d->type~perrors err var pantypesim_fieldsInheritsGraph = svgPanZoom('#typesim_fieldsInheritsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~sim_fields~~InheritedByGraph type~sim_fields sim_fields type~simulation simulation type~simulation->type~sim_fields fields Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables p err sp3 sp2 qb qe psit psi div_vpot reg fxy bxyz cu dcu amu epw epwb bexyz bbxyz psi3d cu3d Type-Bound Procedures new del end_sim_fields init_sim_fields Components Type Visibility Attributes Name Initial class( parallel_pipe ), private, pointer :: p => null() class( perrors ), private, pointer :: err => null() class( spect3d ), private, pointer :: sp3 => null() class( spect2d ), private, pointer :: sp2 => null() type( field2d ), private, allocatable :: qb type( field2d ), private, allocatable :: qe type( field2d ), private, allocatable :: psit type( field2d ), private, allocatable :: psi type( field2d ), private, allocatable :: div_vpot type( field2d ), private, allocatable :: reg type( field2d ), private, allocatable :: fxy type( field2d ), private, allocatable :: bxyz type( field2d ), private, allocatable :: cu type( field2d ), private, allocatable :: dcu type( field2d ), private, allocatable :: amu type( field2d ), private, allocatable :: epw type( field2d ), private, allocatable :: epwb type( field3d ), private, allocatable :: bexyz type( field3d ), private, allocatable :: bbxyz type( field3d ), private, allocatable :: psi3d type( field3d ), private, allocatable :: cu3d Type-Bound Procedures generic, public :: new => init_sim_fields private subroutine init_sim_fields (this, input) Arguments Type Intent Optional Attributes Name class( sim_fields ), intent(inout) :: this type( input_json ), intent(inout), pointer :: input generic, public :: del => end_sim_fields private subroutine end_sim_fields (this) Arguments Type Intent Optional Attributes Name class( sim_fields ), intent(inout) :: this procedure, private :: end_sim_fields private subroutine end_sim_fields (this) Arguments Type Intent Optional Attributes Name class( sim_fields ), intent(inout) :: this procedure, private :: init_sim_fields private subroutine init_sim_fields (this, input) Arguments Type Intent Optional Attributes Name class( sim_fields ), intent(inout) :: this type( input_json ), intent(inout), pointer :: input","tags":"","loc":"type/sim_fields.html"},{"title":"sim_beams – QuickPIC ","text":"type, private :: sim_beams Inherits type~~sim_beams~~InheritsGraph type~sim_beams sim_beams type~spect3d spect3d type~sim_beams->type~spect3d sp3 type~spect2d spect2d type~sim_beams->type~spect2d sp2 type~beam3d beam3d type~sim_beams->type~beam3d beam type~parallel_pipe parallel_pipe type~sim_beams->type~parallel_pipe p type~fdist3d_wrap fdist3d_wrap type~sim_beams->type~fdist3d_wrap pf type~perrors perrors type~sim_beams->type~perrors err type~spect3d->type~spect2d type~spect2d->type~parallel_pipe p type~spect2d->type~perrors err type~beam3d->type~spect3d sp type~beam3d->type~parallel_pipe p type~beam3d->type~perrors err type~fdist3d fdist3d type~beam3d->type~fdist3d pf type~field3d field3d type~beam3d->type~field3d q type~part3d part3d type~beam3d->type~part3d pd type~parallel parallel type~parallel_pipe->type~parallel type~fdist3d_wrap->type~fdist3d p type~perrors->type~parallel p type~fdist3d->type~spect3d sp type~fdist3d->type~parallel_pipe p type~fdist3d->type~perrors err type~field3d->type~spect3d sp type~field3d->type~parallel_pipe p type~field3d->type~perrors err type~ufield3d ufield3d type~field3d->type~ufield3d rs type~part3d->type~spect3d sp type~part3d->type~parallel_pipe p type~part3d->type~perrors err type~ufield3d->type~spect3d sp type~ufield3d->type~parallel_pipe p type~ufield3d->type~perrors err var pantypesim_beamsInheritsGraph = svgPanZoom('#typesim_beamsInheritsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~sim_beams~~InheritedByGraph type~sim_beams sim_beams type~simulation simulation type~simulation->type~sim_beams beams Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables p err sp3 sp2 beam pf Type-Bound Procedures new del end_sim_beams init_sim_beams Components Type Visibility Attributes Name Initial class( parallel_pipe ), private, pointer :: p => null() class( perrors ), private, pointer :: err => null() class( spect3d ), private, pointer :: sp3 => null() class( spect2d ), private, pointer :: sp2 => null() type( beam3d ), private, dimension(:), allocatable :: beam type( fdist3d_wrap ), private, dimension(:), allocatable :: pf Type-Bound Procedures generic, public :: new => init_sim_beams private subroutine init_sim_beams (this, input, fields) Arguments Type Intent Optional Attributes Name class( sim_beams ), intent(inout) :: this type( input_json ), intent(inout), pointer :: input class( sim_fields ), intent(inout) :: fields generic, public :: del => end_sim_beams private subroutine end_sim_beams (this) Arguments Type Intent Optional Attributes Name class( sim_beams ), intent(inout) :: this procedure, private :: end_sim_beams private subroutine end_sim_beams (this) Arguments Type Intent Optional Attributes Name class( sim_beams ), intent(inout) :: this procedure, private :: init_sim_beams private subroutine init_sim_beams (this, input, fields) Arguments Type Intent Optional Attributes Name class( sim_beams ), intent(inout) :: this type( input_json ), intent(inout), pointer :: input class( sim_fields ), intent(inout) :: fields","tags":"","loc":"type/sim_beams.html"},{"title":"sim_species – QuickPIC ","text":"type, private :: sim_species Inherits type~~sim_species~~InheritsGraph type~sim_species sim_species type~spect3d spect3d type~sim_species->type~spect3d sp3 type~spect2d spect2d type~sim_species->type~spect2d sp2 type~species2d species2d type~sim_species->type~species2d spe type~parallel_pipe parallel_pipe type~sim_species->type~parallel_pipe p type~fdist2d_wrap fdist2d_wrap type~sim_species->type~fdist2d_wrap pf type~perrors perrors type~sim_species->type~perrors err type~spect3d->type~spect2d type~spect2d->type~parallel_pipe p type~spect2d->type~perrors err type~species2d->type~spect2d sp type~species2d->type~parallel_pipe p type~species2d->type~perrors err type~fdist2d fdist2d type~species2d->type~fdist2d pf type~field3d field3d type~species2d->type~field3d q3 type~part2d part2d type~species2d->type~part2d pd type~field2d field2d type~species2d->type~field2d q, qn, cu, amu, dcu type~parallel parallel type~parallel_pipe->type~parallel type~fdist2d_wrap->type~fdist2d p type~perrors->type~parallel p type~fdist2d->type~spect2d sp type~fdist2d->type~parallel_pipe p type~fdist2d->type~perrors err type~field3d->type~spect3d sp type~field3d->type~parallel_pipe p type~field3d->type~perrors err type~ufield3d ufield3d type~field3d->type~ufield3d rs type~part2d->type~spect2d sp type~part2d->type~parallel_pipe p type~part2d->type~perrors err type~field2d->type~spect2d sp type~field2d->type~parallel_pipe p type~field2d->type~perrors err type~fft2d fft2d type~field2d->type~fft2d ft type~fpois2d fpois2d type~field2d->type~fpois2d pt type~ufield2d ufield2d type~field2d->type~ufield2d rs, ks type~fft2d->type~spect2d sp type~fft2d->type~parallel_pipe p type~fft2d->type~perrors err type~fpois2d->type~spect2d sp type~fpois2d->type~parallel_pipe p type~fpois2d->type~perrors err type~ufield3d->type~spect3d sp type~ufield3d->type~parallel_pipe p type~ufield3d->type~perrors err type~ufield2d->type~spect2d sp type~ufield2d->type~parallel_pipe p type~ufield2d->type~perrors err var pantypesim_speciesInheritsGraph = svgPanZoom('#typesim_speciesInheritsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~sim_species~~InheritedByGraph type~sim_species sim_species type~simulation simulation type~simulation->type~sim_species species Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables p err sp3 sp2 pf spe Type-Bound Procedures new del end_sim_species init_sim_species Components Type Visibility Attributes Name Initial class( parallel_pipe ), private, pointer :: p => null() class( perrors ), private, pointer :: err => null() class( spect3d ), private, pointer :: sp3 => null() class( spect2d ), private, pointer :: sp2 => null() type( fdist2d_wrap ), private, dimension(:), allocatable :: pf type( species2d ), private, dimension(:), allocatable :: spe Type-Bound Procedures generic, public :: new => init_sim_species private subroutine init_sim_species (this, input, fields, s) Arguments Type Intent Optional Attributes Name class( sim_species ), intent(inout) :: this type( input_json ), intent(inout), pointer :: input class( sim_fields ), intent(inout) :: fields real, intent(in) :: s generic, public :: del => end_sim_species private subroutine end_sim_species (this) Arguments Type Intent Optional Attributes Name class( sim_species ), intent(inout) :: this procedure, private :: end_sim_species private subroutine end_sim_species (this) Arguments Type Intent Optional Attributes Name class( sim_species ), intent(inout) :: this procedure, private :: init_sim_species private subroutine init_sim_species (this, input, fields, s) Arguments Type Intent Optional Attributes Name class( sim_species ), intent(inout) :: this type( input_json ), intent(inout), pointer :: input class( sim_fields ), intent(inout) :: fields real, intent(in) :: s","tags":"","loc":"type/sim_species.html"},{"title":"sim_diag – QuickPIC ","text":"type, private :: sim_diag Inherits type~~sim_diag~~InheritsGraph type~sim_diag sim_diag type~spect3d spect3d type~sim_diag->type~spect3d sp3 type~spect2d spect2d type~sim_diag->type~spect2d sp2 type~parallel_pipe parallel_pipe type~sim_diag->type~parallel_pipe p type~hdf5file hdf5file type~sim_diag->type~hdf5file file type~perrors perrors type~sim_diag->type~perrors err type~spect3d->type~spect2d type~spect2d->type~parallel_pipe p type~spect2d->type~perrors err type~parallel parallel type~parallel_pipe->type~parallel type~perrors->type~parallel p Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~sim_diag~~InheritedByGraph type~sim_diag sim_diag type~simulation simulation type~simulation->type~sim_diag diag Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables p err sp3 sp2 file obj slice slice_pos psample dim df Components Type Visibility Attributes Name Initial class( parallel_pipe ), private, pointer :: p => null() class( perrors ), private, pointer :: err => null() class( spect3d ), private, pointer :: sp3 => null() class( spect2d ), private, pointer :: sp2 => null() type( hdf5file ), private :: file class(*), private, pointer :: obj => null() integer, private, allocatable :: slice integer, private, allocatable :: slice_pos integer, private, allocatable :: psample integer, private, allocatable :: dim integer, private :: df","tags":"","loc":"type/sim_diag.html"},{"title":"simulation – QuickPIC ","text":"type, public :: simulation Inherits type~~simulation~~InheritsGraph type~simulation simulation type~spect3d spect3d type~simulation->type~spect3d sp3 type~spect2d spect2d type~simulation->type~spect2d sp2 type~sim_species sim_species type~simulation->type~sim_species species type~sim_diag sim_diag type~simulation->type~sim_diag diag type~parallel_pipe parallel_pipe type~simulation->type~parallel_pipe p type~input_json input_json type~simulation->type~input_json in type~sim_fields sim_fields type~simulation->type~sim_fields fields type~sim_beams sim_beams type~simulation->type~sim_beams beams type~perrors perrors type~simulation->type~perrors err type~spect3d->type~spect2d type~spect2d->type~parallel_pipe p type~spect2d->type~perrors err type~sim_species->type~spect3d sp3 type~sim_species->type~spect2d sp2 type~sim_species->type~parallel_pipe p type~sim_species->type~perrors err type~species2d species2d type~sim_species->type~species2d spe type~fdist2d_wrap fdist2d_wrap type~sim_species->type~fdist2d_wrap pf type~sim_diag->type~spect3d sp3 type~sim_diag->type~spect2d sp2 type~sim_diag->type~parallel_pipe p type~sim_diag->type~perrors err type~hdf5file hdf5file type~sim_diag->type~hdf5file file type~parallel parallel type~parallel_pipe->type~parallel type~input_json->type~spect3d sp type~input_json->type~parallel_pipe pp type~input_json->type~perrors err json_file json_file type~input_json->json_file input type~input_json->type~parallel p type~sim_fields->type~spect3d sp3 type~sim_fields->type~spect2d sp2 type~sim_fields->type~parallel_pipe p type~sim_fields->type~perrors err type~field3d field3d type~sim_fields->type~field3d bexyz, bbxyz, psi3d, cu3d type~field2d field2d type~sim_fields->type~field2d qb, qe, psit, psi, div_vpot, reg, fxy, bxyz, cu, dcu, amu, epw, epwb type~sim_beams->type~spect3d sp3 type~sim_beams->type~spect2d sp2 type~sim_beams->type~parallel_pipe p type~sim_beams->type~perrors err type~beam3d beam3d type~sim_beams->type~beam3d beam type~fdist3d_wrap fdist3d_wrap type~sim_beams->type~fdist3d_wrap pf type~perrors->type~parallel p type~field3d->type~spect3d sp type~field3d->type~parallel_pipe p type~field3d->type~perrors err type~ufield3d ufield3d type~field3d->type~ufield3d rs type~species2d->type~spect2d sp type~species2d->type~parallel_pipe p type~species2d->type~perrors err type~species2d->type~field3d q3 type~species2d->type~field2d q, qn, cu, amu, dcu type~fdist2d fdist2d type~species2d->type~fdist2d pf type~part2d part2d type~species2d->type~part2d pd type~beam3d->type~spect3d sp type~beam3d->type~parallel_pipe p type~beam3d->type~perrors err type~beam3d->type~field3d q type~fdist3d fdist3d type~beam3d->type~fdist3d pf type~part3d part3d type~beam3d->type~part3d pd type~field2d->type~spect2d sp type~field2d->type~parallel_pipe p type~field2d->type~perrors err type~fft2d fft2d type~field2d->type~fft2d ft type~fpois2d fpois2d type~field2d->type~fpois2d pt type~ufield2d ufield2d type~field2d->type~ufield2d rs, ks type~fdist3d_wrap->type~fdist3d p type~fdist2d_wrap->type~fdist2d p type~fdist2d->type~spect2d sp type~fdist2d->type~parallel_pipe p type~fdist2d->type~perrors err type~ufield3d->type~spect3d sp type~ufield3d->type~parallel_pipe p type~ufield3d->type~perrors err type~fdist3d->type~spect3d sp type~fdist3d->type~parallel_pipe p type~fdist3d->type~perrors err type~fft2d->type~spect2d sp type~fft2d->type~parallel_pipe p type~fft2d->type~perrors err type~part2d->type~spect2d sp type~part2d->type~parallel_pipe p type~part2d->type~perrors err type~part3d->type~spect3d sp type~part3d->type~parallel_pipe p type~part3d->type~perrors err type~fpois2d->type~spect2d sp type~fpois2d->type~parallel_pipe p type~fpois2d->type~perrors err type~ufield2d->type~spect2d sp type~ufield2d->type~parallel_pipe p type~ufield2d->type~perrors err var pantypesimulationInheritsGraph = svgPanZoom('#typesimulationInheritsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables in p err sp3 sp2 fields beams species diag iter nstep3d nstep2d start3d nbeams nspecies tstep tag tag_spe id_spe id tag_beam id_beam id_bq tag_bq dex dxi dex2 dt Type-Bound Procedures new del go end_simulation init_simulation diag_simulation init_diag go_simulation Components Type Visibility Attributes Name Initial type( input_json ), private, pointer :: in => null() class( parallel_pipe ), private, pointer :: p => null() class( perrors ), private, pointer :: err => null() class( spect3d ), private, pointer :: sp3 => null() class( spect2d ), private, pointer :: sp2 => null() type( sim_fields ), private :: fields type( sim_beams ), private :: beams type( sim_species ), private :: species type( sim_diag ), private, dimension(:), allocatable :: diag integer, private :: iter integer, private :: nstep3d integer, private :: nstep2d integer, private :: start3d integer, private :: nbeams integer, private :: nspecies integer, private :: tstep integer, private, dimension(8) :: tag integer, private, dimension(:), allocatable :: tag_spe integer, private, dimension(:), allocatable :: id_spe integer, private, dimension(:), allocatable :: id integer, private, dimension(:), allocatable :: tag_beam integer, private, dimension(:), allocatable :: id_beam integer, private, dimension(:,:), allocatable :: id_bq integer, private, dimension(:,:), allocatable :: tag_bq real, private :: dex real, private :: dxi real, private :: dex2 real, private :: dt Type-Bound Procedures generic, public :: new => init_simulation private subroutine init_simulation (this) Arguments Type Intent Optional Attributes Name class( simulation ), intent(inout) :: this generic, public :: del => end_simulation private subroutine end_simulation (this) Arguments Type Intent Optional Attributes Name class( simulation ), intent(inout) :: this generic, public :: go => go_simulation private subroutine go_simulation (this) Arguments Type Intent Optional Attributes Name class( simulation ), intent(inout) :: this procedure, private :: end_simulation private subroutine end_simulation (this) Arguments Type Intent Optional Attributes Name class( simulation ), intent(inout) :: this procedure, private :: init_simulation private subroutine init_simulation (this) Arguments Type Intent Optional Attributes Name class( simulation ), intent(inout) :: this procedure, private :: diag_simulation private subroutine diag_simulation (this) Arguments Type Intent Optional Attributes Name class( simulation ), intent(inout) :: this procedure, private :: init_diag private subroutine init_diag (this) Arguments Type Intent Optional Attributes Name class( simulation ), intent(inout), target :: this procedure, private :: go_simulation private subroutine go_simulation (this) Arguments Type Intent Optional Attributes Name class( simulation ), intent(inout) :: this","tags":"","loc":"type/simulation.html"},{"title":"field2d – QuickPIC ","text":"type, public :: field2d Inherits type~~field2d~~InheritsGraph type~field2d field2d type~fft2d fft2d type~field2d->type~fft2d ft type~spect2d spect2d type~field2d->type~spect2d sp type~fpois2d fpois2d type~field2d->type~fpois2d pt type~parallel_pipe parallel_pipe type~field2d->type~parallel_pipe p type~ufield2d ufield2d type~field2d->type~ufield2d rs, ks type~perrors perrors type~field2d->type~perrors err type~fft2d->type~spect2d sp type~fft2d->type~parallel_pipe p type~fft2d->type~perrors err type~spect2d->type~parallel_pipe p type~spect2d->type~perrors err type~fpois2d->type~spect2d sp type~fpois2d->type~parallel_pipe p type~fpois2d->type~perrors err type~parallel parallel type~parallel_pipe->type~parallel type~ufield2d->type~spect2d sp type~ufield2d->type~parallel_pipe p type~ufield2d->type~perrors err type~perrors->type~parallel p Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~field2d~~InheritedByGraph type~field2d field2d type~species2d species2d type~species2d->type~field2d q, qn, cu, amu, dcu type~sim_fields sim_fields type~sim_fields->type~field2d qb, qe, psit, psi, div_vpot, reg, fxy, bxyz, cu, dcu, amu, epw, epwb type~simulation simulation type~simulation->type~sim_fields fields type~sim_species sim_species type~simulation->type~sim_species species type~sim_species->type~species2d spe var pantypefield2dInheritedByGraph = svgPanZoom('#typefield2dInheritedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables sp err p rs ks ft pt state gcells Type-Bound Procedures new del fftrk fftkr div grad curl pot smooth elf bf bfqp cg ag psend precv cp ca cb as add sub mult wr end_field2d init_field2d divf_field2d fftkr_field2d fftrk_field2d potential_field2d curlf_field2d gradf_field2d bfield_field2d elfield_field2d smoothf_field2d copyguard_field2d bfield_qp_field2d pipesend_field2d acopyguard_field2d multiply1 minus1 sum1 asa asc piperecv_field2d minus2 sum2 multiply2 writehdf5_field2d copyadd copyto copyfrom getks getrs getgcells getstate Components Type Visibility Attributes Name Initial class( spect2d ), public, pointer :: sp => null() class( perrors ), public, pointer :: err => null() class( parallel_pipe ), public, pointer :: p => null() class( ufield2d ), private, pointer :: rs => null() class( ufield2d ), private, pointer :: ks => null() class( fft2d ), private, pointer :: ft => null() class( fpois2d ), private, pointer :: pt => null() integer, private :: state integer, private :: gcells Type-Bound Procedures generic, public :: new => init_field2d private subroutine init_field2d (this, pp, perr, psp, dim, fftflag, state, gcells) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( spect2d ), intent(in), pointer :: psp integer, intent(in) :: dim logical, intent(in) :: fftflag integer, intent(in), optional :: state integer, intent(in), optional :: gcells generic, public :: del => end_field2d private subroutine end_field2d (this) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this generic, public :: fftrk => fftrk_field2d private subroutine fftrk_field2d (this, kind) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this integer, intent(in) :: kind generic, public :: fftkr => fftkr_field2d private subroutine fftkr_field2d (this, kind) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this integer, intent(in) :: kind generic, public :: div => divf_field2d private subroutine divf_field2d (this, that) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(inout) :: that generic, public :: grad => gradf_field2d private subroutine gradf_field2d (this, that) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(inout) :: that generic, public :: curl => curlf_field2d private subroutine curlf_field2d (this, that) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(inout) :: that generic, public :: pot => potential_field2d private subroutine potential_field2d (this, that) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(inout) :: that generic, public :: smooth => smoothf_field2d private subroutine smoothf_field2d (this, that) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(inout) :: that generic, public :: elf => elfield_field2d private subroutine elfield_field2d (this, that) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(inout) :: that generic, public :: bf => bfield_field2d private subroutine bfield_field2d (this, that) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(inout) :: that generic, public :: bfqp => bfield_qp_field2d private subroutine bfield_qp_field2d (cu, dcu, amu, bxy, c, dex) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: cu class( field2d ), intent(inout) :: dcu class( field2d ), intent(inout) :: amu class( field2d ), intent(inout) :: bxy real, intent(in) :: c real, intent(in) :: dex generic, public :: cg => copyguard_field2d private subroutine copyguard_field2d (this) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this generic, public :: ag => acopyguard_field2d private subroutine acopyguard_field2d (this) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this generic, public :: psend => pipesend_field2d private subroutine pipesend_field2d (this, stag, id) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this integer, intent(in) :: stag integer, intent(inout) :: id generic, public :: precv => piperecv_field2d private subroutine piperecv_field2d (this, rtag) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this integer, intent(in) :: rtag generic, public :: cp => copyfrom private subroutine copyfrom (this, that, lpos, sdim, ddim) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field3d ), intent(in) :: that integer, intent(in) :: lpos integer, intent(in), dimension(:) :: sdim integer, intent(in), dimension(:) :: ddim generic, public :: ca => copyadd private subroutine copyadd (this, that, lpos, sdim, ddim) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field3d ), intent(in) :: that integer, intent(in) :: lpos integer, intent(in), dimension(:) :: sdim integer, intent(in), dimension(:) :: ddim generic, public :: cb => copyto private subroutine copyto (this, that, lpos, sdim, ddim) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field3d ), intent(in) :: that integer, intent(in) :: lpos integer, intent(in), dimension(:) :: sdim integer, intent(in), dimension(:) :: ddim generic, public :: as => asc , asa private subroutine asc (this, value) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this real, intent(in) :: value private subroutine asa (this, that) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(inout) :: that generic, public :: add => sum1 , sum2 private subroutine sum1 (this, a1, a2) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(in) :: a1 class( field2d ), intent(in) :: a2 private subroutine sum2 (this, a1, a2, dim, dim1, dim2) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(in) :: a1 class( field2d ), intent(in) :: a2 integer, intent(in), dimension(:) :: dim integer, intent(in), dimension(:) :: dim1 integer, intent(in), dimension(:) :: dim2 generic, public :: sub => minus1 , minus2 private subroutine minus1 (this, a1, a2) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(in) :: a1 class( field2d ), intent(in) :: a2 private subroutine minus2 (this, a1, a2, dim, dim1, dim2) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(in) :: a1 class( field2d ), intent(in) :: a2 integer, intent(in), dimension(:) :: dim integer, intent(in), dimension(:) :: dim1 integer, intent(in), dimension(:) :: dim2 generic, public :: mult => multiply1 , multiply2 private subroutine multiply1 (this, a1, value) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(in) :: a1 real, intent(in) :: value private subroutine multiply2 (this, a1, dim, dim1, value) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(in) :: a1 integer, intent(in), dimension(:) :: dim integer, intent(in), dimension(:) :: dim1 real, intent(in), dimension(:) :: value generic, public :: wr => writehdf5_field2d private subroutine writehdf5_field2d (this, file, dim) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( hdf5file ), intent(in) :: file integer, intent(in) :: dim procedure, private :: end_field2d private subroutine end_field2d (this) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this procedure, private :: init_field2d private subroutine init_field2d (this, pp, perr, psp, dim, fftflag, state, gcells) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( spect2d ), intent(in), pointer :: psp integer, intent(in) :: dim logical, intent(in) :: fftflag integer, intent(in), optional :: state integer, intent(in), optional :: gcells procedure, private :: divf_field2d private subroutine divf_field2d (this, that) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(inout) :: that procedure, private :: fftkr_field2d private subroutine fftkr_field2d (this, kind) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this integer, intent(in) :: kind procedure, private :: fftrk_field2d private subroutine fftrk_field2d (this, kind) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this integer, intent(in) :: kind procedure, private :: potential_field2d private subroutine potential_field2d (this, that) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(inout) :: that procedure, private :: curlf_field2d private subroutine curlf_field2d (this, that) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(inout) :: that procedure, private :: gradf_field2d private subroutine gradf_field2d (this, that) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(inout) :: that procedure, private :: bfield_field2d private subroutine bfield_field2d (this, that) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(inout) :: that procedure, private :: elfield_field2d private subroutine elfield_field2d (this, that) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(inout) :: that procedure, private :: smoothf_field2d private subroutine smoothf_field2d (this, that) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(inout) :: that procedure, private :: copyguard_field2d private subroutine copyguard_field2d (this) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this procedure, private :: bfield_qp_field2d private subroutine bfield_qp_field2d (cu, dcu, amu, bxy, c, dex) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: cu class( field2d ), intent(inout) :: dcu class( field2d ), intent(inout) :: amu class( field2d ), intent(inout) :: bxy real, intent(in) :: c real, intent(in) :: dex procedure, private :: pipesend_field2d private subroutine pipesend_field2d (this, stag, id) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this integer, intent(in) :: stag integer, intent(inout) :: id procedure, private :: acopyguard_field2d private subroutine acopyguard_field2d (this) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this procedure, private :: multiply1 private subroutine multiply1 (this, a1, value) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(in) :: a1 real, intent(in) :: value procedure, private :: minus1 private subroutine minus1 (this, a1, a2) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(in) :: a1 class( field2d ), intent(in) :: a2 procedure, private :: sum1 private subroutine sum1 (this, a1, a2) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(in) :: a1 class( field2d ), intent(in) :: a2 procedure, private :: asa private subroutine asa (this, that) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(inout) :: that procedure, private :: asc private subroutine asc (this, value) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this real, intent(in) :: value procedure, private :: piperecv_field2d private subroutine piperecv_field2d (this, rtag) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this integer, intent(in) :: rtag procedure, private :: minus2 private subroutine minus2 (this, a1, a2, dim, dim1, dim2) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(in) :: a1 class( field2d ), intent(in) :: a2 integer, intent(in), dimension(:) :: dim integer, intent(in), dimension(:) :: dim1 integer, intent(in), dimension(:) :: dim2 procedure, private :: sum2 private subroutine sum2 (this, a1, a2, dim, dim1, dim2) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(in) :: a1 class( field2d ), intent(in) :: a2 integer, intent(in), dimension(:) :: dim integer, intent(in), dimension(:) :: dim1 integer, intent(in), dimension(:) :: dim2 procedure, private :: multiply2 private subroutine multiply2 (this, a1, dim, dim1, value) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(in) :: a1 integer, intent(in), dimension(:) :: dim integer, intent(in), dimension(:) :: dim1 real, intent(in), dimension(:) :: value procedure, private :: writehdf5_field2d private subroutine writehdf5_field2d (this, file, dim) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( hdf5file ), intent(in) :: file integer, intent(in) :: dim procedure, private :: copyadd private subroutine copyadd (this, that, lpos, sdim, ddim) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field3d ), intent(in) :: that integer, intent(in) :: lpos integer, intent(in), dimension(:) :: sdim integer, intent(in), dimension(:) :: ddim procedure, private :: copyto private subroutine copyto (this, that, lpos, sdim, ddim) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field3d ), intent(in) :: that integer, intent(in) :: lpos integer, intent(in), dimension(:) :: sdim integer, intent(in), dimension(:) :: ddim procedure, private :: copyfrom private subroutine copyfrom (this, that, lpos, sdim, ddim) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field3d ), intent(in) :: that integer, intent(in) :: lpos integer, intent(in), dimension(:) :: sdim integer, intent(in), dimension(:) :: ddim procedure, public :: getks private function getks (this) Arguments Type Intent Optional Attributes Name class( field2d ), intent(in) :: this Return Value class( ufield2d ),\n  pointer procedure, public :: getrs private function getrs (this) Arguments Type Intent Optional Attributes Name class( field2d ), intent(in) :: this Return Value class( ufield2d ),\n  pointer procedure, public :: getgcells private function getgcells (this) Arguments Type Intent Optional Attributes Name class( field2d ), intent(in) :: this Return Value integer procedure, public :: getstate private function getstate (this) Arguments Type Intent Optional Attributes Name class( field2d ), intent(in) :: this Return Value integer","tags":"","loc":"type/field2d.html"},{"title":"ufield3d – QuickPIC ","text":"type, public :: ufield3d Inherits type~~ufield3d~~InheritsGraph type~ufield3d ufield3d type~parallel_pipe parallel_pipe type~ufield3d->type~parallel_pipe p type~perrors perrors type~ufield3d->type~perrors err type~spect3d spect3d type~ufield3d->type~spect3d sp type~parallel parallel type~parallel_pipe->type~parallel type~perrors->type~parallel p type~spect2d spect2d type~spect3d->type~spect2d type~spect2d->type~parallel_pipe p type~spect2d->type~perrors err Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~ufield3d~~InheritedByGraph type~ufield3d ufield3d type~field3d field3d type~field3d->type~ufield3d rs type~species2d species2d type~species2d->type~field3d q3 type~sim_fields sim_fields type~sim_fields->type~field3d bexyz, bbxyz, psi3d, cu3d type~beam3d beam3d type~beam3d->type~field3d q type~simulation simulation type~simulation->type~sim_fields fields type~sim_species sim_species type~simulation->type~sim_species species type~sim_beams sim_beams type~simulation->type~sim_beams beams type~sim_species->type~species2d spe type~sim_beams->type~beam3d beam Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables sp err p dim noff nd1 nvpx nd1p nd2 nvpy nd2p nd3 nvpz nd3p rf Finalization Procedures final_ufield3d Type-Bound Procedures new del pcg ag cp cb ca wr as add sub mult init_ufield3d end_ufield3d getdim getnd1p getnvpx getnd1 getnd2p getnvpy getnd2 getnd3p getnvpz getnd3 getnoff getrf acopyguard copyguard_pipe copyadd copyout copyin writehdf5_2dslice writehdf5_3d multiply minus sum asa asc Components Type Visibility Attributes Name Initial class( spect3d ), public, pointer :: sp => null() class( perrors ), public, pointer :: err => null() class( parallel_pipe ), public, pointer :: p => null() integer, private :: dim integer, private, dimension(2) :: noff integer, private :: nd1 integer, private :: nvpx integer, private :: nd1p integer, private :: nd2 integer, private :: nvpy integer, private :: nd2p integer, private :: nd3 integer, private :: nvpz integer, private :: nd3p real, private, dimension(:,:,:,:), pointer :: rf => null() Finalization Procedures final :: final_ufield3d private subroutine final_ufield3d (this) Arguments Type Intent Optional Attributes Name type( ufield3d ), intent(inout) :: this Type-Bound Procedures generic, public :: new => init_ufield3d private subroutine init_ufield3d (this, pp, perr, psp, dim, nvpx, nvpy, nvpz) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( spect3d ), intent(in), pointer :: psp integer, intent(in) :: dim integer, intent(in) :: nvpx integer, intent(in) :: nvpy integer, intent(in) :: nvpz generic, public :: del => end_ufield3d private subroutine end_ufield3d (this) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(inout) :: this generic, public :: pcg => copyguard_pipe private subroutine copyguard_pipe (this, rtag, stag, rid, sid) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(inout) :: this integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: rid integer, intent(inout) :: sid generic, public :: ag => acopyguard private subroutine acopyguard (this, rtag, stag, id) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(inout) :: this integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id generic, public :: cp => copyin private subroutine copyin (this, fd2d, lpos, sdim, ddim) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(inout) :: this class( ufield2d ), intent(in), target :: fd2d integer, intent(in) :: lpos integer, intent(in), dimension(:) :: sdim integer, intent(in), dimension(:) :: ddim generic, public :: cb => copyout private subroutine copyout (this, fd2d, lpos, sdim, ddim) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(inout) :: this class( ufield2d ), intent(in), target :: fd2d integer, intent(in) :: lpos integer, intent(in), dimension(:) :: sdim integer, intent(in), dimension(:) :: ddim generic, public :: ca => copyadd private subroutine copyadd (this, fd2d, lpos, sdim, ddim) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(inout) :: this class( ufield2d ), intent(in), target :: fd2d integer, intent(in) :: lpos integer, intent(in), dimension(:) :: sdim integer, intent(in), dimension(:) :: ddim generic, public :: wr => writehdf5_3d , writehdf5_2dslice private subroutine writehdf5_3d (this, file, dim, rtag, stag, id) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file integer, intent(in) :: dim integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id private subroutine writehdf5_2dslice (this, file, dim, slice, spos, rtag, stag, id) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file integer, intent(in) :: dim integer, intent(in) :: slice integer, intent(in) :: spos integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id generic, public :: as => asc , asa private subroutine asc (this, value) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(inout) :: this real, intent(in) :: value private subroutine asa (this, that) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(inout) :: this class( ufield3d ), intent(in), target :: that generic, public :: add => sum private subroutine sum (this, a1, a2) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(inout) :: this class( ufield3d ), intent(in), target :: a1 class( ufield3d ), intent(in), target :: a2 generic, public :: sub => minus private subroutine minus (this, a1, a2) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(inout) :: this class( ufield3d ), intent(in), target :: a1 class( ufield3d ), intent(in), target :: a2 generic, public :: mult => multiply private subroutine multiply (this, a1, value) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(inout) :: this class( ufield3d ), intent(in), target :: a1 real, intent(in) :: value procedure, private :: init_ufield3d private subroutine init_ufield3d (this, pp, perr, psp, dim, nvpx, nvpy, nvpz) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( spect3d ), intent(in), pointer :: psp integer, intent(in) :: dim integer, intent(in) :: nvpx integer, intent(in) :: nvpy integer, intent(in) :: nvpz procedure, private :: end_ufield3d private subroutine end_ufield3d (this) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(inout) :: this procedure, public :: getdim private function getdim (this) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(in) :: this Return Value integer procedure, public :: getnd1p private function getnd1p (this) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(in) :: this Return Value integer procedure, public :: getnvpx private function getnvpx (this) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(in) :: this Return Value integer procedure, public :: getnd1 private function getnd1 (this) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(in) :: this Return Value integer procedure, public :: getnd2p private function getnd2p (this) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(in) :: this Return Value integer procedure, public :: getnvpy private function getnvpy (this) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(in) :: this Return Value integer procedure, public :: getnd2 private function getnd2 (this) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(in) :: this Return Value integer procedure, public :: getnd3p private function getnd3p (this) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(in) :: this Return Value integer procedure, public :: getnvpz private function getnvpz (this) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(in) :: this Return Value integer procedure, public :: getnd3 private function getnd3 (this) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(in) :: this Return Value integer procedure, public :: getnoff private function getnoff (this) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(in) :: this Return Value integer,\n  dimension(2) procedure, public :: getrf private function getrf (this) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(in) :: this Return Value real,\n  dimension(:,:,:,:), pointer procedure, private :: acopyguard private subroutine acopyguard (this, rtag, stag, id) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(inout) :: this integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id procedure, private :: copyguard_pipe private subroutine copyguard_pipe (this, rtag, stag, rid, sid) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(inout) :: this integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: rid integer, intent(inout) :: sid procedure, private :: copyadd private subroutine copyadd (this, fd2d, lpos, sdim, ddim) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(inout) :: this class( ufield2d ), intent(in), target :: fd2d integer, intent(in) :: lpos integer, intent(in), dimension(:) :: sdim integer, intent(in), dimension(:) :: ddim procedure, private :: copyout private subroutine copyout (this, fd2d, lpos, sdim, ddim) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(inout) :: this class( ufield2d ), intent(in), target :: fd2d integer, intent(in) :: lpos integer, intent(in), dimension(:) :: sdim integer, intent(in), dimension(:) :: ddim procedure, private :: copyin private subroutine copyin (this, fd2d, lpos, sdim, ddim) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(inout) :: this class( ufield2d ), intent(in), target :: fd2d integer, intent(in) :: lpos integer, intent(in), dimension(:) :: sdim integer, intent(in), dimension(:) :: ddim procedure, private :: writehdf5_2dslice private subroutine writehdf5_2dslice (this, file, dim, slice, spos, rtag, stag, id) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file integer, intent(in) :: dim integer, intent(in) :: slice integer, intent(in) :: spos integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id procedure, private :: writehdf5_3d private subroutine writehdf5_3d (this, file, dim, rtag, stag, id) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file integer, intent(in) :: dim integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id procedure, private :: multiply private subroutine multiply (this, a1, value) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(inout) :: this class( ufield3d ), intent(in), target :: a1 real, intent(in) :: value procedure, private :: minus private subroutine minus (this, a1, a2) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(inout) :: this class( ufield3d ), intent(in), target :: a1 class( ufield3d ), intent(in), target :: a2 procedure, private :: sum private subroutine sum (this, a1, a2) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(inout) :: this class( ufield3d ), intent(in), target :: a1 class( ufield3d ), intent(in), target :: a2 procedure, private :: asa private subroutine asa (this, that) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(inout) :: this class( ufield3d ), intent(in), target :: that procedure, private :: asc private subroutine asc (this, value) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(inout) :: this real, intent(in) :: value","tags":"","loc":"type/ufield3d.html"},{"title":"fdist3d – QuickPIC ","text":"type, public, abstract :: fdist3d Inherits type~~fdist3d~~InheritsGraph type~fdist3d fdist3d type~parallel_pipe parallel_pipe type~fdist3d->type~parallel_pipe p type~perrors perrors type~fdist3d->type~perrors err type~spect3d spect3d type~fdist3d->type~spect3d sp type~parallel parallel type~parallel_pipe->type~parallel type~perrors->type~parallel p type~spect2d spect2d type~spect3d->type~spect2d type~spect2d->type~parallel_pipe p type~spect2d->type~perrors err Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~fdist3d~~InheritedByGraph type~fdist3d fdist3d type~beam3d beam3d type~beam3d->type~fdist3d pf type~fdist3d_000 fdist3d_000 type~fdist3d_000->type~fdist3d type~fdist3d_wrap fdist3d_wrap type~fdist3d_wrap->type~fdist3d p type~sim_beams sim_beams type~sim_beams->type~beam3d beam type~sim_beams->type~fdist3d_wrap pf type~simulation simulation type~simulation->type~sim_beams beams Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables sp err p npf npmax Type-Bound Procedures new del dist init_fdist3d end_fdist3d dist3d getnpmax getnpf Components Type Visibility Attributes Name Initial class( spect3d ), public, pointer :: sp => null() class( perrors ), public, pointer :: err => null() class( parallel_pipe ), public, pointer :: p => null() integer, private :: npf integer, private :: npmax Type-Bound Procedures generic, public :: new => init_fdist3d private subroutine init_fdist3d_000 (this, input, i) Arguments Type Intent Optional Attributes Name class( fdist3d_000 ), intent(inout) :: this type( input_json ), intent(inout), pointer :: input integer, intent(in) :: i generic, public :: del => end_fdist3d private subroutine end_fdist3d (this) Arguments Type Intent Optional Attributes Name class( fdist3d ), intent(inout) :: this generic, public :: dist => dist3d private subroutine dist3d_000 (this, part3d, npp, fd) Arguments Type Intent Optional Attributes Name class( fdist3d_000 ), intent(inout) :: this real, intent(inout), dimension(:,:), pointer :: part3d integer, intent(inout) :: npp class( ufield3d ), intent(in), pointer :: fd procedure( ab_init_fdist3d ), private, deferred :: init_fdist3d subroutine ab_init_fdist3d(this, input, i) Prototype Arguments Type Intent Optional Attributes Name class( fdist3d ), intent(inout) :: this type( input_json ), intent(inout), pointer :: input integer, intent(in) :: i procedure, private :: end_fdist3d private subroutine end_fdist3d (this) Arguments Type Intent Optional Attributes Name class( fdist3d ), intent(inout) :: this procedure( ab_dist3d ), private, deferred :: dist3d subroutine ab_dist3d(this, part3d, npp, fd) Prototype Arguments Type Intent Optional Attributes Name class( fdist3d ), intent(inout) :: this real, intent(inout), dimension(:,:), pointer :: part3d integer, intent(inout) :: npp class( ufield3d ), intent(in), pointer :: fd procedure, public :: getnpmax private function getnpmax (this) Arguments Type Intent Optional Attributes Name class( fdist3d ), intent(in) :: this Return Value integer procedure, public :: getnpf private function getnpf (this) Arguments Type Intent Optional Attributes Name class( fdist3d ), intent(in) :: this Return Value integer","tags":"","loc":"type/fdist3d.html"},{"title":"fdist3d_000 – QuickPIC ","text":"type, public, extends( fdist3d ) :: fdist3d_000 Inherits type~~fdist3d_000~~InheritsGraph type~fdist3d_000 fdist3d_000 type~fdist3d fdist3d type~fdist3d_000->type~fdist3d type~parallel_pipe parallel_pipe type~fdist3d->type~parallel_pipe p type~perrors perrors type~fdist3d->type~perrors err type~spect3d spect3d type~fdist3d->type~spect3d sp type~parallel parallel type~parallel_pipe->type~parallel type~perrors->type~parallel p type~spect2d spect2d type~spect3d->type~spect2d type~spect2d->type~parallel_pipe p type~spect2d->type~perrors err Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables sp err p npx npy npz qm sigx sigy sigz bcx bcy bcz sigvx sigvy sigvz cx1 cx2 cx3 cy1 cy2 cy3 gamma np quiet Type-Bound Procedures new del dist getnpmax getnpf init_fdist3d dist3d Components Type Visibility Attributes Name Initial class( spect3d ), public, pointer :: sp => null() class( perrors ), public, pointer :: err => null() class( parallel_pipe ), public, pointer :: p => null() integer, private :: npx integer, private :: npy integer, private :: npz real, private :: qm real, private :: sigx real, private :: sigy real, private :: sigz real, private :: bcx real, private :: bcy real, private :: bcz real, private :: sigvx real, private :: sigvy real, private :: sigvz real, private :: cx1 real, private :: cx2 real, private :: cx3 real, private :: cy1 real, private :: cy2 real, private :: cy3 real, private :: gamma real, private :: np logical, private :: quiet Type-Bound Procedures generic, public :: new => init_fdist3d private subroutine init_fdist3d_000 (this, input, i) Arguments Type Intent Optional Attributes Name class( fdist3d_000 ), intent(inout) :: this type( input_json ), intent(inout), pointer :: input integer, intent(in) :: i generic, public :: del => end_fdist3d private subroutine end_fdist3d (this) Arguments Type Intent Optional Attributes Name class( fdist3d ), intent(inout) :: this generic, public :: dist => dist3d private subroutine dist3d_000 (this, part3d, npp, fd) Arguments Type Intent Optional Attributes Name class( fdist3d_000 ), intent(inout) :: this real, intent(inout), dimension(:,:), pointer :: part3d integer, intent(inout) :: npp class( ufield3d ), intent(in), pointer :: fd procedure, public :: getnpmax private function getnpmax (this) Arguments Type Intent Optional Attributes Name class( fdist3d ), intent(in) :: this Return Value integer procedure, public :: getnpf private function getnpf (this) Arguments Type Intent Optional Attributes Name class( fdist3d ), intent(in) :: this Return Value integer procedure, private :: init_fdist3d => init_fdist3d_000 private subroutine init_fdist3d_000 (this, input, i) Arguments Type Intent Optional Attributes Name class( fdist3d_000 ), intent(inout) :: this type( input_json ), intent(inout), pointer :: input integer, intent(in) :: i procedure, private :: dist3d => dist3d_000 private subroutine dist3d_000 (this, part3d, npp, fd) Arguments Type Intent Optional Attributes Name class( fdist3d_000 ), intent(inout) :: this real, intent(inout), dimension(:,:), pointer :: part3d integer, intent(inout) :: npp class( ufield3d ), intent(in), pointer :: fd","tags":"","loc":"type/fdist3d_000.html"},{"title":"parallel – QuickPIC ","text":"type, public :: parallel Inherited by type~~parallel~~InheritedByGraph type~parallel parallel type~input_json input_json type~input_json->type~parallel p type~parallel_pipe parallel_pipe type~input_json->type~parallel_pipe pp type~perrors perrors type~input_json->type~perrors err type~spect3d spect3d type~input_json->type~spect3d sp type~parallel_pipe->type~parallel type~perrors->type~parallel p type~simulation simulation type~simulation->type~input_json in type~simulation->type~parallel_pipe p type~simulation->type~perrors err type~spect2d spect2d type~simulation->type~spect2d sp2 type~sim_species sim_species type~simulation->type~sim_species species type~sim_beams sim_beams type~simulation->type~sim_beams beams type~sim_diag sim_diag type~simulation->type~sim_diag diag type~sim_fields sim_fields type~simulation->type~sim_fields fields type~simulation->type~spect3d sp3 type~fdist2d fdist2d type~fdist2d->type~parallel_pipe p type~fdist2d->type~perrors err type~fdist2d->type~spect2d sp type~ufield3d ufield3d type~ufield3d->type~parallel_pipe p type~ufield3d->type~perrors err type~ufield3d->type~spect3d sp type~field3d field3d type~field3d->type~parallel_pipe p type~field3d->type~perrors err type~field3d->type~ufield3d rs type~field3d->type~spect3d sp type~fdist3d fdist3d type~fdist3d->type~parallel_pipe p type~fdist3d->type~perrors err type~fdist3d->type~spect3d sp type~fft2d fft2d type~fft2d->type~parallel_pipe p type~fft2d->type~perrors err type~fft2d->type~spect2d sp type~spect2d->type~parallel_pipe p type~spect2d->type~perrors err type~beam3d beam3d type~beam3d->type~parallel_pipe p type~beam3d->type~perrors err type~beam3d->type~field3d q type~beam3d->type~fdist3d pf type~part3d part3d type~beam3d->type~part3d pd type~beam3d->type~spect3d sp type~sim_species->type~parallel_pipe p type~sim_species->type~perrors err type~sim_species->type~spect2d sp2 type~species2d species2d type~sim_species->type~species2d spe type~sim_species->type~spect3d sp3 type~fdist2d_wrap fdist2d_wrap type~sim_species->type~fdist2d_wrap pf type~species2d->type~parallel_pipe p type~species2d->type~perrors err type~species2d->type~fdist2d pf type~species2d->type~field3d q3 type~species2d->type~spect2d sp type~field2d field2d type~species2d->type~field2d q, qn, cu, amu, dcu type~part2d part2d type~species2d->type~part2d pd type~sim_beams->type~parallel_pipe p type~sim_beams->type~perrors err type~sim_beams->type~spect2d sp2 type~sim_beams->type~beam3d beam type~sim_beams->type~spect3d sp3 type~fdist3d_wrap fdist3d_wrap type~sim_beams->type~fdist3d_wrap pf type~field2d->type~parallel_pipe p type~field2d->type~perrors err type~field2d->type~fft2d ft type~field2d->type~spect2d sp type~fpois2d fpois2d type~field2d->type~fpois2d pt type~ufield2d ufield2d type~field2d->type~ufield2d rs, ks type~part3d->type~parallel_pipe p type~part3d->type~perrors err type~part3d->type~spect3d sp type~part2d->type~parallel_pipe p type~part2d->type~perrors err type~part2d->type~spect2d sp type~sim_diag->type~parallel_pipe p type~sim_diag->type~perrors err type~sim_diag->type~spect2d sp2 type~sim_diag->type~spect3d sp3 type~fpois2d->type~parallel_pipe p type~fpois2d->type~perrors err type~fpois2d->type~spect2d sp type~sim_fields->type~parallel_pipe p type~sim_fields->type~perrors err type~sim_fields->type~field3d bexyz, bbxyz, psi3d, cu3d type~sim_fields->type~spect2d sp2 type~sim_fields->type~field2d qb, qe, psit, psi, div_vpot, reg, fxy, bxyz, cu, dcu, amu, epw, epwb type~sim_fields->type~spect3d sp3 type~ufield2d->type~parallel_pipe p type~ufield2d->type~perrors err type~ufield2d->type~spect2d sp type~spect3d->type~spect2d type~fpois2d_link fpois2d_link type~fpois2d_link->type~fpois2d table type~fpois2d_link->type~fpois2d_link next type~fdist3d_000 fdist3d_000 type~fdist3d_000->type~fdist3d type~fdist3d_wrap->type~fdist3d p type~fdist2d_wrap->type~fdist2d p type~fdist2d_000 fdist2d_000 type~fdist2d_000->type~fdist2d type~fft2d_link fft2d_link type~fft2d_link->type~fft2d table type~fft2d_link->type~fft2d_link next var pantypeparallelInheritedByGraph = svgPanZoom('#typeparallelInheritedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables nvp idproc kstrt mreal mint mcplx mdouble mchar lworld Type-Bound Procedures new del getnvp getidproc getkstrt getlworld getmreal getmint getmdouble getmcplx getmchar init_parallel end_parallel Components Type Visibility Attributes Name Initial integer, private :: nvp integer, private :: idproc integer, private :: kstrt integer, private :: mreal integer, private :: mint integer, private :: mcplx integer, private :: mdouble integer, private :: mchar integer, private :: lworld Type-Bound Procedures generic, public :: new => init_parallel private subroutine init_parallel (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(inout) :: this generic, public :: del => end_parallel private subroutine end_parallel (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(inout) :: this procedure, public :: getnvp private function getnvp (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer procedure, public :: getidproc private function getidproc (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer procedure, public :: getkstrt private function getkstrt (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer procedure, public :: getlworld private function getlworld (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer procedure, public :: getmreal private function getmreal (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer procedure, public :: getmint private function getmint (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer procedure, public :: getmdouble private function getmdouble (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer procedure, public :: getmcplx private function getmcplx (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer procedure, public :: getmchar private function getmchar (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer procedure, private :: init_parallel private subroutine init_parallel (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(inout) :: this procedure, private :: end_parallel private subroutine end_parallel (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(inout) :: this","tags":"","loc":"type/parallel.html"},{"title":"part2d – QuickPIC ","text":"type, public :: part2d Inherits type~~part2d~~InheritsGraph type~part2d part2d type~spect2d spect2d type~part2d->type~spect2d sp type~parallel_pipe parallel_pipe type~part2d->type~parallel_pipe p type~perrors perrors type~part2d->type~perrors err type~spect2d->type~parallel_pipe p type~spect2d->type~perrors err type~parallel parallel type~parallel_pipe->type~parallel type~perrors->type~parallel p Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~part2d~~InheritedByGraph type~part2d part2d type~species2d species2d type~species2d->type~part2d pd type~sim_species sim_species type~sim_species->type~species2d spe type~simulation simulation type~simulation->type~sim_species species Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables sp err p qbm dt ci npmax nbmax np xdim npp part ppart nppmx nppmx0 nbmaxp ntmaxp npbmx irc ncl ihole kpic Type-Bound Procedures new renew del qdp amjdp push pmv extpsi pcp pcb psend precv wr renew_part2d init_part2d end_part2d qdeposit amjdeposit partpush pmove extractpsi partcopy partcopyback pipesend_part2d writehdf5_part2d piperecv_part2d Components Type Visibility Attributes Name Initial class( spect2d ), public, pointer :: sp => null() class( perrors ), public, pointer :: err => null() class( parallel_pipe ), public, pointer :: p => null() real, private :: qbm real, private :: dt real, private :: ci integer, private :: npmax integer, private :: nbmax integer, private :: np integer, private :: xdim integer, private :: npp = 0 real, private, dimension(:,:), pointer :: part => null() real, private, dimension(:,:,:), pointer :: ppart => null() integer, private :: nppmx integer, private :: nppmx0 integer, private :: nbmaxp integer, private :: ntmaxp integer, private :: npbmx integer, private :: irc = 0 integer, private, dimension(:,:), pointer :: ncl => null() integer, private, dimension(:,:,:), pointer :: ihole => null() integer, private, dimension(:), pointer :: kpic => null() Type-Bound Procedures generic, public :: new => init_part2d private subroutine init_part2d (this, pp, perr, psp, pf, fd, qbm, dt, ci, xdim, s) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( spect2d ), intent(in), pointer :: psp class( fdist2d ), intent(inout) :: pf class( ufield2d ), intent(in), pointer :: fd real, intent(in) :: qbm real, intent(in) :: dt real, intent(in) :: ci integer, intent(in) :: xdim real, intent(in) :: s generic, public :: renew => renew_part2d private subroutine renew_part2d (this, pf, fd, s) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this class( fdist2d ), intent(inout) :: pf class( ufield2d ), intent(in), pointer :: fd real, intent(in) :: s generic, public :: del => end_part2d private subroutine end_part2d (this) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this generic, public :: qdp => qdeposit private subroutine qdeposit (this, q) Arguments Type Intent Optional Attributes Name class( part2d ), intent(in) :: this class( ufield2d ), intent(in), pointer :: q generic, public :: amjdp => amjdeposit private subroutine amjdeposit (this, ef, bf, psit, cu, amu, dcu, dex) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this class( ufield2d ), intent(in), pointer :: ef class( ufield2d ), intent(in), pointer :: bf class( ufield2d ), intent(in), pointer :: psit class( ufield2d ), intent(in), pointer :: cu class( ufield2d ), intent(in), pointer :: amu class( ufield2d ), intent(in), pointer :: dcu real, intent(in) :: dex generic, public :: push => partpush private subroutine partpush (this, ef, bf, psit, dex) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this class( ufield2d ), intent(in), pointer :: ef class( ufield2d ), intent(in), pointer :: bf class( ufield2d ), intent(in), pointer :: psit real, intent(in) :: dex generic, public :: pmv => pmove private subroutine pmove (this, fd) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this class( ufield2d ), intent(in), pointer :: fd generic, public :: extpsi => extractpsi private subroutine extractpsi (this, psi, dex) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this class( ufield2d ), intent(in), pointer :: psi real, intent(in) :: dex generic, public :: pcp => partcopy private subroutine partcopy (this, fd) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this class( ufield2d ), intent(in), pointer :: fd generic, public :: pcb => partcopyback private subroutine partcopyback (this) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this generic, public :: psend => pipesend_part2d private subroutine pipesend_part2d (this, tag, id) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this integer, intent(in) :: tag integer, intent(inout) :: id generic, public :: precv => piperecv_part2d private subroutine piperecv_part2d (this, fd, tag) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this class( ufield2d ), intent(in), pointer :: fd integer, intent(in) :: tag generic, public :: wr => writehdf5_part2d private subroutine writehdf5_part2d (this, file, delta) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this class( hdf5file ), intent(in) :: file real, intent(in), dimension(2) :: delta procedure, private :: renew_part2d private subroutine renew_part2d (this, pf, fd, s) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this class( fdist2d ), intent(inout) :: pf class( ufield2d ), intent(in), pointer :: fd real, intent(in) :: s procedure, private :: init_part2d private subroutine init_part2d (this, pp, perr, psp, pf, fd, qbm, dt, ci, xdim, s) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( spect2d ), intent(in), pointer :: psp class( fdist2d ), intent(inout) :: pf class( ufield2d ), intent(in), pointer :: fd real, intent(in) :: qbm real, intent(in) :: dt real, intent(in) :: ci integer, intent(in) :: xdim real, intent(in) :: s procedure, private :: end_part2d private subroutine end_part2d (this) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this procedure, private :: qdeposit private subroutine qdeposit (this, q) Arguments Type Intent Optional Attributes Name class( part2d ), intent(in) :: this class( ufield2d ), intent(in), pointer :: q procedure, private :: amjdeposit private subroutine amjdeposit (this, ef, bf, psit, cu, amu, dcu, dex) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this class( ufield2d ), intent(in), pointer :: ef class( ufield2d ), intent(in), pointer :: bf class( ufield2d ), intent(in), pointer :: psit class( ufield2d ), intent(in), pointer :: cu class( ufield2d ), intent(in), pointer :: amu class( ufield2d ), intent(in), pointer :: dcu real, intent(in) :: dex procedure, private :: partpush private subroutine partpush (this, ef, bf, psit, dex) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this class( ufield2d ), intent(in), pointer :: ef class( ufield2d ), intent(in), pointer :: bf class( ufield2d ), intent(in), pointer :: psit real, intent(in) :: dex procedure, private :: pmove private subroutine pmove (this, fd) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this class( ufield2d ), intent(in), pointer :: fd procedure, private :: extractpsi private subroutine extractpsi (this, psi, dex) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this class( ufield2d ), intent(in), pointer :: psi real, intent(in) :: dex procedure, private :: partcopy private subroutine partcopy (this, fd) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this class( ufield2d ), intent(in), pointer :: fd procedure, private :: partcopyback private subroutine partcopyback (this) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this procedure, private :: pipesend_part2d private subroutine pipesend_part2d (this, tag, id) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this integer, intent(in) :: tag integer, intent(inout) :: id procedure, private :: writehdf5_part2d private subroutine writehdf5_part2d (this, file, delta) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this class( hdf5file ), intent(in) :: file real, intent(in), dimension(2) :: delta procedure, private :: piperecv_part2d private subroutine piperecv_part2d (this, fd, tag) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this class( ufield2d ), intent(in), pointer :: fd integer, intent(in) :: tag","tags":"","loc":"type/part2d.html"},{"title":"spect3d – QuickPIC ","text":"type, public, extends( spect2d ) :: spect3d Inherits type~~spect3d~~InheritsGraph type~spect3d spect3d type~spect2d spect2d type~spect3d->type~spect2d type~parallel_pipe parallel_pipe type~spect2d->type~parallel_pipe p type~perrors perrors type~spect2d->type~perrors err type~parallel parallel type~parallel_pipe->type~parallel type~perrors->type~parallel p Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~spect3d~~InheritedByGraph type~spect3d spect3d type~simulation simulation type~simulation->type~spect3d sp3 type~sim_species sim_species type~simulation->type~sim_species species type~sim_diag sim_diag type~simulation->type~sim_diag diag type~input_json input_json type~simulation->type~input_json in type~sim_fields sim_fields type~simulation->type~sim_fields fields type~sim_beams sim_beams type~simulation->type~sim_beams beams type~ufield3d ufield3d type~ufield3d->type~spect3d sp type~field3d field3d type~field3d->type~spect3d sp type~field3d->type~ufield3d rs type~fdist3d fdist3d type~fdist3d->type~spect3d sp type~beam3d beam3d type~beam3d->type~spect3d sp type~beam3d->type~field3d q type~beam3d->type~fdist3d pf type~part3d part3d type~beam3d->type~part3d pd type~sim_species->type~spect3d sp3 type~species2d species2d type~sim_species->type~species2d spe type~part3d->type~spect3d sp type~sim_diag->type~spect3d sp3 type~input_json->type~spect3d sp type~sim_fields->type~spect3d sp3 type~sim_fields->type~field3d bexyz, bbxyz, psi3d, cu3d type~sim_beams->type~spect3d sp3 type~sim_beams->type~beam3d beam type~fdist3d_wrap fdist3d_wrap type~sim_beams->type~fdist3d_wrap pf type~species2d->type~field3d q3 type~fdist3d_000 fdist3d_000 type~fdist3d_000->type~fdist3d type~fdist3d_wrap->type~fdist3d p var pantypespect3dInheritedByGraph = svgPanZoom('#typespect3dInheritedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables err p indz Type-Bound Procedures del getindx getindy getpsolver getinorder init_spect3d end_spect2d new getindz Components Type Visibility Attributes Name Initial class( perrors ), public, pointer :: err => null() class( parallel_pipe ), public, pointer :: p => null() integer, private :: indz Type-Bound Procedures generic, public :: del => end_spect2d private subroutine end_spect3d (this) Arguments Type Intent Optional Attributes Name class( spect3d ), intent(inout) :: this procedure, public :: getindx private function getindx (this) Arguments Type Intent Optional Attributes Name class( spect2d ), intent(in) :: this Return Value integer procedure, public :: getindy private function getindy (this) Arguments Type Intent Optional Attributes Name class( spect2d ), intent(in) :: this Return Value integer procedure, public :: getpsolver private function getpsolver (this) Arguments Type Intent Optional Attributes Name class( spect2d ), intent(in) :: this Return Value integer procedure, public :: getinorder private function getinorder (this) Arguments Type Intent Optional Attributes Name class( spect2d ), intent(in) :: this Return Value integer procedure, private :: init_spect3d private subroutine init_spect3d (this, pp, perr, indx, indy, indz, psolver, inorder) Arguments Type Intent Optional Attributes Name class( spect3d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: indz integer, intent(in) :: psolver integer, intent(in) :: inorder procedure, private :: end_spect2d => end_spect3d private subroutine end_spect3d (this) Arguments Type Intent Optional Attributes Name class( spect3d ), intent(inout) :: this generic, public :: new => init_spect2d , init_spect3d private subroutine init_spect2d (this, pp, perr, indx, indy, psolver, inorder) Arguments Type Intent Optional Attributes Name class( spect2d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: psolver integer, intent(in) :: inorder private subroutine init_spect3d (this, pp, perr, indx, indy, indz, psolver, inorder) Arguments Type Intent Optional Attributes Name class( spect3d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: indz integer, intent(in) :: psolver integer, intent(in) :: inorder procedure, public :: getindz private function getindz (this) Arguments Type Intent Optional Attributes Name class( spect3d ), intent(in) :: this Return Value integer","tags":"","loc":"type/spect3d.html"},{"title":"fdist2d – QuickPIC ","text":"type, public, abstract :: fdist2d Inherits type~~fdist2d~~InheritsGraph type~fdist2d fdist2d type~spect2d spect2d type~fdist2d->type~spect2d sp type~parallel_pipe parallel_pipe type~fdist2d->type~parallel_pipe p type~perrors perrors type~fdist2d->type~perrors err type~spect2d->type~parallel_pipe p type~spect2d->type~perrors err type~parallel parallel type~parallel_pipe->type~parallel type~perrors->type~parallel p Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~fdist2d~~InheritedByGraph type~fdist2d fdist2d type~fdist2d_wrap fdist2d_wrap type~fdist2d_wrap->type~fdist2d p type~fdist2d_000 fdist2d_000 type~fdist2d_000->type~fdist2d type~species2d species2d type~species2d->type~fdist2d pf type~sim_species sim_species type~sim_species->type~fdist2d_wrap pf type~sim_species->type~species2d spe type~simulation simulation type~simulation->type~sim_species species Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables sp err p npf npmax Type-Bound Procedures new del dist init_fdist2d end_fdist2d dist2d getnpmax getnpf Components Type Visibility Attributes Name Initial class( spect2d ), public, pointer :: sp => null() class( perrors ), public, pointer :: err => null() class( parallel_pipe ), public, pointer :: p => null() integer, private :: npf integer, private :: npmax Type-Bound Procedures generic, public :: new => init_fdist2d private subroutine init_fdist2d_000 (this, input, i) Arguments Type Intent Optional Attributes Name class( fdist2d_000 ), intent(inout) :: this type( input_json ), intent(inout), pointer :: input integer, intent(in) :: i generic, public :: del => end_fdist2d private subroutine end_fdist2d (this) Arguments Type Intent Optional Attributes Name class( fdist2d ), intent(inout) :: this generic, public :: dist => dist2d private subroutine dist2d_000 (this, part2d, npp, fd, s) Arguments Type Intent Optional Attributes Name class( fdist2d_000 ), intent(inout) :: this real, intent(inout), dimension(:,:), pointer :: part2d integer, intent(inout) :: npp class( ufield2d ), intent(in), pointer :: fd real, intent(in) :: s procedure( ab_init_fdist2d ), private, deferred :: init_fdist2d subroutine ab_init_fdist2d(this, input, i) Prototype Arguments Type Intent Optional Attributes Name class( fdist2d ), intent(inout) :: this type( input_json ), intent(inout), pointer :: input integer, intent(in) :: i procedure, private :: end_fdist2d private subroutine end_fdist2d (this) Arguments Type Intent Optional Attributes Name class( fdist2d ), intent(inout) :: this procedure( ab_dist2d ), private, deferred :: dist2d subroutine ab_dist2d(this, part2d, npp, fd, s) Prototype Arguments Type Intent Optional Attributes Name class( fdist2d ), intent(inout) :: this real, intent(inout), dimension(:,:), pointer :: part2d integer, intent(inout) :: npp class( ufield2d ), intent(in), pointer :: fd real, intent(in) :: s procedure, public :: getnpmax private function getnpmax (this) Arguments Type Intent Optional Attributes Name class( fdist2d ), intent(in) :: this Return Value integer procedure, public :: getnpf private function getnpf (this) Arguments Type Intent Optional Attributes Name class( fdist2d ), intent(in) :: this Return Value integer","tags":"","loc":"type/fdist2d.html"},{"title":"fdist2d_000 – QuickPIC ","text":"type, public, extends( fdist2d ) :: fdist2d_000 Inherits type~~fdist2d_000~~InheritsGraph type~fdist2d_000 fdist2d_000 type~fdist2d fdist2d type~fdist2d_000->type~fdist2d type~spect2d spect2d type~fdist2d->type~spect2d sp type~parallel_pipe parallel_pipe type~fdist2d->type~parallel_pipe p type~perrors perrors type~fdist2d->type~perrors err type~spect2d->type~parallel_pipe p type~spect2d->type~perrors err type~parallel parallel type~parallel_pipe->type~parallel type~perrors->type~parallel p Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables sp err p xppc yppc qm den long_prof s fs Type-Bound Procedures new del dist getnpmax getnpf init_fdist2d dist2d Components Type Visibility Attributes Name Initial class( spect2d ), public, pointer :: sp => null() class( perrors ), public, pointer :: err => null() class( parallel_pipe ), public, pointer :: p => null() integer, private :: xppc integer, private :: yppc real, private :: qm real, private :: den character(len=:), private, allocatable :: long_prof real, private, dimension(:), allocatable :: s real, private, dimension(:), allocatable :: fs Type-Bound Procedures generic, public :: new => init_fdist2d private subroutine init_fdist2d_000 (this, input, i) Arguments Type Intent Optional Attributes Name class( fdist2d_000 ), intent(inout) :: this type( input_json ), intent(inout), pointer :: input integer, intent(in) :: i generic, public :: del => end_fdist2d private subroutine end_fdist2d (this) Arguments Type Intent Optional Attributes Name class( fdist2d ), intent(inout) :: this generic, public :: dist => dist2d private subroutine dist2d_000 (this, part2d, npp, fd, s) Arguments Type Intent Optional Attributes Name class( fdist2d_000 ), intent(inout) :: this real, intent(inout), dimension(:,:), pointer :: part2d integer, intent(inout) :: npp class( ufield2d ), intent(in), pointer :: fd real, intent(in) :: s procedure, public :: getnpmax private function getnpmax (this) Arguments Type Intent Optional Attributes Name class( fdist2d ), intent(in) :: this Return Value integer procedure, public :: getnpf private function getnpf (this) Arguments Type Intent Optional Attributes Name class( fdist2d ), intent(in) :: this Return Value integer procedure, private :: init_fdist2d => init_fdist2d_000 private subroutine init_fdist2d_000 (this, input, i) Arguments Type Intent Optional Attributes Name class( fdist2d_000 ), intent(inout) :: this type( input_json ), intent(inout), pointer :: input integer, intent(in) :: i procedure, private :: dist2d => dist2d_000 private subroutine dist2d_000 (this, part2d, npp, fd, s) Arguments Type Intent Optional Attributes Name class( fdist2d_000 ), intent(inout) :: this real, intent(inout), dimension(:,:), pointer :: part2d integer, intent(inout) :: npp class( ufield2d ), intent(in), pointer :: fd real, intent(in) :: s","tags":"","loc":"type/fdist2d_000.html"},{"title":"hdf5file – QuickPIC ","text":"type, public :: hdf5file Inherited by type~~hdf5file~~InheritedByGraph type~hdf5file hdf5file type~sim_diag sim_diag type~sim_diag->type~hdf5file file type~simulation simulation type~simulation->type~sim_diag diag Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables filename timeunits dataname units label ty n rank t dt axisname axislabel axisunits axismax axismin Type-Bound Procedures new init_hdf5file Components Type Visibility Attributes Name Initial character(len=100), private :: filename = 'file.h5' character(len=100), private :: timeunits = 'a.u.' character(len=100), private :: dataname = 'Data' character(len=100), private :: units = 'a.u.' character(len=100), private :: label = 'Data' character(len=100), private :: ty = 'grid' integer, private :: n = 1 integer, private :: rank = 2 real, private :: t = 1.0 real, private :: dt = 1.0 character(len=100), private, dimension(3) :: axisname = (/'x1', 'x2', 'x3'/) character(len=100), private, dimension(3) :: axislabel = (/'x1', 'x2', 'x3'/) character(len=100), private, dimension(3) :: axisunits = (/'a.u.', 'a.u.', 'a.u.'/) real, private, dimension(3) :: axismax = (/1.0, 1.0, 1.0/) real, private, dimension(3) :: axismin = (/0.0, 0.0, 0.0/) Type-Bound Procedures generic, public :: new => init_hdf5file private subroutine init_hdf5file (this, filename, timeunits, ty, n, t, dt, axisname, axislabel, axisunits, axismax, axismin, dataname, units, label, rank) Arguments Type Intent Optional Attributes Name class( hdf5file ), intent(inout) :: this character(len=*), intent(in), optional :: filename character(len=*), intent(in), optional :: timeunits character(len=*), intent(in), optional :: ty integer, intent(in), optional :: n real, intent(in), optional :: t real, intent(in), optional :: dt character(len=*), intent(in), optional dimension(3) :: axisname character(len=*), intent(in), optional dimension(3) :: axislabel character(len=*), intent(in), optional dimension(3) :: axisunits real, intent(in), optional dimension(3) :: axismax real, intent(in), optional dimension(3) :: axismin character(len=*), intent(in), optional :: dataname character(len=*), intent(in), optional :: units character(len=*), intent(in), optional :: label integer, intent(in), optional :: rank procedure, private :: init_hdf5file private subroutine init_hdf5file (this, filename, timeunits, ty, n, t, dt, axisname, axislabel, axisunits, axismax, axismin, dataname, units, label, rank) Arguments Type Intent Optional Attributes Name class( hdf5file ), intent(inout) :: this character(len=*), intent(in), optional :: filename character(len=*), intent(in), optional :: timeunits character(len=*), intent(in), optional :: ty integer, intent(in), optional :: n real, intent(in), optional :: t real, intent(in), optional :: dt character(len=*), intent(in), optional dimension(3) :: axisname character(len=*), intent(in), optional dimension(3) :: axislabel character(len=*), intent(in), optional dimension(3) :: axisunits real, intent(in), optional dimension(3) :: axismax real, intent(in), optional dimension(3) :: axismin character(len=*), intent(in), optional :: dataname character(len=*), intent(in), optional :: units character(len=*), intent(in), optional :: label integer, intent(in), optional :: rank","tags":"","loc":"type/hdf5file.html"},{"title":"beam3d – QuickPIC ","text":"type, public :: beam3d Inherits type~~beam3d~~InheritsGraph type~beam3d beam3d type~field3d field3d type~beam3d->type~field3d q type~spect3d spect3d type~beam3d->type~spect3d sp type~fdist3d fdist3d type~beam3d->type~fdist3d pf type~part3d part3d type~beam3d->type~part3d pd type~parallel_pipe parallel_pipe type~beam3d->type~parallel_pipe p type~perrors perrors type~beam3d->type~perrors err type~field3d->type~spect3d sp type~field3d->type~parallel_pipe p type~field3d->type~perrors err type~ufield3d ufield3d type~field3d->type~ufield3d rs type~spect2d spect2d type~spect3d->type~spect2d type~fdist3d->type~spect3d sp type~fdist3d->type~parallel_pipe p type~fdist3d->type~perrors err type~part3d->type~spect3d sp type~part3d->type~parallel_pipe p type~part3d->type~perrors err type~parallel parallel type~parallel_pipe->type~parallel type~perrors->type~parallel p type~spect2d->type~parallel_pipe p type~spect2d->type~perrors err type~ufield3d->type~spect3d sp type~ufield3d->type~parallel_pipe p type~ufield3d->type~perrors err var pantypebeam3dInheritsGraph = svgPanZoom('#typebeam3dInheritsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~beam3d~~InheritedByGraph type~beam3d beam3d type~sim_beams sim_beams type~sim_beams->type~beam3d beam type~simulation simulation type~simulation->type~sim_beams beams Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables sp err p pd q pf Type-Bound Procedures new del push pmv qdp wr wrq wrst rrst init_beam3d end_beam3d push_beam3d pmove_beam3d writehdf5_beam3d qdeposit_beam3d readrst_beam3d writerst_beam3d writeqslice_beam3d writeq_beam3d qdpcopy_beam3d Components Type Visibility Attributes Name Initial class( spect3d ), public, pointer :: sp => null() class( perrors ), public, pointer :: err => null() class( parallel_pipe ), public, pointer :: p => null() class( part3d ), private, pointer :: pd class( field3d ), private, pointer :: q => null() class( fdist3d ), private, pointer :: pf => null() Type-Bound Procedures generic, public :: new => init_beam3d private subroutine init_beam3d (this, pp, perr, psp, pf, qbm, dt, ci, xdim) Arguments Type Intent Optional Attributes Name class( beam3d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( spect3d ), intent(in), pointer :: psp class( fdist3d ), intent(inout), target :: pf real, intent(in) :: qbm real, intent(in) :: dt real, intent(in) :: ci integer, intent(in) :: xdim generic, public :: del => end_beam3d private subroutine end_beam3d (this) Arguments Type Intent Optional Attributes Name class( beam3d ), intent(inout) :: this generic, public :: push => push_beam3d private subroutine push_beam3d (this, ef, bf, dex, dez, rtag, stag, sid) Arguments Type Intent Optional Attributes Name class( beam3d ), intent(inout) :: this class( field3d ), intent(in) :: ef class( field3d ), intent(in) :: bf real, intent(in) :: dex real, intent(in) :: dez integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: sid generic, public :: pmv => pmove_beam3d private subroutine pmove_beam3d (this, fd, rtag, stag, sid) Arguments Type Intent Optional Attributes Name class( beam3d ), intent(inout) :: this class( field3d ), intent(in) :: fd integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: sid generic, public :: qdp => qdeposit_beam3d , qdpcopy_beam3d private subroutine qdeposit_beam3d (this, id1, id2, id3, tag1, tag2) Arguments Type Intent Optional Attributes Name class( beam3d ), intent(inout) :: this integer, intent(inout) :: id1 integer, intent(inout) :: id2 integer, intent(inout) :: id3 integer, intent(inout) :: tag1 integer, intent(inout) :: tag2 private subroutine qdpcopy_beam3d (this, q, slice) Arguments Type Intent Optional Attributes Name class( beam3d ), intent(inout) :: this class( field2d ), intent(inout) :: q integer, intent(in) :: slice generic, public :: wr => writehdf5_beam3d private subroutine writehdf5_beam3d (this, file, dspl, delta, rtag, stag, id) Arguments Type Intent Optional Attributes Name class( beam3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file integer, intent(in) :: dspl real, intent(in), dimension(3) :: delta integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id generic, public :: wrq => writeq_beam3d , writeqslice_beam3d private subroutine writeq_beam3d (this, file, rtag, stag, id) Arguments Type Intent Optional Attributes Name class( beam3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id private subroutine writeqslice_beam3d (this, file, slice, spos, rtag, stag, id) Arguments Type Intent Optional Attributes Name class( beam3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file integer, intent(in) :: slice integer, intent(in) :: spos integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id generic, public :: wrst => writerst_beam3d private subroutine writerst_beam3d (this, file) Arguments Type Intent Optional Attributes Name class( beam3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file generic, public :: rrst => readrst_beam3d private subroutine readrst_beam3d (this, file) Arguments Type Intent Optional Attributes Name class( beam3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file procedure, private :: init_beam3d private subroutine init_beam3d (this, pp, perr, psp, pf, qbm, dt, ci, xdim) Arguments Type Intent Optional Attributes Name class( beam3d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( spect3d ), intent(in), pointer :: psp class( fdist3d ), intent(inout), target :: pf real, intent(in) :: qbm real, intent(in) :: dt real, intent(in) :: ci integer, intent(in) :: xdim procedure, private :: end_beam3d private subroutine end_beam3d (this) Arguments Type Intent Optional Attributes Name class( beam3d ), intent(inout) :: this procedure, private :: push_beam3d private subroutine push_beam3d (this, ef, bf, dex, dez, rtag, stag, sid) Arguments Type Intent Optional Attributes Name class( beam3d ), intent(inout) :: this class( field3d ), intent(in) :: ef class( field3d ), intent(in) :: bf real, intent(in) :: dex real, intent(in) :: dez integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: sid procedure, private :: pmove_beam3d private subroutine pmove_beam3d (this, fd, rtag, stag, sid) Arguments Type Intent Optional Attributes Name class( beam3d ), intent(inout) :: this class( field3d ), intent(in) :: fd integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: sid procedure, private :: writehdf5_beam3d private subroutine writehdf5_beam3d (this, file, dspl, delta, rtag, stag, id) Arguments Type Intent Optional Attributes Name class( beam3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file integer, intent(in) :: dspl real, intent(in), dimension(3) :: delta integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id procedure, private :: qdeposit_beam3d private subroutine qdeposit_beam3d (this, id1, id2, id3, tag1, tag2) Arguments Type Intent Optional Attributes Name class( beam3d ), intent(inout) :: this integer, intent(inout) :: id1 integer, intent(inout) :: id2 integer, intent(inout) :: id3 integer, intent(inout) :: tag1 integer, intent(inout) :: tag2 procedure, private :: readrst_beam3d private subroutine readrst_beam3d (this, file) Arguments Type Intent Optional Attributes Name class( beam3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file procedure, private :: writerst_beam3d private subroutine writerst_beam3d (this, file) Arguments Type Intent Optional Attributes Name class( beam3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file procedure, private :: writeqslice_beam3d private subroutine writeqslice_beam3d (this, file, slice, spos, rtag, stag, id) Arguments Type Intent Optional Attributes Name class( beam3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file integer, intent(in) :: slice integer, intent(in) :: spos integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id procedure, private :: writeq_beam3d private subroutine writeq_beam3d (this, file, rtag, stag, id) Arguments Type Intent Optional Attributes Name class( beam3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id procedure, private :: qdpcopy_beam3d private subroutine qdpcopy_beam3d (this, q, slice) Arguments Type Intent Optional Attributes Name class( beam3d ), intent(inout) :: this class( field2d ), intent(inout) :: q integer, intent(in) :: slice","tags":"","loc":"type/beam3d.html"},{"title":"species2d – QuickPIC ","text":"type, public :: species2d Inherits type~~species2d~~InheritsGraph type~species2d species2d type~fdist2d fdist2d type~species2d->type~fdist2d pf type~field3d field3d type~species2d->type~field3d q3 type~spect2d spect2d type~species2d->type~spect2d sp type~part2d part2d type~species2d->type~part2d pd type~field2d field2d type~species2d->type~field2d q, qn, cu, amu, dcu type~parallel_pipe parallel_pipe type~species2d->type~parallel_pipe p type~perrors perrors type~species2d->type~perrors err type~fdist2d->type~spect2d sp type~fdist2d->type~parallel_pipe p type~fdist2d->type~perrors err type~field3d->type~parallel_pipe p type~field3d->type~perrors err type~ufield3d ufield3d type~field3d->type~ufield3d rs type~spect3d spect3d type~field3d->type~spect3d sp type~spect2d->type~parallel_pipe p type~spect2d->type~perrors err type~part2d->type~spect2d sp type~part2d->type~parallel_pipe p type~part2d->type~perrors err type~field2d->type~spect2d sp type~field2d->type~parallel_pipe p type~field2d->type~perrors err type~fft2d fft2d type~field2d->type~fft2d ft type~fpois2d fpois2d type~field2d->type~fpois2d pt type~ufield2d ufield2d type~field2d->type~ufield2d rs, ks type~parallel parallel type~parallel_pipe->type~parallel type~perrors->type~parallel p type~ufield3d->type~parallel_pipe p type~ufield3d->type~perrors err type~ufield3d->type~spect3d sp type~spect3d->type~spect2d type~fft2d->type~spect2d sp type~fft2d->type~parallel_pipe p type~fft2d->type~perrors err type~fpois2d->type~spect2d sp type~fpois2d->type~parallel_pipe p type~fpois2d->type~perrors err type~ufield2d->type~spect2d sp type~ufield2d->type~parallel_pipe p type~ufield2d->type~perrors err var pantypespecies2dInheritsGraph = svgPanZoom('#typespecies2dInheritsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~species2d~~InheritedByGraph type~species2d species2d type~sim_species sim_species type~sim_species->type~species2d spe type~simulation simulation type~simulation->type~sim_species species Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables sp err p pd q qn cu amu dcu q3 pf Type-Bound Procedures new renew del qdp amjdp push pmv extpsi pcp pcb psend precv wr wrq cbq renew_species2d init_species2d end_species2d qdp_species2d amjdp_species2d push_species2d pmove_species2d extpsi_species2d pcp_species2d pcb_species2d psend_species2d writehdf5_species2d precv_species2d writeqslice_species2d writeq_species2d cbq_species2d Components Type Visibility Attributes Name Initial class( spect2d ), public, pointer :: sp => null() class( perrors ), public, pointer :: err => null() class( parallel_pipe ), public, pointer :: p => null() class( part2d ), private, pointer :: pd => null() class( field2d ), private, pointer :: q => null() class( field2d ), private, pointer :: qn => null() class( field2d ), private, pointer :: cu => null() class( field2d ), private, pointer :: amu => null() class( field2d ), private, pointer :: dcu => null() class( field3d ), private, pointer :: q3 => null() class( fdist2d ), private, pointer :: pf => null() Type-Bound Procedures generic, public :: new => init_species2d private subroutine init_species2d (this, pp, perr, psp, pf, qbm, dt, ci, xdim, s) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( spect3d ), intent(in), pointer :: psp class( fdist2d ), intent(inout), target :: pf real, intent(in) :: qbm real, intent(in) :: dt real, intent(in) :: ci integer, intent(in) :: xdim real, intent(in) :: s generic, public :: renew => renew_species2d private subroutine renew_species2d (this, s) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this real, intent(in) :: s generic, public :: del => end_species2d private subroutine end_species2d (this) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this generic, public :: qdp => qdp_species2d private subroutine qdp_species2d (this, q) Arguments Type Intent Optional Attributes Name class( species2d ), intent(in) :: this class( field2d ), intent(inout) :: q generic, public :: amjdp => amjdp_species2d private subroutine amjdp_species2d (this, ef, bf, psit, cu, amu, dcu, dex) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this class( field2d ), intent(in) :: ef class( field2d ), intent(in) :: bf class( field2d ), intent(in) :: psit class( field2d ), intent(inout) :: cu class( field2d ), intent(inout) :: amu class( field2d ), intent(inout) :: dcu real, intent(in) :: dex generic, public :: push => push_species2d private subroutine push_species2d (this, ef, bf, psit, dex) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this class( field2d ), intent(in) :: ef class( field2d ), intent(in) :: bf class( field2d ), intent(in) :: psit real, intent(in) :: dex generic, public :: pmv => pmove_species2d private subroutine pmove_species2d (this, fd) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this class( field2d ), intent(in) :: fd generic, public :: extpsi => extpsi_species2d private subroutine extpsi_species2d (this, psi, dex) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this class( field2d ), intent(in) :: psi real, intent(in) :: dex generic, public :: pcp => pcp_species2d private subroutine pcp_species2d (this, fd) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this class( field2d ), intent(in) :: fd generic, public :: pcb => pcb_species2d private subroutine pcb_species2d (this) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this generic, public :: psend => psend_species2d private subroutine psend_species2d (this, tag, id) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this integer, intent(in) :: tag integer, intent(inout) :: id generic, public :: precv => precv_species2d private subroutine precv_species2d (this, tag) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this integer, intent(in) :: tag generic, public :: wr => writehdf5_species2d private subroutine writehdf5_species2d (this, file, delta) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this class( hdf5file ), intent(in) :: file real, intent(in), dimension(2) :: delta generic, public :: wrq => writeq_species2d , writeqslice_species2d private subroutine writeq_species2d (this, file, rtag, stag, id) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this class( hdf5file ), intent(in) :: file integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id private subroutine writeqslice_species2d (this, file, slice, spos, rtag, stag, id) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this class( hdf5file ), intent(in) :: file integer, intent(in) :: slice integer, intent(in) :: spos integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id generic, public :: cbq => cbq_species2d private subroutine cbq_species2d (this, pos) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this integer, intent(in) :: pos procedure, private :: renew_species2d private subroutine renew_species2d (this, s) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this real, intent(in) :: s procedure, private :: init_species2d private subroutine init_species2d (this, pp, perr, psp, pf, qbm, dt, ci, xdim, s) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( spect3d ), intent(in), pointer :: psp class( fdist2d ), intent(inout), target :: pf real, intent(in) :: qbm real, intent(in) :: dt real, intent(in) :: ci integer, intent(in) :: xdim real, intent(in) :: s procedure, private :: end_species2d private subroutine end_species2d (this) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this procedure, private :: qdp_species2d private subroutine qdp_species2d (this, q) Arguments Type Intent Optional Attributes Name class( species2d ), intent(in) :: this class( field2d ), intent(inout) :: q procedure, private :: amjdp_species2d private subroutine amjdp_species2d (this, ef, bf, psit, cu, amu, dcu, dex) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this class( field2d ), intent(in) :: ef class( field2d ), intent(in) :: bf class( field2d ), intent(in) :: psit class( field2d ), intent(inout) :: cu class( field2d ), intent(inout) :: amu class( field2d ), intent(inout) :: dcu real, intent(in) :: dex procedure, private :: push_species2d private subroutine push_species2d (this, ef, bf, psit, dex) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this class( field2d ), intent(in) :: ef class( field2d ), intent(in) :: bf class( field2d ), intent(in) :: psit real, intent(in) :: dex procedure, private :: pmove_species2d private subroutine pmove_species2d (this, fd) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this class( field2d ), intent(in) :: fd procedure, private :: extpsi_species2d private subroutine extpsi_species2d (this, psi, dex) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this class( field2d ), intent(in) :: psi real, intent(in) :: dex procedure, private :: pcp_species2d private subroutine pcp_species2d (this, fd) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this class( field2d ), intent(in) :: fd procedure, private :: pcb_species2d private subroutine pcb_species2d (this) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this procedure, private :: psend_species2d private subroutine psend_species2d (this, tag, id) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this integer, intent(in) :: tag integer, intent(inout) :: id procedure, private :: writehdf5_species2d private subroutine writehdf5_species2d (this, file, delta) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this class( hdf5file ), intent(in) :: file real, intent(in), dimension(2) :: delta procedure, private :: precv_species2d private subroutine precv_species2d (this, tag) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this integer, intent(in) :: tag procedure, private :: writeqslice_species2d private subroutine writeqslice_species2d (this, file, slice, spos, rtag, stag, id) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this class( hdf5file ), intent(in) :: file integer, intent(in) :: slice integer, intent(in) :: spos integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id procedure, private :: writeq_species2d private subroutine writeq_species2d (this, file, rtag, stag, id) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this class( hdf5file ), intent(in) :: file integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id procedure, private :: cbq_species2d private subroutine cbq_species2d (this, pos) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this integer, intent(in) :: pos","tags":"","loc":"type/species2d.html"},{"title":"parallel_pipe – QuickPIC ","text":"type, public, extends( parallel ) :: parallel_pipe Inherits type~~parallel_pipe~~InheritsGraph type~parallel_pipe parallel_pipe type~parallel parallel type~parallel_pipe->type~parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~parallel_pipe~~InheritedByGraph type~parallel_pipe parallel_pipe type~fdist2d fdist2d type~fdist2d->type~parallel_pipe p type~spect2d spect2d type~fdist2d->type~spect2d sp type~simulation simulation type~simulation->type~parallel_pipe p type~simulation->type~spect2d sp2 type~sim_species sim_species type~simulation->type~sim_species species type~sim_beams sim_beams type~simulation->type~sim_beams beams type~sim_diag sim_diag type~simulation->type~sim_diag diag type~input_json input_json type~simulation->type~input_json in type~sim_fields sim_fields type~simulation->type~sim_fields fields type~spect3d spect3d type~simulation->type~spect3d sp3 type~ufield3d ufield3d type~ufield3d->type~parallel_pipe p type~ufield3d->type~spect3d sp type~field3d field3d type~field3d->type~parallel_pipe p type~field3d->type~ufield3d rs type~field3d->type~spect3d sp type~fdist3d fdist3d type~fdist3d->type~parallel_pipe p type~fdist3d->type~spect3d sp type~fft2d fft2d type~fft2d->type~parallel_pipe p type~fft2d->type~spect2d sp type~spect2d->type~parallel_pipe p type~beam3d beam3d type~beam3d->type~parallel_pipe p type~beam3d->type~field3d q type~beam3d->type~fdist3d pf type~part3d part3d type~beam3d->type~part3d pd type~beam3d->type~spect3d sp type~sim_species->type~parallel_pipe p type~sim_species->type~spect2d sp2 type~species2d species2d type~sim_species->type~species2d spe type~sim_species->type~spect3d sp3 type~fdist2d_wrap fdist2d_wrap type~sim_species->type~fdist2d_wrap pf type~species2d->type~parallel_pipe p type~species2d->type~fdist2d pf type~species2d->type~field3d q3 type~species2d->type~spect2d sp type~field2d field2d type~species2d->type~field2d q, qn, cu, amu, dcu type~part2d part2d type~species2d->type~part2d pd type~sim_beams->type~parallel_pipe p type~sim_beams->type~spect2d sp2 type~sim_beams->type~beam3d beam type~sim_beams->type~spect3d sp3 type~fdist3d_wrap fdist3d_wrap type~sim_beams->type~fdist3d_wrap pf type~field2d->type~parallel_pipe p type~field2d->type~fft2d ft type~field2d->type~spect2d sp type~fpois2d fpois2d type~field2d->type~fpois2d pt type~ufield2d ufield2d type~field2d->type~ufield2d rs, ks type~part3d->type~parallel_pipe p type~part3d->type~spect3d sp type~part2d->type~parallel_pipe p type~part2d->type~spect2d sp type~sim_diag->type~parallel_pipe p type~sim_diag->type~spect2d sp2 type~sim_diag->type~spect3d sp3 type~fpois2d->type~parallel_pipe p type~fpois2d->type~spect2d sp type~input_json->type~parallel_pipe pp type~input_json->type~spect3d sp type~sim_fields->type~parallel_pipe p type~sim_fields->type~field3d bexyz, bbxyz, psi3d, cu3d type~sim_fields->type~spect2d sp2 type~sim_fields->type~field2d qb, qe, psit, psi, div_vpot, reg, fxy, bxyz, cu, dcu, amu, epw, epwb type~sim_fields->type~spect3d sp3 type~ufield2d->type~parallel_pipe p type~ufield2d->type~spect2d sp type~spect3d->type~spect2d type~fpois2d_link fpois2d_link type~fpois2d_link->type~fpois2d table type~fpois2d_link->type~fpois2d_link next type~fdist3d_000 fdist3d_000 type~fdist3d_000->type~fdist3d type~fdist3d_wrap->type~fdist3d p type~fdist2d_wrap->type~fdist2d p type~fdist2d_000 fdist2d_000 type~fdist2d_000->type~fdist2d type~fft2d_link fft2d_link type~fft2d_link->type~fft2d table type~fft2d_link->type~fft2d_link next var pantypeparallel_pipeInheritedByGraph = svgPanZoom('#typeparallel_pipeInheritedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables nstage stageid lidproc lkstrt lgrp lnvp Type-Bound Procedures del getnvp getidproc getkstrt getlworld getmreal getmint getmdouble getmcplx getmchar getnstage getstageid getlidproc getlkstrt getlgrp getlnvp init_parallel_pipe new Components Type Visibility Attributes Name Initial integer, private :: nstage = 1 integer, private :: stageid = 0 integer, private :: lidproc integer, private :: lkstrt integer, private :: lgrp integer, private :: lnvp Type-Bound Procedures generic, public :: del => end_parallel private subroutine end_parallel (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(inout) :: this procedure, public :: getnvp private function getnvp (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer procedure, public :: getidproc private function getidproc (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer procedure, public :: getkstrt private function getkstrt (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer procedure, public :: getlworld private function getlworld (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer procedure, public :: getmreal private function getmreal (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer procedure, public :: getmint private function getmint (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer procedure, public :: getmdouble private function getmdouble (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer procedure, public :: getmcplx private function getmcplx (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer procedure, public :: getmchar private function getmchar (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer procedure, public :: getnstage private function getnstage (this) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in) :: this Return Value integer procedure, public :: getstageid private function getstageid (this) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in) :: this Return Value integer procedure, public :: getlidproc private function getlidproc (this) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in) :: this Return Value integer procedure, public :: getlkstrt private function getlkstrt (this) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in) :: this Return Value integer procedure, public :: getlgrp private function getlgrp (this) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in) :: this Return Value integer procedure, public :: getlnvp private function getlnvp (this) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in) :: this Return Value integer procedure, private :: init_parallel_pipe private subroutine init_parallel_pipe (this, nst) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(inout) :: this integer, intent(in) :: nst generic, public :: new => init_parallel , init_parallel_pipe private subroutine init_parallel (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(inout) :: this private subroutine init_parallel_pipe (this, nst) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(inout) :: this integer, intent(in) :: nst","tags":"","loc":"type/parallel_pipe.html"},{"title":"ufield2d – QuickPIC ","text":"type, public :: ufield2d Inherits type~~ufield2d~~InheritsGraph type~ufield2d ufield2d type~spect2d spect2d type~ufield2d->type~spect2d sp type~parallel_pipe parallel_pipe type~ufield2d->type~parallel_pipe p type~perrors perrors type~ufield2d->type~perrors err type~spect2d->type~parallel_pipe p type~spect2d->type~perrors err type~parallel parallel type~parallel_pipe->type~parallel type~perrors->type~parallel p Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~ufield2d~~InheritedByGraph type~ufield2d ufield2d type~field2d field2d type~field2d->type~ufield2d rs, ks type~species2d species2d type~species2d->type~field2d q, qn, cu, amu, dcu type~sim_fields sim_fields type~sim_fields->type~field2d qb, qe, psit, psi, div_vpot, reg, fxy, bxyz, cu, dcu, amu, epw, epwb type~simulation simulation type~simulation->type~sim_fields fields type~sim_species sim_species type~simulation->type~sim_species species type~sim_species->type~species2d spe var pantypeufield2dInheritedByGraph = svgPanZoom('#typeufield2dInheritedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables sp err p layout dim noff nd1 nvpx nd1p nd2 nvpy nd2p rf buff Finalization Procedures final_ufield2d Type-Bound Procedures new del cg ag wr psend precv as add sub mult init_ufield2d init_ufield2d_k end_ufield2d getdim getlayout getnd1p getnvpx getnd1 getnd2p getnvpy getnd2 getnoff getrf writehdf5 acopyguard copyguard piperecv_ufield2d pipesend_ufield2d minus1 multiply2 multiply1 sum1 asa asc minus2 sum2 Components Type Visibility Attributes Name Initial class( spect2d ), public, pointer :: sp => null() class( perrors ), public, pointer :: err => null() class( parallel_pipe ), public, pointer :: p => null() integer, private :: layout integer, private :: dim integer, private :: noff integer, private :: nd1 integer, private :: nvpx integer, private :: nd1p integer, private :: nd2 integer, private :: nvpy integer, private :: nd2p real, private, dimension(:,:,:), pointer :: rf => null() real, private, dimension(:,:,:), pointer :: buff => null() Finalization Procedures final :: final_ufield2d private subroutine final_ufield2d (this) Arguments Type Intent Optional Attributes Name type( ufield2d ), intent(inout) :: this Type-Bound Procedures generic, public :: new => init_ufield2d , init_ufield2d_k private subroutine init_ufield2d (this, pp, perr, psp, dim, layout, nvpx, nvpy) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( spect2d ), intent(in), pointer :: psp integer, intent(in) :: dim integer, intent(in) :: layout integer, intent(in) :: nvpx integer, intent(in) :: nvpy private subroutine init_ufield2d_k (this, pp, perr, psp, dim, layout, nd1, nd2, nvpx, nvpy) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( spect2d ), intent(in), pointer :: psp integer, intent(in) :: dim integer, intent(in) :: layout integer, intent(in) :: nd1 integer, intent(in) :: nd2 integer, intent(in) :: nvpx integer, intent(in) :: nvpy generic, public :: del => end_ufield2d private subroutine end_ufield2d (this) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this generic, public :: cg => copyguard private subroutine copyguard (this) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this generic, public :: ag => acopyguard private subroutine acopyguard (this) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this generic, public :: wr => writehdf5 private subroutine writehdf5 (this, file, dim) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this class( hdf5file ), intent(in) :: file integer, intent(in) :: dim generic, public :: psend => pipesend_ufield2d private subroutine pipesend_ufield2d (this, stag, id) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this integer, intent(in) :: stag integer, intent(inout) :: id generic, public :: precv => piperecv_ufield2d private subroutine piperecv_ufield2d (this, rtag) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this integer, intent(in) :: rtag generic, public :: as => asc , asa private subroutine asc (this, value) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this real, intent(in) :: value private subroutine asa (this, that) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this class( ufield2d ), intent(in), target :: that generic, public :: add => sum1 , sum2 private subroutine sum1 (this, a1, a2) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this class( ufield2d ), intent(in), target :: a1 class( ufield2d ), intent(in), target :: a2 private subroutine sum2 (this, a1, a2, dim, dim1, dim2) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this class( ufield2d ), intent(in), target :: a1 class( ufield2d ), intent(in), target :: a2 integer, intent(in), dimension(:) :: dim integer, intent(in), dimension(:) :: dim1 integer, intent(in), dimension(:) :: dim2 generic, public :: sub => minus1 , minus2 private subroutine minus1 (this, a1, a2) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this class( ufield2d ), intent(in), target :: a1 class( ufield2d ), intent(in), target :: a2 private subroutine minus2 (this, a1, a2, dim, dim1, dim2) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this class( ufield2d ), intent(in), target :: a1 class( ufield2d ), intent(in), target :: a2 integer, intent(in), dimension(:) :: dim integer, intent(in), dimension(:) :: dim1 integer, intent(in), dimension(:) :: dim2 generic, public :: mult => multiply1 , multiply2 private subroutine multiply1 (this, a1, value) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this class( ufield2d ), intent(in), target :: a1 real, intent(in) :: value private subroutine multiply2 (this, a1, dim, dim1, value) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this class( ufield2d ), intent(in), target :: a1 integer, intent(in), dimension(:) :: dim integer, intent(in), dimension(:) :: dim1 real, intent(in), dimension(:) :: value procedure, private :: init_ufield2d private subroutine init_ufield2d (this, pp, perr, psp, dim, layout, nvpx, nvpy) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( spect2d ), intent(in), pointer :: psp integer, intent(in) :: dim integer, intent(in) :: layout integer, intent(in) :: nvpx integer, intent(in) :: nvpy procedure, private :: init_ufield2d_k private subroutine init_ufield2d_k (this, pp, perr, psp, dim, layout, nd1, nd2, nvpx, nvpy) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( spect2d ), intent(in), pointer :: psp integer, intent(in) :: dim integer, intent(in) :: layout integer, intent(in) :: nd1 integer, intent(in) :: nd2 integer, intent(in) :: nvpx integer, intent(in) :: nvpy procedure, private :: end_ufield2d private subroutine end_ufield2d (this) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this procedure, public :: getdim private function getdim (this) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(in) :: this Return Value integer procedure, public :: getlayout private function getlayout (this) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(in) :: this Return Value integer procedure, public :: getnd1p private function getnd1p (this) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(in) :: this Return Value integer procedure, public :: getnvpx private function getnvpx (this) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(in) :: this Return Value integer procedure, public :: getnd1 private function getnd1 (this) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(in) :: this Return Value integer procedure, public :: getnd2p private function getnd2p (this) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(in) :: this Return Value integer procedure, public :: getnvpy private function getnvpy (this) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(in) :: this Return Value integer procedure, public :: getnd2 private function getnd2 (this) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(in) :: this Return Value integer procedure, public :: getnoff private function getnoff (this) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(in) :: this Return Value integer procedure, public :: getrf private function getrf (this) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(in) :: this Return Value real,\n  dimension(:,:,:), pointer procedure, private :: writehdf5 private subroutine writehdf5 (this, file, dim) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this class( hdf5file ), intent(in) :: file integer, intent(in) :: dim procedure, private :: acopyguard private subroutine acopyguard (this) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this procedure, private :: copyguard private subroutine copyguard (this) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this procedure, private :: piperecv_ufield2d private subroutine piperecv_ufield2d (this, rtag) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this integer, intent(in) :: rtag procedure, private :: pipesend_ufield2d private subroutine pipesend_ufield2d (this, stag, id) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this integer, intent(in) :: stag integer, intent(inout) :: id procedure, private :: minus1 private subroutine minus1 (this, a1, a2) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this class( ufield2d ), intent(in), target :: a1 class( ufield2d ), intent(in), target :: a2 procedure, private :: multiply2 private subroutine multiply2 (this, a1, dim, dim1, value) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this class( ufield2d ), intent(in), target :: a1 integer, intent(in), dimension(:) :: dim integer, intent(in), dimension(:) :: dim1 real, intent(in), dimension(:) :: value procedure, private :: multiply1 private subroutine multiply1 (this, a1, value) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this class( ufield2d ), intent(in), target :: a1 real, intent(in) :: value procedure, private :: sum1 private subroutine sum1 (this, a1, a2) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this class( ufield2d ), intent(in), target :: a1 class( ufield2d ), intent(in), target :: a2 procedure, private :: asa private subroutine asa (this, that) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this class( ufield2d ), intent(in), target :: that procedure, private :: asc private subroutine asc (this, value) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this real, intent(in) :: value procedure, private :: minus2 private subroutine minus2 (this, a1, a2, dim, dim1, dim2) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this class( ufield2d ), intent(in), target :: a1 class( ufield2d ), intent(in), target :: a2 integer, intent(in), dimension(:) :: dim integer, intent(in), dimension(:) :: dim1 integer, intent(in), dimension(:) :: dim2 procedure, private :: sum2 private subroutine sum2 (this, a1, a2, dim, dim1, dim2) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this class( ufield2d ), intent(in), target :: a1 class( ufield2d ), intent(in), target :: a2 integer, intent(in), dimension(:) :: dim integer, intent(in), dimension(:) :: dim1 integer, intent(in), dimension(:) :: dim2","tags":"","loc":"type/ufield2d.html"},{"title":"field3d – QuickPIC ","text":"type, public :: field3d Inherits type~~field3d~~InheritsGraph type~field3d field3d type~parallel_pipe parallel_pipe type~field3d->type~parallel_pipe p type~ufield3d ufield3d type~field3d->type~ufield3d rs type~perrors perrors type~field3d->type~perrors err type~spect3d spect3d type~field3d->type~spect3d sp type~parallel parallel type~parallel_pipe->type~parallel type~ufield3d->type~parallel_pipe p type~ufield3d->type~perrors err type~ufield3d->type~spect3d sp type~perrors->type~parallel p type~spect2d spect2d type~spect3d->type~spect2d type~spect2d->type~parallel_pipe p type~spect2d->type~perrors err Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~field3d~~InheritedByGraph type~field3d field3d type~species2d species2d type~species2d->type~field3d q3 type~sim_fields sim_fields type~sim_fields->type~field3d bexyz, bbxyz, psi3d, cu3d type~beam3d beam3d type~beam3d->type~field3d q type~simulation simulation type~simulation->type~sim_fields fields type~sim_species sim_species type~simulation->type~sim_species species type~sim_beams sim_beams type~simulation->type~sim_beams beams type~sim_species->type~species2d spe type~sim_beams->type~beam3d beam Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables sp err p rs gcells Type-Bound Procedures new del pcg ag wr as add sub mult init_field3d end_field3d acopyguard_field3d pipecg_field3d writehdf5_2dslice writehdf5_3d multiply minus sum asa asc getrs getgcells Components Type Visibility Attributes Name Initial class( spect3d ), public, pointer :: sp => null() class( perrors ), public, pointer :: err => null() class( parallel_pipe ), public, pointer :: p => null() class( ufield3d ), private, pointer :: rs => null() integer, private :: gcells Type-Bound Procedures generic, public :: new => init_field3d private subroutine init_field3d (this, pp, perr, psp, dim) Arguments Type Intent Optional Attributes Name class( field3d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( spect3d ), intent(in), pointer :: psp integer, intent(in) :: dim generic, public :: del => end_field3d private subroutine end_field3d (this) Arguments Type Intent Optional Attributes Name class( field3d ), intent(inout) :: this generic, public :: pcg => pipecg_field3d private subroutine pipecg_field3d (this, rtag, stag, rid, sid) Arguments Type Intent Optional Attributes Name class( field3d ), intent(inout) :: this integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: rid integer, intent(inout) :: sid generic, public :: ag => acopyguard_field3d private subroutine acopyguard_field3d (this, rtag, stag, id) Arguments Type Intent Optional Attributes Name class( field3d ), intent(inout) :: this integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id generic, public :: wr => writehdf5_3d , writehdf5_2dslice private subroutine writehdf5_3d (this, file, dim, rtag, stag, id) Arguments Type Intent Optional Attributes Name class( field3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file integer, intent(in) :: dim integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id private subroutine writehdf5_2dslice (this, file, dim, slice, spos, rtag, stag, id) Arguments Type Intent Optional Attributes Name class( field3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file integer, intent(in) :: dim integer, intent(in) :: slice integer, intent(in) :: spos integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id generic, public :: as => asc , asa private subroutine asc (this, value) Arguments Type Intent Optional Attributes Name class( field3d ), intent(inout) :: this real, intent(in) :: value private subroutine asa (this, that) Arguments Type Intent Optional Attributes Name class( field3d ), intent(inout) :: this class( field3d ), intent(inout) :: that generic, public :: add => sum private subroutine sum (this, a1, a2) Arguments Type Intent Optional Attributes Name class( field3d ), intent(inout) :: this class( field3d ), intent(in) :: a1 class( field3d ), intent(in) :: a2 generic, public :: sub => minus private subroutine minus (this, a1, a2) Arguments Type Intent Optional Attributes Name class( field3d ), intent(inout) :: this class( field3d ), intent(in) :: a1 class( field3d ), intent(in) :: a2 generic, public :: mult => multiply private subroutine multiply (this, a1, value) Arguments Type Intent Optional Attributes Name class( field3d ), intent(inout) :: this class( field3d ), intent(in) :: a1 real, intent(in) :: value procedure, private :: init_field3d private subroutine init_field3d (this, pp, perr, psp, dim) Arguments Type Intent Optional Attributes Name class( field3d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( spect3d ), intent(in), pointer :: psp integer, intent(in) :: dim procedure, private :: end_field3d private subroutine end_field3d (this) Arguments Type Intent Optional Attributes Name class( field3d ), intent(inout) :: this procedure, private :: acopyguard_field3d private subroutine acopyguard_field3d (this, rtag, stag, id) Arguments Type Intent Optional Attributes Name class( field3d ), intent(inout) :: this integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id procedure, private :: pipecg_field3d private subroutine pipecg_field3d (this, rtag, stag, rid, sid) Arguments Type Intent Optional Attributes Name class( field3d ), intent(inout) :: this integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: rid integer, intent(inout) :: sid procedure, private :: writehdf5_2dslice private subroutine writehdf5_2dslice (this, file, dim, slice, spos, rtag, stag, id) Arguments Type Intent Optional Attributes Name class( field3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file integer, intent(in) :: dim integer, intent(in) :: slice integer, intent(in) :: spos integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id procedure, private :: writehdf5_3d private subroutine writehdf5_3d (this, file, dim, rtag, stag, id) Arguments Type Intent Optional Attributes Name class( field3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file integer, intent(in) :: dim integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id procedure, private :: multiply private subroutine multiply (this, a1, value) Arguments Type Intent Optional Attributes Name class( field3d ), intent(inout) :: this class( field3d ), intent(in) :: a1 real, intent(in) :: value procedure, private :: minus private subroutine minus (this, a1, a2) Arguments Type Intent Optional Attributes Name class( field3d ), intent(inout) :: this class( field3d ), intent(in) :: a1 class( field3d ), intent(in) :: a2 procedure, private :: sum private subroutine sum (this, a1, a2) Arguments Type Intent Optional Attributes Name class( field3d ), intent(inout) :: this class( field3d ), intent(in) :: a1 class( field3d ), intent(in) :: a2 procedure, private :: asa private subroutine asa (this, that) Arguments Type Intent Optional Attributes Name class( field3d ), intent(inout) :: this class( field3d ), intent(inout) :: that procedure, private :: asc private subroutine asc (this, value) Arguments Type Intent Optional Attributes Name class( field3d ), intent(inout) :: this real, intent(in) :: value procedure, public :: getrs private function getrs (this) Arguments Type Intent Optional Attributes Name class( field3d ), intent(in) :: this Return Value class( ufield3d ),\n  pointer procedure, public :: getgcells private function getgcells (this) Arguments Type Intent Optional Attributes Name class( field3d ), intent(in) :: this Return Value integer","tags":"","loc":"type/field3d.html"},{"title":"fpois2d – QuickPIC ","text":"type, public :: fpois2d Inherits type~~fpois2d~~InheritsGraph type~fpois2d fpois2d type~spect2d spect2d type~fpois2d->type~spect2d sp type~parallel_pipe parallel_pipe type~fpois2d->type~parallel_pipe p type~perrors perrors type~fpois2d->type~perrors err type~spect2d->type~parallel_pipe p type~spect2d->type~perrors err type~parallel parallel type~parallel_pipe->type~parallel type~perrors->type~parallel p Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~fpois2d~~InheritedByGraph type~fpois2d fpois2d type~fpois2d_link fpois2d_link type~fpois2d_link->type~fpois2d table type~fpois2d_link->type~fpois2d_link next type~field2d field2d type~field2d->type~fpois2d pt type~species2d species2d type~species2d->type~field2d q, qn, cu, amu, dcu type~sim_fields sim_fields type~sim_fields->type~field2d qb, qe, psit, psi, div_vpot, reg, fxy, bxyz, cu, dcu, amu, epw, epwb type~simulation simulation type~simulation->type~sim_fields fields type~sim_species sim_species type~simulation->type~sim_species species type~sim_species->type~species2d spe var pantypefpois2dInheritedByGraph = svgPanZoom('#typefpois2dInheritedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables sp err p nd a anorm ffc ffg Type-Bound Procedures new del potential smoothf elfield bfield bfield_qp init_fpois2d end_fpois2d ibfieldd2 ippoisd23 ismoothfd2 ipotd2 jpbpoisd23n_qp Components Type Visibility Attributes Name Initial class( spect2d ), public, pointer :: sp => null() class( perrors ), public, pointer :: err => null() class( parallel_pipe ), public, pointer :: p => null() integer, private, dimension(2) :: nd real, private, dimension(2) :: a real, private :: anorm complex, private, dimension(:,:), pointer :: ffc => null() real, private, dimension(:,:,:), pointer :: ffg => null() Type-Bound Procedures generic, public :: new => init_fpois2d private subroutine init_fpois2d (this, pp, perr, psp, nx, ny, ax, ay, affp) Arguments Type Intent Optional Attributes Name class( fpois2d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( spect2d ), intent(in), pointer :: psp integer, intent(in) :: nx integer, intent(in) :: ny real, intent(in) :: ax real, intent(in) :: ay real, intent(in) :: affp generic, public :: del => end_fpois2d private subroutine end_fpois2d (this) Arguments Type Intent Optional Attributes Name class( fpois2d ), intent(inout) :: this generic, public :: potential => ipotd2 private subroutine ipotd2 (this, q, fx, we) Arguments Type Intent Optional Attributes Name class( fpois2d ), intent(in) :: this class( ufield2d ), intent(inout) :: q class( ufield2d ), intent(inout) :: fx real, intent(inout) :: we generic, public :: smoothf => ismoothfd2 private subroutine ismoothfd2 (this, f, fs) Arguments Type Intent Optional Attributes Name class( fpois2d ), intent(in) :: this class( ufield2d ), intent(inout) :: f class( ufield2d ), intent(inout) :: fs generic, public :: elfield => ippoisd23 private subroutine ippoisd23 (this, q, fxy, we) Arguments Type Intent Optional Attributes Name class( fpois2d ), intent(in) :: this class( ufield2d ), intent(inout) :: q class( ufield2d ), intent(inout) :: fxy real, intent(inout) :: we generic, public :: bfield => ibfieldd2 private subroutine ibfieldd2 (this, cu, bxy, ci, wm) Arguments Type Intent Optional Attributes Name class( fpois2d ), intent(in) :: this class( ufield2d ), intent(inout) :: cu class( ufield2d ), intent(inout) :: bxy real, intent(in) :: ci real, intent(inout) :: wm generic, public :: bfield_qp => jpbpoisd23n_qp private subroutine jpbpoisd23n_qp (this, cu, dcu, amu, bxy, ci, c, dex, wm) Arguments Type Intent Optional Attributes Name class( fpois2d ), intent(in) :: this class( ufield2d ), intent(inout) :: cu class( ufield2d ), intent(inout) :: dcu class( ufield2d ), intent(inout) :: amu class( ufield2d ), intent(inout) :: bxy real, intent(in) :: ci real, intent(in) :: c real, intent(in) :: dex real, intent(inout) :: wm procedure, private :: init_fpois2d private subroutine init_fpois2d (this, pp, perr, psp, nx, ny, ax, ay, affp) Arguments Type Intent Optional Attributes Name class( fpois2d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( spect2d ), intent(in), pointer :: psp integer, intent(in) :: nx integer, intent(in) :: ny real, intent(in) :: ax real, intent(in) :: ay real, intent(in) :: affp procedure, private :: end_fpois2d private subroutine end_fpois2d (this) Arguments Type Intent Optional Attributes Name class( fpois2d ), intent(inout) :: this procedure, private :: ibfieldd2 private subroutine ibfieldd2 (this, cu, bxy, ci, wm) Arguments Type Intent Optional Attributes Name class( fpois2d ), intent(in) :: this class( ufield2d ), intent(inout) :: cu class( ufield2d ), intent(inout) :: bxy real, intent(in) :: ci real, intent(inout) :: wm procedure, private :: ippoisd23 private subroutine ippoisd23 (this, q, fxy, we) Arguments Type Intent Optional Attributes Name class( fpois2d ), intent(in) :: this class( ufield2d ), intent(inout) :: q class( ufield2d ), intent(inout) :: fxy real, intent(inout) :: we procedure, private :: ismoothfd2 private subroutine ismoothfd2 (this, f, fs) Arguments Type Intent Optional Attributes Name class( fpois2d ), intent(in) :: this class( ufield2d ), intent(inout) :: f class( ufield2d ), intent(inout) :: fs procedure, private :: ipotd2 private subroutine ipotd2 (this, q, fx, we) Arguments Type Intent Optional Attributes Name class( fpois2d ), intent(in) :: this class( ufield2d ), intent(inout) :: q class( ufield2d ), intent(inout) :: fx real, intent(inout) :: we procedure, private :: jpbpoisd23n_qp private subroutine jpbpoisd23n_qp (this, cu, dcu, amu, bxy, ci, c, dex, wm) Arguments Type Intent Optional Attributes Name class( fpois2d ), intent(in) :: this class( ufield2d ), intent(inout) :: cu class( ufield2d ), intent(inout) :: dcu class( ufield2d ), intent(inout) :: amu class( ufield2d ), intent(inout) :: bxy real, intent(in) :: ci real, intent(in) :: c real, intent(in) :: dex real, intent(inout) :: wm","tags":"","loc":"type/fpois2d.html"},{"title":"fpois2d_link – QuickPIC ","text":"type, private :: fpois2d_link Inherits type~~fpois2d_link~~InheritsGraph type~fpois2d_link fpois2d_link type~fpois2d_link->type~fpois2d_link next type~fpois2d fpois2d type~fpois2d_link->type~fpois2d table type~spect2d spect2d type~fpois2d->type~spect2d sp type~parallel_pipe parallel_pipe type~fpois2d->type~parallel_pipe p type~perrors perrors type~fpois2d->type~perrors err type~spect2d->type~parallel_pipe p type~spect2d->type~perrors err type~parallel parallel type~parallel_pipe->type~parallel type~perrors->type~parallel p Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables next table refcount Components Type Visibility Attributes Name Initial type( fpois2d_link ), public, pointer :: next => null() type( fpois2d ), public, pointer :: table => null() integer, public :: refcount","tags":"","loc":"type/fpois2d_link.html"},{"title":"ab_dist3d – QuickPIC","text":"abstract interface private subroutine ab_dist3d(this, part3d, npp, fd) Arguments Type Intent Optional Attributes Name class( fdist3d ), intent(inout) :: this real, intent(inout), dimension(:,:), pointer :: part3d integer, intent(inout) :: npp class( ufield3d ), intent(in), pointer :: fd","tags":"","loc":"interface/ab_dist3d.html"},{"title":"ab_init_fdist3d – QuickPIC","text":"abstract interface private subroutine ab_init_fdist3d(this, input, i) Arguments Type Intent Optional Attributes Name class( fdist3d ), intent(inout) :: this type( input_json ), intent(inout), pointer :: input integer, intent(in) :: i","tags":"","loc":"interface/ab_init_fdist3d.html"},{"title":"ab_dist2d – QuickPIC","text":"abstract interface private subroutine ab_dist2d(this, part2d, npp, fd, s) Arguments Type Intent Optional Attributes Name class( fdist2d ), intent(inout) :: this real, intent(inout), dimension(:,:), pointer :: part2d integer, intent(inout) :: npp class( ufield2d ), intent(in), pointer :: fd real, intent(in) :: s","tags":"","loc":"interface/ab_dist2d.html"},{"title":"ab_init_fdist2d – QuickPIC","text":"abstract interface private subroutine ab_init_fdist2d(this, input, i) Arguments Type Intent Optional Attributes Name class( fdist2d ), intent(inout) :: this type( input_json ), intent(inout), pointer :: input integer, intent(in) :: i","tags":"","loc":"interface/ab_init_fdist2d.html"},{"title":"WPFST2RINIT – QuickPIC","text":"subroutine WPFST2RINIT(mixup, sctd, indx, indy, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name integer :: mixup complex :: sctd integer :: indx integer :: indy integer :: nxhyd integer :: nxyd Calls proc~~wpfst2rinit~~CallsGraph proc~wpfst2rinit WPFST2RINIT float float proc~wpfst2rinit->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/wpfst2rinit.html"},{"title":"WPFSST2R – QuickPIC","text":"subroutine WPFSST2R(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, ind y, kstrt, nxvh, nyv, kxp2, kyp, kypd, kxp2d, jblok, kblok, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: f real :: g real :: bs real :: br integer :: isign integer :: ntpose integer :: mixup complex :: sctd real :: ttp integer :: indx integer :: ind y integer :: kstrt integer :: nxvh integer :: nyv integer :: kxp2 integer :: kyp integer :: kypd integer :: kxp2d integer :: jblok integer :: kblok integer :: nxhyd integer :: nxyd Calls proc~~wpfsst2r~~CallsGraph proc~wpfsst2r WPFSST2R proc~pfst2rxx PFST2RXX proc~wpfsst2r->proc~pfst2rxx proc~pfst2rxy PFST2RXY proc~wpfsst2r->proc~pfst2rxy proc~prtpose PRTPOSE proc~wpfsst2r->proc~prtpose proc~pwtimera PWTIMERA proc~wpfsst2r->proc~pwtimera float float proc~pfst2rxx->float mpi_wait mpi_wait proc~prtpose->mpi_wait mpi_wtime mpi_wtime proc~pwtimera->mpi_wtime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/wpfsst2r.html"},{"title":"WPFCCT2R – QuickPIC","text":"subroutine WPFCCT2R(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, ind y, kstrt, nxvh, nyv, kxp2, kyp, kypd, kxp2d, jblok, kblok, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: f real :: g real :: bs real :: br integer :: isign integer :: ntpose integer :: mixup complex :: sctd real :: ttp integer :: indx integer :: ind y integer :: kstrt integer :: nxvh integer :: nyv integer :: kxp2 integer :: kyp integer :: kypd integer :: kxp2d integer :: jblok integer :: kblok integer :: nxhyd integer :: nxyd Calls proc~~wpfcct2r~~CallsGraph proc~wpfcct2r WPFCCT2R proc~prtpose PRTPOSE proc~wpfcct2r->proc~prtpose proc~pfct2rxx PFCT2RXX proc~wpfcct2r->proc~pfct2rxx proc~pwtimera PWTIMERA proc~wpfcct2r->proc~pwtimera proc~pfct2rxy PFCT2RXY proc~wpfcct2r->proc~pfct2rxy mpi_wait mpi_wait proc~prtpose->mpi_wait float float proc~pfct2rxx->float mpi_wtime mpi_wtime proc~pwtimera->mpi_wtime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/wpfcct2r.html"},{"title":"PFST2RXX – QuickPIC","text":"subroutine PFST2RXX(f, isign, mixup, sctd, indx, indy, kstrt, kyp, kypi, ky pp, nxvh, kypd, kblok, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: f integer :: isign integer :: mixup complex :: sctd integer :: indx integer :: indy integer :: kstrt integer :: kyp integer :: kypi integer :: ky pp integer :: nxvh integer :: kypd integer :: kblok integer :: nxhyd integer :: nxyd Calls proc~~pfst2rxx~~CallsGraph proc~pfst2rxx PFST2RXX float float proc~pfst2rxx->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~pfst2rxx~~CalledByGraph proc~pfst2rxx PFST2RXX proc~wpfsst2r WPFSST2R proc~wpfsst2r->proc~pfst2rxx Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/pfst2rxx.html"},{"title":"PFCT2RXX – QuickPIC","text":"subroutine PFCT2RXX(f, isign, mixup, sctd, indx, indy, kstrt, kyp, kypi, ky pp, nxvh, kypd, kblok, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: f integer :: isign integer :: mixup complex :: sctd integer :: indx integer :: indy integer :: kstrt integer :: kyp integer :: kypi integer :: ky pp integer :: nxvh integer :: kypd integer :: kblok integer :: nxhyd integer :: nxyd Calls proc~~pfct2rxx~~CallsGraph proc~pfct2rxx PFCT2RXX float float proc~pfct2rxx->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~pfct2rxx~~CalledByGraph proc~pfct2rxx PFCT2RXX proc~wpfcct2r WPFCCT2R proc~wpfcct2r->proc~pfct2rxx Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/pfct2rxx.html"},{"title":"PFST2RXY – QuickPIC","text":"subroutine PFST2RXY(g, isign, mixup, sctd, indx, indy, kstrt, kxp, kxpi, kx pp, nyv, kxpd, jblok, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: g integer :: isign integer :: mixup complex :: sctd integer :: indx integer :: indy integer :: kstrt integer :: kxp integer :: kxpi integer :: kx pp integer :: nyv integer :: kxpd integer :: jblok integer :: nxhyd integer :: nxyd Called by proc~~pfst2rxy~~CalledByGraph proc~pfst2rxy PFST2RXY proc~wpfsst2r WPFSST2R proc~wpfsst2r->proc~pfst2rxy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/pfst2rxy.html"},{"title":"PFCT2RXY – QuickPIC","text":"subroutine PFCT2RXY(g, isign, mixup, sctd, indx, indy, kstrt, kxp, kxpi, kx pp, nyv, kxpd, jblok, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: g integer :: isign integer :: mixup complex :: sctd integer :: indx integer :: indy integer :: kstrt integer :: kxp integer :: kxpi integer :: kx pp integer :: nyv integer :: kxpd integer :: jblok integer :: nxhyd integer :: nxyd Called by proc~~pfct2rxy~~CalledByGraph proc~pfct2rxy PFCT2RXY proc~wpfcct2r WPFCCT2R proc~wpfcct2r->proc~pfct2rxy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/pfct2rxy.html"},{"title":"WPFCST2R2 – QuickPIC","text":"subroutine WPFCST2R2(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, in dy, kstrt, nxvh, nyv, kxp2, kyp, kypd, kxp2d, jblok, kblok, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: f real :: g real :: bs real :: br integer :: isign integer :: ntpose integer :: mixup complex :: sctd real :: ttp integer :: indx integer :: in dy integer :: kstrt integer :: nxvh integer :: nyv integer :: kxp2 integer :: kyp integer :: kypd integer :: kxp2d integer :: jblok integer :: kblok integer :: nxhyd integer :: nxyd Calls proc~~wpfcst2r2~~CallsGraph proc~wpfcst2r2 WPFCST2R2 proc~pfcst2r2x PFCST2R2X proc~wpfcst2r2->proc~pfcst2r2x proc~pfsct2r2y PFSCT2R2Y proc~wpfcst2r2->proc~pfsct2r2y proc~pwtimera PWTIMERA proc~wpfcst2r2->proc~pwtimera proc~pr2tpose PR2TPOSE proc~wpfcst2r2->proc~pr2tpose float float proc~pfcst2r2x->float mpi_wtime mpi_wtime proc~pwtimera->mpi_wtime mpi_wait mpi_wait proc~pr2tpose->mpi_wait Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/wpfcst2r2.html"},{"title":"WPFSCT2R2 – QuickPIC","text":"subroutine WPFSCT2R2(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, in dy, kstrt, nxvh, nyv, kxp2, kyp, kypd, kxp2d, jblok, kblok, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: f real :: g real :: bs real :: br integer :: isign integer :: ntpose integer :: mixup complex :: sctd real :: ttp integer :: indx integer :: in dy integer :: kstrt integer :: nxvh integer :: nyv integer :: kxp2 integer :: kyp integer :: kypd integer :: kxp2d integer :: jblok integer :: kblok integer :: nxhyd integer :: nxyd Calls proc~~wpfsct2r2~~CallsGraph proc~wpfsct2r2 WPFSCT2R2 proc~pfsct2r2x PFSCT2R2X proc~wpfsct2r2->proc~pfsct2r2x proc~pfcst2r2y PFCST2R2Y proc~wpfsct2r2->proc~pfcst2r2y proc~pwtimera PWTIMERA proc~wpfsct2r2->proc~pwtimera proc~pr2tpose PR2TPOSE proc~wpfsct2r2->proc~pr2tpose float float proc~pfsct2r2x->float mpi_wtime mpi_wtime proc~pwtimera->mpi_wtime mpi_wait mpi_wait proc~pr2tpose->mpi_wait Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/wpfsct2r2.html"},{"title":"PFCST2R2X – QuickPIC","text":"subroutine PFCST2R2X(f, isign, mixup, sctd, indx, indy, kstrt, kyp, kypi, k ypp, nxvh, kypd, kblok, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: f integer :: isign integer :: mixup complex :: sctd integer :: indx integer :: indy integer :: kstrt integer :: kyp integer :: kypi integer :: k ypp integer :: nxvh integer :: kypd integer :: kblok integer :: nxhyd integer :: nxyd Calls proc~~pfcst2r2x~~CallsGraph proc~pfcst2r2x PFCST2R2X float float proc~pfcst2r2x->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~pfcst2r2x~~CalledByGraph proc~pfcst2r2x PFCST2R2X proc~wpfcst2r2 WPFCST2R2 proc~wpfcst2r2->proc~pfcst2r2x Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/pfcst2r2x.html"},{"title":"PFSCT2R2X – QuickPIC","text":"subroutine PFSCT2R2X(f, isign, mixup, sctd, indx, indy, kstrt, kyp, kypi, k ypp, nxvh, kypd, kblok, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: f integer :: isign integer :: mixup complex :: sctd integer :: indx integer :: indy integer :: kstrt integer :: kyp integer :: kypi integer :: k ypp integer :: nxvh integer :: kypd integer :: kblok integer :: nxhyd integer :: nxyd Calls proc~~pfsct2r2x~~CallsGraph proc~pfsct2r2x PFSCT2R2X float float proc~pfsct2r2x->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~pfsct2r2x~~CalledByGraph proc~pfsct2r2x PFSCT2R2X proc~wpfsct2r2 WPFSCT2R2 proc~wpfsct2r2->proc~pfsct2r2x Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/pfsct2r2x.html"},{"title":"PFSCT2R2Y – QuickPIC","text":"subroutine PFSCT2R2Y(g, isign, mixup, sctd, indx, indy, kstrt, kxp, kxpi, k xpp, nyv, kxpd, jblok, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: g integer :: isign integer :: mixup complex :: sctd integer :: indx integer :: indy integer :: kstrt integer :: kxp integer :: kxpi integer :: k xpp integer :: nyv integer :: kxpd integer :: jblok integer :: nxhyd integer :: nxyd Called by proc~~pfsct2r2y~~CalledByGraph proc~pfsct2r2y PFSCT2R2Y proc~wpfcst2r2 WPFCST2R2 proc~wpfcst2r2->proc~pfsct2r2y Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/pfsct2r2y.html"},{"title":"PFCST2R2Y – QuickPIC","text":"subroutine PFCST2R2Y(g, isign, mixup, sctd, indx, indy, kstrt, kxp, kxpi, k xpp, nyv, kxpd, jblok, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: g integer :: isign integer :: mixup complex :: sctd integer :: indx integer :: indy integer :: kstrt integer :: kxp integer :: kxpi integer :: k xpp integer :: nyv integer :: kxpd integer :: jblok integer :: nxhyd integer :: nxyd Called by proc~~pfcst2r2y~~CalledByGraph proc~pfcst2r2y PFCST2R2Y proc~wpfsct2r2 WPFSCT2R2 proc~wpfsct2r2->proc~pfcst2r2y Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/pfcst2r2y.html"},{"title":"WPFCST2R3 – QuickPIC","text":"subroutine WPFCST2R3(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, in dy, kstrt, nxvh, nyv, kxp2, kyp, kypd, kxp2d, jblok, kblok, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: f real :: g real :: bs real :: br integer :: isign integer :: ntpose integer :: mixup complex :: sctd real :: ttp integer :: indx integer :: in dy integer :: kstrt integer :: nxvh integer :: nyv integer :: kxp2 integer :: kyp integer :: kypd integer :: kxp2d integer :: jblok integer :: kblok integer :: nxhyd integer :: nxyd Calls proc~~wpfcst2r3~~CallsGraph proc~wpfcst2r3 WPFCST2R3 proc~pfcsst2r3x PFCSST2R3X proc~wpfcst2r3->proc~pfcsst2r3x proc~pfscst2r3y PFSCST2R3Y proc~wpfcst2r3->proc~pfscst2r3y proc~pr3tpose PR3TPOSE proc~wpfcst2r3->proc~pr3tpose proc~pwtimera PWTIMERA proc~wpfcst2r3->proc~pwtimera float float proc~pfcsst2r3x->float mpi_wait mpi_wait proc~pr3tpose->mpi_wait mpi_wtime mpi_wtime proc~pwtimera->mpi_wtime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/wpfcst2r3.html"},{"title":"WPFSCT2R3 – QuickPIC","text":"subroutine WPFSCT2R3(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, in dy, kstrt, nxvh, nyv, kxp2, kyp, kypd, kxp2d, jblok, kblok, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: f real :: g real :: bs real :: br integer :: isign integer :: ntpose integer :: mixup complex :: sctd real :: ttp integer :: indx integer :: in dy integer :: kstrt integer :: nxvh integer :: nyv integer :: kxp2 integer :: kyp integer :: kypd integer :: kxp2d integer :: jblok integer :: kblok integer :: nxhyd integer :: nxyd Calls proc~~wpfsct2r3~~CallsGraph proc~wpfsct2r3 WPFSCT2R3 proc~pfcsct2r3y PFCSCT2R3Y proc~wpfsct2r3->proc~pfcsct2r3y proc~pr3tpose PR3TPOSE proc~wpfsct2r3->proc~pr3tpose proc~pfscct2r3x PFSCCT2R3X proc~wpfsct2r3->proc~pfscct2r3x proc~pwtimera PWTIMERA proc~wpfsct2r3->proc~pwtimera mpi_wait mpi_wait proc~pr3tpose->mpi_wait float float proc~pfscct2r3x->float mpi_wtime mpi_wtime proc~pwtimera->mpi_wtime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/wpfsct2r3.html"},{"title":"PFCSST2R3X – QuickPIC","text":"subroutine PFCSST2R3X(f, isign, mixup, sctd, indx, indy, kstrt, kyp, kypi, kypp, nxvh, kypd, kblok, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: f integer :: isign integer :: mixup complex :: sctd integer :: indx integer :: indy integer :: kstrt integer :: kyp integer :: kypi integer :: kypp integer :: nxvh integer :: kypd integer :: kblok integer :: nxhyd integer :: nxyd Calls proc~~pfcsst2r3x~~CallsGraph proc~pfcsst2r3x PFCSST2R3X float float proc~pfcsst2r3x->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~pfcsst2r3x~~CalledByGraph proc~pfcsst2r3x PFCSST2R3X proc~wpfcst2r3 WPFCST2R3 proc~wpfcst2r3->proc~pfcsst2r3x Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/pfcsst2r3x.html"},{"title":"PFSCCT2R3X – QuickPIC","text":"subroutine PFSCCT2R3X(f, isign, mixup, sctd, indx, indy, kstrt, kyp, kypi, kypp, nxvh, kypd, kblok, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: f integer :: isign integer :: mixup complex :: sctd integer :: indx integer :: indy integer :: kstrt integer :: kyp integer :: kypi integer :: kypp integer :: nxvh integer :: kypd integer :: kblok integer :: nxhyd integer :: nxyd Calls proc~~pfscct2r3x~~CallsGraph proc~pfscct2r3x PFSCCT2R3X float float proc~pfscct2r3x->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~pfscct2r3x~~CalledByGraph proc~pfscct2r3x PFSCCT2R3X proc~wpfsct2r3 WPFSCT2R3 proc~wpfsct2r3->proc~pfscct2r3x Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/pfscct2r3x.html"},{"title":"PFSCST2R3Y – QuickPIC","text":"subroutine PFSCST2R3Y(g, isign, mixup, sctd, indx, indy, kstrt, kxp, kxpi, kxpp, nyv, kxpd, jblok, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: g integer :: isign integer :: mixup complex :: sctd integer :: indx integer :: indy integer :: kstrt integer :: kxp integer :: kxpi integer :: kxpp integer :: nyv integer :: kxpd integer :: jblok integer :: nxhyd integer :: nxyd Called by proc~~pfscst2r3y~~CalledByGraph proc~pfscst2r3y PFSCST2R3Y proc~wpfcst2r3 WPFCST2R3 proc~wpfcst2r3->proc~pfscst2r3y Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/pfscst2r3y.html"},{"title":"PFCSCT2R3Y – QuickPIC","text":"subroutine PFCSCT2R3Y(g, isign, mixup, sctd, indx, indy, kstrt, kxp, kxpi, kxpp, nyv, kxpd, jblok, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: g integer :: isign integer :: mixup complex :: sctd integer :: indx integer :: indy integer :: kstrt integer :: kxp integer :: kxpi integer :: kxpp integer :: nyv integer :: kxpd integer :: jblok integer :: nxhyd integer :: nxyd Called by proc~~pfcsct2r3y~~CalledByGraph proc~pfcsct2r3y PFCSCT2R3Y proc~wpfsct2r3 WPFSCT2R3 proc~wpfsct2r3->proc~pfcsct2r3y Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/pfcsct2r3y.html"},{"title":"PFSSCT2R3Y – QuickPIC","text":"subroutine PFSSCT2R3Y(g, isign, mixup, sctd, indx, indy, kstrt, kxp, kxpi, kxpp, nyv, kxpd, jblok, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: g integer :: isign integer :: mixup complex :: sctd integer :: indx integer :: indy integer :: kstrt integer :: kxp integer :: kxpi integer :: kxpp integer :: nyv integer :: kxpd integer :: jblok integer :: nxhyd integer :: nxyd Called by proc~~pfssct2r3y~~CalledByGraph proc~pfssct2r3y PFSSCT2R3Y proc~wpfs3t2r3 WPFS3T2R3 proc~wpfs3t2r3->proc~pfssct2r3y Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/pfssct2r3y.html"},{"title":"PFSSCT2R3X – QuickPIC","text":"subroutine PFSSCT2R3X(f, isign, mixup, sctd, indx, indy, kstrt, kyp, kypi, kypp, nxvh, kypd, kblok, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: f integer :: isign integer :: mixup complex :: sctd integer :: indx integer :: indy integer :: kstrt integer :: kyp integer :: kypi integer :: kypp integer :: nxvh integer :: kypd integer :: kblok integer :: nxhyd integer :: nxyd Calls proc~~pfssct2r3x~~CallsGraph proc~pfssct2r3x PFSSCT2R3X float float proc~pfssct2r3x->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~pfssct2r3x~~CalledByGraph proc~pfssct2r3x PFSSCT2R3X proc~wpfs3t2r3 WPFS3T2R3 proc~wpfs3t2r3->proc~pfssct2r3x Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/pfssct2r3x.html"},{"title":"WPFS3T2R3 – QuickPIC","text":"subroutine WPFS3T2R3(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, in dy, kstrt, nxvh, nyv, kxp2, kyp, kypd, kxp2d, jblok, kblok, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: f real :: g real :: bs real :: br integer :: isign integer :: ntpose integer :: mixup complex :: sctd real :: ttp integer :: indx integer :: in dy integer :: kstrt integer :: nxvh integer :: nyv integer :: kxp2 integer :: kyp integer :: kypd integer :: kxp2d integer :: jblok integer :: kblok integer :: nxhyd integer :: nxyd Calls proc~~wpfs3t2r3~~CallsGraph proc~wpfs3t2r3 WPFS3T2R3 proc~pfssct2r3x PFSSCT2R3X proc~wpfs3t2r3->proc~pfssct2r3x proc~pr3tpose PR3TPOSE proc~wpfs3t2r3->proc~pr3tpose proc~pwtimera PWTIMERA proc~wpfs3t2r3->proc~pwtimera proc~pfssct2r3y PFSSCT2R3Y proc~wpfs3t2r3->proc~pfssct2r3y float float proc~pfssct2r3x->float mpi_wait mpi_wait proc~pr3tpose->mpi_wait mpi_wtime mpi_wtime proc~pwtimera->mpi_wtime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/wpfs3t2r3.html"},{"title":"PRTPOSE – QuickPIC","text":"subroutine PRTPOSE(f, g, s, t, nx, ny, kstrt, nxv, nyv, kxp, kyp, kxpd, kypd, j blok, kblok) Arguments Type Intent Optional Attributes Name real :: f real :: g real :: s real :: t integer :: nx integer :: ny integer :: kstrt integer :: nxv integer :: nyv integer :: kxp integer :: kyp integer :: kxpd integer :: kypd integer :: j blok integer :: kblok Calls proc~~prtpose~~CallsGraph proc~prtpose PRTPOSE mpi_wait mpi_wait proc~prtpose->mpi_wait Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~prtpose~~CalledByGraph proc~prtpose PRTPOSE proc~wpfcct2r WPFCCT2R proc~wpfcct2r->proc~prtpose proc~wpfsst2r WPFSST2R proc~wpfsst2r->proc~prtpose Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks PPARMS Common Blocks common /PPARMS/ Type Attributes Name Initial integer :: nproc integer :: lgrp integer :: mreal integer :: mint integer :: mcplx integer :: mdouble integer :: lworld $(function () {\n      $('[data-toggle=\"popover\"]').popover()\n      })","tags":"","loc":"proc/prtpose.html"},{"title":"PR2TPOSE – QuickPIC","text":"subroutine PR2TPOSE(f, g, s, t, nx, ny, kstrt, nxv, nyv, kxp, kyp, kxpd, kypd, jblok, kblok) Arguments Type Intent Optional Attributes Name real :: f real :: g real :: s real :: t integer :: nx integer :: ny integer :: kstrt integer :: nxv integer :: nyv integer :: kxp integer :: kyp integer :: kxpd integer :: kypd integer :: jblok integer :: kblok Calls proc~~pr2tpose~~CallsGraph proc~pr2tpose PR2TPOSE mpi_wait mpi_wait proc~pr2tpose->mpi_wait Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~pr2tpose~~CalledByGraph proc~pr2tpose PR2TPOSE proc~wpfsct2r2 WPFSCT2R2 proc~wpfsct2r2->proc~pr2tpose proc~wpfcst2r2 WPFCST2R2 proc~wpfcst2r2->proc~pr2tpose Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks PPARMS Common Blocks common /PPARMS/ Type Attributes Name Initial integer :: nproc integer :: lgrp integer :: mreal integer :: mint integer :: mcplx integer :: mdouble integer :: lworld $(function () {\n      $('[data-toggle=\"popover\"]').popover()\n      })","tags":"","loc":"proc/pr2tpose.html"},{"title":"PR3TPOSE – QuickPIC","text":"subroutine PR3TPOSE(f, g, s, t, nx, ny, kstrt, nxv, nyv, kxp, kyp, kxpd, kypd, jblok, kblok) Arguments Type Intent Optional Attributes Name real :: f real :: g real :: s real :: t integer :: nx integer :: ny integer :: kstrt integer :: nxv integer :: nyv integer :: kxp integer :: kyp integer :: kxpd integer :: kypd integer :: jblok integer :: kblok Calls proc~~pr3tpose~~CallsGraph proc~pr3tpose PR3TPOSE mpi_wait mpi_wait proc~pr3tpose->mpi_wait Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~pr3tpose~~CalledByGraph proc~pr3tpose PR3TPOSE proc~wpfsct2r3 WPFSCT2R3 proc~wpfsct2r3->proc~pr3tpose proc~wpfs3t2r3 WPFS3T2R3 proc~wpfs3t2r3->proc~pr3tpose proc~wpfcst2r3 WPFCST2R3 proc~wpfcst2r3->proc~pr3tpose Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks PPARMS Common Blocks common /PPARMS/ Type Attributes Name Initial integer :: nproc integer :: lgrp integer :: mreal integer :: mint integer :: mcplx integer :: mdouble integer :: lworld $(function () {\n      $('[data-toggle=\"popover\"]').popover()\n      })","tags":"","loc":"proc/pr3tpose.html"},{"title":"PWTIMERA – QuickPIC","text":"subroutine PWTIMERA(icntrl, time, dtime) Arguments Type Intent Optional Attributes Name integer :: icntrl real :: time double precision :: dtime Calls proc~~pwtimera~~CallsGraph proc~pwtimera PWTIMERA mpi_wtime mpi_wtime proc~pwtimera->mpi_wtime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~pwtimera~~CalledByGraph proc~pwtimera PWTIMERA proc~wpfcct2r WPFCCT2R proc~wpfcct2r->proc~pwtimera proc~wpfsct2r3 WPFSCT2R3 proc~wpfsct2r3->proc~pwtimera proc~wppfcst2rm2 WPPFCST2RM2 proc~wppfcst2rm2->proc~pwtimera proc~wppfsct2rm3 WPPFSCT2RM3 proc~wppfsct2rm3->proc~pwtimera proc~wpfsct2r2 WPFSCT2R2 proc~wpfsct2r2->proc~pwtimera proc~wppfsct2rm22 WPPFSCT2RM22 proc~wppfsct2rm22->proc~pwtimera proc~wppfsst2rm23 WPPFSST2RM23 proc~wppfsst2rm23->proc~pwtimera proc~wpfcst2r2 WPFCST2R2 proc~wpfcst2r2->proc~pwtimera proc~wpfs3t2r3 WPFS3T2R3 proc~wpfs3t2r3->proc~pwtimera proc~wpfcst2r3 WPFCST2R3 proc~wpfcst2r3->proc~pwtimera proc~wppfcct2rm WPPFCCT2RM proc~wppfcct2rm->proc~pwtimera proc~wppfcst2rm WPPFCST2RM proc~wppfcst2rm->proc~pwtimera proc~wppfsct2rm WPPFSCT2RM proc~wppfsct2rm->proc~pwtimera proc~wppfsct2rm2 WPPFSCT2RM2 proc~wppfsct2rm2->proc~pwtimera proc~wpfsst2r WPFSST2R proc~wpfsst2r->proc~pwtimera proc~wppfsst2rm WPPFSST2RM proc~wppfsst2rm->proc~pwtimera proc~wppfcst2rm3 WPPFCST2RM3 proc~wppfcst2rm3->proc~pwtimera proc~wppfsct2rm4 WPPFSCT2RM4 proc~wppfsct2rm4->proc~pwtimera Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/pwtimera.html"},{"title":"PDIVFD2 – QuickPIC","text":"subroutine PDIVFD2(f, df, nx, ny, kstrt, ndim, nyv, kxp2, j2blok) Arguments Type Intent Optional Attributes Name real :: f real :: df integer :: nx integer :: ny integer :: kstrt integer :: ndim integer :: nyv integer :: kxp2 integer :: j2blok Calls proc~~pdivfd2~~CallsGraph proc~pdivfd2 PDIVFD2 float float proc~pdivfd2->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/pdivfd2.html"},{"title":"PGRADFD2 – QuickPIC","text":"subroutine PGRADFD2(df, f, nx, ny, kstrt, ndim, nyv, kxp2, j2blok) Arguments Type Intent Optional Attributes Name real :: df real :: f integer :: nx integer :: ny integer :: kstrt integer :: ndim integer :: nyv integer :: kxp2 integer :: j2blok Calls proc~~pgradfd2~~CallsGraph proc~pgradfd2 PGRADFD2 float float proc~pgradfd2->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/pgradfd2.html"},{"title":"PCURLFD22 – QuickPIC","text":"subroutine PCURLFD22(f, g, nx, ny, kstrt, nyv, kxp2, j2blok) Arguments Type Intent Optional Attributes Name real :: f real :: g integer :: nx integer :: ny integer :: kstrt integer :: nyv integer :: kxp2 integer :: j2blok Calls proc~~pcurlfd22~~CallsGraph proc~pcurlfd22 PCURLFD22 float float proc~pcurlfd22->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/pcurlfd22.html"},{"title":"PCURLFD2 – QuickPIC","text":"subroutine PCURLFD2(f, g, nx, ny, kstrt, nyv, kxp2, j2blok) Arguments Type Intent Optional Attributes Name real :: f real :: g integer :: nx integer :: ny integer :: kstrt integer :: nyv integer :: kxp2 integer :: j2blok Calls proc~~pcurlfd2~~CallsGraph proc~pcurlfd2 PCURLFD2 float float proc~pcurlfd2->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/pcurlfd2.html"},{"title":"WPPFSST2RM – QuickPIC","text":"subroutine WPPFSST2RM(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nvp, nxvh, nyv, kxp2, kyp, kypd, kxp2d, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: f real :: g real :: bs real :: br integer :: isign integer :: ntpose integer :: mixup complex :: sctd real :: ttp integer :: indx integer :: indy integer :: kstrt integer :: nvp integer :: nxvh integer :: nyv integer :: kxp2 integer :: kyp integer :: kypd integer :: kxp2d integer :: nxhyd integer :: nxyd Calls proc~~wppfsst2rm~~CallsGraph proc~wppfsst2rm WPPFSST2RM proc~ppfst2rmxy PPFST2RMXY proc~wppfsst2rm->proc~ppfst2rmxy proc~ppfst2rmxx PPFST2RMXX proc~wppfsst2rm->proc~ppfst2rmxx proc~pwtimera PWTIMERA proc~wppfsst2rm->proc~pwtimera proc~pprtpose PPRTPOSE proc~wppfsst2rm->proc~pprtpose mpi_wtime mpi_wtime proc~pwtimera->mpi_wtime sub sub proc~pprtpose->sub Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/wppfsst2rm.html"},{"title":"WPPFSCT2RM – QuickPIC","text":"subroutine WPPFSCT2RM(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nvp, nxvh, nyv, kxp2, kyp, kypd, kxp2d, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: f real :: g real :: bs real :: br integer :: isign integer :: ntpose integer :: mixup complex :: sctd real :: ttp integer :: indx integer :: indy integer :: kstrt integer :: nvp integer :: nxvh integer :: nyv integer :: kxp2 integer :: kyp integer :: kypd integer :: kxp2d integer :: nxhyd integer :: nxyd Calls proc~~wppfsct2rm~~CallsGraph proc~wppfsct2rm WPPFSCT2RM proc~ppfct2rmxy PPFCT2RMXY proc~wppfsct2rm->proc~ppfct2rmxy proc~ppfst2rmxx PPFST2RMXX proc~wppfsct2rm->proc~ppfst2rmxx proc~pwtimera PWTIMERA proc~wppfsct2rm->proc~pwtimera proc~pprtpose PPRTPOSE proc~wppfsct2rm->proc~pprtpose mpi_wtime mpi_wtime proc~pwtimera->mpi_wtime sub sub proc~pprtpose->sub Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/wppfsct2rm.html"},{"title":"WPPFCST2RM – QuickPIC","text":"subroutine WPPFCST2RM(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nvp, nxvh, nyv, kxp2, kyp, kypd, kxp2d, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: f real :: g real :: bs real :: br integer :: isign integer :: ntpose integer :: mixup complex :: sctd real :: ttp integer :: indx integer :: indy integer :: kstrt integer :: nvp integer :: nxvh integer :: nyv integer :: kxp2 integer :: kyp integer :: kypd integer :: kxp2d integer :: nxhyd integer :: nxyd Calls proc~~wppfcst2rm~~CallsGraph proc~wppfcst2rm WPPFCST2RM proc~pwtimera PWTIMERA proc~wppfcst2rm->proc~pwtimera proc~ppfct2rmxx PPFCT2RMXX proc~wppfcst2rm->proc~ppfct2rmxx proc~ppfst2rmxy PPFST2RMXY proc~wppfcst2rm->proc~ppfst2rmxy proc~pprtpose PPRTPOSE proc~wppfcst2rm->proc~pprtpose mpi_wtime mpi_wtime proc~pwtimera->mpi_wtime sub sub proc~pprtpose->sub Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/wppfcst2rm.html"},{"title":"WPPFCCT2RM – QuickPIC","text":"subroutine WPPFCCT2RM(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nvp, nxvh, nyv, kxp2, kyp, kypd, kxp2d, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: f real :: g real :: bs real :: br integer :: isign integer :: ntpose integer :: mixup complex :: sctd real :: ttp integer :: indx integer :: indy integer :: kstrt integer :: nvp integer :: nxvh integer :: nyv integer :: kxp2 integer :: kyp integer :: kypd integer :: kxp2d integer :: nxhyd integer :: nxyd Calls proc~~wppfcct2rm~~CallsGraph proc~wppfcct2rm WPPFCCT2RM proc~ppfct2rmxy PPFCT2RMXY proc~wppfcct2rm->proc~ppfct2rmxy proc~ppfct2rmxx PPFCT2RMXX proc~wppfcct2rm->proc~ppfct2rmxx proc~pwtimera PWTIMERA proc~wppfcct2rm->proc~pwtimera proc~pprtpose PPRTPOSE proc~wppfcct2rm->proc~pprtpose mpi_wtime mpi_wtime proc~pwtimera->mpi_wtime sub sub proc~pprtpose->sub Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/wppfcct2rm.html"},{"title":"PPFST2RMXX – QuickPIC","text":"subroutine PPFST2RMXX(f, isign, mixup, sctd, indx, indy, kstrt, kypi, kypp, nxvh, kypd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: f integer :: isign integer :: mixup complex :: sctd integer :: indx integer :: indy integer :: kstrt integer :: kypi integer :: kypp integer :: nxvh integer :: kypd integer :: nxhyd integer :: nxyd Called by proc~~ppfst2rmxx~~CalledByGraph proc~ppfst2rmxx PPFST2RMXX proc~wppfsct2rm WPPFSCT2RM proc~wppfsct2rm->proc~ppfst2rmxx proc~wppfsst2rm WPPFSST2RM proc~wppfsst2rm->proc~ppfst2rmxx Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ppfst2rmxx.html"},{"title":"PPFCT2RMXX – QuickPIC","text":"subroutine PPFCT2RMXX(f, isign, mixup, sctd, indx, indy, kstrt, kypi, kypp, nxvh, kypd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: f integer :: isign integer :: mixup complex :: sctd integer :: indx integer :: indy integer :: kstrt integer :: kypi integer :: kypp integer :: nxvh integer :: kypd integer :: nxhyd integer :: nxyd Called by proc~~ppfct2rmxx~~CalledByGraph proc~ppfct2rmxx PPFCT2RMXX proc~wppfcst2rm WPPFCST2RM proc~wppfcst2rm->proc~ppfct2rmxx proc~wppfcct2rm WPPFCCT2RM proc~wppfcct2rm->proc~ppfct2rmxx Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ppfct2rmxx.html"},{"title":"PPFST2RMXY – QuickPIC","text":"subroutine PPFST2RMXY(g, isign, mixup, sctd, indx, indy, kstrt, kxpi, kxpp, nyv, kxpd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: g integer :: isign integer :: mixup complex :: sctd integer :: indx integer :: indy integer :: kstrt integer :: kxpi integer :: kxpp integer :: nyv integer :: kxpd integer :: nxhyd integer :: nxyd Called by proc~~ppfst2rmxy~~CalledByGraph proc~ppfst2rmxy PPFST2RMXY proc~wppfcst2rm WPPFCST2RM proc~wppfcst2rm->proc~ppfst2rmxy proc~wppfsst2rm WPPFSST2RM proc~wppfsst2rm->proc~ppfst2rmxy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ppfst2rmxy.html"},{"title":"PPFCT2RMXY – QuickPIC","text":"subroutine PPFCT2RMXY(g, isign, mixup, sctd, indx, indy, kstrt, kxpi, kxpp, nyv, kxpd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: g integer :: isign integer :: mixup complex :: sctd integer :: indx integer :: indy integer :: kstrt integer :: kxpi integer :: kxpp integer :: nyv integer :: kxpd integer :: nxhyd integer :: nxyd Called by proc~~ppfct2rmxy~~CalledByGraph proc~ppfct2rmxy PPFCT2RMXY proc~wppfsct2rm WPPFSCT2RM proc~wppfsct2rm->proc~ppfct2rmxy proc~wppfcct2rm WPPFCCT2RM proc~wppfcct2rm->proc~ppfct2rmxy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ppfct2rmxy.html"},{"title":"WPPFCST2RM2 – QuickPIC","text":"subroutine WPPFCST2RM2(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nvp, nxvh, nyv, kxp2, kyp, kypd, kxp2d, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: f real :: g real :: bs real :: br integer :: isign integer :: ntpose integer :: mixup complex :: sctd real :: ttp integer :: indx integer :: indy integer :: kstrt integer :: nvp integer :: nxvh integer :: nyv integer :: kxp2 integer :: kyp integer :: kypd integer :: kxp2d integer :: nxhyd integer :: nxyd Calls proc~~wppfcst2rm2~~CallsGraph proc~wppfcst2rm2 WPPFCST2RM2 proc~pprntpose PPRNTPOSE proc~wppfcst2rm2->proc~pprntpose proc~ppfsct2rm2y PPFSCT2RM2Y proc~wppfcst2rm2->proc~ppfsct2rm2y proc~ppfcst2rm2x PPFCST2RM2X proc~wppfcst2rm2->proc~ppfcst2rm2x proc~pwtimera PWTIMERA proc~wppfcst2rm2->proc~pwtimera sub sub proc~pprntpose->sub mpi_wtime mpi_wtime proc~pwtimera->mpi_wtime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/wppfcst2rm2.html"},{"title":"WPPFSCT2RM2 – QuickPIC","text":"subroutine WPPFSCT2RM2(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nvp, nxvh, nyv, kxp2, kyp, kypd, kxp2d, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: f real :: g real :: bs real :: br integer :: isign integer :: ntpose integer :: mixup complex :: sctd real :: ttp integer :: indx integer :: indy integer :: kstrt integer :: nvp integer :: nxvh integer :: nyv integer :: kxp2 integer :: kyp integer :: kypd integer :: kxp2d integer :: nxhyd integer :: nxyd Calls proc~~wppfsct2rm2~~CallsGraph proc~wppfsct2rm2 WPPFSCT2RM2 proc~pprntpose PPRNTPOSE proc~wppfsct2rm2->proc~pprntpose proc~ppfcst2rm2y PPFCST2RM2Y proc~wppfsct2rm2->proc~ppfcst2rm2y proc~ppfsct2rm2x PPFSCT2RM2X proc~wppfsct2rm2->proc~ppfsct2rm2x proc~pwtimera PWTIMERA proc~wppfsct2rm2->proc~pwtimera sub sub proc~pprntpose->sub mpi_wtime mpi_wtime proc~pwtimera->mpi_wtime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/wppfsct2rm2.html"},{"title":"PPFCST2RM2X – QuickPIC","text":"subroutine PPFCST2RM2X(f, isign, mixup, sctd, indx, indy, kstrt, kypi, kypp, nxvh, kypd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: f integer :: isign integer :: mixup complex :: sctd integer :: indx integer :: indy integer :: kstrt integer :: kypi integer :: kypp integer :: nxvh integer :: kypd integer :: nxhyd integer :: nxyd Called by proc~~ppfcst2rm2x~~CalledByGraph proc~ppfcst2rm2x PPFCST2RM2X proc~wppfcst2rm2 WPPFCST2RM2 proc~wppfcst2rm2->proc~ppfcst2rm2x Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ppfcst2rm2x.html"},{"title":"PPFSCT2RM2X – QuickPIC","text":"subroutine PPFSCT2RM2X(f, isign, mixup, sctd, indx, indy, kstrt, kypi, kypp, nxvh, kypd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: f integer :: isign integer :: mixup complex :: sctd integer :: indx integer :: indy integer :: kstrt integer :: kypi integer :: kypp integer :: nxvh integer :: kypd integer :: nxhyd integer :: nxyd Called by proc~~ppfsct2rm2x~~CalledByGraph proc~ppfsct2rm2x PPFSCT2RM2X proc~wppfsct2rm2 WPPFSCT2RM2 proc~wppfsct2rm2->proc~ppfsct2rm2x Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ppfsct2rm2x.html"},{"title":"PPFSCT2RM2Y – QuickPIC","text":"subroutine PPFSCT2RM2Y(g, isign, mixup, sctd, indx, indy, kstrt, kxpi, kxpp, nyv, kxpd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: g integer :: isign integer :: mixup complex :: sctd integer :: indx integer :: indy integer :: kstrt integer :: kxpi integer :: kxpp integer :: nyv integer :: kxpd integer :: nxhyd integer :: nxyd Called by proc~~ppfsct2rm2y~~CalledByGraph proc~ppfsct2rm2y PPFSCT2RM2Y proc~wppfcst2rm2 WPPFCST2RM2 proc~wppfcst2rm2->proc~ppfsct2rm2y Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ppfsct2rm2y.html"},{"title":"PPFCST2RM2Y – QuickPIC","text":"subroutine PPFCST2RM2Y(g, isign, mixup, sctd, indx, indy, kstrt, kxpi, kxpp, nyv, kxpd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: g integer :: isign integer :: mixup complex :: sctd integer :: indx integer :: indy integer :: kstrt integer :: kxpi integer :: kxpp integer :: nyv integer :: kxpd integer :: nxhyd integer :: nxyd Called by proc~~ppfcst2rm2y~~CalledByGraph proc~ppfcst2rm2y PPFCST2RM2Y proc~wppfsct2rm2 WPPFSCT2RM2 proc~wppfsct2rm2->proc~ppfcst2rm2y Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ppfcst2rm2y.html"},{"title":"WPPFCST2RM3 – QuickPIC","text":"subroutine WPPFCST2RM3(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nvp, nxvh, nyv, kxp2, kyp, kypd, kxp2d, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: f real :: g real :: bs real :: br integer :: isign integer :: ntpose integer :: mixup complex :: sctd real :: ttp integer :: indx integer :: indy integer :: kstrt integer :: nvp integer :: nxvh integer :: nyv integer :: kxp2 integer :: kyp integer :: kypd integer :: kxp2d integer :: nxhyd integer :: nxyd Calls proc~~wppfcst2rm3~~CallsGraph proc~wppfcst2rm3 WPPFCST2RM3 proc~ppfcsst2rm3x PPFCSST2RM3X proc~wppfcst2rm3->proc~ppfcsst2rm3x proc~pprntpose PPRNTPOSE proc~wppfcst2rm3->proc~pprntpose proc~pwtimera PWTIMERA proc~wppfcst2rm3->proc~pwtimera proc~ppfscst2rm3y PPFSCST2RM3Y proc~wppfcst2rm3->proc~ppfscst2rm3y sub sub proc~pprntpose->sub mpi_wtime mpi_wtime proc~pwtimera->mpi_wtime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/wppfcst2rm3.html"},{"title":"WPPFSCT2RM3 – QuickPIC","text":"subroutine WPPFSCT2RM3(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nvp, nxvh, nyv, kxp2, kyp, kypd, kxp2d, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: f real :: g real :: bs real :: br integer :: isign integer :: ntpose integer :: mixup complex :: sctd real :: ttp integer :: indx integer :: indy integer :: kstrt integer :: nvp integer :: nxvh integer :: nyv integer :: kxp2 integer :: kyp integer :: kypd integer :: kxp2d integer :: nxhyd integer :: nxyd Calls proc~~wppfsct2rm3~~CallsGraph proc~wppfsct2rm3 WPPFSCT2RM3 proc~pprntpose PPRNTPOSE proc~wppfsct2rm3->proc~pprntpose proc~ppfcsct2rm3y PPFCSCT2RM3Y proc~wppfsct2rm3->proc~ppfcsct2rm3y proc~pwtimera PWTIMERA proc~wppfsct2rm3->proc~pwtimera proc~ppfscct2rm3x PPFSCCT2RM3X proc~wppfsct2rm3->proc~ppfscct2rm3x sub sub proc~pprntpose->sub mpi_wtime mpi_wtime proc~pwtimera->mpi_wtime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/wppfsct2rm3.html"},{"title":"PPFCSST2RM3X – QuickPIC","text":"subroutine PPFCSST2RM3X(f, isign, mixup, sctd, indx, indy, kstrt, kypi, kypp, nxvh, kypd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: f integer :: isign integer :: mixup complex :: sctd integer :: indx integer :: indy integer :: kstrt integer :: kypi integer :: kypp integer :: nxvh integer :: kypd integer :: nxhyd integer :: nxyd Called by proc~~ppfcsst2rm3x~~CalledByGraph proc~ppfcsst2rm3x PPFCSST2RM3X proc~wppfcst2rm3 WPPFCST2RM3 proc~wppfcst2rm3->proc~ppfcsst2rm3x Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ppfcsst2rm3x.html"},{"title":"PPFSCCT2RM3X – QuickPIC","text":"subroutine PPFSCCT2RM3X(f, isign, mixup, sctd, indx, indy, kstrt, kypi, kypp, nxvh, kypd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: f integer :: isign integer :: mixup complex :: sctd integer :: indx integer :: indy integer :: kstrt integer :: kypi integer :: kypp integer :: nxvh integer :: kypd integer :: nxhyd integer :: nxyd Called by proc~~ppfscct2rm3x~~CalledByGraph proc~ppfscct2rm3x PPFSCCT2RM3X proc~wppfsct2rm3 WPPFSCT2RM3 proc~wppfsct2rm3->proc~ppfscct2rm3x Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ppfscct2rm3x.html"},{"title":"PPFSCST2RM3Y – QuickPIC","text":"subroutine PPFSCST2RM3Y(g, isign, mixup, sctd, indx, indy, kstrt, kxpi, kxpp, nyv, kxpd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: g integer :: isign integer :: mixup complex :: sctd integer :: indx integer :: indy integer :: kstrt integer :: kxpi integer :: kxpp integer :: nyv integer :: kxpd integer :: nxhyd integer :: nxyd Called by proc~~ppfscst2rm3y~~CalledByGraph proc~ppfscst2rm3y PPFSCST2RM3Y proc~wppfcst2rm3 WPPFCST2RM3 proc~wppfcst2rm3->proc~ppfscst2rm3y Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ppfscst2rm3y.html"},{"title":"PPFCSCT2RM3Y – QuickPIC","text":"subroutine PPFCSCT2RM3Y(g, isign, mixup, sctd, indx, indy, kstrt, kxpi, kxpp, nyv, kxpd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: g integer :: isign integer :: mixup complex :: sctd integer :: indx integer :: indy integer :: kstrt integer :: kxpi integer :: kxpp integer :: nyv integer :: kxpd integer :: nxhyd integer :: nxyd Called by proc~~ppfcsct2rm3y~~CalledByGraph proc~ppfcsct2rm3y PPFCSCT2RM3Y proc~wppfsct2rm3 WPPFSCT2RM3 proc~wppfsct2rm3->proc~ppfcsct2rm3y Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ppfcsct2rm3y.html"},{"title":"WPPFSCT2RM4 – QuickPIC","text":"subroutine WPPFSCT2RM4(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nvp, nxvh, nyv, kxp2, kyp, kypd, kxp2d, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: f real :: g real :: bs real :: br integer :: isign integer :: ntpose integer :: mixup complex :: sctd real :: ttp integer :: indx integer :: indy integer :: kstrt integer :: nvp integer :: nxvh integer :: nyv integer :: kxp2 integer :: kyp integer :: kypd integer :: kxp2d integer :: nxhyd integer :: nxyd Calls proc~~wppfsct2rm4~~CallsGraph proc~wppfsct2rm4 WPPFSCT2RM4 proc~pprntpose PPRNTPOSE proc~wppfsct2rm4->proc~pprntpose proc~ppfsccst2rm4x PPFSCCST2RM4X proc~wppfsct2rm4->proc~ppfsccst2rm4x proc~ppfscsct2rm4y PPFSCSCT2RM4Y proc~wppfsct2rm4->proc~ppfscsct2rm4y proc~pwtimera PWTIMERA proc~wppfsct2rm4->proc~pwtimera sub sub proc~pprntpose->sub mpi_wtime mpi_wtime proc~pwtimera->mpi_wtime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/wppfsct2rm4.html"},{"title":"PPFSCCST2RM4X – QuickPIC","text":"subroutine PPFSCCST2RM4X(f, isign, mixup, sctd, indx, indy, kstrt, kypi, kypp, nxvh, kypd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: f integer :: isign integer :: mixup complex :: sctd integer :: indx integer :: indy integer :: kstrt integer :: kypi integer :: kypp integer :: nxvh integer :: kypd integer :: nxhyd integer :: nxyd Called by proc~~ppfsccst2rm4x~~CalledByGraph proc~ppfsccst2rm4x PPFSCCST2RM4X proc~wppfsct2rm4 WPPFSCT2RM4 proc~wppfsct2rm4->proc~ppfsccst2rm4x Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ppfsccst2rm4x.html"},{"title":"PPFSCSCT2RM4Y – QuickPIC","text":"subroutine PPFSCSCT2RM4Y(g, isign, mixup, sctd, indx, indy, kstrt, kxpi, kxpp, nyv, kxpd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: g integer :: isign integer :: mixup complex :: sctd integer :: indx integer :: indy integer :: kstrt integer :: kxpi integer :: kxpp integer :: nyv integer :: kxpd integer :: nxhyd integer :: nxyd Called by proc~~ppfscsct2rm4y~~CalledByGraph proc~ppfscsct2rm4y PPFSCSCT2RM4Y proc~wppfsct2rm4 WPPFSCT2RM4 proc~wppfsct2rm4->proc~ppfscsct2rm4y Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ppfscsct2rm4y.html"},{"title":"WPPFSCT2RM22 – QuickPIC","text":"subroutine WPPFSCT2RM22(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nvp, nxvh, nyv, kxp2, kyp, kypd, kxp2d, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: f real :: g real :: bs real :: br integer :: isign integer :: ntpose integer :: mixup complex :: sctd real :: ttp integer :: indx integer :: indy integer :: kstrt integer :: nvp integer :: nxvh integer :: nyv integer :: kxp2 integer :: kyp integer :: kypd integer :: kxp2d integer :: nxhyd integer :: nxyd Calls proc~~wppfsct2rm22~~CallsGraph proc~wppfsct2rm22 WPPFSCT2RM22 proc~pprntpose PPRNTPOSE proc~wppfsct2rm22->proc~pprntpose proc~ppfsccst2rm22x PPFSCCST2RM22X proc~wppfsct2rm22->proc~ppfsccst2rm22x proc~ppfscsct2rm22y PPFSCSCT2RM22Y proc~wppfsct2rm22->proc~ppfscsct2rm22y proc~pwtimera PWTIMERA proc~wppfsct2rm22->proc~pwtimera sub sub proc~pprntpose->sub mpi_wtime mpi_wtime proc~pwtimera->mpi_wtime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/wppfsct2rm22.html"},{"title":"PPFSCCST2RM22X – QuickPIC","text":"subroutine PPFSCCST2RM22X(f, isign, mixup, sctd, indx, indy, kstrt, kypi, kypp, nxvh, kypd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: f integer :: isign integer :: mixup complex :: sctd integer :: indx integer :: indy integer :: kstrt integer :: kypi integer :: kypp integer :: nxvh integer :: kypd integer :: nxhyd integer :: nxyd Called by proc~~ppfsccst2rm22x~~CalledByGraph proc~ppfsccst2rm22x PPFSCCST2RM22X proc~wppfsct2rm22 WPPFSCT2RM22 proc~wppfsct2rm22->proc~ppfsccst2rm22x Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ppfsccst2rm22x.html"},{"title":"PPFSCSCT2RM22Y – QuickPIC","text":"subroutine PPFSCSCT2RM22Y(g, isign, mixup, sctd, indx, indy, kstrt, kxpi, kxpp, nyv, kxpd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: g integer :: isign integer :: mixup complex :: sctd integer :: indx integer :: indy integer :: kstrt integer :: kxpi integer :: kxpp integer :: nyv integer :: kxpd integer :: nxhyd integer :: nxyd Called by proc~~ppfscsct2rm22y~~CalledByGraph proc~ppfscsct2rm22y PPFSCSCT2RM22Y proc~wppfsct2rm22 WPPFSCT2RM22 proc~wppfsct2rm22->proc~ppfscsct2rm22y Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ppfscsct2rm22y.html"},{"title":"WPPFSST2RM23 – QuickPIC","text":"subroutine WPPFSST2RM23(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nvp, nxvh, nyv, kxp2, kyp, kypd, kxp2d, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: f real :: g real :: bs real :: br integer :: isign integer :: ntpose integer :: mixup complex :: sctd real :: ttp integer :: indx integer :: indy integer :: kstrt integer :: nvp integer :: nxvh integer :: nyv integer :: kxp2 integer :: kyp integer :: kypd integer :: kxp2d integer :: nxhyd integer :: nxyd Calls proc~~wppfsst2rm23~~CallsGraph proc~wppfsst2rm23 WPPFSST2RM23 proc~pprntpose PPRNTPOSE proc~wppfsst2rm23->proc~pprntpose proc~ppfssct2rm23x PPFSSCT2RM23X proc~wppfsst2rm23->proc~ppfssct2rm23x proc~ppfssct2rm23y PPFSSCT2RM23Y proc~wppfsst2rm23->proc~ppfssct2rm23y proc~pwtimera PWTIMERA proc~wppfsst2rm23->proc~pwtimera sub sub proc~pprntpose->sub mpi_wtime mpi_wtime proc~pwtimera->mpi_wtime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/wppfsst2rm23.html"},{"title":"PPFSSCT2RM23X – QuickPIC","text":"subroutine PPFSSCT2RM23X(f, isign, mixup, sctd, indx, indy, kstrt, kypi, kypp, nxvh, kypd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: f integer :: isign integer :: mixup complex :: sctd integer :: indx integer :: indy integer :: kstrt integer :: kypi integer :: kypp integer :: nxvh integer :: kypd integer :: nxhyd integer :: nxyd Called by proc~~ppfssct2rm23x~~CalledByGraph proc~ppfssct2rm23x PPFSSCT2RM23X proc~wppfsst2rm23 WPPFSST2RM23 proc~wppfsst2rm23->proc~ppfssct2rm23x Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ppfssct2rm23x.html"},{"title":"PPFSSCT2RM23Y – QuickPIC","text":"subroutine PPFSSCT2RM23Y(g, isign, mixup, sctd, indx, indy, kstrt, kxpi, kxpp, nyv, kxpd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real :: g integer :: isign integer :: mixup complex :: sctd integer :: indx integer :: indy integer :: kstrt integer :: kxpi integer :: kxpp integer :: nyv integer :: kxpd integer :: nxhyd integer :: nxyd Called by proc~~ppfssct2rm23y~~CalledByGraph proc~ppfssct2rm23y PPFSSCT2RM23Y proc~wppfsst2rm23 WPPFSST2RM23 proc~wppfsst2rm23->proc~ppfssct2rm23y Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ppfssct2rm23y.html"},{"title":"MPPDIVFD2 – QuickPIC","text":"subroutine MPPDIVFD2(f, df, nx, ny, kstrt, ndim, nyv, kxp2) Arguments Type Intent Optional Attributes Name real :: f real :: df integer :: nx integer :: ny integer :: kstrt integer :: ndim integer :: nyv integer :: kxp2 Contents None","tags":"","loc":"proc/mppdivfd2.html"},{"title":"MPPGRADFD2 – QuickPIC","text":"subroutine MPPGRADFD2(df, f, nx, ny, kstrt, ndim, nyv, kxp2) Arguments Type Intent Optional Attributes Name real :: df real :: f integer :: nx integer :: ny integer :: kstrt integer :: ndim integer :: nyv integer :: kxp2 Contents None","tags":"","loc":"proc/mppgradfd2.html"},{"title":"MPPCURLFD2 – QuickPIC","text":"subroutine MPPCURLFD2(f, g, nx, ny, kstrt, nyv, kxp2) Arguments Type Intent Optional Attributes Name real :: f real :: g integer :: nx integer :: ny integer :: kstrt integer :: nyv integer :: kxp2 Contents None","tags":"","loc":"proc/mppcurlfd2.html"},{"title":"PPOISDX2 – QuickPIC","text":"subroutine PPOISDX2(q, fx, fy, isign, ffd, ax, ay, affp, we, nx, ny, kstrt, ny 2d, kxp2, j2blok, nyd) Arguments Type Intent Optional Attributes Name complex :: q complex :: fx complex :: fy integer :: isign complex :: ffd real :: ax real :: ay real :: affp real :: we integer :: nx integer :: ny integer :: kstrt integer :: ny 2d integer :: kxp2 integer :: j2blok integer :: nyd Calls proc~~ppoisdx2~~CallsGraph proc~ppoisdx2 PPOISDX2 float float proc~ppoisdx2->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ppoisdx2.html"},{"title":"PPOISD2 – QuickPIC","text":"subroutine PPOISD2(q, fx, fy, isign, ffd, ax, ay, affp, we, nx, ny, kstrt, ny v, kxp2, j2blok, nyd) Arguments Type Intent Optional Attributes Name real :: q real :: fx real :: fy integer :: isign complex :: ffd real :: ax real :: ay real :: affp real :: we integer :: nx integer :: ny integer :: kstrt integer :: ny v integer :: kxp2 integer :: j2blok integer :: nyd Calls proc~~ppoisd2~~CallsGraph proc~ppoisd2 PPOISD2 float float proc~ppoisd2->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ppoisd2.html"},{"title":"PPOISD22 – QuickPIC","text":"subroutine PPOISD22(q, fxy, isign, ffd, ax, ay, affp, we, nx, ny, kstrt, nyv, kxp2, j2blok, nyd) Arguments Type Intent Optional Attributes Name real :: q real :: fxy integer :: isign complex :: ffd real :: ax real :: ay real :: affp real :: we integer :: nx integer :: ny integer :: kstrt integer :: nyv integer :: kxp2 integer :: j2blok integer :: nyd Calls proc~~ppoisd22~~CallsGraph proc~ppoisd22 PPOISD22 float float proc~ppoisd22->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ppoisd22.html"},{"title":"PPOISDX23 – QuickPIC","text":"subroutine PPOISDX23(q, fxy, isign, ffd, ax, ay, affp, we, nx, ny, kstrt, ny2 d, kxp2, j2blok, nyd) Arguments Type Intent Optional Attributes Name complex :: q complex :: fxy integer :: isign complex :: ffd real :: ax real :: ay real :: affp real :: we integer :: nx integer :: ny integer :: kstrt integer :: ny2 d integer :: kxp2 integer :: j2blok integer :: nyd Calls proc~~ppoisdx23~~CallsGraph proc~ppoisdx23 PPOISDX23 float float proc~ppoisdx23->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ppoisdx23.html"},{"title":"PPOISD23 – QuickPIC","text":"subroutine PPOISD23(q, fxy, isign, ffd, ax, ay, affp, we, nx, ny, kstrt, nyv, kxp2, j2blok, nyd) Arguments Type Intent Optional Attributes Name real :: q real :: fxy integer :: isign complex :: ffd real :: ax real :: ay real :: affp real :: we integer :: nx integer :: ny integer :: kstrt integer :: nyv integer :: kxp2 integer :: j2blok integer :: nyd Calls proc~~ppoisd23~~CallsGraph proc~ppoisd23 PPOISD23 float float proc~ppoisd23->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ppoisd23.html"},{"title":"PBPOISD22 – QuickPIC","text":"subroutine PBPOISD22(cu, bxy, bz, isign, ffd, ax, ay, affp, ci, wm, nx, ny, ks trt, nyv, kxp2, j2blok, nyd) Arguments Type Intent Optional Attributes Name real :: cu real :: bxy real :: bz integer :: isign complex :: ffd real :: ax real :: ay real :: affp real :: ci real :: wm integer :: nx integer :: ny integer :: ks trt integer :: nyv integer :: kxp2 integer :: j2blok integer :: nyd Calls proc~~pbpoisd22~~CallsGraph proc~pbpoisd22 PBPOISD22 float float proc~pbpoisd22->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/pbpoisd22.html"},{"title":"PBPOISD23 – QuickPIC","text":"subroutine PBPOISD23(cu, bxy, isign, ffd, ax, ay, affp, ci, wm, nx, ny, kstrt, nyv, kxp2, j2blok, nyd) Arguments Type Intent Optional Attributes Name real :: cu real :: bxy integer :: isign complex :: ffd real :: ax real :: ay real :: affp real :: ci real :: wm integer :: nx integer :: ny integer :: kstrt integer :: nyv integer :: kxp2 integer :: j2blok integer :: nyd Calls proc~~pbpoisd23~~CallsGraph proc~pbpoisd23 PBPOISD23 float float proc~pbpoisd23->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/pbpoisd23.html"},{"title":"PBPOISD22N_QP – QuickPIC","text":"subroutine PBPOISD22N_QP(cu, dcu, amu, bxy, bz, isign, ffd, ax, ay, affp, ci, wm, nx, ny, kstrt, nyv, kxp2, j2blok, nyd, aa, dex) Arguments Type Intent Optional Attributes Name real :: cu real :: dcu real :: amu real :: bxy real :: bz integer :: isign complex :: ffd real :: ax real :: ay real :: affp real :: ci real :: wm integer :: nx integer :: ny integer :: kstrt integer :: nyv integer :: kxp2 integer :: j2blok integer :: nyd real :: aa real :: dex Calls proc~~pbpoisd22n_qp~~CallsGraph proc~pbpoisd22n_qp PBPOISD22N_QP float float proc~pbpoisd22n_qp->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/pbpoisd22n_qp.html"},{"title":"MPPOISD22 – QuickPIC","text":"subroutine MPPOISD22(q, fxy, isign, ffd, ax, ay, affp, we, nx, ny, kstrt, nyv, kxp2, nyd) Arguments Type Intent Optional Attributes Name real :: q real :: fxy integer :: isign complex :: ffd real :: ax real :: ay real :: affp real :: we integer :: nx integer :: ny integer :: kstrt integer :: nyv integer :: kxp2 integer :: nyd Contents None","tags":"","loc":"proc/mppoisd22.html"},{"title":"MPPOISD23 – QuickPIC","text":"subroutine MPPOISD23(q, fxy, isign, ffd, ax, ay, affp, we, nx, ny, kstrt, nyv, kxp2, nyd) Arguments Type Intent Optional Attributes Name real :: q real :: fxy integer :: isign complex :: ffd real :: ax real :: ay real :: affp real :: we integer :: nx integer :: ny integer :: kstrt integer :: nyv integer :: kxp2 integer :: nyd Contents None","tags":"","loc":"proc/mppoisd23.html"},{"title":"MPPOTPD2 – QuickPIC","text":"subroutine MPPOTPD2(q, pot, ffd, we, nx, ny, kstrt, nyv, kxp2, nyd) Arguments Type Intent Optional Attributes Name real :: q real :: pot complex :: ffd real :: we integer :: nx integer :: ny integer :: kstrt integer :: nyv integer :: kxp2 integer :: nyd Contents None","tags":"","loc":"proc/mppotpd2.html"},{"title":"MPPSMOOTHD2 – QuickPIC","text":"subroutine MPPSMOOTHD2(q, qs, ffd, nx, ny, kstrt, nyv, kxp2, nyd) Arguments Type Intent Optional Attributes Name real :: q real :: qs complex :: ffd integer :: nx integer :: ny integer :: kstrt integer :: nyv integer :: kxp2 integer :: nyd Contents None","tags":"","loc":"proc/mppsmoothd2.html"},{"title":"MPPBBPOISD23 – QuickPIC","text":"subroutine MPPBBPOISD23(cu, bxy, ffd, ci, wm, nx, ny, kstrt, nyv, kxp2, nyd) Arguments Type Intent Optional Attributes Name real :: cu real :: bxy complex :: ffd real :: ci real :: wm integer :: nx integer :: ny integer :: kstrt integer :: nyv integer :: kxp2 integer :: nyd Contents None","tags":"","loc":"proc/mppbbpoisd23.html"},{"title":"PWRITE2 – QuickPIC","text":"subroutine PWRITE2(f, nx, kyp, nxv, kypmx, nblok, iunit, nrec, lrec, name) Arguments Type Intent Optional Attributes Name real :: f integer :: nx integer :: kyp integer :: nxv integer :: kypmx integer :: nblok integer :: iunit integer :: nrec integer :: lrec character(len=*) :: name Calls proc~~pwrite2~~CallsGraph proc~pwrite2 PWRITE2 mpi_comm_rank mpi_comm_rank proc~pwrite2->mpi_comm_rank mpi_comm_size mpi_comm_size proc~pwrite2->mpi_comm_size mpi_send mpi_send proc~pwrite2->mpi_send mpi_recv mpi_recv proc~pwrite2->mpi_recv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks PPARMS Common Blocks common /PPARMS/ Type Attributes Name Initial integer :: nproc integer :: lgrp integer :: mreal integer :: mint integer :: mcplx integer :: mdouble integer :: lworld $(function () {\n      $('[data-toggle=\"popover\"]').popover()\n      })","tags":"","loc":"proc/pwrite2.html"},{"title":"PCGUARD32L – QuickPIC","text":"subroutine PCGUARD32L(f, scs, kstrt, nvpy, nvpz, nxv, nypmx, nzpmx, mblok, nblok, kyp, kzp, ngds, tag1, tag2, rid, sid, ierr) Arguments Type Intent Optional Attributes Name real :: f real :: scs integer :: kstrt integer :: nvpy integer :: nvpz integer :: nxv integer :: nypmx integer :: nzpmx integer :: mblok integer :: nblok integer :: kyp integer :: kzp integer :: ngds integer :: tag1 integer :: tag2 integer :: rid integer :: sid integer :: ierr Contents Common Blocks PPARMS Common Blocks common /PPARMS/ Type Attributes Name Initial integer :: nproc integer :: lgrp integer :: mreal integer :: mint integer :: mcplx integer :: mdouble integer :: lworld $(function () {\n      $('[data-toggle=\"popover\"]').popover()\n      })","tags":"","loc":"proc/pcguard32l.html"},{"title":"PACGUARD32L – QuickPIC","text":"subroutine PACGUARD32L(f, scs, kstrt, nvpy, nvpz, nx, nxv, nypmx, nzpmx, mb lok, nblok, kyp, kzp, ngds) Arguments Type Intent Optional Attributes Name real :: f real :: scs integer :: kstrt integer :: nvpy integer :: nvpz integer :: nx integer :: nxv integer :: nypmx integer :: nzpmx integer :: mb lok integer :: nblok integer :: kyp integer :: kzp integer :: ngds Calls proc~~pacguard32l~~CallsGraph proc~pacguard32l PACGUARD32L mpi_wait mpi_wait proc~pacguard32l->mpi_wait Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks PPARMS Common Blocks common /PPARMS/ Type Attributes Name Initial integer :: nproc integer :: lgrp integer :: mreal integer :: mint integer :: mcplx integer :: mdouble integer :: lworld $(function () {\n      $('[data-toggle=\"popover\"]').popover()\n      })","tags":"","loc":"proc/pacguard32l.html"},{"title":"PAGUARD32L – QuickPIC","text":"subroutine PAGUARD32L(f, scs, scr, kstrt, nvpy, nvpz, nx, nxv, nypmx, nzpmx, mblok, nblok, kyp, kzp, ngds, tag1, tag2, id, ierr) Arguments Type Intent Optional Attributes Name real :: f real :: scs real :: scr integer :: kstrt integer :: nvpy integer :: nvpz integer :: nx integer :: nxv integer :: nypmx integer :: nzpmx integer :: mblok integer :: nblok integer :: kyp integer :: kzp integer :: ngds integer :: tag1 integer :: tag2 integer :: id integer :: ierr Calls proc~~paguard32l~~CallsGraph proc~paguard32l PAGUARD32L mpi_wait mpi_wait proc~paguard32l->mpi_wait mpi_irecv mpi_irecv proc~paguard32l->mpi_irecv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks PPARMS Common Blocks common /PPARMS/ Type Attributes Name Initial integer :: nproc integer :: lgrp integer :: mreal integer :: mint integer :: mcplx integer :: mdouble integer :: lworld $(function () {\n      $('[data-toggle=\"popover\"]').popover()\n      })","tags":"","loc":"proc/paguard32l.html"},{"title":"ranorm – QuickPIC","text":"function ranorm() Arguments None Return Value double precision Calls proc~~ranorm~~CallsGraph proc~ranorm ranorm dcos dcos proc~ranorm->dcos dsin dsin proc~ranorm->dsin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ranorm.html"},{"title":"PRVDIST32_RANDOM – QuickPIC","text":"subroutine PRVDIST32_RANDOM(part, qm, edges, npp, nps, vtx, vty, vtz, vdx, vdy, vdz, npx, npy, npz, nx, ny, nz, ipbc, idimp, npmax, mblok, nblok, idps, sig x, sigy, sigz, x0, y0, z0, cx, cy, lquiet, ierr) Arguments Type Intent Optional Attributes Name real :: part real :: qm real :: edges integer :: npp integer :: nps real :: vtx real :: vty real :: vtz real :: vdx real :: vdy real :: vdz integer :: npx integer :: npy integer :: npz integer :: nx integer :: ny integer :: nz integer :: ipbc integer :: idimp integer :: npmax integer :: mblok integer :: nblok integer :: idps real :: sig x real :: sigy real :: sigz real :: x0 real :: y0 real :: z0 real :: cx real :: cy logical :: lquiet integer :: ierr Calls proc~~prvdist32_random~~CallsGraph proc~prvdist32_random PRVDIST32_RANDOM float float proc~prvdist32_random->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/prvdist32_random.html"},{"title":"PGPOST32L – QuickPIC","text":"subroutine PGPOST32L(part, q, npp, noff, idimp, npmax, mnblok, nxv, nypmx, nzpmx, idds) Arguments Type Intent Optional Attributes Name real :: part real :: q integer :: npp integer :: noff integer :: idimp integer :: npmax integer :: mnblok integer :: nxv integer :: nypmx integer :: nzpmx integer :: idds Calls proc~~pgpost32l~~CallsGraph proc~pgpost32l PGPOST32L float float proc~pgpost32l->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/pgpost32l.html"},{"title":"PGBPUSH32L_QP – QuickPIC","text":"subroutine PGBPUSH32L_QP(part, fxyz, bxyz, npp, noff, qbm, dt, dtc, ek, nx, ny, nz, idimp, npmax, mnblok, nxv, nypmx, nzpmx, idds, ipbc, deltax, deltaz, cofd) Arguments Type Intent Optional Attributes Name real :: part real :: fxyz real :: bxyz integer :: npp integer :: noff real :: qbm real :: dt real :: dtc real :: ek integer :: nx integer :: ny integer :: nz integer :: idimp integer :: npmax integer :: mnblok integer :: nxv integer :: nypmx integer :: nzpmx integer :: idds integer :: ipbc real :: deltax real :: deltaz real :: cofd Calls proc~~pgbpush32l_qp~~CallsGraph proc~pgbpush32l_qp PGBPUSH32L_QP float float proc~pgbpush32l_qp->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/pgbpush32l_qp.html"},{"title":"PMOVE32 – QuickPIC","text":"subroutine PMOVE32(part, edges, npp, sbufr, sbufl, rbufr, rbufl, ihole, pb uff, jsr, jsl, jss, ny, nz, kstrt, nvpy, nvpz, idimp, npmax, mblok, nblok, idps, nbmax, idds, ntmax, tag1, tag2, id, info) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Arguments Type Intent Optional Attributes Name real :: part real :: edges integer :: npp real :: sbufr real :: sbufl real :: rbufr real :: rbufl integer :: ihole real :: pb uff integer :: jsr integer :: jsl integer :: jss integer :: ny integer :: nz integer :: kstrt integer :: nvpy integer :: nvpz integer :: idimp integer :: npmax integer :: mblok integer :: nblok integer :: idps integer :: nbmax integer :: idds integer :: ntmax integer :: tag1 integer :: tag2 integer :: id integer :: info Calls proc~~pmove32~~CallsGraph proc~pmove32 PMOVE32 mpi_get_count mpi_get_count proc~pmove32->mpi_get_count float float proc~pmove32->float mpi_allreduce mpi_allreduce proc~pmove32->mpi_allreduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks mpi_fortran_bottom mpi_fortran_in_place mpi_fortran_argv_null mpi_fortran_argvs_null mpi_fortran_errcodes_ignore mpi_fortran_status_ignore mpi_fortran_statuses_ignore mpi_fortran_unweighted mpi_fortran_weights_empty PPARMS Common Blocks common /mpi_fortran_bottom/ Type Attributes Name Initial integer :: MPI_BOTTOM common /mpi_fortran_in_place/ Type Attributes Name Initial integer :: MPI_IN_PLACE common /mpi_fortran_argv_null/ Type Attributes Name Initial integer :: MPI_ARGV_NULL common /mpi_fortran_argvs_null/ Type Attributes Name Initial integer :: MPI_ARGVS_NULL common /mpi_fortran_errcodes_ignore/ Type Attributes Name Initial integer :: MPI_ERRCODES_IGNORE common /mpi_fortran_status_ignore/ Type Attributes Name Initial integer :: MPI_STATUS_IGNORE common /mpi_fortran_statuses_ignore/ Type Attributes Name Initial integer :: MPI_STATUSES_IGNORE common /mpi_fortran_unweighted/ Type Attributes Name Initial integer :: MPI_UNWEIGHTED common /mpi_fortran_weights_empty/ Type Attributes Name Initial integer :: MPI_WEIGHTS_EMPTY common /PPARMS/ Type Attributes Name Initial integer :: nproc integer :: lgrp integer :: mreal integer :: mint integer :: mcplx integer :: mdouble integer :: lworld $(function () {\n      $('[data-toggle=\"popover\"]').popover()\n      })","tags":"","loc":"proc/pmove32.html"},{"title":"PPDBLKP2L – QuickPIC","text":"subroutine PPDBLKP2L(part, kpic, npp, noff, nppmx, idimp, npmax, mx, my, mx1, mxyp1, irc) Arguments Type Intent Optional Attributes Name real :: part integer :: kpic integer :: npp integer :: noff integer :: nppmx integer :: idimp integer :: npmax integer :: mx integer :: my integer :: mx1 integer :: mxyp1 integer :: irc Contents None","tags":"","loc":"proc/ppdblkp2l.html"},{"title":"PPPMOVIN2L – QuickPIC","text":"subroutine PPPMOVIN2L(part, ppart, kpic, npp, noff, nppmx, idimp, npmax, mx, my, mx1, mxyp1, irc) Arguments Type Intent Optional Attributes Name real :: part real :: ppart integer :: kpic integer :: npp integer :: noff integer :: nppmx integer :: idimp integer :: npmax integer :: mx integer :: my integer :: mx1 integer :: mxyp1 integer :: irc Contents None","tags":"","loc":"proc/pppmovin2l.html"},{"title":"PPPCHECK2L – QuickPIC","text":"subroutine PPPCHECK2L(ppart, kpic, noff, nyp, idimp, nppmx, nx, mx, my, mx1, myp1, irc) Arguments Type Intent Optional Attributes Name real :: ppart integer :: kpic integer :: noff integer :: nyp integer :: idimp integer :: nppmx integer :: nx integer :: mx integer :: my integer :: mx1 integer :: myp1 integer :: irc Contents None","tags":"","loc":"proc/pppcheck2l.html"},{"title":"PPGPPOST2L – QuickPIC","text":"subroutine PPGPPOST2L(ppart, q, kpic, noff, idimp, nppmx, mx, my, nxv, nypm x, mx1, mxyp1) Arguments Type Intent Optional Attributes Name real :: ppart real :: q integer :: kpic integer :: noff integer :: idimp integer :: nppmx integer :: mx integer :: my integer :: nxv integer :: nypm x integer :: mx1 integer :: mxyp1 Contents None","tags":"","loc":"proc/ppgppost2l.html"},{"title":"PPGRDCJPPOST2L_QP – QuickPIC","text":"subroutine PPGRDCJPPOST2L_QP(ppart, fxy, bxy, psit, cu, dcu, amu, kpic, no ff, nyp, qbm, dt, ci, idimp, nppmx, nx, mx, my, nxv, nypmx, mx1, mxyp1, dex) Arguments Type Intent Optional Attributes Name real :: ppart real :: fxy real :: bxy real :: psit real :: cu real :: dcu real :: amu integer :: kpic integer :: no ff integer :: nyp real :: qbm real :: dt real :: ci integer :: idimp integer :: nppmx integer :: nx integer :: mx integer :: my integer :: nxv integer :: nypmx integer :: mx1 integer :: mxyp1 real :: dex Contents None","tags":"","loc":"proc/ppgrdcjppost2l_qp.html"},{"title":"PPGRBPPUSHF23L_QP – QuickPIC","text":"subroutine PPGRBPPUSHF23L_QP(ppart, fxy, bxy, psit, kpic, ncl, ihole, nof f, nyp, qbm, dt, dtc, ci, ek, idimp, nppmx, nx, ny, mx, my, nxv, nypmx, mx1, mxyp1, ntmax, irc, dex) Arguments Type Intent Optional Attributes Name real :: ppart real :: fxy real :: bxy real :: psit integer :: kpic integer :: ncl integer :: ihole integer :: nof f integer :: nyp real :: qbm real :: dt real :: dtc real :: ci real :: ek integer :: idimp integer :: nppmx integer :: nx integer :: ny integer :: mx integer :: my integer :: nxv integer :: nypmx integer :: mx1 integer :: mxyp1 integer :: ntmax integer :: irc real :: dex Contents None","tags":"","loc":"proc/ppgrbppushf23l_qp.html"},{"title":"PPPORDER2LA – QuickPIC","text":"subroutine PPPORDER2LA(ppart, ppbuff, sbufl, sbufr, kpic, ncl, ihole, ncll, nclr, noff, nyp, idimp, nppmx, nx, ny, mx, my, mx1, myp1, npbmx, ntmax, nbmax, irc) Arguments Type Intent Optional Attributes Name real :: ppart real :: ppbuff real :: sbufl real :: sbufr integer :: kpic integer :: ncl integer :: ihole integer :: ncll integer :: nclr integer :: noff integer :: nyp integer :: idimp integer :: nppmx integer :: nx integer :: ny integer :: mx integer :: my integer :: mx1 integer :: myp1 integer :: npbmx integer :: ntmax integer :: nbmax integer :: irc Contents None","tags":"","loc":"proc/ppporder2la.html"},{"title":"PPPORDERF2LA – QuickPIC","text":"subroutine PPPORDERF2LA(ppart, ppbuff, sbufl, sbufr, ncl, ihole, ncll, nclr, idimp, nppmx, mx1, myp1, npbmx, ntmax, nbmax, irc) Arguments Type Intent Optional Attributes Name real :: ppart real :: ppbuff real :: sbufl real :: sbufr integer :: ncl integer :: ihole integer :: ncll integer :: nclr integer :: idimp integer :: nppmx integer :: mx1 integer :: myp1 integer :: npbmx integer :: ntmax integer :: nbmax integer :: irc Contents None","tags":"","loc":"proc/ppporderf2la.html"},{"title":"PPPORDER2LB – QuickPIC","text":"subroutine PPPORDER2LB(ppart, ppbuff, rbufl, rbufr, kpic, ncl, ihole, mcll, mclr, idimp, nppmx, mx1, myp1, npbmx, ntmax, nbmax, irc) Arguments Type Intent Optional Attributes Name real :: ppart real :: ppbuff real :: rbufl real :: rbufr integer :: kpic integer :: ncl integer :: ihole integer :: mcll integer :: mclr integer :: idimp integer :: nppmx integer :: mx1 integer :: myp1 integer :: npbmx integer :: ntmax integer :: nbmax integer :: irc Contents None","tags":"","loc":"proc/ppporder2lb.html"},{"title":"WPGPSIPOST2L_QP – QuickPIC","text":"subroutine WPGPSIPOST2L_QP(ppart, psi, kpic, qbm, noff, nyp, idimp, nppmx, nx, mx, my, nxv, nypmx, mx1, mxyp1, dex) Arguments Type Intent Optional Attributes Name real :: ppart real :: psi integer :: kpic real :: qbm integer :: noff integer :: nyp integer :: idimp integer :: nppmx integer :: nx integer :: mx integer :: my integer :: nxv integer :: nypmx integer :: mx1 integer :: mxyp1 real :: dex Contents None","tags":"","loc":"proc/wpgpsipost2l_qp.html"},{"title":"PPPCOPYOUT2 – QuickPIC","text":"subroutine PPPCOPYOUT2(part, ppart, kpic, npp, npmax, nppmx, idimp, mxyp1, irc) Arguments Type Intent Optional Attributes Name real :: part real :: ppart integer :: kpic integer :: npp integer :: npmax integer :: nppmx integer :: idimp integer :: mxyp1 integer :: irc Contents None","tags":"","loc":"proc/pppcopyout2.html"},{"title":"PPRTPOSE – QuickPIC","text":"subroutine PPRTPOSE(f, g, s, t, nx, ny, kxp, kyp, kstrt, nvp, nxv, nyv, kxpd, kypd) Uses fft2d_lib proc~~pprtpose~~UsesGraph proc~pprtpose PPRTPOSE module~fft2d_lib fft2d_lib proc~pprtpose->module~fft2d_lib mpi mpi module~fft2d_lib->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(nxv,kypd) :: f real, intent(inout), dimension(nyv,kxpd) :: g real, intent(inout), dimension((kxp+1)*(kyp+1)) :: s real, intent(inout), dimension((kxp+1)*(kyp+1)) :: t integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kxp integer, intent(in) :: kyp integer, intent(in) :: kstrt integer, intent(in) :: nvp integer, intent(in) :: nxv integer, intent(in) :: nyv integer, intent(in) :: kxpd integer, intent(in) :: kypd Calls proc~~pprtpose~~CallsGraph proc~pprtpose PPRTPOSE sub sub proc~pprtpose->sub Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~pprtpose~~CalledByGraph proc~pprtpose PPRTPOSE proc~wppfsct2rm WPPFSCT2RM proc~wppfsct2rm->proc~pprtpose proc~wppfcst2rm WPPFCST2RM proc~wppfcst2rm->proc~pprtpose proc~wppfsst2rm WPPFSST2RM proc~wppfsst2rm->proc~pprtpose proc~wppfcct2rm WPPFCCT2RM proc~wppfcct2rm->proc~pprtpose Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/pprtpose.html"},{"title":"PPRNTPOSE – QuickPIC","text":"subroutine PPRNTPOSE(f, g, s, t, nx, ny, kxp, kyp, kstrt, nvp, ndim, nxv, nyv, kxpd, kypd) Uses fft2d_lib proc~~pprntpose~~UsesGraph proc~pprntpose PPRNTPOSE module~fft2d_lib fft2d_lib proc~pprntpose->module~fft2d_lib mpi mpi module~fft2d_lib->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(ndim,nxv,kypd) :: f real, intent(inout), dimension(ndim,nyv,kxpd) :: g real, intent(inout), dimension(ndim,kxp*kyp) :: s real, intent(inout), dimension(ndim,kxp*kyp) :: t integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kxp integer, intent(in) :: kyp integer, intent(in) :: kstrt integer, intent(in) :: nvp integer, intent(in) :: ndim integer, intent(in) :: nxv integer, intent(in) :: nyv integer, intent(in) :: kxpd integer, intent(in) :: kypd Calls proc~~pprntpose~~CallsGraph proc~pprntpose PPRNTPOSE sub sub proc~pprntpose->sub Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~pprntpose~~CalledByGraph proc~pprntpose PPRNTPOSE proc~wppfcst2rm2 WPPFCST2RM2 proc~wppfcst2rm2->proc~pprntpose proc~wppfsct2rm3 WPPFSCT2RM3 proc~wppfsct2rm3->proc~pprntpose proc~wppfsct2rm22 WPPFSCT2RM22 proc~wppfsct2rm22->proc~pprntpose proc~wppfsst2rm23 WPPFSST2RM23 proc~wppfsst2rm23->proc~pprntpose proc~wppfsct2rm2 WPPFSCT2RM2 proc~wppfsct2rm2->proc~pprntpose proc~wppfcst2rm3 WPPFCST2RM3 proc~wppfcst2rm3->proc~pprntpose proc~wppfsct2rm4 WPPFSCT2RM4 proc~wppfsct2rm4->proc~pprntpose Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/pprntpose.html"},{"title":"init_perrors – QuickPIC","text":"private subroutine init_perrors(this, prl, eunit, monitor) Arguments Type Intent Optional Attributes Name class( perrors ), intent(inout) :: this class( parallel ), intent(in), pointer :: prl integer, intent(in) :: eunit integer, intent(in) :: monitor Calls proc~~init_perrors~~CallsGraph proc~init_perrors init_perrors dtimer dtimer proc~init_perrors->dtimer proc~set_ename set_ename proc~init_perrors->proc~set_ename mpi_barrier mpi_barrier proc~init_perrors->mpi_barrier Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/init_perrors.html"},{"title":"set_ename – QuickPIC","text":"private subroutine set_ename(eunit, ename) Arguments Type Intent Optional Attributes Name integer, intent(in) :: eunit character(len=*), intent(in) :: ename Called by proc~~set_ename~~CalledByGraph proc~set_ename set_ename proc~init_perrors init_perrors proc~init_perrors->proc~set_ename Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/set_ename.html"},{"title":"end_perrors – QuickPIC","text":"private subroutine end_perrors(this) Arguments Type Intent Optional Attributes Name class( perrors ), intent(inout) :: this Contents None","tags":"","loc":"proc/end_perrors.html"},{"title":"equit – QuickPIC","text":"private subroutine equit(this, estr) Arguments Type Intent Optional Attributes Name class( perrors ), intent(in) :: this character(len=*), intent(in), optional :: estr Calls proc~~equit~~CallsGraph proc~equit equit mpi_abort mpi_abort proc~equit->mpi_abort dtimer dtimer proc~equit->dtimer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/equit.html"},{"title":"werrfl0 – QuickPIC","text":"private subroutine werrfl0(this, estr) Arguments Type Intent Optional Attributes Name class( perrors ), intent(in) :: this character(len=*), intent(in) :: estr Calls proc~~werrfl0~~CallsGraph proc~werrfl0 werrfl0 dtimer dtimer proc~werrfl0->dtimer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/werrfl0.html"},{"title":"werrfl1 – QuickPIC","text":"private subroutine werrfl1(this, estr) Arguments Type Intent Optional Attributes Name class( perrors ), intent(in) :: this character(len=*), intent(in) :: estr Calls proc~~werrfl1~~CallsGraph proc~werrfl1 werrfl1 dtimer dtimer proc~werrfl1->dtimer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/werrfl1.html"},{"title":"werrfl2 – QuickPIC","text":"private subroutine werrfl2(this, estr) Arguments Type Intent Optional Attributes Name class( perrors ), intent(in) :: this character(len=*), intent(in) :: estr Calls proc~~werrfl2~~CallsGraph proc~werrfl2 werrfl2 dtimer dtimer proc~werrfl2->dtimer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/werrfl2.html"},{"title":"setmonitor – QuickPIC","text":"private subroutine setmonitor(this, moniter) Arguments Type Intent Optional Attributes Name class( perrors ), intent(inout) :: this integer, intent(in) :: moniter Contents None","tags":"","loc":"proc/setmonitor.html"},{"title":"getindx – QuickPIC","text":"private function getindx(this) Arguments Type Intent Optional Attributes Name class( spect2d ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getindx.html"},{"title":"getindy – QuickPIC","text":"private function getindy(this) Arguments Type Intent Optional Attributes Name class( spect2d ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getindy.html"},{"title":"getpsolver – QuickPIC","text":"private function getpsolver(this) Arguments Type Intent Optional Attributes Name class( spect2d ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getpsolver.html"},{"title":"getinorder – QuickPIC","text":"private function getinorder(this) Arguments Type Intent Optional Attributes Name class( spect2d ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getinorder.html"},{"title":"init_spect2d – QuickPIC","text":"private subroutine init_spect2d(this, pp, perr, indx, indy, psolver, inorder) Arguments Type Intent Optional Attributes Name class( spect2d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: psolver integer, intent(in) :: inorder Contents None","tags":"","loc":"proc/init_spect2d.html"},{"title":"end_spect2d – QuickPIC","text":"private subroutine end_spect2d(this) Arguments Type Intent Optional Attributes Name class( spect2d ), intent(inout) :: this Contents None","tags":"","loc":"proc/end_spect2d.html"},{"title":"found – QuickPIC","text":"private function found(this, path) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path Return Value logical Contents None","tags":"","loc":"proc/found.html"},{"title":"read_input_json – QuickPIC","text":"private subroutine read_input_json(this) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this Calls proc~~read_input_json~~CallsGraph proc~read_input_json read_input_json mpi_bcast mpi_bcast proc~read_input_json->mpi_bcast Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/read_input_json.html"},{"title":"initialize – QuickPIC","text":"private subroutine initialize(this, verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys, no_whitespace, unescape_strings, comment_char, path_mode, path_separator, compress_vectors, allow_duplicate_keys) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this logical, intent(in), optional :: verbose logical, intent(in), optional :: compact_reals logical, intent(in), optional :: print_signs character(len=*), intent(in), optional :: real_format integer, intent(in), optional :: spaces_per_tab logical, intent(in), optional :: strict_type_checking logical, intent(in), optional :: trailing_spaces_significant logical, intent(in), optional :: case_sensitive_keys logical, intent(in), optional :: no_whitespace logical, intent(in), optional :: unescape_strings character(len=1), intent(in), optional :: comment_char integer, intent(in), optional :: path_mode character(len=1), intent(in), optional :: path_separator logical, intent(in), optional :: compress_vectors logical, intent(in), optional :: allow_duplicate_keys Contents None","tags":"","loc":"proc/initialize.html"},{"title":"set_json_core_in_file – QuickPIC","text":"private subroutine set_json_core_in_file(this, core) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this type(json_core), intent(in) :: core Contents None","tags":"","loc":"proc/set_json_core_in_file.html"},{"title":"load_file – QuickPIC","text":"private subroutine load_file(this, filename, unit) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: filename integer, intent(in), optional :: unit Contents None","tags":"","loc":"proc/load_file.html"},{"title":"print_to_string – QuickPIC","text":"private subroutine print_to_string(this, str) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=:), intent(out), allocatable :: str Contents None","tags":"","loc":"proc/print_to_string.html"},{"title":"load_from_string – QuickPIC","text":"private subroutine load_from_string(this, str) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: str Contents None","tags":"","loc":"proc/load_from_string.html"},{"title":"json_file_get_object – QuickPIC","text":"private subroutine json_file_get_object(this, path, p) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path type(json_value), intent(out), pointer :: p Contents None","tags":"","loc":"proc/json_file_get_object.html"},{"title":"json_file_get_integer – QuickPIC","text":"private subroutine json_file_get_integer(this, path, val) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path integer, intent(out) :: val Contents None","tags":"","loc":"proc/json_file_get_integer.html"},{"title":"json_file_get_double – QuickPIC","text":"private subroutine json_file_get_double(this, path, val) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path real, intent(out) :: val Contents None","tags":"","loc":"proc/json_file_get_double.html"},{"title":"json_file_get_logical – QuickPIC","text":"private subroutine json_file_get_logical(this, path, val) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path logical, intent(out) :: val Contents None","tags":"","loc":"proc/json_file_get_logical.html"},{"title":"json_file_get_string – QuickPIC","text":"private subroutine json_file_get_string(this, path, val) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path character(len=:), intent(out), allocatable :: val Contents None","tags":"","loc":"proc/json_file_get_string.html"},{"title":"json_file_get_integer_vec – QuickPIC","text":"private subroutine json_file_get_integer_vec(this, path, vec) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path integer, intent(out), dimension(:), allocatable :: vec Contents None","tags":"","loc":"proc/json_file_get_integer_vec.html"},{"title":"json_file_get_double_vec – QuickPIC","text":"private subroutine json_file_get_double_vec(this, path, vec) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path real, intent(out), dimension(:), allocatable :: vec Contents None","tags":"","loc":"proc/json_file_get_double_vec.html"},{"title":"json_file_get_logical_vec – QuickPIC","text":"private subroutine json_file_get_logical_vec(this, path, vec) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path logical, intent(out), dimension(:), allocatable :: vec Contents None","tags":"","loc":"proc/json_file_get_logical_vec.html"},{"title":"json_file_get_string_vec – QuickPIC","text":"private subroutine json_file_get_string_vec(this, path, vec) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path character(len=*), intent(out), dimension(:), allocatable :: vec Contents None","tags":"","loc":"proc/json_file_get_string_vec.html"},{"title":"json_file_get_alloc_string_vec – QuickPIC","text":"private subroutine json_file_get_alloc_string_vec(this, path, vec, ilen) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path character(len=:), intent(out), dimension(:), allocatable :: vec integer, intent(out), dimension(:), allocatable :: ilen Contents None","tags":"","loc":"proc/json_file_get_alloc_string_vec.html"},{"title":"json_file_get_root – QuickPIC","text":"private subroutine json_file_get_root(this, p) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this type(json_value), intent(out), pointer :: p Contents None","tags":"","loc":"proc/json_file_get_root.html"},{"title":"json_file_variable_info – QuickPIC","text":"private subroutine json_file_variable_info(this, path, n_children) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path integer, intent(out) :: n_children Contents None","tags":"","loc":"proc/json_file_variable_info.html"},{"title":"get_fft2table – QuickPIC","text":"public function get_fft2table(pp, perr, psp, indx, indy) result(table) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( spect2d ), intent(in), pointer :: psp integer, intent(in) :: indx integer, intent(in) :: indy Return Value type( fft2d ),\n  pointer Called by proc~~get_fft2table~~CalledByGraph proc~get_fft2table get_fft2table proc~init_field2d init_field2d proc~init_field2d->proc~get_fft2table Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_fft2table.html"},{"title":"init_fft2d – QuickPIC","text":"private subroutine init_fft2d(this, pp, perr, psp, indx, indy, nrc) Arguments Type Intent Optional Attributes Name class( fft2d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( spect2d ), intent(in), pointer :: psp integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: nrc Calls proc~~init_fft2d~~CallsGraph proc~init_fft2d init_fft2d interface~wpfst2rinit WPFST2RINIT proc~init_fft2d->interface~wpfst2rinit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/init_fft2d.html"},{"title":"end_fft2d – QuickPIC","text":"private subroutine end_fft2d(this) Arguments Type Intent Optional Attributes Name class( fft2d ), intent(inout) :: this Contents None","tags":"","loc":"proc/end_fft2d.html"},{"title":"iwpfsst2r – QuickPIC","text":"private subroutine iwpfsst2r(this, rspace, krspace, isign) Arguments Type Intent Optional Attributes Name class( fft2d ), intent(in) :: this class( ufield2d ), intent(inout) :: rspace class( ufield2d ), intent(inout) :: krspace integer, intent(in) :: isign Calls proc~~iwpfsst2r~~CallsGraph proc~iwpfsst2r iwpfsst2r interface~wppfcst2rm2 WPPFCST2RM2 proc~iwpfsst2r->interface~wppfcst2rm2 interface~wppfcst2rm3 WPPFCST2RM3 proc~iwpfsst2r->interface~wppfcst2rm3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/iwpfsst2r.html"},{"title":"iwpfcct2r – QuickPIC","text":"private subroutine iwpfcct2r(this, rspace, krspace, isign) Arguments Type Intent Optional Attributes Name class( fft2d ), intent(in) :: this class( ufield2d ), intent(inout) :: rspace class( ufield2d ), intent(inout) :: krspace integer, intent(in) :: isign Calls proc~~iwpfcct2r~~CallsGraph proc~iwpfcct2r iwpfcct2r interface~wppfsct2rm2 WPPFSCT2RM2 proc~iwpfcct2r->interface~wppfsct2rm2 interface~wppfsct2rm3 WPPFSCT2RM3 proc~iwpfcct2r->interface~wppfsct2rm3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/iwpfcct2r.html"},{"title":"iwpfs3t2r – QuickPIC","text":"private subroutine iwpfs3t2r(this, rspace, krspace, isign) Arguments Type Intent Optional Attributes Name class( fft2d ), intent(in) :: this class( ufield2d ), intent(inout) :: rspace class( ufield2d ), intent(inout) :: krspace integer, intent(in) :: isign Calls proc~~iwpfs3t2r~~CallsGraph proc~iwpfs3t2r iwpfs3t2r interface~wppfsst2rm23 WPPFSST2RM23 proc~iwpfs3t2r->interface~wppfsst2rm23 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/iwpfs3t2r.html"},{"title":"ipdivfd2 – QuickPIC","text":"private subroutine ipdivfd2(this, krspace, kdspace) Arguments Type Intent Optional Attributes Name class( fft2d ), intent(in) :: this class( ufield2d ), intent(inout) :: krspace class( ufield2d ), intent(inout) :: kdspace Contents None","tags":"","loc":"proc/ipdivfd2.html"},{"title":"ipgradfd2 – QuickPIC","text":"private subroutine ipgradfd2(this, krspace, kdspace) Arguments Type Intent Optional Attributes Name class( fft2d ), intent(in) :: this class( ufield2d ), intent(inout) :: krspace class( ufield2d ), intent(inout) :: kdspace Contents None","tags":"","loc":"proc/ipgradfd2.html"},{"title":"ipcurlfd2 – QuickPIC","text":"private subroutine ipcurlfd2(this, krspace, kdspace) Arguments Type Intent Optional Attributes Name class( fft2d ), intent(in) :: this class( ufield2d ), intent(inout) :: krspace class( ufield2d ), intent(inout) :: kdspace Calls proc~~ipcurlfd2~~CallsGraph proc~ipcurlfd2 ipcurlfd2 interface~mppcurlfd2 MPPCURLFD2 proc~ipcurlfd2->interface~mppcurlfd2 interface~pcurlfd22 PCURLFD22 proc~ipcurlfd2->interface~pcurlfd22 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ipcurlfd2.html"},{"title":"PRVDIST32_RANDOM – QuickPIC","text":"interface Called by interface~~prvdist32_random~~CalledByGraph interface~prvdist32_random PRVDIST32_RANDOM proc~dist3d_000 dist3d_000 proc~dist3d_000->interface~prvdist32_random Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine PRVDIST32_RANDOM(part, qm, edges, npp, nps, vtx, vty, vtz, vdx, vdy, vdz, npx, npy, npz, nx, ny, nz, ipbc, idimp, npmax, mblok, nblok, idps, sigx, sigy, sigz, x0, y0, z0, cx, cy, lquiet, ierr) Arguments Type Intent Optional Attributes Name real, intent(inout) :: part real, intent(in) :: qm real, intent(in) :: edges integer, intent(inout) :: npp integer, intent(inout) :: nps real, intent(in) :: vtx real, intent(in) :: vty real, intent(in) :: vtz real, intent(in) :: vdx real, intent(in) :: vdy real, intent(in) :: vdz integer, intent(in) :: npx integer, intent(in) :: npy integer, intent(in) :: npz integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz integer, intent(in) :: ipbc integer, intent(in) :: idimp integer, intent(in) :: npmax integer, intent(in) :: mblok integer, intent(in) :: nblok integer, intent(in) :: idps real, intent(in) :: sigx real, intent(in) :: sigy real, intent(in) :: sigz real, intent(in) :: x0 real, intent(in) :: y0 real, intent(in) :: z0 real, intent(in) :: cx real, intent(in) :: cy logical, intent(in) :: lquiet integer, intent(inout) :: ierr","tags":"","loc":"interface/prvdist32_random.html"},{"title":"PGPOST32L – QuickPIC","text":"interface public subroutine PGPOST32L(part, q, npp, noff, idimp, npmax, mnblok, nxv, nypmx, nzpmx, idds) Arguments Type Intent Optional Attributes Name real, intent(inout) :: part real, intent(inout) :: q integer, intent(in) :: npp integer, intent(in) :: noff integer, intent(in) :: idimp integer, intent(in) :: npmax integer, intent(in) :: mnblok integer, intent(in) :: nxv integer, intent(in) :: nypmx integer, intent(in) :: nzpmx integer, intent(in) :: idds","tags":"","loc":"interface/pgpost32l.html"},{"title":"PGBPUSH32L_QP – QuickPIC","text":"interface Called by interface~~pgbpush32l_qp~~CalledByGraph interface~pgbpush32l_qp PGBPUSH32L_QP proc~partpush partpush proc~partpush->interface~pgbpush32l_qp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine PGBPUSH32L_QP(part, fxyz, bxyz, npp, noff, qbm, dt, dtc, ek, nx, ny, nz, idimp, npmax, mnblok, nxv, nypmx, nzpmx, idds, ipbc, deltax, deltaz, cofd) Arguments Type Intent Optional Attributes Name real, intent(inout) :: part real, intent(inout) :: fxyz real, intent(inout) :: bxyz integer, intent(inout) :: npp integer, intent(in) :: noff real, intent(in) :: qbm real, intent(in) :: dt real, intent(in) :: dtc real, intent(in) :: ek integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz integer, intent(in) :: idimp integer, intent(in) :: npmax integer, intent(in) :: mnblok integer, intent(in) :: nxv integer, intent(in) :: nypmx integer, intent(in) :: nzpmx integer, intent(in) :: idds integer, intent(in) :: ipbc real, intent(in) :: deltax real, intent(in) :: deltaz real, intent(in) :: cofd","tags":"","loc":"interface/pgbpush32l_qp.html"},{"title":"PMOVE32 – QuickPIC","text":"interface Called by interface~~pmove32~~CalledByGraph interface~pmove32 PMOVE32 proc~pmove pmove proc~pmove->interface~pmove32 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine PMOVE32(part, edges, npp, sbufr, sbufl, rbufr, rbufl, ihole, pbuff, jsr, jsl, jss, ny, nz, kstrt, nvpy, nvpz, idimp, npmax, mblok, nblok, idps, nbmax, idds, ntmax, tag1, tag2, id, info) Arguments Type Intent Optional Attributes Name real, intent(inout) :: part real, intent(in) :: edges integer, intent(inout) :: npp real, intent(in) :: sbufr real, intent(in) :: sbufl real, intent(in) :: rbufr real, intent(in) :: rbufl integer, intent(in) :: ihole real, intent(inout) :: pbuff integer, intent(in) :: jsr integer, intent(in) :: jsl integer, intent(in) :: jss integer, intent(in) :: ny integer, intent(in) :: nz integer, intent(in) :: kstrt integer, intent(in) :: nvpy integer, intent(in) :: nvpz integer, intent(in) :: idimp integer, intent(in) :: npmax integer, intent(in) :: mblok integer, intent(in) :: nblok integer, intent(in) :: idps integer, intent(in) :: nbmax integer, intent(in) :: idds integer, intent(in) :: ntmax integer, intent(in) :: tag1 integer, intent(in) :: tag2 integer, intent(inout) :: id integer, intent(inout) :: info","tags":"","loc":"interface/pmove32.html"},{"title":"PPPMOVE2 – QuickPIC","text":"public subroutine PPPMOVE2(sbufr, sbufl, rbufr, rbufl, ncll, nclr, mcll, mclr, kstrt, nvp, idimp, nbmax, mx1) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(idimp,nbmax) :: sbufr real, intent(in), dimension(idimp,nbmax) :: sbufl real, intent(inout), dimension(idimp,nbmax) :: rbufr real, intent(inout), dimension(idimp,nbmax) :: rbufl integer, intent(in), dimension(3,mx1) :: ncll integer, intent(in), dimension(3,mx1) :: nclr integer, intent(inout), dimension(3,mx1) :: mcll integer, intent(inout), dimension(3,mx1) :: mclr integer, intent(in) :: kstrt integer, intent(in) :: nvp integer, intent(in) :: idimp integer, intent(in) :: nbmax integer, intent(in) :: mx1 Called by proc~~pppmove2~~CalledByGraph proc~pppmove2 PPPMOVE2 proc~pmove~2 pmove proc~pmove~2->proc~pppmove2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/pppmove2.html"},{"title":"PPDBLKP2L – QuickPIC","text":"interface Called by interface~~ppdblkp2l~~CalledByGraph interface~ppdblkp2l PPDBLKP2L proc~init_part2d init_part2d proc~init_part2d->interface~ppdblkp2l proc~renew_part2d renew_part2d proc~renew_part2d->interface~ppdblkp2l Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine PPDBLKP2L(part, kpic, npp, noff, nppmx, idimp, npmax, mx, my, mx1, mxyp1, irc) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(idimp,npmax) :: part integer, intent(inout), dimension(mxyp1) :: kpic integer, intent(in) :: npp integer, intent(in) :: noff integer, intent(inout) :: nppmx integer, intent(in) :: idimp integer, intent(in) :: npmax integer, intent(in) :: mx integer, intent(in) :: my integer, intent(in) :: mx1 integer, intent(in) :: mxyp1 integer, intent(inout) :: irc","tags":"","loc":"interface/ppdblkp2l.html"},{"title":"PPPMOVIN2L – QuickPIC","text":"interface Called by interface~~pppmovin2l~~CalledByGraph interface~pppmovin2l PPPMOVIN2L proc~init_part2d init_part2d proc~init_part2d->interface~pppmovin2l proc~renew_part2d renew_part2d proc~renew_part2d->interface~pppmovin2l proc~partcopy partcopy proc~partcopy->interface~pppmovin2l Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine PPPMOVIN2L(part, ppart, kpic, npp, noff, nppmx, idimp, npmax, mx, my, mx1, mxyp1, irc) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(idimp,npmax) :: part real, intent(inout), dimension(idimp,nppmx,mxyp1) :: ppart integer, intent(inout), dimension(mxyp1) :: kpic integer, intent(in) :: npp integer, intent(in) :: noff integer, intent(in) :: nppmx integer, intent(in) :: idimp integer, intent(in) :: npmax integer, intent(in) :: mx integer, intent(in) :: my integer, intent(in) :: mx1 integer, intent(in) :: mxyp1 integer, intent(inout) :: irc","tags":"","loc":"interface/pppmovin2l.html"},{"title":"PPPCHECK2L – QuickPIC","text":"interface public subroutine PPPCHECK2L(ppart, kpic, noff, nyp, idimp, nppmx, nx, mx, my, mx1, myp1, irc) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(idimp,nppmx,mx1*myp1) :: ppart integer, intent(in), dimension(mx1*myp1) :: kpic integer, intent(in) :: noff integer, intent(in) :: nyp integer, intent(in) :: idimp integer, intent(in) :: nppmx integer, intent(in) :: nx integer, intent(in) :: mx integer, intent(in) :: my integer, intent(in) :: mx1 integer, intent(in) :: myp1 integer, intent(inout) :: irc","tags":"","loc":"interface/pppcheck2l.html"},{"title":"PPGPPOST2L – QuickPIC","text":"interface public subroutine PPGPPOST2L(ppart, q, kpic, noff, idimp, nppmx, mx, my, nxv, nypmx, mx1, mxyp1) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(idimp,nppmx,mxyp1) :: ppart real, intent(inout), dimension(nxv,nypmx) :: q integer, intent(in), dimension(mxyp1) :: kpic integer, intent(in) :: noff integer, intent(in) :: idimp integer, intent(in) :: nppmx integer, intent(in) :: mx integer, intent(in) :: my integer, intent(in) :: nxv integer, intent(in) :: nypmx integer, intent(in) :: mx1 integer, intent(in) :: mxyp1","tags":"","loc":"interface/ppgppost2l.html"},{"title":"PPGRDCJPPOST2L_QP – QuickPIC","text":"interface public subroutine PPGRDCJPPOST2L_QP(ppart, fxy, bxy, psit, cu, dcu, amu, kpic, noff, nyp, qbm, dt, ci, idimp, nppmx, nx, mx, my, nxv, nypmx, mx1, mxyp1, dex) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(idimp,nppmx,mxyp1) :: ppart real, intent(in), dimension(2,nxv,nypmx) :: fxy real, intent(in), dimension(3,nxv,nypmx) :: bxy real, intent(in), dimension(nxv,nypmx) :: psit real, intent(inout), dimension(3,nxv,nypmx) :: cu real, intent(inout), dimension(2,nxv,nypmx) :: dcu real, intent(inout), dimension(3,nxv,nypmx) :: amu integer, intent(in), dimension(mxyp1) :: kpic integer, intent(in) :: noff integer, intent(in) :: nyp real, intent(in) :: qbm real, intent(in) :: dt real, intent(in) :: ci integer, intent(in) :: idimp integer, intent(in) :: nppmx integer, intent(in) :: nx integer, intent(in) :: mx integer, intent(in) :: my integer, intent(in) :: nxv integer, intent(in) :: nypmx integer, intent(in) :: mx1 integer, intent(in) :: mxyp1 real, intent(in) :: dex","tags":"","loc":"interface/ppgrdcjppost2l_qp.html"},{"title":"PPGRBPPUSHF23L_QP – QuickPIC","text":"interface public subroutine PPGRBPPUSHF23L_QP(ppart, fxy, bxy, psit, kpic, ncl, ihole, noff, nyp, qbm, dt, dtc, ci, ek, idimp, nppmx, nx, ny, mx, my, nxv, nypmx, mx1, mxyp1, ntmax, irc, dex) Arguments Type Intent Optional Attributes Name real :: ppart real :: fxy real :: bxy real :: psit integer :: kpic integer :: ncl integer :: ihole integer :: noff integer :: nyp real :: qbm real :: dt real :: dtc real :: ci real :: ek integer :: idimp integer :: nppmx integer :: nx integer :: ny integer :: mx integer :: my integer :: nxv integer :: nypmx integer :: mx1 integer :: mxyp1 integer :: ntmax integer :: irc real :: dex","tags":"","loc":"interface/ppgrbppushf23l_qp.html"},{"title":"PPPORDER2LA – QuickPIC","text":"interface Called by interface~~ppporder2la~~CalledByGraph interface~ppporder2la PPPORDER2LA proc~pmove~2 pmove proc~pmove~2->interface~ppporder2la Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine PPPORDER2LA(ppart, ppbuff, sbufl, sbufr, kpic, ncl, ihole, ncll, nclr, noff, nyp, idimp, nppmx, nx, ny, mx, my, mx1, myp1, npbmx, ntmax, nbmax, irc) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(idimp,nppmx,mx1*myp1) :: ppart real, intent(inout), dimension(idimp,npbmx,mx1*myp1) :: ppbuff real, intent(inout), dimension(idimp,nbmax) :: sbufl real, intent(inout), dimension(idimp,nbmax) :: sbufr integer, intent(in), dimension(mx1*myp1) :: kpic integer, intent(inout), dimension(8,mx1*myp1) :: ncl integer, intent(inout), dimension(2,ntmax+1,mx1*myp1) :: ihole integer, intent(inout), dimension(3,mx1) :: ncll integer, intent(inout), dimension(3,mx1) :: nclr integer, intent(in) :: noff integer, intent(in) :: nyp integer, intent(in) :: idimp integer, intent(in) :: nppmx integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: mx integer, intent(in) :: my integer, intent(in) :: mx1 integer, intent(in) :: myp1 integer, intent(in) :: npbmx integer, intent(in) :: ntmax integer, intent(in) :: nbmax integer, intent(inout) :: irc","tags":"","loc":"interface/ppporder2la.html"},{"title":"PPPORDERF2LA – QuickPIC","text":"interface Called by interface~~ppporderf2la~~CalledByGraph interface~ppporderf2la PPPORDERF2LA proc~pmove~2 pmove proc~pmove~2->interface~ppporderf2la Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine PPPORDERF2LA(ppart, ppbuff, sbufl, sbufr, ncl, ihole, ncll, nclr, idimp, nppmx, mx1, myp1, npbmx, ntmax, nbmax, irc) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(idimp,nppmx,mx1*myp1) :: ppart real, intent(inout), dimension(idimp,npbmx,mx1*myp1) :: ppbuff real, intent(inout), dimension(idimp,nbmax) :: sbufl real, intent(inout), dimension(idimp,nbmax) :: sbufr integer, intent(inout), dimension(8,mx1*myp1) :: ncl integer, intent(in), dimension(2,ntmax+1,mx1*myp1) :: ihole integer, intent(inout), dimension(3,mx1) :: ncll integer, intent(inout), dimension(3,mx1) :: nclr integer, intent(in) :: idimp integer, intent(in) :: nppmx integer, intent(in) :: mx1 integer, intent(in) :: myp1 integer, intent(in) :: npbmx integer, intent(in) :: ntmax integer, intent(in) :: nbmax integer, intent(inout) :: irc","tags":"","loc":"interface/ppporderf2la.html"},{"title":"PPPORDER2LB – QuickPIC","text":"interface Called by interface~~ppporder2lb~~CalledByGraph interface~ppporder2lb PPPORDER2LB proc~pmove~2 pmove proc~pmove~2->interface~ppporder2lb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine PPPORDER2LB(ppart, ppbuff, rbufl, rbufr, kpic, ncl, ihole, mcll, mclr, idimp, nppmx, mx1, myp1, npbmx, ntmax, nbmax, irc) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(idimp,nppmx,mx1*myp1) :: ppart real, intent(in), dimension(idimp,npbmx,mx1*myp1) :: ppbuff real, intent(in), dimension(idimp,nbmax) :: rbufl real, intent(in), dimension(idimp,nbmax) :: rbufr integer, intent(inout), dimension(mx1*myp1) :: kpic integer, intent(in), dimension(8,mx1*myp1) :: ncl integer, intent(in), dimension(2,ntmax+1,mx1*myp1) :: ihole integer, intent(in), dimension(3,mx1) :: mcll integer, intent(in), dimension(3,mx1) :: mclr integer, intent(in) :: idimp integer, intent(in) :: nppmx integer, intent(in) :: mx1 integer, intent(in) :: myp1 integer, intent(in) :: npbmx integer, intent(in) :: ntmax integer, intent(in) :: nbmax integer, intent(inout) :: irc","tags":"","loc":"interface/ppporder2lb.html"},{"title":"WPGPSIPOST2L_QP – QuickPIC","text":"interface public subroutine WPGPSIPOST2L_QP(ppart, psi, kpic, qbm, noff, nyp, idimp, nppmx, nx, mx, my, nxv, nypmx, mx1, mxyp1, dex) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(idimp,nppmx,mxyp1) :: ppart real, intent(in), dimension(nxv,nypmx) :: psi integer, intent(in), dimension(mxyp1) :: kpic real, intent(in) :: qbm integer, intent(in) :: noff integer, intent(in) :: nyp integer, intent(in) :: idimp integer, intent(in) :: nppmx integer, intent(in) :: nx integer, intent(in) :: mx integer, intent(in) :: my integer, intent(in) :: nxv integer, intent(in) :: nypmx integer, intent(in) :: mx1 integer, intent(in) :: mxyp1 real, intent(in) :: dex","tags":"","loc":"interface/wpgpsipost2l_qp.html"},{"title":"PPPCOPYOUT2 – QuickPIC","text":"interface Called by interface~~pppcopyout2~~CalledByGraph interface~pppcopyout2 PPPCOPYOUT2 proc~partcopyback partcopyback proc~partcopyback->interface~pppcopyout2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine PPPCOPYOUT2(part, ppart, kpic, npp, npmax, nppmx, idimp, mxyp1, irc) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(idimp,npmax) :: part real, intent(in), dimension(idimp,nppmx,mxyp1) :: ppart integer, intent(in), dimension(mxyp1) :: kpic integer, intent(inout) :: npp integer, intent(in) :: npmax integer, intent(in) :: nppmx integer, intent(in) :: idimp integer, intent(in) :: mxyp1 integer, intent(inout) :: irc","tags":"","loc":"interface/pppcopyout2.html"},{"title":"getnpp – QuickPIC","text":"private function getnpp(this) Arguments Type Intent Optional Attributes Name class( part3d ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getnpp.html"},{"title":"init_part3d – QuickPIC","text":"private subroutine init_part3d(this, pp, perr, psp, pf, fd, qbm, dt, ci, xdim) Arguments Type Intent Optional Attributes Name class( part3d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( spect3d ), intent(in), pointer :: psp class( fdist3d ), intent(inout) :: pf class( ufield3d ), intent(in), pointer :: fd real, intent(in) :: qbm real, intent(in) :: dt real, intent(in) :: ci integer, intent(in) :: xdim Contents None","tags":"","loc":"proc/init_part3d.html"},{"title":"end_part3d – QuickPIC","text":"private subroutine end_part3d(this) Arguments Type Intent Optional Attributes Name class( part3d ), intent(inout) :: this Contents None","tags":"","loc":"proc/end_part3d.html"},{"title":"qdeposit – QuickPIC","text":"private subroutine qdeposit(this, q) Arguments Type Intent Optional Attributes Name class( part3d ), intent(in) :: this class( ufield3d ), intent(in), pointer :: q Contents None","tags":"","loc":"proc/qdeposit.html"},{"title":"partpush – QuickPIC","text":"private subroutine partpush(this, ef, bf, dex, dez) Arguments Type Intent Optional Attributes Name class( part3d ), intent(inout) :: this class( ufield3d ), intent(in), pointer :: ef class( ufield3d ), intent(in), pointer :: bf real, intent(in) :: dex real, intent(in) :: dez Calls proc~~partpush~~CallsGraph proc~partpush partpush interface~pgbpush32l_qp PGBPUSH32L_QP proc~partpush->interface~pgbpush32l_qp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/partpush.html"},{"title":"pmove – QuickPIC","text":"private subroutine pmove(this, fd, rtag, stag, sid) Arguments Type Intent Optional Attributes Name class( part3d ), intent(inout) :: this class( ufield3d ), intent(in), pointer :: fd integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: sid Calls proc~~pmove~~CallsGraph proc~pmove pmove interface~pmove32 PMOVE32 proc~pmove->interface~pmove32 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/pmove.html"},{"title":"writehdf5_part3d – QuickPIC","text":"private subroutine writehdf5_part3d(this, file, dspl, delta, rtag, stag, id) Arguments Type Intent Optional Attributes Name class( part3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file integer, intent(in) :: dspl real, intent(in), dimension(3) :: delta integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id Calls proc~~writehdf5_part3d~~CallsGraph proc~writehdf5_part3d writehdf5_part3d interface~pwpart_pipe pwpart_pipe proc~writehdf5_part3d->interface~pwpart_pipe proc~pwpart_3d_pipe pwpart_3d_pipe interface~pwpart_pipe->proc~pwpart_3d_pipe h5gopen_f h5gopen_f proc~pwpart_3d_pipe->h5gopen_f proc~wrattr_file wrattr_file proc~pwpart_3d_pipe->proc~wrattr_file h5aclose_f h5aclose_f proc~pwpart_3d_pipe->h5aclose_f h5sclose_f h5sclose_f proc~pwpart_3d_pipe->h5sclose_f h5pset_chunk_f h5pset_chunk_f proc~pwpart_3d_pipe->h5pset_chunk_f mpi_comm_rank mpi_comm_rank proc~pwpart_3d_pipe->mpi_comm_rank mpi_isend mpi_isend proc~pwpart_3d_pipe->mpi_isend h5pset_dxpl_mpio_f h5pset_dxpl_mpio_f proc~pwpart_3d_pipe->h5pset_dxpl_mpio_f h5screate_simple_f h5screate_simple_f proc~pwpart_3d_pipe->h5screate_simple_f h5gclose_f h5gclose_f proc~pwpart_3d_pipe->h5gclose_f h5open_f h5open_f proc~pwpart_3d_pipe->h5open_f h5pcreate_f h5pcreate_f proc~pwpart_3d_pipe->h5pcreate_f mpi_allreduce mpi_allreduce proc~pwpart_3d_pipe->mpi_allreduce h5acreate_f h5acreate_f proc~pwpart_3d_pipe->h5acreate_f proc~wrattr_dataset wrattr_dataset proc~pwpart_3d_pipe->proc~wrattr_dataset h5dcreate_f h5dcreate_f proc~pwpart_3d_pipe->h5dcreate_f mpi_comm_free mpi_comm_free proc~pwpart_3d_pipe->mpi_comm_free mpi_allgather mpi_allgather proc~pwpart_3d_pipe->mpi_allgather mpi_irecv mpi_irecv proc~pwpart_3d_pipe->mpi_irecv h5aopen_f h5aopen_f proc~pwpart_3d_pipe->h5aopen_f h5fclose_f h5fclose_f proc~pwpart_3d_pipe->h5fclose_f mpi_comm_split mpi_comm_split proc~pwpart_3d_pipe->mpi_comm_split h5sselect_hyperslab_f h5sselect_hyperslab_f proc~pwpart_3d_pipe->h5sselect_hyperslab_f h5dclose_f h5dclose_f proc~pwpart_3d_pipe->h5dclose_f h5aread_f h5aread_f proc~pwpart_3d_pipe->h5aread_f h5close_f h5close_f proc~pwpart_3d_pipe->h5close_f h5pclose_f h5pclose_f proc~pwpart_3d_pipe->h5pclose_f h5dextend_f h5dextend_f proc~pwpart_3d_pipe->h5dextend_f h5pset_fapl_mpio_f h5pset_fapl_mpio_f proc~pwpart_3d_pipe->h5pset_fapl_mpio_f h5dopen_f h5dopen_f proc~pwpart_3d_pipe->h5dopen_f h5fopen_f h5fopen_f proc~pwpart_3d_pipe->h5fopen_f h5dwrite_f h5dwrite_f proc~pwpart_3d_pipe->h5dwrite_f h5awrite_f h5awrite_f proc~pwpart_3d_pipe->h5awrite_f proc~detect_precision detect_precision proc~pwpart_3d_pipe->proc~detect_precision mpi_comm_size mpi_comm_size proc~pwpart_3d_pipe->mpi_comm_size mpi_wait mpi_wait proc~pwpart_3d_pipe->mpi_wait h5fcreate_f h5fcreate_f proc~pwpart_3d_pipe->h5fcreate_f proc~wrattr_file->h5gopen_f proc~wrattr_file->h5sclose_f proc~wrattr_file->h5screate_simple_f proc~wrattr_file->h5gclose_f proc~wrattr_file->h5dclose_f proc~wrattr_file->h5dwrite_f proc~wrattr_file->proc~detect_precision h5gcreate_f h5gcreate_f proc~wrattr_file->h5gcreate_f interface~add_h5_atribute add_h5_atribute proc~wrattr_file->interface~add_h5_atribute proc~wrattr_dataset->interface~add_h5_atribute proc~add_h5_atribute_str add_h5_atribute_str interface~add_h5_atribute->proc~add_h5_atribute_str proc~add_h5_atribute_int add_h5_atribute_int interface~add_h5_atribute->proc~add_h5_atribute_int proc~add_h5_atribute_v1_int add_h5_atribute_v1_int interface~add_h5_atribute->proc~add_h5_atribute_v1_int proc~add_h5_atribute_v1_single add_h5_atribute_v1_single interface~add_h5_atribute->proc~add_h5_atribute_v1_single proc~add_h5_atribute_single add_h5_atribute_single interface~add_h5_atribute->proc~add_h5_atribute_single proc~add_h5_atribute_str_v1 add_h5_atribute_str_v1 interface~add_h5_atribute->proc~add_h5_atribute_str_v1 proc~add_h5_atribute_str->h5aclose_f proc~add_h5_atribute_str->h5sclose_f proc~add_h5_atribute_str->h5screate_simple_f proc~add_h5_atribute_str->h5acreate_f proc~add_h5_atribute_str->h5awrite_f h5tset_size_f h5tset_size_f proc~add_h5_atribute_str->h5tset_size_f h5tcopy_f h5tcopy_f proc~add_h5_atribute_str->h5tcopy_f h5tclose_f h5tclose_f proc~add_h5_atribute_str->h5tclose_f proc~add_h5_atribute_int->h5aclose_f proc~add_h5_atribute_int->h5sclose_f proc~add_h5_atribute_int->h5screate_simple_f proc~add_h5_atribute_int->h5acreate_f proc~add_h5_atribute_int->h5awrite_f proc~add_h5_atribute_v1_int->h5aclose_f proc~add_h5_atribute_v1_int->h5sclose_f proc~add_h5_atribute_v1_int->h5screate_simple_f proc~add_h5_atribute_v1_int->h5acreate_f proc~add_h5_atribute_v1_int->h5awrite_f proc~add_h5_atribute_v1_single->h5aclose_f proc~add_h5_atribute_v1_single->h5sclose_f proc~add_h5_atribute_v1_single->h5screate_simple_f proc~add_h5_atribute_v1_single->h5acreate_f proc~add_h5_atribute_v1_single->h5awrite_f proc~add_h5_atribute_v1_single->proc~detect_precision proc~add_h5_atribute_single->h5aclose_f proc~add_h5_atribute_single->h5sclose_f proc~add_h5_atribute_single->h5screate_simple_f proc~add_h5_atribute_single->h5acreate_f proc~add_h5_atribute_single->h5awrite_f proc~add_h5_atribute_single->proc~detect_precision proc~add_h5_atribute_str_v1->h5aclose_f proc~add_h5_atribute_str_v1->h5sclose_f proc~add_h5_atribute_str_v1->h5screate_simple_f proc~add_h5_atribute_str_v1->h5acreate_f proc~add_h5_atribute_str_v1->h5awrite_f proc~add_h5_atribute_str_v1->h5tset_size_f proc~add_h5_atribute_str_v1->h5tcopy_f proc~add_h5_atribute_str_v1->h5tclose_f var panprocwritehdf5_part3dCallsGraph = svgPanZoom('#procwritehdf5_part3dCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/writehdf5_part3d.html"},{"title":"writerst_part3d – QuickPIC","text":"private subroutine writerst_part3d(this, file) Arguments Type Intent Optional Attributes Name class( part3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file Calls proc~~writerst_part3d~~CallsGraph proc~writerst_part3d writerst_part3d proc~wpart wpart proc~writerst_part3d->proc~wpart h5screate_simple_f h5screate_simple_f proc~wpart->h5screate_simple_f h5gclose_f h5gclose_f proc~wpart->h5gclose_f h5gopen_f h5gopen_f proc~wpart->h5gopen_f h5fclose_f h5fclose_f proc~wpart->h5fclose_f proc~wrattr_file wrattr_file proc~wpart->proc~wrattr_file h5sclose_f h5sclose_f proc~wpart->h5sclose_f h5open_f h5open_f proc~wpart->h5open_f h5acreate_f h5acreate_f proc~wpart->h5acreate_f h5awrite_f h5awrite_f proc~wpart->h5awrite_f proc~wrattr_dataset wrattr_dataset proc~wpart->proc~wrattr_dataset h5dclose_f h5dclose_f proc~wpart->h5dclose_f proc~detect_precision detect_precision proc~wpart->proc~detect_precision h5fcreate_f h5fcreate_f proc~wpart->h5fcreate_f h5dcreate_f h5dcreate_f proc~wpart->h5dcreate_f h5close_f h5close_f proc~wpart->h5close_f h5aclose_f h5aclose_f proc~wpart->h5aclose_f proc~wrattr_file->h5screate_simple_f proc~wrattr_file->h5gclose_f proc~wrattr_file->h5gopen_f proc~wrattr_file->h5sclose_f proc~wrattr_file->h5dclose_f proc~wrattr_file->proc~detect_precision h5dwrite_f h5dwrite_f proc~wrattr_file->h5dwrite_f h5gcreate_f h5gcreate_f proc~wrattr_file->h5gcreate_f interface~add_h5_atribute add_h5_atribute proc~wrattr_file->interface~add_h5_atribute proc~wrattr_dataset->interface~add_h5_atribute proc~add_h5_atribute_str add_h5_atribute_str interface~add_h5_atribute->proc~add_h5_atribute_str proc~add_h5_atribute_int add_h5_atribute_int interface~add_h5_atribute->proc~add_h5_atribute_int proc~add_h5_atribute_v1_int add_h5_atribute_v1_int interface~add_h5_atribute->proc~add_h5_atribute_v1_int proc~add_h5_atribute_v1_single add_h5_atribute_v1_single interface~add_h5_atribute->proc~add_h5_atribute_v1_single proc~add_h5_atribute_single add_h5_atribute_single interface~add_h5_atribute->proc~add_h5_atribute_single proc~add_h5_atribute_str_v1 add_h5_atribute_str_v1 interface~add_h5_atribute->proc~add_h5_atribute_str_v1 proc~add_h5_atribute_str->h5screate_simple_f proc~add_h5_atribute_str->h5sclose_f proc~add_h5_atribute_str->h5acreate_f proc~add_h5_atribute_str->h5awrite_f proc~add_h5_atribute_str->h5aclose_f h5tset_size_f h5tset_size_f proc~add_h5_atribute_str->h5tset_size_f h5tcopy_f h5tcopy_f proc~add_h5_atribute_str->h5tcopy_f h5tclose_f h5tclose_f proc~add_h5_atribute_str->h5tclose_f proc~add_h5_atribute_int->h5screate_simple_f proc~add_h5_atribute_int->h5sclose_f proc~add_h5_atribute_int->h5acreate_f proc~add_h5_atribute_int->h5awrite_f proc~add_h5_atribute_int->h5aclose_f proc~add_h5_atribute_v1_int->h5screate_simple_f proc~add_h5_atribute_v1_int->h5sclose_f proc~add_h5_atribute_v1_int->h5acreate_f proc~add_h5_atribute_v1_int->h5awrite_f proc~add_h5_atribute_v1_int->h5aclose_f proc~add_h5_atribute_v1_single->h5screate_simple_f proc~add_h5_atribute_v1_single->h5sclose_f proc~add_h5_atribute_v1_single->h5acreate_f proc~add_h5_atribute_v1_single->h5awrite_f proc~add_h5_atribute_v1_single->proc~detect_precision proc~add_h5_atribute_v1_single->h5aclose_f proc~add_h5_atribute_single->h5screate_simple_f proc~add_h5_atribute_single->h5sclose_f proc~add_h5_atribute_single->h5acreate_f proc~add_h5_atribute_single->h5awrite_f proc~add_h5_atribute_single->proc~detect_precision proc~add_h5_atribute_single->h5aclose_f proc~add_h5_atribute_str_v1->h5screate_simple_f proc~add_h5_atribute_str_v1->h5sclose_f proc~add_h5_atribute_str_v1->h5acreate_f proc~add_h5_atribute_str_v1->h5awrite_f proc~add_h5_atribute_str_v1->h5aclose_f proc~add_h5_atribute_str_v1->h5tset_size_f proc~add_h5_atribute_str_v1->h5tcopy_f proc~add_h5_atribute_str_v1->h5tclose_f var panprocwriterst_part3dCallsGraph = svgPanZoom('#procwriterst_part3dCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/writerst_part3d.html"},{"title":"readrst_part3d – QuickPIC","text":"private subroutine readrst_part3d(this, file) Arguments Type Intent Optional Attributes Name class( part3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file Calls proc~~readrst_part3d~~CallsGraph proc~readrst_part3d readrst_part3d proc~rpart rpart proc~readrst_part3d->proc~rpart h5screate_simple_f h5screate_simple_f proc~rpart->h5screate_simple_f h5gclose_f h5gclose_f proc~rpart->h5gclose_f h5gopen_f h5gopen_f proc~rpart->h5gopen_f h5dopen_f h5dopen_f proc~rpart->h5dopen_f h5fclose_f h5fclose_f proc~rpart->h5fclose_f h5aopen_f h5aopen_f proc~rpart->h5aopen_f h5sclose_f h5sclose_f proc~rpart->h5sclose_f h5open_f h5open_f proc~rpart->h5open_f h5fopen_f h5fopen_f proc~rpart->h5fopen_f h5aread_f h5aread_f proc~rpart->h5aread_f h5dclose_f h5dclose_f proc~rpart->h5dclose_f h5dread_f h5dread_f proc~rpart->h5dread_f proc~detect_precision detect_precision proc~rpart->proc~detect_precision h5close_f h5close_f proc~rpart->h5close_f h5aclose_f h5aclose_f proc~rpart->h5aclose_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/readrst_part3d.html"},{"title":"ntag – QuickPIC","text":"private function ntag() Arguments None Return Value integer Called by proc~~ntag~~CalledByGraph proc~ntag ntag proc~go_simulation go_simulation proc~go_simulation->proc~ntag proc~diag_simulation diag_simulation proc~diag_simulation->proc~ntag Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ntag.html"},{"title":"init_simulation – QuickPIC","text":"private subroutine init_simulation(this) Arguments Type Intent Optional Attributes Name class( simulation ), intent(inout) :: this Contents None","tags":"","loc":"proc/init_simulation.html"},{"title":"end_simulation – QuickPIC","text":"private subroutine end_simulation(this) Arguments Type Intent Optional Attributes Name class( simulation ), intent(inout) :: this Calls proc~~end_simulation~~CallsGraph proc~end_simulation end_simulation mpi_finalize mpi_finalize proc~end_simulation->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/end_simulation.html"},{"title":"init_sim_fields – QuickPIC","text":"private subroutine init_sim_fields(this, input) Arguments Type Intent Optional Attributes Name class( sim_fields ), intent(inout) :: this type( input_json ), intent(inout), pointer :: input Contents None","tags":"","loc":"proc/init_sim_fields.html"},{"title":"end_sim_fields – QuickPIC","text":"private subroutine end_sim_fields(this) Arguments Type Intent Optional Attributes Name class( sim_fields ), intent(inout) :: this Contents None","tags":"","loc":"proc/end_sim_fields.html"},{"title":"init_sim_beams – QuickPIC","text":"private subroutine init_sim_beams(this, input, fields) Arguments Type Intent Optional Attributes Name class( sim_beams ), intent(inout) :: this type( input_json ), intent(inout), pointer :: input class( sim_fields ), intent(inout) :: fields Calls proc~~init_sim_beams~~CallsGraph proc~init_sim_beams init_sim_beams mpi_barrier mpi_barrier proc~init_sim_beams->mpi_barrier Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/init_sim_beams.html"},{"title":"end_sim_beams – QuickPIC","text":"private subroutine end_sim_beams(this) Arguments Type Intent Optional Attributes Name class( sim_beams ), intent(inout) :: this Contents None","tags":"","loc":"proc/end_sim_beams.html"},{"title":"init_sim_species – QuickPIC","text":"private subroutine init_sim_species(this, input, fields, s) Arguments Type Intent Optional Attributes Name class( sim_species ), intent(inout) :: this type( input_json ), intent(inout), pointer :: input class( sim_fields ), intent(inout) :: fields real, intent(in) :: s Contents None","tags":"","loc":"proc/init_sim_species.html"},{"title":"end_sim_species – QuickPIC","text":"private subroutine end_sim_species(this) Arguments Type Intent Optional Attributes Name class( sim_species ), intent(inout) :: this Contents None","tags":"","loc":"proc/end_sim_species.html"},{"title":"go_simulation – QuickPIC","text":"private subroutine go_simulation(this) Arguments Type Intent Optional Attributes Name class( simulation ), intent(inout) :: this Calls proc~~go_simulation~~CallsGraph proc~go_simulation go_simulation proc~ntag ntag proc~go_simulation->proc~ntag mpi_wait mpi_wait proc~go_simulation->mpi_wait Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/go_simulation.html"},{"title":"init_diag – QuickPIC","text":"private subroutine init_diag(this) Arguments Type Intent Optional Attributes Name class( simulation ), intent(inout), target :: this Calls proc~~init_diag~~CallsGraph proc~init_diag init_diag mpi_barrier mpi_barrier proc~init_diag->mpi_barrier Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/init_diag.html"},{"title":"diag_simulation – QuickPIC","text":"private subroutine diag_simulation(this) Arguments Type Intent Optional Attributes Name class( simulation ), intent(inout) :: this Calls proc~~diag_simulation~~CallsGraph proc~diag_simulation diag_simulation proc~ntag ntag proc~diag_simulation->proc~ntag mpi_wait mpi_wait proc~diag_simulation->mpi_wait Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/diag_simulation.html"},{"title":"getstate – QuickPIC","text":"private function getstate(this) Arguments Type Intent Optional Attributes Name class( field2d ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getstate.html"},{"title":"getgcells – QuickPIC","text":"private function getgcells(this) Arguments Type Intent Optional Attributes Name class( field2d ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getgcells.html"},{"title":"getrs – QuickPIC","text":"private function getrs(this) Arguments Type Intent Optional Attributes Name class( field2d ), intent(in) :: this Return Value class( ufield2d ),\n  pointer Contents None","tags":"","loc":"proc/getrs.html"},{"title":"getks – QuickPIC","text":"private function getks(this) Arguments Type Intent Optional Attributes Name class( field2d ), intent(in) :: this Return Value class( ufield2d ),\n  pointer Contents None","tags":"","loc":"proc/getks.html"},{"title":"init_field2d – QuickPIC","text":"private subroutine init_field2d(this, pp, perr, psp, dim, fftflag, state, gcells) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( spect2d ), intent(in), pointer :: psp integer, intent(in) :: dim logical, intent(in) :: fftflag integer, intent(in), optional :: state integer, intent(in), optional :: gcells Calls proc~~init_field2d~~CallsGraph proc~init_field2d init_field2d proc~get_pois2table get_pois2table proc~init_field2d->proc~get_pois2table proc~get_fft2table get_fft2table proc~init_field2d->proc~get_fft2table Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/init_field2d.html"},{"title":"end_field2d – QuickPIC","text":"private subroutine end_field2d(this) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this Contents None","tags":"","loc":"proc/end_field2d.html"},{"title":"fftrk_field2d – QuickPIC","text":"private subroutine fftrk_field2d(this, kind) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this integer, intent(in) :: kind Contents None","tags":"","loc":"proc/fftrk_field2d.html"},{"title":"fftkr_field2d – QuickPIC","text":"private subroutine fftkr_field2d(this, kind) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this integer, intent(in) :: kind Contents None","tags":"","loc":"proc/fftkr_field2d.html"},{"title":"divf_field2d – QuickPIC","text":"private subroutine divf_field2d(this, that) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(inout) :: that Contents None","tags":"","loc":"proc/divf_field2d.html"},{"title":"gradf_field2d – QuickPIC","text":"private subroutine gradf_field2d(this, that) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(inout) :: that Contents None","tags":"","loc":"proc/gradf_field2d.html"},{"title":"curlf_field2d – QuickPIC","text":"private subroutine curlf_field2d(this, that) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(inout) :: that Contents None","tags":"","loc":"proc/curlf_field2d.html"},{"title":"potential_field2d – QuickPIC","text":"private subroutine potential_field2d(this, that) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(inout) :: that Contents None","tags":"","loc":"proc/potential_field2d.html"},{"title":"smoothf_field2d – QuickPIC","text":"private subroutine smoothf_field2d(this, that) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(inout) :: that Contents None","tags":"","loc":"proc/smoothf_field2d.html"},{"title":"elfield_field2d – QuickPIC","text":"private subroutine elfield_field2d(this, that) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(inout) :: that Contents None","tags":"","loc":"proc/elfield_field2d.html"},{"title":"bfield_field2d – QuickPIC","text":"private subroutine bfield_field2d(this, that) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(inout) :: that Contents None","tags":"","loc":"proc/bfield_field2d.html"},{"title":"bfield_qp_field2d – QuickPIC","text":"private subroutine bfield_qp_field2d(cu, dcu, amu, bxy, c, dex) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: cu class( field2d ), intent(inout) :: dcu class( field2d ), intent(inout) :: amu class( field2d ), intent(inout) :: bxy real, intent(in) :: c real, intent(in) :: dex Contents None","tags":"","loc":"proc/bfield_qp_field2d.html"},{"title":"copyguard_field2d – QuickPIC","text":"private subroutine copyguard_field2d(this) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this Contents None","tags":"","loc":"proc/copyguard_field2d.html"},{"title":"acopyguard_field2d – QuickPIC","text":"private subroutine acopyguard_field2d(this) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this Contents None","tags":"","loc":"proc/acopyguard_field2d.html"},{"title":"pipesend_field2d – QuickPIC","text":"private subroutine pipesend_field2d(this, stag, id) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this integer, intent(in) :: stag integer, intent(inout) :: id Contents None","tags":"","loc":"proc/pipesend_field2d.html"},{"title":"piperecv_field2d – QuickPIC","text":"private subroutine piperecv_field2d(this, rtag) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this integer, intent(in) :: rtag Contents None","tags":"","loc":"proc/piperecv_field2d.html"},{"title":"asc – QuickPIC","text":"private subroutine asc(this, value) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this real, intent(in) :: value Contents None","tags":"","loc":"proc/asc.html"},{"title":"copyto – QuickPIC","text":"private subroutine copyto(this, that, lpos, sdim, ddim) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field3d ), intent(in) :: that integer, intent(in) :: lpos integer, intent(in), dimension(:) :: sdim integer, intent(in), dimension(:) :: ddim Contents None","tags":"","loc":"proc/copyto.html"},{"title":"copyfrom – QuickPIC","text":"private subroutine copyfrom(this, that, lpos, sdim, ddim) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field3d ), intent(in) :: that integer, intent(in) :: lpos integer, intent(in), dimension(:) :: sdim integer, intent(in), dimension(:) :: ddim Contents None","tags":"","loc":"proc/copyfrom.html"},{"title":"copyadd – QuickPIC","text":"private subroutine copyadd(this, that, lpos, sdim, ddim) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field3d ), intent(in) :: that integer, intent(in) :: lpos integer, intent(in), dimension(:) :: sdim integer, intent(in), dimension(:) :: ddim Contents None","tags":"","loc":"proc/copyadd.html"},{"title":"asa – QuickPIC","text":"private subroutine asa(this, that) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(inout) :: that Contents None","tags":"","loc":"proc/asa.html"},{"title":"sum1 – QuickPIC","text":"private subroutine sum1(this, a1, a2) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(in) :: a1 class( field2d ), intent(in) :: a2 Contents None","tags":"","loc":"proc/sum1.html"},{"title":"sum2 – QuickPIC","text":"private subroutine sum2(this, a1, a2, dim, dim1, dim2) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(in) :: a1 class( field2d ), intent(in) :: a2 integer, intent(in), dimension(:) :: dim integer, intent(in), dimension(:) :: dim1 integer, intent(in), dimension(:) :: dim2 Contents None","tags":"","loc":"proc/sum2.html"},{"title":"minus1 – QuickPIC","text":"private subroutine minus1(this, a1, a2) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(in) :: a1 class( field2d ), intent(in) :: a2 Contents None","tags":"","loc":"proc/minus1.html"},{"title":"minus2 – QuickPIC","text":"private subroutine minus2(this, a1, a2, dim, dim1, dim2) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(in) :: a1 class( field2d ), intent(in) :: a2 integer, intent(in), dimension(:) :: dim integer, intent(in), dimension(:) :: dim1 integer, intent(in), dimension(:) :: dim2 Contents None","tags":"","loc":"proc/minus2.html"},{"title":"multiply1 – QuickPIC","text":"private subroutine multiply1(this, a1, value) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(in) :: a1 real, intent(in) :: value Contents None","tags":"","loc":"proc/multiply1.html"},{"title":"multiply2 – QuickPIC","text":"private subroutine multiply2(this, a1, dim, dim1, value) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(in) :: a1 integer, intent(in), dimension(:) :: dim integer, intent(in), dimension(:) :: dim1 real, intent(in), dimension(:) :: value Contents None","tags":"","loc":"proc/multiply2.html"},{"title":"writehdf5_field2d – QuickPIC","text":"private subroutine writehdf5_field2d(this, file, dim) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( hdf5file ), intent(in) :: file integer, intent(in) :: dim Contents None","tags":"","loc":"proc/writehdf5_field2d.html"},{"title":"getnvpy – QuickPIC","text":"private function getnvpy(this) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getnvpy.html"},{"title":"getnvpx – QuickPIC","text":"private function getnvpx(this) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getnvpx.html"},{"title":"getnvpz – QuickPIC","text":"private function getnvpz(this) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getnvpz.html"},{"title":"getnd2 – QuickPIC","text":"private function getnd2(this) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getnd2.html"},{"title":"getnd1 – QuickPIC","text":"private function getnd1(this) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getnd1.html"},{"title":"getnd3 – QuickPIC","text":"private function getnd3(this) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getnd3.html"},{"title":"getnd3p – QuickPIC","text":"private function getnd3p(this) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getnd3p.html"},{"title":"getnd2p – QuickPIC","text":"private function getnd2p(this) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getnd2p.html"},{"title":"getnd1p – QuickPIC","text":"private function getnd1p(this) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getnd1p.html"},{"title":"getdim – QuickPIC","text":"private function getdim(this) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getdim.html"},{"title":"getnoff – QuickPIC","text":"private function getnoff(this) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(in) :: this Return Value integer,\n  dimension(2) Contents None","tags":"","loc":"proc/getnoff.html"},{"title":"getrf – QuickPIC","text":"private function getrf(this) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(in) :: this Return Value real,\n  dimension(:,:,:,:),pointer Contents None","tags":"","loc":"proc/getrf.html"},{"title":"init_ufield3d – QuickPIC","text":"private subroutine init_ufield3d(this, pp, perr, psp, dim, nvpx, nvpy, nvpz) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( spect3d ), intent(in), pointer :: psp integer, intent(in) :: dim integer, intent(in) :: nvpx integer, intent(in) :: nvpy integer, intent(in) :: nvpz Contents None","tags":"","loc":"proc/init_ufield3d.html"},{"title":"end_ufield3d – QuickPIC","text":"private subroutine end_ufield3d(this) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(inout) :: this Contents None","tags":"","loc":"proc/end_ufield3d.html"},{"title":"final_ufield3d – QuickPIC","text":"private subroutine final_ufield3d(this) Arguments Type Intent Optional Attributes Name type( ufield3d ), intent(inout) :: this Contents None","tags":"","loc":"proc/final_ufield3d.html"},{"title":"copyguard_pipe – QuickPIC","text":"private subroutine copyguard_pipe(this, rtag, stag, rid, sid) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(inout) :: this integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: rid integer, intent(inout) :: sid Calls proc~~copyguard_pipe~~CallsGraph proc~copyguard_pipe copyguard_pipe interface~pcguard32l PCGUARD32L proc~copyguard_pipe->interface~pcguard32l Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/copyguard_pipe.html"},{"title":"acopyguard – QuickPIC","text":"private subroutine acopyguard(this, rtag, stag, id) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(inout) :: this integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id Calls proc~~acopyguard~~CallsGraph proc~acopyguard acopyguard interface~pacguard32l PACGUARD32L proc~acopyguard->interface~pacguard32l interface~paguard32l PAGUARD32L proc~acopyguard->interface~paguard32l Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/acopyguard.html"},{"title":"copyin – QuickPIC","text":"private subroutine copyin(this, fd2d, lpos, sdim, ddim) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(inout) :: this class( ufield2d ), intent(in), target :: fd2d integer, intent(in) :: lpos integer, intent(in), dimension(:) :: sdim integer, intent(in), dimension(:) :: ddim Contents None","tags":"","loc":"proc/copyin.html"},{"title":"copyout – QuickPIC","text":"private subroutine copyout(this, fd2d, lpos, sdim, ddim) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(inout) :: this class( ufield2d ), intent(in), target :: fd2d integer, intent(in) :: lpos integer, intent(in), dimension(:) :: sdim integer, intent(in), dimension(:) :: ddim Contents None","tags":"","loc":"proc/copyout.html"},{"title":"copyadd – QuickPIC","text":"private subroutine copyadd(this, fd2d, lpos, sdim, ddim) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(inout) :: this class( ufield2d ), intent(in), target :: fd2d integer, intent(in) :: lpos integer, intent(in), dimension(:) :: sdim integer, intent(in), dimension(:) :: ddim Contents None","tags":"","loc":"proc/copyadd~2.html"},{"title":"writehdf5_3d – QuickPIC","text":"private subroutine writehdf5_3d(this, file, dim, rtag, stag, id) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file integer, intent(in) :: dim integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id Calls proc~~writehdf5_3d~~CallsGraph proc~writehdf5_3d writehdf5_3d interface~pwfield_pipe pwfield_pipe proc~writehdf5_3d->interface~pwfield_pipe proc~pwfield_3d_pipe pwfield_3d_pipe interface~pwfield_pipe->proc~pwfield_3d_pipe proc~pwfield_2d_pipe pwfield_2d_pipe interface~pwfield_pipe->proc~pwfield_2d_pipe h5gopen_f h5gopen_f proc~pwfield_3d_pipe->h5gopen_f proc~wrattr_file wrattr_file proc~pwfield_3d_pipe->proc~wrattr_file h5sclose_f h5sclose_f proc~pwfield_3d_pipe->h5sclose_f h5tcopy_f h5tcopy_f proc~pwfield_3d_pipe->h5tcopy_f h5aopen_by_name_f h5aopen_by_name_f proc~pwfield_3d_pipe->h5aopen_by_name_f mpi_isend mpi_isend proc~pwfield_3d_pipe->mpi_isend h5pset_dxpl_mpio_f h5pset_dxpl_mpio_f proc~pwfield_3d_pipe->h5pset_dxpl_mpio_f h5screate_simple_f h5screate_simple_f proc~pwfield_3d_pipe->h5screate_simple_f h5gclose_f h5gclose_f proc~pwfield_3d_pipe->h5gclose_f h5tset_size_f h5tset_size_f proc~pwfield_3d_pipe->h5tset_size_f h5open_f h5open_f proc~pwfield_3d_pipe->h5open_f h5pcreate_f h5pcreate_f proc~pwfield_3d_pipe->h5pcreate_f proc~wrattr_dataset wrattr_dataset proc~pwfield_3d_pipe->proc~wrattr_dataset h5dcreate_f h5dcreate_f proc~pwfield_3d_pipe->h5dcreate_f mpi_irecv mpi_irecv proc~pwfield_3d_pipe->mpi_irecv h5tclose_f h5tclose_f proc~pwfield_3d_pipe->h5tclose_f h5fclose_f h5fclose_f proc~pwfield_3d_pipe->h5fclose_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~pwfield_3d_pipe->h5sselect_hyperslab_f h5dclose_f h5dclose_f proc~pwfield_3d_pipe->h5dclose_f h5aread_f h5aread_f proc~pwfield_3d_pipe->h5aread_f h5close_f h5close_f proc~pwfield_3d_pipe->h5close_f h5pclose_f h5pclose_f proc~pwfield_3d_pipe->h5pclose_f h5pset_fapl_mpio_f h5pset_fapl_mpio_f proc~pwfield_3d_pipe->h5pset_fapl_mpio_f h5dopen_f h5dopen_f proc~pwfield_3d_pipe->h5dopen_f h5fopen_f h5fopen_f proc~pwfield_3d_pipe->h5fopen_f proc~detect_precision detect_precision proc~pwfield_3d_pipe->proc~detect_precision h5fcreate_f h5fcreate_f proc~pwfield_3d_pipe->h5fcreate_f mpi_wait mpi_wait proc~pwfield_3d_pipe->mpi_wait h5aclose_f h5aclose_f proc~pwfield_3d_pipe->h5aclose_f proc~pwfield_2d_pipe->h5gopen_f proc~pwfield_2d_pipe->proc~wrattr_file proc~pwfield_2d_pipe->h5sclose_f proc~pwfield_2d_pipe->h5tcopy_f proc~pwfield_2d_pipe->h5aopen_by_name_f proc~pwfield_2d_pipe->mpi_isend proc~pwfield_2d_pipe->h5pset_dxpl_mpio_f proc~pwfield_2d_pipe->h5screate_simple_f proc~pwfield_2d_pipe->h5gclose_f proc~pwfield_2d_pipe->h5tset_size_f proc~pwfield_2d_pipe->h5open_f proc~pwfield_2d_pipe->h5pcreate_f proc~pwfield_2d_pipe->proc~wrattr_dataset proc~pwfield_2d_pipe->h5dcreate_f proc~pwfield_2d_pipe->mpi_irecv proc~pwfield_2d_pipe->h5tclose_f proc~pwfield_2d_pipe->h5fclose_f proc~pwfield_2d_pipe->h5sselect_hyperslab_f proc~pwfield_2d_pipe->h5dclose_f proc~pwfield_2d_pipe->h5aread_f proc~pwfield_2d_pipe->h5close_f proc~pwfield_2d_pipe->h5pclose_f proc~pwfield_2d_pipe->h5pset_fapl_mpio_f proc~pwfield_2d_pipe->h5dopen_f proc~pwfield_2d_pipe->h5fopen_f proc~pwfield_2d_pipe->proc~detect_precision proc~pwfield_2d_pipe->h5fcreate_f proc~pwfield_2d_pipe->mpi_wait proc~pwfield_2d_pipe->h5aclose_f proc~wrattr_file->h5gopen_f proc~wrattr_file->h5sclose_f proc~wrattr_file->h5screate_simple_f proc~wrattr_file->h5gclose_f proc~wrattr_file->h5dclose_f proc~wrattr_file->proc~detect_precision h5dwrite_f h5dwrite_f proc~wrattr_file->h5dwrite_f h5gcreate_f h5gcreate_f proc~wrattr_file->h5gcreate_f interface~add_h5_atribute add_h5_atribute proc~wrattr_file->interface~add_h5_atribute proc~wrattr_dataset->interface~add_h5_atribute proc~add_h5_atribute_str add_h5_atribute_str interface~add_h5_atribute->proc~add_h5_atribute_str proc~add_h5_atribute_int add_h5_atribute_int interface~add_h5_atribute->proc~add_h5_atribute_int proc~add_h5_atribute_v1_int add_h5_atribute_v1_int interface~add_h5_atribute->proc~add_h5_atribute_v1_int proc~add_h5_atribute_v1_single add_h5_atribute_v1_single interface~add_h5_atribute->proc~add_h5_atribute_v1_single proc~add_h5_atribute_single add_h5_atribute_single interface~add_h5_atribute->proc~add_h5_atribute_single proc~add_h5_atribute_str_v1 add_h5_atribute_str_v1 interface~add_h5_atribute->proc~add_h5_atribute_str_v1 proc~add_h5_atribute_str->h5sclose_f proc~add_h5_atribute_str->h5tcopy_f proc~add_h5_atribute_str->h5screate_simple_f proc~add_h5_atribute_str->h5tset_size_f proc~add_h5_atribute_str->h5tclose_f proc~add_h5_atribute_str->h5aclose_f h5acreate_f h5acreate_f proc~add_h5_atribute_str->h5acreate_f h5awrite_f h5awrite_f proc~add_h5_atribute_str->h5awrite_f proc~add_h5_atribute_int->h5sclose_f proc~add_h5_atribute_int->h5screate_simple_f proc~add_h5_atribute_int->h5aclose_f proc~add_h5_atribute_int->h5acreate_f proc~add_h5_atribute_int->h5awrite_f proc~add_h5_atribute_v1_int->h5sclose_f proc~add_h5_atribute_v1_int->h5screate_simple_f proc~add_h5_atribute_v1_int->h5aclose_f proc~add_h5_atribute_v1_int->h5acreate_f proc~add_h5_atribute_v1_int->h5awrite_f proc~add_h5_atribute_v1_single->h5sclose_f proc~add_h5_atribute_v1_single->h5screate_simple_f proc~add_h5_atribute_v1_single->proc~detect_precision proc~add_h5_atribute_v1_single->h5aclose_f proc~add_h5_atribute_v1_single->h5acreate_f proc~add_h5_atribute_v1_single->h5awrite_f proc~add_h5_atribute_single->h5sclose_f proc~add_h5_atribute_single->h5screate_simple_f proc~add_h5_atribute_single->proc~detect_precision proc~add_h5_atribute_single->h5aclose_f proc~add_h5_atribute_single->h5acreate_f proc~add_h5_atribute_single->h5awrite_f proc~add_h5_atribute_str_v1->h5sclose_f proc~add_h5_atribute_str_v1->h5tcopy_f proc~add_h5_atribute_str_v1->h5screate_simple_f proc~add_h5_atribute_str_v1->h5tset_size_f proc~add_h5_atribute_str_v1->h5tclose_f proc~add_h5_atribute_str_v1->h5aclose_f proc~add_h5_atribute_str_v1->h5acreate_f proc~add_h5_atribute_str_v1->h5awrite_f var panprocwritehdf5_3dCallsGraph = svgPanZoom('#procwritehdf5_3dCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/writehdf5_3d.html"},{"title":"writehdf5_2dslice – QuickPIC","text":"private subroutine writehdf5_2dslice(this, file, dim, slice, spos, rtag, stag, id) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file integer, intent(in) :: dim integer, intent(in) :: slice integer, intent(in) :: spos integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id Calls proc~~writehdf5_2dslice~~CallsGraph proc~writehdf5_2dslice writehdf5_2dslice interface~pwfield_pipe pwfield_pipe proc~writehdf5_2dslice->interface~pwfield_pipe interface~wfield_pipe wfield_pipe proc~writehdf5_2dslice->interface~wfield_pipe proc~pwfield_3d_pipe pwfield_3d_pipe interface~pwfield_pipe->proc~pwfield_3d_pipe proc~pwfield_2d_pipe pwfield_2d_pipe interface~pwfield_pipe->proc~pwfield_2d_pipe proc~wfield_2d_pipe wfield_2d_pipe interface~wfield_pipe->proc~wfield_2d_pipe h5gopen_f h5gopen_f proc~pwfield_3d_pipe->h5gopen_f proc~wrattr_file wrattr_file proc~pwfield_3d_pipe->proc~wrattr_file h5sclose_f h5sclose_f proc~pwfield_3d_pipe->h5sclose_f h5tcopy_f h5tcopy_f proc~pwfield_3d_pipe->h5tcopy_f h5aopen_by_name_f h5aopen_by_name_f proc~pwfield_3d_pipe->h5aopen_by_name_f mpi_isend mpi_isend proc~pwfield_3d_pipe->mpi_isend h5pset_dxpl_mpio_f h5pset_dxpl_mpio_f proc~pwfield_3d_pipe->h5pset_dxpl_mpio_f h5screate_simple_f h5screate_simple_f proc~pwfield_3d_pipe->h5screate_simple_f h5gclose_f h5gclose_f proc~pwfield_3d_pipe->h5gclose_f h5tset_size_f h5tset_size_f proc~pwfield_3d_pipe->h5tset_size_f h5open_f h5open_f proc~pwfield_3d_pipe->h5open_f h5pcreate_f h5pcreate_f proc~pwfield_3d_pipe->h5pcreate_f proc~wrattr_dataset wrattr_dataset proc~pwfield_3d_pipe->proc~wrattr_dataset h5dcreate_f h5dcreate_f proc~pwfield_3d_pipe->h5dcreate_f mpi_irecv mpi_irecv proc~pwfield_3d_pipe->mpi_irecv h5tclose_f h5tclose_f proc~pwfield_3d_pipe->h5tclose_f h5fclose_f h5fclose_f proc~pwfield_3d_pipe->h5fclose_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~pwfield_3d_pipe->h5sselect_hyperslab_f h5dclose_f h5dclose_f proc~pwfield_3d_pipe->h5dclose_f h5aread_f h5aread_f proc~pwfield_3d_pipe->h5aread_f h5close_f h5close_f proc~pwfield_3d_pipe->h5close_f h5pclose_f h5pclose_f proc~pwfield_3d_pipe->h5pclose_f h5pset_fapl_mpio_f h5pset_fapl_mpio_f proc~pwfield_3d_pipe->h5pset_fapl_mpio_f h5dopen_f h5dopen_f proc~pwfield_3d_pipe->h5dopen_f h5fopen_f h5fopen_f proc~pwfield_3d_pipe->h5fopen_f proc~detect_precision detect_precision proc~pwfield_3d_pipe->proc~detect_precision h5fcreate_f h5fcreate_f proc~pwfield_3d_pipe->h5fcreate_f mpi_wait mpi_wait proc~pwfield_3d_pipe->mpi_wait h5aclose_f h5aclose_f proc~pwfield_3d_pipe->h5aclose_f proc~wfield_2d_pipe->h5gopen_f proc~wfield_2d_pipe->proc~wrattr_file proc~wfield_2d_pipe->h5sclose_f proc~wfield_2d_pipe->h5tcopy_f proc~wfield_2d_pipe->h5aopen_by_name_f proc~wfield_2d_pipe->mpi_isend proc~wfield_2d_pipe->h5screate_simple_f proc~wfield_2d_pipe->h5gclose_f proc~wfield_2d_pipe->h5tset_size_f proc~wfield_2d_pipe->h5open_f proc~wfield_2d_pipe->proc~wrattr_dataset proc~wfield_2d_pipe->h5dcreate_f proc~wfield_2d_pipe->mpi_irecv proc~wfield_2d_pipe->h5tclose_f proc~wfield_2d_pipe->h5fclose_f proc~wfield_2d_pipe->h5sselect_hyperslab_f proc~wfield_2d_pipe->h5dclose_f proc~wfield_2d_pipe->h5aread_f proc~wfield_2d_pipe->h5close_f proc~wfield_2d_pipe->h5dopen_f proc~wfield_2d_pipe->h5fopen_f proc~wfield_2d_pipe->proc~detect_precision proc~wfield_2d_pipe->h5fcreate_f proc~wfield_2d_pipe->mpi_wait proc~wfield_2d_pipe->h5aclose_f proc~pwfield_2d_pipe->h5gopen_f proc~pwfield_2d_pipe->proc~wrattr_file proc~pwfield_2d_pipe->h5sclose_f proc~pwfield_2d_pipe->h5tcopy_f proc~pwfield_2d_pipe->h5aopen_by_name_f proc~pwfield_2d_pipe->mpi_isend proc~pwfield_2d_pipe->h5pset_dxpl_mpio_f proc~pwfield_2d_pipe->h5screate_simple_f proc~pwfield_2d_pipe->h5gclose_f proc~pwfield_2d_pipe->h5tset_size_f proc~pwfield_2d_pipe->h5open_f proc~pwfield_2d_pipe->h5pcreate_f proc~pwfield_2d_pipe->proc~wrattr_dataset proc~pwfield_2d_pipe->h5dcreate_f proc~pwfield_2d_pipe->mpi_irecv proc~pwfield_2d_pipe->h5tclose_f proc~pwfield_2d_pipe->h5fclose_f proc~pwfield_2d_pipe->h5sselect_hyperslab_f proc~pwfield_2d_pipe->h5dclose_f proc~pwfield_2d_pipe->h5aread_f proc~pwfield_2d_pipe->h5close_f proc~pwfield_2d_pipe->h5pclose_f proc~pwfield_2d_pipe->h5pset_fapl_mpio_f proc~pwfield_2d_pipe->h5dopen_f proc~pwfield_2d_pipe->h5fopen_f proc~pwfield_2d_pipe->proc~detect_precision proc~pwfield_2d_pipe->h5fcreate_f proc~pwfield_2d_pipe->mpi_wait proc~pwfield_2d_pipe->h5aclose_f proc~wrattr_file->h5gopen_f proc~wrattr_file->h5sclose_f proc~wrattr_file->h5screate_simple_f proc~wrattr_file->h5gclose_f proc~wrattr_file->h5dclose_f proc~wrattr_file->proc~detect_precision h5dwrite_f h5dwrite_f proc~wrattr_file->h5dwrite_f h5gcreate_f h5gcreate_f proc~wrattr_file->h5gcreate_f interface~add_h5_atribute add_h5_atribute proc~wrattr_file->interface~add_h5_atribute proc~wrattr_dataset->interface~add_h5_atribute proc~add_h5_atribute_str add_h5_atribute_str interface~add_h5_atribute->proc~add_h5_atribute_str proc~add_h5_atribute_int add_h5_atribute_int interface~add_h5_atribute->proc~add_h5_atribute_int proc~add_h5_atribute_v1_int add_h5_atribute_v1_int interface~add_h5_atribute->proc~add_h5_atribute_v1_int proc~add_h5_atribute_v1_single add_h5_atribute_v1_single interface~add_h5_atribute->proc~add_h5_atribute_v1_single proc~add_h5_atribute_single add_h5_atribute_single interface~add_h5_atribute->proc~add_h5_atribute_single proc~add_h5_atribute_str_v1 add_h5_atribute_str_v1 interface~add_h5_atribute->proc~add_h5_atribute_str_v1 proc~add_h5_atribute_str->h5sclose_f proc~add_h5_atribute_str->h5tcopy_f proc~add_h5_atribute_str->h5screate_simple_f proc~add_h5_atribute_str->h5tset_size_f proc~add_h5_atribute_str->h5tclose_f proc~add_h5_atribute_str->h5aclose_f h5acreate_f h5acreate_f proc~add_h5_atribute_str->h5acreate_f h5awrite_f h5awrite_f proc~add_h5_atribute_str->h5awrite_f proc~add_h5_atribute_int->h5sclose_f proc~add_h5_atribute_int->h5screate_simple_f proc~add_h5_atribute_int->h5aclose_f proc~add_h5_atribute_int->h5acreate_f proc~add_h5_atribute_int->h5awrite_f proc~add_h5_atribute_v1_int->h5sclose_f proc~add_h5_atribute_v1_int->h5screate_simple_f proc~add_h5_atribute_v1_int->h5aclose_f proc~add_h5_atribute_v1_int->h5acreate_f proc~add_h5_atribute_v1_int->h5awrite_f proc~add_h5_atribute_v1_single->h5sclose_f proc~add_h5_atribute_v1_single->h5screate_simple_f proc~add_h5_atribute_v1_single->proc~detect_precision proc~add_h5_atribute_v1_single->h5aclose_f proc~add_h5_atribute_v1_single->h5acreate_f proc~add_h5_atribute_v1_single->h5awrite_f proc~add_h5_atribute_single->h5sclose_f proc~add_h5_atribute_single->h5screate_simple_f proc~add_h5_atribute_single->proc~detect_precision proc~add_h5_atribute_single->h5aclose_f proc~add_h5_atribute_single->h5acreate_f proc~add_h5_atribute_single->h5awrite_f proc~add_h5_atribute_str_v1->h5sclose_f proc~add_h5_atribute_str_v1->h5tcopy_f proc~add_h5_atribute_str_v1->h5screate_simple_f proc~add_h5_atribute_str_v1->h5tset_size_f proc~add_h5_atribute_str_v1->h5tclose_f proc~add_h5_atribute_str_v1->h5aclose_f proc~add_h5_atribute_str_v1->h5acreate_f proc~add_h5_atribute_str_v1->h5awrite_f var panprocwritehdf5_2dsliceCallsGraph = svgPanZoom('#procwritehdf5_2dsliceCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/writehdf5_2dslice.html"},{"title":"sum – QuickPIC","text":"private subroutine sum(this, a1, a2) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(inout) :: this class( ufield3d ), intent(in), target :: a1 class( ufield3d ), intent(in), target :: a2 Contents None","tags":"","loc":"proc/sum.html"},{"title":"minus – QuickPIC","text":"private subroutine minus(this, a1, a2) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(inout) :: this class( ufield3d ), intent(in), target :: a1 class( ufield3d ), intent(in), target :: a2 Contents None","tags":"","loc":"proc/minus.html"},{"title":"multiply – QuickPIC","text":"private subroutine multiply(this, a1, value) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(inout) :: this class( ufield3d ), intent(in), target :: a1 real, intent(in) :: value Contents None","tags":"","loc":"proc/multiply.html"},{"title":"asc – QuickPIC","text":"private subroutine asc(this, value) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(inout) :: this real, intent(in) :: value Contents None","tags":"","loc":"proc/asc~2.html"},{"title":"asa – QuickPIC","text":"private subroutine asa(this, that) Arguments Type Intent Optional Attributes Name class( ufield3d ), intent(inout) :: this class( ufield3d ), intent(in), target :: that Contents None","tags":"","loc":"proc/asa~2.html"},{"title":"getnpf – QuickPIC","text":"private function getnpf(this) Arguments Type Intent Optional Attributes Name class( fdist3d ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getnpf.html"},{"title":"getnpmax – QuickPIC","text":"private function getnpmax(this) Arguments Type Intent Optional Attributes Name class( fdist3d ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getnpmax.html"},{"title":"end_fdist3d – QuickPIC","text":"private subroutine end_fdist3d(this) Arguments Type Intent Optional Attributes Name class( fdist3d ), intent(inout) :: this Contents None","tags":"","loc":"proc/end_fdist3d.html"},{"title":"init_fdist3d_000 – QuickPIC","text":"private subroutine init_fdist3d_000(this, input, i) Arguments Type Intent Optional Attributes Name class( fdist3d_000 ), intent(inout) :: this type( input_json ), intent(inout), pointer :: input integer, intent(in) :: i Contents None","tags":"","loc":"proc/init_fdist3d_000.html"},{"title":"dist3d_000 – QuickPIC","text":"private subroutine dist3d_000(this, part3d, npp, fd) Arguments Type Intent Optional Attributes Name class( fdist3d_000 ), intent(inout) :: this real, intent(inout), dimension(:,:), pointer :: part3d integer, intent(inout) :: npp class( ufield3d ), intent(in), pointer :: fd Calls proc~~dist3d_000~~CallsGraph proc~dist3d_000 dist3d_000 interface~prvdist32_random PRVDIST32_RANDOM proc~dist3d_000->interface~prvdist32_random Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/dist3d_000.html"},{"title":"getnvp – QuickPIC","text":"private function getnvp(this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getnvp.html"},{"title":"getidproc – QuickPIC","text":"private function getidproc(this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getidproc.html"},{"title":"getkstrt – QuickPIC","text":"private function getkstrt(this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getkstrt.html"},{"title":"getlworld – QuickPIC","text":"private function getlworld(this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getlworld.html"},{"title":"getmint – QuickPIC","text":"private function getmint(this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getmint.html"},{"title":"getmreal – QuickPIC","text":"private function getmreal(this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getmreal.html"},{"title":"getmdouble – QuickPIC","text":"private function getmdouble(this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getmdouble.html"},{"title":"getmcplx – QuickPIC","text":"private function getmcplx(this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getmcplx.html"},{"title":"getmchar – QuickPIC","text":"private function getmchar(this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getmchar.html"},{"title":"init_parallel – QuickPIC","text":"private subroutine init_parallel(this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(inout) :: this Calls proc~~init_parallel~~CallsGraph proc~init_parallel init_parallel proc~init_omp init_omp proc~init_parallel->proc~init_omp proc~ppinit2 ppinit2 proc~init_parallel->proc~ppinit2 omp_set_num_threads omp_set_num_threads proc~init_omp->omp_set_num_threads omp_get_num_procs omp_get_num_procs proc~init_omp->omp_get_num_procs omp_get_thread_num omp_get_thread_num proc~init_omp->omp_get_thread_num omp_get_max_threads omp_get_max_threads proc~init_omp->omp_get_max_threads mpi_init mpi_init proc~ppinit2->mpi_init mpi_comm_size mpi_comm_size proc~ppinit2->mpi_comm_size mpi_initialized mpi_initialized proc~ppinit2->mpi_initialized mpi_comm_rank mpi_comm_rank proc~ppinit2->mpi_comm_rank Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/init_parallel.html"},{"title":"ppinit2 – QuickPIC","text":"private subroutine ppinit2(idproc, nvp, lworld, mint, mreal, mdouble, mcplx, mchar) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: idproc integer, intent(inout) :: nvp integer, intent(inout) :: lworld integer, intent(inout) :: mint integer, intent(inout) :: mreal integer, intent(inout) :: mdouble integer, intent(inout) :: mcplx integer, intent(inout) :: mchar Calls proc~~ppinit2~~CallsGraph proc~ppinit2 ppinit2 mpi_comm_rank mpi_comm_rank proc~ppinit2->mpi_comm_rank mpi_comm_size mpi_comm_size proc~ppinit2->mpi_comm_size mpi_initialized mpi_initialized proc~ppinit2->mpi_initialized mpi_init mpi_init proc~ppinit2->mpi_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~ppinit2~~CalledByGraph proc~ppinit2 ppinit2 proc~init_parallel init_parallel proc~init_parallel->proc~ppinit2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ppinit2.html"},{"title":"init_omp – QuickPIC","text":"private subroutine init_omp(nth) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nth Calls proc~~init_omp~~CallsGraph proc~init_omp init_omp omp_set_num_threads omp_set_num_threads proc~init_omp->omp_set_num_threads omp_get_max_threads omp_get_max_threads proc~init_omp->omp_get_max_threads omp_get_num_procs omp_get_num_procs proc~init_omp->omp_get_num_procs omp_get_thread_num omp_get_thread_num proc~init_omp->omp_get_thread_num Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~init_omp~~CalledByGraph proc~init_omp init_omp proc~init_parallel init_parallel proc~init_parallel->proc~init_omp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/init_omp.html"},{"title":"end_parallel – QuickPIC","text":"private subroutine end_parallel(this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(inout) :: this Calls proc~~end_parallel~~CallsGraph proc~end_parallel end_parallel mpi_finalize mpi_finalize proc~end_parallel->mpi_finalize mpi_initialized mpi_initialized proc~end_parallel->mpi_initialized mpi_barrier mpi_barrier proc~end_parallel->mpi_barrier Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/end_parallel.html"},{"title":"init_part2d – QuickPIC","text":"private subroutine init_part2d(this, pp, perr, psp, pf, fd, qbm, dt, ci, xdim, s) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( spect2d ), intent(in), pointer :: psp class( fdist2d ), intent(inout) :: pf class( ufield2d ), intent(in), pointer :: fd real, intent(in) :: qbm real, intent(in) :: dt real, intent(in) :: ci integer, intent(in) :: xdim real, intent(in) :: s Calls proc~~init_part2d~~CallsGraph proc~init_part2d init_part2d interface~pppmovin2l PPPMOVIN2L proc~init_part2d->interface~pppmovin2l interface~ppdblkp2l PPDBLKP2L proc~init_part2d->interface~ppdblkp2l Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/init_part2d.html"},{"title":"end_part2d – QuickPIC","text":"private subroutine end_part2d(this) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this Contents None","tags":"","loc":"proc/end_part2d.html"},{"title":"renew_part2d – QuickPIC","text":"private subroutine renew_part2d(this, pf, fd, s) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this class( fdist2d ), intent(inout) :: pf class( ufield2d ), intent(in), pointer :: fd real, intent(in) :: s Calls proc~~renew_part2d~~CallsGraph proc~renew_part2d renew_part2d interface~pppmovin2l PPPMOVIN2L proc~renew_part2d->interface~pppmovin2l interface~ppdblkp2l PPDBLKP2L proc~renew_part2d->interface~ppdblkp2l Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/renew_part2d.html"},{"title":"qdeposit – QuickPIC","text":"private subroutine qdeposit(this, q) Arguments Type Intent Optional Attributes Name class( part2d ), intent(in) :: this class( ufield2d ), intent(in), pointer :: q Contents None","tags":"","loc":"proc/qdeposit~2.html"},{"title":"amjdeposit – QuickPIC","text":"private subroutine amjdeposit(this, ef, bf, psit, cu, amu, dcu, dex) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this class( ufield2d ), intent(in), pointer :: ef class( ufield2d ), intent(in), pointer :: bf class( ufield2d ), intent(in), pointer :: psit class( ufield2d ), intent(in), pointer :: cu class( ufield2d ), intent(in), pointer :: amu class( ufield2d ), intent(in), pointer :: dcu real, intent(in) :: dex Contents None","tags":"","loc":"proc/amjdeposit.html"},{"title":"partpush – QuickPIC","text":"private subroutine partpush(this, ef, bf, psit, dex) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this class( ufield2d ), intent(in), pointer :: ef class( ufield2d ), intent(in), pointer :: bf class( ufield2d ), intent(in), pointer :: psit real, intent(in) :: dex Contents None","tags":"","loc":"proc/partpush~2.html"},{"title":"pmove – QuickPIC","text":"private subroutine pmove(this, fd) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this class( ufield2d ), intent(in), pointer :: fd Calls proc~~pmove~2~~CallsGraph proc~pmove~2 pmove interface~ppporderf2la PPPORDERF2LA proc~pmove~2->interface~ppporderf2la proc~pppmove2 PPPMOVE2 proc~pmove~2->proc~pppmove2 interface~ppporder2la PPPORDER2LA proc~pmove~2->interface~ppporder2la interface~ppporder2lb PPPORDER2LB proc~pmove~2->interface~ppporder2lb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/pmove~2.html"},{"title":"extractpsi – QuickPIC","text":"private subroutine extractpsi(this, psi, dex) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this class( ufield2d ), intent(in), pointer :: psi real, intent(in) :: dex Contents None","tags":"","loc":"proc/extractpsi.html"},{"title":"partcopy – QuickPIC","text":"private subroutine partcopy(this, fd) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this class( ufield2d ), intent(in), pointer :: fd Calls proc~~partcopy~~CallsGraph proc~partcopy partcopy interface~pppmovin2l PPPMOVIN2L proc~partcopy->interface~pppmovin2l Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/partcopy.html"},{"title":"partcopyback – QuickPIC","text":"private subroutine partcopyback(this) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this Calls proc~~partcopyback~~CallsGraph proc~partcopyback partcopyback interface~pppcopyout2 PPPCOPYOUT2 proc~partcopyback->interface~pppcopyout2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/partcopyback.html"},{"title":"pipesend_part2d – QuickPIC","text":"private subroutine pipesend_part2d(this, tag, id) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this integer, intent(in) :: tag integer, intent(inout) :: id Calls proc~~pipesend_part2d~~CallsGraph proc~pipesend_part2d pipesend_part2d mpi_isend mpi_isend proc~pipesend_part2d->mpi_isend Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/pipesend_part2d.html"},{"title":"piperecv_part2d – QuickPIC","text":"private subroutine piperecv_part2d(this, fd, tag) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this class( ufield2d ), intent(in), pointer :: fd integer, intent(in) :: tag Calls proc~~piperecv_part2d~~CallsGraph proc~piperecv_part2d piperecv_part2d mpi_get_count mpi_get_count proc~piperecv_part2d->mpi_get_count mpi_wait mpi_wait proc~piperecv_part2d->mpi_wait mpi_irecv mpi_irecv proc~piperecv_part2d->mpi_irecv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/piperecv_part2d.html"},{"title":"writehdf5_part2d – QuickPIC","text":"private subroutine writehdf5_part2d(this, file, delta) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this class( hdf5file ), intent(in) :: file real, intent(in), dimension(2) :: delta Calls proc~~writehdf5_part2d~~CallsGraph proc~writehdf5_part2d writehdf5_part2d interface~pwpart pwpart proc~writehdf5_part2d->interface~pwpart proc~pwpart_2d pwpart_2d interface~pwpart->proc~pwpart_2d h5gopen_f h5gopen_f proc~pwpart_2d->h5gopen_f proc~wrattr_file wrattr_file proc~pwpart_2d->proc~wrattr_file h5aclose_f h5aclose_f proc~pwpart_2d->h5aclose_f h5sclose_f h5sclose_f proc~pwpart_2d->h5sclose_f mpi_comm_rank mpi_comm_rank proc~pwpart_2d->mpi_comm_rank h5pset_dxpl_mpio_f h5pset_dxpl_mpio_f proc~pwpart_2d->h5pset_dxpl_mpio_f h5screate_simple_f h5screate_simple_f proc~pwpart_2d->h5screate_simple_f h5gclose_f h5gclose_f proc~pwpart_2d->h5gclose_f h5pcreate_f h5pcreate_f proc~pwpart_2d->h5pcreate_f h5open_f h5open_f proc~pwpart_2d->h5open_f mpi_allreduce mpi_allreduce proc~pwpart_2d->mpi_allreduce h5acreate_f h5acreate_f proc~pwpart_2d->h5acreate_f proc~wrattr_dataset wrattr_dataset proc~pwpart_2d->proc~wrattr_dataset h5dcreate_f h5dcreate_f proc~pwpart_2d->h5dcreate_f mpi_comm_free mpi_comm_free proc~pwpart_2d->mpi_comm_free mpi_allgather mpi_allgather proc~pwpart_2d->mpi_allgather h5fclose_f h5fclose_f proc~pwpart_2d->h5fclose_f mpi_comm_split mpi_comm_split proc~pwpart_2d->mpi_comm_split h5sselect_hyperslab_f h5sselect_hyperslab_f proc~pwpart_2d->h5sselect_hyperslab_f h5dclose_f h5dclose_f proc~pwpart_2d->h5dclose_f h5close_f h5close_f proc~pwpart_2d->h5close_f h5pclose_f h5pclose_f proc~pwpart_2d->h5pclose_f h5pset_fapl_mpio_f h5pset_fapl_mpio_f proc~pwpart_2d->h5pset_fapl_mpio_f h5dwrite_f h5dwrite_f proc~pwpart_2d->h5dwrite_f h5awrite_f h5awrite_f proc~pwpart_2d->h5awrite_f proc~detect_precision detect_precision proc~pwpart_2d->proc~detect_precision mpi_comm_size mpi_comm_size proc~pwpart_2d->mpi_comm_size h5fcreate_f h5fcreate_f proc~pwpart_2d->h5fcreate_f proc~wrattr_file->h5gopen_f proc~wrattr_file->h5sclose_f proc~wrattr_file->h5screate_simple_f proc~wrattr_file->h5gclose_f proc~wrattr_file->h5dclose_f proc~wrattr_file->h5dwrite_f proc~wrattr_file->proc~detect_precision h5gcreate_f h5gcreate_f proc~wrattr_file->h5gcreate_f interface~add_h5_atribute add_h5_atribute proc~wrattr_file->interface~add_h5_atribute proc~wrattr_dataset->interface~add_h5_atribute proc~add_h5_atribute_str add_h5_atribute_str interface~add_h5_atribute->proc~add_h5_atribute_str proc~add_h5_atribute_int add_h5_atribute_int interface~add_h5_atribute->proc~add_h5_atribute_int proc~add_h5_atribute_v1_int add_h5_atribute_v1_int interface~add_h5_atribute->proc~add_h5_atribute_v1_int proc~add_h5_atribute_v1_single add_h5_atribute_v1_single interface~add_h5_atribute->proc~add_h5_atribute_v1_single proc~add_h5_atribute_single add_h5_atribute_single interface~add_h5_atribute->proc~add_h5_atribute_single proc~add_h5_atribute_str_v1 add_h5_atribute_str_v1 interface~add_h5_atribute->proc~add_h5_atribute_str_v1 proc~add_h5_atribute_str->h5aclose_f proc~add_h5_atribute_str->h5sclose_f proc~add_h5_atribute_str->h5screate_simple_f proc~add_h5_atribute_str->h5acreate_f proc~add_h5_atribute_str->h5awrite_f h5tset_size_f h5tset_size_f proc~add_h5_atribute_str->h5tset_size_f h5tcopy_f h5tcopy_f proc~add_h5_atribute_str->h5tcopy_f h5tclose_f h5tclose_f proc~add_h5_atribute_str->h5tclose_f proc~add_h5_atribute_int->h5aclose_f proc~add_h5_atribute_int->h5sclose_f proc~add_h5_atribute_int->h5screate_simple_f proc~add_h5_atribute_int->h5acreate_f proc~add_h5_atribute_int->h5awrite_f proc~add_h5_atribute_v1_int->h5aclose_f proc~add_h5_atribute_v1_int->h5sclose_f proc~add_h5_atribute_v1_int->h5screate_simple_f proc~add_h5_atribute_v1_int->h5acreate_f proc~add_h5_atribute_v1_int->h5awrite_f proc~add_h5_atribute_v1_single->h5aclose_f proc~add_h5_atribute_v1_single->h5sclose_f proc~add_h5_atribute_v1_single->h5screate_simple_f proc~add_h5_atribute_v1_single->h5acreate_f proc~add_h5_atribute_v1_single->h5awrite_f proc~add_h5_atribute_v1_single->proc~detect_precision proc~add_h5_atribute_single->h5aclose_f proc~add_h5_atribute_single->h5sclose_f proc~add_h5_atribute_single->h5screate_simple_f proc~add_h5_atribute_single->h5acreate_f proc~add_h5_atribute_single->h5awrite_f proc~add_h5_atribute_single->proc~detect_precision proc~add_h5_atribute_str_v1->h5aclose_f proc~add_h5_atribute_str_v1->h5sclose_f proc~add_h5_atribute_str_v1->h5screate_simple_f proc~add_h5_atribute_str_v1->h5acreate_f proc~add_h5_atribute_str_v1->h5awrite_f proc~add_h5_atribute_str_v1->h5tset_size_f proc~add_h5_atribute_str_v1->h5tcopy_f proc~add_h5_atribute_str_v1->h5tclose_f var panprocwritehdf5_part2dCallsGraph = svgPanZoom('#procwritehdf5_part2dCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/writehdf5_part2d.html"},{"title":"getindz – QuickPIC","text":"private function getindz(this) Arguments Type Intent Optional Attributes Name class( spect3d ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getindz.html"},{"title":"init_spect3d – QuickPIC","text":"private subroutine init_spect3d(this, pp, perr, indx, indy, indz, psolver, inorder) Arguments Type Intent Optional Attributes Name class( spect3d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: indz integer, intent(in) :: psolver integer, intent(in) :: inorder Contents None","tags":"","loc":"proc/init_spect3d.html"},{"title":"end_spect3d – QuickPIC","text":"private subroutine end_spect3d(this) Arguments Type Intent Optional Attributes Name class( spect3d ), intent(inout) :: this Contents None","tags":"","loc":"proc/end_spect3d.html"},{"title":"PPNCGUARD2L – QuickPIC","text":"public subroutine PPNCGUARD2L(f, nyp, kstrt, nvp, nxv, nypmx, lgrp, mreal) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(nxv,nypmx) :: f integer, intent(in) :: nyp integer, intent(in) :: kstrt integer, intent(in) :: nvp integer, intent(in) :: nxv integer, intent(in) :: nypmx integer, intent(in) :: lgrp integer, intent(in) :: mreal Calls proc~~ppncguard2l~~CallsGraph proc~ppncguard2l PPNCGUARD2L mpi_wait mpi_wait proc~ppncguard2l->mpi_wait mpi_send mpi_send proc~ppncguard2l->mpi_send Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~ppncguard2l~~CalledByGraph proc~ppncguard2l PPNCGUARD2L proc~copyguard copyguard proc~copyguard->proc~ppncguard2l Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ppncguard2l.html"},{"title":"PPNACGUARD2L – QuickPIC","text":"public subroutine PPNACGUARD2L(f, scr, nyp, nx, ndim, kstrt, nvp, nxv, nypmx, lgrp, mreal) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(ndim,nxv,nypmx) :: f real, intent(inout), dimension(ndim,nxv) :: scr integer, intent(in) :: nyp integer, intent(in) :: nx integer, intent(in) :: ndim integer, intent(in) :: kstrt integer, intent(in) :: nvp integer, intent(in) :: nxv integer, intent(in) :: nypmx integer, intent(in) :: lgrp integer, intent(in) :: mreal Calls proc~~ppnacguard2l~~CallsGraph proc~ppnacguard2l PPNACGUARD2L mpi_wait mpi_wait proc~ppnacguard2l->mpi_wait mpi_irecv mpi_irecv proc~ppnacguard2l->mpi_irecv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~ppnacguard2l~~CalledByGraph proc~ppnacguard2l PPNACGUARD2L proc~acopyguard~2 acopyguard proc~acopyguard~2->proc~ppnacguard2l Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ppnacguard2l.html"},{"title":"PCGUARD32L – QuickPIC","text":"interface Called by interface~~pcguard32l~~CalledByGraph interface~pcguard32l PCGUARD32L proc~copyguard_pipe copyguard_pipe proc~copyguard_pipe->interface~pcguard32l Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine PCGUARD32L(f, scs, kstrt, nvpy, nvpz, nxv, nypmx, nzpmx, mblok, nblok, kyp, kzp, ngds, tag1, tag2, rid, sid, ierr) Arguments Type Intent Optional Attributes Name real, intent(inout) :: f real, intent(inout) :: scs integer, intent(in) :: kstrt integer, intent(in) :: nvpy integer, intent(in) :: nvpz integer, intent(in) :: nxv integer, intent(in) :: nypmx integer, intent(in) :: nzpmx integer, intent(in) :: mblok integer, intent(in) :: nblok integer, intent(in) :: kyp integer, intent(in) :: kzp integer, intent(in) :: ngds integer, intent(in) :: tag1 integer, intent(in) :: tag2 integer, intent(inout) :: rid integer, intent(inout) :: sid integer, intent(inout) :: ierr","tags":"","loc":"interface/pcguard32l.html"},{"title":"PACGUARD32L – QuickPIC","text":"interface Called by interface~~pacguard32l~~CalledByGraph interface~pacguard32l PACGUARD32L proc~acopyguard acopyguard proc~acopyguard->interface~pacguard32l Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine PACGUARD32L(f, scs, kstrt, nvpy, nvpz, nx, nxv, nypmx, nzpmx, mblok, nblok, kyp, kzp, ngds) Arguments Type Intent Optional Attributes Name real, intent(inout) :: f real, intent(inout) :: scs integer, intent(in) :: kstrt integer, intent(in) :: nvpy integer, intent(in) :: nvpz integer, intent(in) :: nx integer, intent(in) :: nxv integer, intent(in) :: nypmx integer, intent(in) :: nzpmx integer, intent(in) :: mblok integer, intent(in) :: nblok integer, intent(in) :: kyp integer, intent(in) :: kzp integer, intent(in) :: ngds","tags":"","loc":"interface/pacguard32l.html"},{"title":"PAGUARD32L – QuickPIC","text":"interface Called by interface~~paguard32l~~CalledByGraph interface~paguard32l PAGUARD32L proc~acopyguard acopyguard proc~acopyguard->interface~paguard32l Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine PAGUARD32L(f, scs, scr, kstrt, nvpy, nvpz, nx, nxv, nypmx, nzpmx, mblok, nblok, kyp, kzp, ngds, tag1, tag2, id, ierr) Arguments Type Intent Optional Attributes Name real, intent(inout) :: f real, intent(inout) :: scs real, intent(inout) :: scr integer, intent(in) :: kstrt integer, intent(in) :: nvpy integer, intent(in) :: nvpz integer, intent(in) :: nx integer, intent(in) :: nxv integer, intent(in) :: nypmx integer, intent(in) :: nzpmx integer, intent(in) :: mblok integer, intent(in) :: nblok integer, intent(in) :: kyp integer, intent(in) :: kzp integer, intent(in) :: ngds integer, intent(in) :: tag1 integer, intent(in) :: tag2 integer, intent(inout) :: id integer, intent(inout) :: ierr","tags":"","loc":"interface/paguard32l.html"},{"title":"getnpf – QuickPIC","text":"private function getnpf(this) Arguments Type Intent Optional Attributes Name class( fdist2d ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getnpf~2.html"},{"title":"getnpmax – QuickPIC","text":"private function getnpmax(this) Arguments Type Intent Optional Attributes Name class( fdist2d ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getnpmax~2.html"},{"title":"end_fdist2d – QuickPIC","text":"private subroutine end_fdist2d(this) Arguments Type Intent Optional Attributes Name class( fdist2d ), intent(inout) :: this Contents None","tags":"","loc":"proc/end_fdist2d.html"},{"title":"init_fdist2d_000 – QuickPIC","text":"private subroutine init_fdist2d_000(this, input, i) Arguments Type Intent Optional Attributes Name class( fdist2d_000 ), intent(inout) :: this type( input_json ), intent(inout), pointer :: input integer, intent(in) :: i Contents None","tags":"","loc":"proc/init_fdist2d_000.html"},{"title":"dist2d_000 – QuickPIC","text":"private subroutine dist2d_000(this, part2d, npp, fd, s) Arguments Type Intent Optional Attributes Name class( fdist2d_000 ), intent(inout) :: this real, intent(inout), dimension(:,:), pointer :: part2d integer, intent(inout) :: npp class( ufield2d ), intent(in), pointer :: fd real, intent(in) :: s Contents None","tags":"","loc":"proc/dist2d_000.html"},{"title":"detect_precision – QuickPIC","text":"private function detect_precision() Arguments None Return Value integer(kind=hid_t) Called by proc~~detect_precision~~CalledByGraph proc~detect_precision detect_precision proc~pwfield_2d pwfield_2d proc~pwfield_2d->proc~detect_precision proc~wrattr_file wrattr_file proc~pwfield_2d->proc~wrattr_file proc~wrattr_dataset wrattr_dataset proc~pwfield_2d->proc~wrattr_dataset proc~pwpart_3d_pipe pwpart_3d_pipe proc~pwpart_3d_pipe->proc~detect_precision proc~pwpart_3d_pipe->proc~wrattr_file proc~pwpart_3d_pipe->proc~wrattr_dataset proc~pwfield_2d_pipe pwfield_2d_pipe proc~pwfield_2d_pipe->proc~detect_precision proc~pwfield_2d_pipe->proc~wrattr_file proc~pwfield_2d_pipe->proc~wrattr_dataset proc~wpart wpart proc~wpart->proc~detect_precision proc~wpart->proc~wrattr_file proc~wpart->proc~wrattr_dataset proc~wrattr_file->proc~detect_precision interface~add_h5_atribute add_h5_atribute proc~wrattr_file->interface~add_h5_atribute proc~rpart rpart proc~rpart->proc~detect_precision proc~add_h5_atribute_v1_single add_h5_atribute_v1_single proc~add_h5_atribute_v1_single->proc~detect_precision proc~wfield_2d_pipe wfield_2d_pipe proc~wfield_2d_pipe->proc~detect_precision proc~wfield_2d_pipe->proc~wrattr_file proc~wfield_2d_pipe->proc~wrattr_dataset proc~pwpart_2d pwpart_2d proc~pwpart_2d->proc~detect_precision proc~pwpart_2d->proc~wrattr_file proc~pwpart_2d->proc~wrattr_dataset proc~pwfield_3d pwfield_3d proc~pwfield_3d->proc~detect_precision proc~pwfield_3d->proc~wrattr_file proc~pwfield_3d->proc~wrattr_dataset proc~pwfield_3d_pipe pwfield_3d_pipe proc~pwfield_3d_pipe->proc~detect_precision proc~pwfield_3d_pipe->proc~wrattr_file proc~pwfield_3d_pipe->proc~wrattr_dataset proc~add_h5_atribute_single add_h5_atribute_single proc~add_h5_atribute_single->proc~detect_precision interface~pwpart_pipe pwpart_pipe interface~pwpart_pipe->proc~pwpart_3d_pipe interface~wfield_pipe wfield_pipe interface~wfield_pipe->proc~wfield_2d_pipe interface~add_h5_atribute->proc~add_h5_atribute_v1_single interface~add_h5_atribute->proc~add_h5_atribute_single interface~pwfield pwfield interface~pwfield->proc~pwfield_2d interface~pwfield->proc~pwfield_3d interface~pwpart pwpart interface~pwpart->proc~pwpart_2d proc~readrst_part3d readrst_part3d proc~readrst_part3d->proc~rpart interface~pwfield_pipe pwfield_pipe interface~pwfield_pipe->proc~pwfield_2d_pipe interface~pwfield_pipe->proc~pwfield_3d_pipe proc~writerst_part3d writerst_part3d proc~writerst_part3d->proc~wpart proc~writehdf5 writehdf5 proc~writehdf5->interface~pwfield proc~writehdf5_2dslice writehdf5_2dslice proc~writehdf5_2dslice->interface~wfield_pipe proc~writehdf5_2dslice->interface~pwfield_pipe proc~wrattr_dataset->interface~add_h5_atribute proc~writehdf5_part3d writehdf5_part3d proc~writehdf5_part3d->interface~pwpart_pipe proc~writehdf5_3d writehdf5_3d proc~writehdf5_3d->interface~pwfield_pipe proc~writehdf5_part2d writehdf5_part2d proc~writehdf5_part2d->interface~pwpart var panprocdetect_precisionCalledByGraph = svgPanZoom('#procdetect_precisionCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/detect_precision.html"},{"title":"init_hdf5file – QuickPIC","text":"private subroutine init_hdf5file(this, filename, timeunits, ty, n, t, dt, axisname, axislabel, axisunits, axismax, axismin, dataname, units, label, rank) Arguments Type Intent Optional Attributes Name class( hdf5file ), intent(inout) :: this character(len=*), intent(in), optional :: filename character(len=*), intent(in), optional :: timeunits character(len=*), intent(in), optional :: ty integer, intent(in), optional :: n real, intent(in), optional :: t real, intent(in), optional :: dt character(len=*), intent(in), optional dimension(3) :: axisname character(len=*), intent(in), optional dimension(3) :: axislabel character(len=*), intent(in), optional dimension(3) :: axisunits real, intent(in), optional dimension(3) :: axismax real, intent(in), optional dimension(3) :: axismin character(len=*), intent(in), optional :: dataname character(len=*), intent(in), optional :: units character(len=*), intent(in), optional :: label integer, intent(in), optional :: rank Contents None","tags":"","loc":"proc/init_hdf5file.html"},{"title":"add_h5_atribute_str – QuickPIC","text":"private subroutine add_h5_atribute_str(objID, name, attribute) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: objID character(len=*), intent(in) :: name character(len=*), intent(in) :: attribute Calls proc~~add_h5_atribute_str~~CallsGraph proc~add_h5_atribute_str add_h5_atribute_str h5screate_simple_f h5screate_simple_f proc~add_h5_atribute_str->h5screate_simple_f h5tset_size_f h5tset_size_f proc~add_h5_atribute_str->h5tset_size_f h5sclose_f h5sclose_f proc~add_h5_atribute_str->h5sclose_f h5acreate_f h5acreate_f proc~add_h5_atribute_str->h5acreate_f h5awrite_f h5awrite_f proc~add_h5_atribute_str->h5awrite_f h5tcopy_f h5tcopy_f proc~add_h5_atribute_str->h5tcopy_f h5aclose_f h5aclose_f proc~add_h5_atribute_str->h5aclose_f h5tclose_f h5tclose_f proc~add_h5_atribute_str->h5tclose_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~add_h5_atribute_str~~CalledByGraph proc~add_h5_atribute_str add_h5_atribute_str interface~add_h5_atribute add_h5_atribute interface~add_h5_atribute->proc~add_h5_atribute_str proc~wrattr_dataset wrattr_dataset proc~wrattr_dataset->interface~add_h5_atribute proc~wrattr_file wrattr_file proc~wrattr_file->interface~add_h5_atribute proc~pwfield_2d pwfield_2d proc~pwfield_2d->proc~wrattr_dataset proc~pwfield_2d->proc~wrattr_file proc~pwpart_3d_pipe pwpart_3d_pipe proc~pwpart_3d_pipe->proc~wrattr_dataset proc~pwpart_3d_pipe->proc~wrattr_file proc~pwfield_2d_pipe pwfield_2d_pipe proc~pwfield_2d_pipe->proc~wrattr_dataset proc~pwfield_2d_pipe->proc~wrattr_file proc~wpart wpart proc~wpart->proc~wrattr_dataset proc~wpart->proc~wrattr_file proc~wfield_2d_pipe wfield_2d_pipe proc~wfield_2d_pipe->proc~wrattr_dataset proc~wfield_2d_pipe->proc~wrattr_file proc~pwpart_2d pwpart_2d proc~pwpart_2d->proc~wrattr_dataset proc~pwpart_2d->proc~wrattr_file proc~pwfield_3d pwfield_3d proc~pwfield_3d->proc~wrattr_dataset proc~pwfield_3d->proc~wrattr_file proc~pwfield_3d_pipe pwfield_3d_pipe proc~pwfield_3d_pipe->proc~wrattr_dataset proc~pwfield_3d_pipe->proc~wrattr_file interface~pwpart_pipe pwpart_pipe interface~pwpart_pipe->proc~pwpart_3d_pipe interface~wfield_pipe wfield_pipe interface~wfield_pipe->proc~wfield_2d_pipe interface~pwfield pwfield interface~pwfield->proc~pwfield_2d interface~pwfield->proc~pwfield_3d interface~pwpart pwpart interface~pwpart->proc~pwpart_2d interface~pwfield_pipe pwfield_pipe interface~pwfield_pipe->proc~pwfield_2d_pipe interface~pwfield_pipe->proc~pwfield_3d_pipe proc~writerst_part3d writerst_part3d proc~writerst_part3d->proc~wpart proc~writehdf5 writehdf5 proc~writehdf5->interface~pwfield proc~writehdf5_2dslice writehdf5_2dslice proc~writehdf5_2dslice->interface~wfield_pipe proc~writehdf5_2dslice->interface~pwfield_pipe proc~writehdf5_part3d writehdf5_part3d proc~writehdf5_part3d->interface~pwpart_pipe proc~writehdf5_3d writehdf5_3d proc~writehdf5_3d->interface~pwfield_pipe proc~writehdf5_part2d writehdf5_part2d proc~writehdf5_part2d->interface~pwpart var panprocadd_h5_atribute_strCalledByGraph = svgPanZoom('#procadd_h5_atribute_strCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/add_h5_atribute_str.html"},{"title":"add_h5_atribute_str_v1 – QuickPIC","text":"private subroutine add_h5_atribute_str_v1(objID, name, attribute) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: objID character(len=*), intent(in) :: name character(len=*), intent(in), dimension(:) :: attribute Calls proc~~add_h5_atribute_str_v1~~CallsGraph proc~add_h5_atribute_str_v1 add_h5_atribute_str_v1 h5screate_simple_f h5screate_simple_f proc~add_h5_atribute_str_v1->h5screate_simple_f h5tset_size_f h5tset_size_f proc~add_h5_atribute_str_v1->h5tset_size_f h5sclose_f h5sclose_f proc~add_h5_atribute_str_v1->h5sclose_f h5acreate_f h5acreate_f proc~add_h5_atribute_str_v1->h5acreate_f h5awrite_f h5awrite_f proc~add_h5_atribute_str_v1->h5awrite_f h5tcopy_f h5tcopy_f proc~add_h5_atribute_str_v1->h5tcopy_f h5aclose_f h5aclose_f proc~add_h5_atribute_str_v1->h5aclose_f h5tclose_f h5tclose_f proc~add_h5_atribute_str_v1->h5tclose_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~add_h5_atribute_str_v1~~CalledByGraph proc~add_h5_atribute_str_v1 add_h5_atribute_str_v1 interface~add_h5_atribute add_h5_atribute interface~add_h5_atribute->proc~add_h5_atribute_str_v1 proc~wrattr_dataset wrattr_dataset proc~wrattr_dataset->interface~add_h5_atribute proc~wrattr_file wrattr_file proc~wrattr_file->interface~add_h5_atribute proc~pwfield_2d pwfield_2d proc~pwfield_2d->proc~wrattr_dataset proc~pwfield_2d->proc~wrattr_file proc~pwpart_3d_pipe pwpart_3d_pipe proc~pwpart_3d_pipe->proc~wrattr_dataset proc~pwpart_3d_pipe->proc~wrattr_file proc~pwfield_2d_pipe pwfield_2d_pipe proc~pwfield_2d_pipe->proc~wrattr_dataset proc~pwfield_2d_pipe->proc~wrattr_file proc~wpart wpart proc~wpart->proc~wrattr_dataset proc~wpart->proc~wrattr_file proc~wfield_2d_pipe wfield_2d_pipe proc~wfield_2d_pipe->proc~wrattr_dataset proc~wfield_2d_pipe->proc~wrattr_file proc~pwpart_2d pwpart_2d proc~pwpart_2d->proc~wrattr_dataset proc~pwpart_2d->proc~wrattr_file proc~pwfield_3d pwfield_3d proc~pwfield_3d->proc~wrattr_dataset proc~pwfield_3d->proc~wrattr_file proc~pwfield_3d_pipe pwfield_3d_pipe proc~pwfield_3d_pipe->proc~wrattr_dataset proc~pwfield_3d_pipe->proc~wrattr_file interface~pwpart_pipe pwpart_pipe interface~pwpart_pipe->proc~pwpart_3d_pipe interface~wfield_pipe wfield_pipe interface~wfield_pipe->proc~wfield_2d_pipe interface~pwfield pwfield interface~pwfield->proc~pwfield_2d interface~pwfield->proc~pwfield_3d interface~pwpart pwpart interface~pwpart->proc~pwpart_2d interface~pwfield_pipe pwfield_pipe interface~pwfield_pipe->proc~pwfield_2d_pipe interface~pwfield_pipe->proc~pwfield_3d_pipe proc~writerst_part3d writerst_part3d proc~writerst_part3d->proc~wpart proc~writehdf5 writehdf5 proc~writehdf5->interface~pwfield proc~writehdf5_2dslice writehdf5_2dslice proc~writehdf5_2dslice->interface~wfield_pipe proc~writehdf5_2dslice->interface~pwfield_pipe proc~writehdf5_part3d writehdf5_part3d proc~writehdf5_part3d->interface~pwpart_pipe proc~writehdf5_3d writehdf5_3d proc~writehdf5_3d->interface~pwfield_pipe proc~writehdf5_part2d writehdf5_part2d proc~writehdf5_part2d->interface~pwpart var panprocadd_h5_atribute_str_v1CalledByGraph = svgPanZoom('#procadd_h5_atribute_str_v1CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/add_h5_atribute_str_v1.html"},{"title":"add_h5_atribute_single – QuickPIC","text":"private subroutine add_h5_atribute_single(objID, name, attribute) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: objID character(len=*), intent(in) :: name real, intent(in) :: attribute Calls proc~~add_h5_atribute_single~~CallsGraph proc~add_h5_atribute_single add_h5_atribute_single h5screate_simple_f h5screate_simple_f proc~add_h5_atribute_single->h5screate_simple_f h5sclose_f h5sclose_f proc~add_h5_atribute_single->h5sclose_f h5acreate_f h5acreate_f proc~add_h5_atribute_single->h5acreate_f h5awrite_f h5awrite_f proc~add_h5_atribute_single->h5awrite_f proc~detect_precision detect_precision proc~add_h5_atribute_single->proc~detect_precision h5aclose_f h5aclose_f proc~add_h5_atribute_single->h5aclose_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~add_h5_atribute_single~~CalledByGraph proc~add_h5_atribute_single add_h5_atribute_single interface~add_h5_atribute add_h5_atribute interface~add_h5_atribute->proc~add_h5_atribute_single proc~wrattr_dataset wrattr_dataset proc~wrattr_dataset->interface~add_h5_atribute proc~wrattr_file wrattr_file proc~wrattr_file->interface~add_h5_atribute proc~pwfield_2d pwfield_2d proc~pwfield_2d->proc~wrattr_dataset proc~pwfield_2d->proc~wrattr_file proc~pwpart_3d_pipe pwpart_3d_pipe proc~pwpart_3d_pipe->proc~wrattr_dataset proc~pwpart_3d_pipe->proc~wrattr_file proc~pwfield_2d_pipe pwfield_2d_pipe proc~pwfield_2d_pipe->proc~wrattr_dataset proc~pwfield_2d_pipe->proc~wrattr_file proc~wpart wpart proc~wpart->proc~wrattr_dataset proc~wpart->proc~wrattr_file proc~wfield_2d_pipe wfield_2d_pipe proc~wfield_2d_pipe->proc~wrattr_dataset proc~wfield_2d_pipe->proc~wrattr_file proc~pwpart_2d pwpart_2d proc~pwpart_2d->proc~wrattr_dataset proc~pwpart_2d->proc~wrattr_file proc~pwfield_3d pwfield_3d proc~pwfield_3d->proc~wrattr_dataset proc~pwfield_3d->proc~wrattr_file proc~pwfield_3d_pipe pwfield_3d_pipe proc~pwfield_3d_pipe->proc~wrattr_dataset proc~pwfield_3d_pipe->proc~wrattr_file interface~pwpart_pipe pwpart_pipe interface~pwpart_pipe->proc~pwpart_3d_pipe interface~wfield_pipe wfield_pipe interface~wfield_pipe->proc~wfield_2d_pipe interface~pwfield pwfield interface~pwfield->proc~pwfield_2d interface~pwfield->proc~pwfield_3d interface~pwpart pwpart interface~pwpart->proc~pwpart_2d interface~pwfield_pipe pwfield_pipe interface~pwfield_pipe->proc~pwfield_2d_pipe interface~pwfield_pipe->proc~pwfield_3d_pipe proc~writerst_part3d writerst_part3d proc~writerst_part3d->proc~wpart proc~writehdf5 writehdf5 proc~writehdf5->interface~pwfield proc~writehdf5_2dslice writehdf5_2dslice proc~writehdf5_2dslice->interface~wfield_pipe proc~writehdf5_2dslice->interface~pwfield_pipe proc~writehdf5_part3d writehdf5_part3d proc~writehdf5_part3d->interface~pwpart_pipe proc~writehdf5_3d writehdf5_3d proc~writehdf5_3d->interface~pwfield_pipe proc~writehdf5_part2d writehdf5_part2d proc~writehdf5_part2d->interface~pwpart var panprocadd_h5_atribute_singleCalledByGraph = svgPanZoom('#procadd_h5_atribute_singleCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/add_h5_atribute_single.html"},{"title":"add_h5_atribute_v1_single – QuickPIC","text":"private subroutine add_h5_atribute_v1_single(objID, name, attribute) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: objID character(len=*), intent(in) :: name real, intent(in), dimension(:) :: attribute Calls proc~~add_h5_atribute_v1_single~~CallsGraph proc~add_h5_atribute_v1_single add_h5_atribute_v1_single h5screate_simple_f h5screate_simple_f proc~add_h5_atribute_v1_single->h5screate_simple_f h5sclose_f h5sclose_f proc~add_h5_atribute_v1_single->h5sclose_f h5acreate_f h5acreate_f proc~add_h5_atribute_v1_single->h5acreate_f h5awrite_f h5awrite_f proc~add_h5_atribute_v1_single->h5awrite_f proc~detect_precision detect_precision proc~add_h5_atribute_v1_single->proc~detect_precision h5aclose_f h5aclose_f proc~add_h5_atribute_v1_single->h5aclose_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~add_h5_atribute_v1_single~~CalledByGraph proc~add_h5_atribute_v1_single add_h5_atribute_v1_single interface~add_h5_atribute add_h5_atribute interface~add_h5_atribute->proc~add_h5_atribute_v1_single proc~wrattr_dataset wrattr_dataset proc~wrattr_dataset->interface~add_h5_atribute proc~wrattr_file wrattr_file proc~wrattr_file->interface~add_h5_atribute proc~pwfield_2d pwfield_2d proc~pwfield_2d->proc~wrattr_dataset proc~pwfield_2d->proc~wrattr_file proc~pwpart_3d_pipe pwpart_3d_pipe proc~pwpart_3d_pipe->proc~wrattr_dataset proc~pwpart_3d_pipe->proc~wrattr_file proc~pwfield_2d_pipe pwfield_2d_pipe proc~pwfield_2d_pipe->proc~wrattr_dataset proc~pwfield_2d_pipe->proc~wrattr_file proc~wpart wpart proc~wpart->proc~wrattr_dataset proc~wpart->proc~wrattr_file proc~wfield_2d_pipe wfield_2d_pipe proc~wfield_2d_pipe->proc~wrattr_dataset proc~wfield_2d_pipe->proc~wrattr_file proc~pwpart_2d pwpart_2d proc~pwpart_2d->proc~wrattr_dataset proc~pwpart_2d->proc~wrattr_file proc~pwfield_3d pwfield_3d proc~pwfield_3d->proc~wrattr_dataset proc~pwfield_3d->proc~wrattr_file proc~pwfield_3d_pipe pwfield_3d_pipe proc~pwfield_3d_pipe->proc~wrattr_dataset proc~pwfield_3d_pipe->proc~wrattr_file interface~pwpart_pipe pwpart_pipe interface~pwpart_pipe->proc~pwpart_3d_pipe interface~wfield_pipe wfield_pipe interface~wfield_pipe->proc~wfield_2d_pipe interface~pwfield pwfield interface~pwfield->proc~pwfield_2d interface~pwfield->proc~pwfield_3d interface~pwpart pwpart interface~pwpart->proc~pwpart_2d interface~pwfield_pipe pwfield_pipe interface~pwfield_pipe->proc~pwfield_2d_pipe interface~pwfield_pipe->proc~pwfield_3d_pipe proc~writerst_part3d writerst_part3d proc~writerst_part3d->proc~wpart proc~writehdf5 writehdf5 proc~writehdf5->interface~pwfield proc~writehdf5_2dslice writehdf5_2dslice proc~writehdf5_2dslice->interface~wfield_pipe proc~writehdf5_2dslice->interface~pwfield_pipe proc~writehdf5_part3d writehdf5_part3d proc~writehdf5_part3d->interface~pwpart_pipe proc~writehdf5_3d writehdf5_3d proc~writehdf5_3d->interface~pwfield_pipe proc~writehdf5_part2d writehdf5_part2d proc~writehdf5_part2d->interface~pwpart var panprocadd_h5_atribute_v1_singleCalledByGraph = svgPanZoom('#procadd_h5_atribute_v1_singleCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/add_h5_atribute_v1_single.html"},{"title":"add_h5_atribute_int – QuickPIC","text":"private subroutine add_h5_atribute_int(objID, name, attribute) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: objID character(len=*), intent(in) :: name integer, intent(in) :: attribute Calls proc~~add_h5_atribute_int~~CallsGraph proc~add_h5_atribute_int add_h5_atribute_int h5screate_simple_f h5screate_simple_f proc~add_h5_atribute_int->h5screate_simple_f h5sclose_f h5sclose_f proc~add_h5_atribute_int->h5sclose_f h5acreate_f h5acreate_f proc~add_h5_atribute_int->h5acreate_f h5awrite_f h5awrite_f proc~add_h5_atribute_int->h5awrite_f h5aclose_f h5aclose_f proc~add_h5_atribute_int->h5aclose_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~add_h5_atribute_int~~CalledByGraph proc~add_h5_atribute_int add_h5_atribute_int interface~add_h5_atribute add_h5_atribute interface~add_h5_atribute->proc~add_h5_atribute_int proc~wrattr_dataset wrattr_dataset proc~wrattr_dataset->interface~add_h5_atribute proc~wrattr_file wrattr_file proc~wrattr_file->interface~add_h5_atribute proc~pwfield_2d pwfield_2d proc~pwfield_2d->proc~wrattr_dataset proc~pwfield_2d->proc~wrattr_file proc~pwpart_3d_pipe pwpart_3d_pipe proc~pwpart_3d_pipe->proc~wrattr_dataset proc~pwpart_3d_pipe->proc~wrattr_file proc~pwfield_2d_pipe pwfield_2d_pipe proc~pwfield_2d_pipe->proc~wrattr_dataset proc~pwfield_2d_pipe->proc~wrattr_file proc~wpart wpart proc~wpart->proc~wrattr_dataset proc~wpart->proc~wrattr_file proc~wfield_2d_pipe wfield_2d_pipe proc~wfield_2d_pipe->proc~wrattr_dataset proc~wfield_2d_pipe->proc~wrattr_file proc~pwpart_2d pwpart_2d proc~pwpart_2d->proc~wrattr_dataset proc~pwpart_2d->proc~wrattr_file proc~pwfield_3d pwfield_3d proc~pwfield_3d->proc~wrattr_dataset proc~pwfield_3d->proc~wrattr_file proc~pwfield_3d_pipe pwfield_3d_pipe proc~pwfield_3d_pipe->proc~wrattr_dataset proc~pwfield_3d_pipe->proc~wrattr_file interface~pwpart_pipe pwpart_pipe interface~pwpart_pipe->proc~pwpart_3d_pipe interface~wfield_pipe wfield_pipe interface~wfield_pipe->proc~wfield_2d_pipe interface~pwfield pwfield interface~pwfield->proc~pwfield_2d interface~pwfield->proc~pwfield_3d interface~pwpart pwpart interface~pwpart->proc~pwpart_2d interface~pwfield_pipe pwfield_pipe interface~pwfield_pipe->proc~pwfield_2d_pipe interface~pwfield_pipe->proc~pwfield_3d_pipe proc~writerst_part3d writerst_part3d proc~writerst_part3d->proc~wpart proc~writehdf5 writehdf5 proc~writehdf5->interface~pwfield proc~writehdf5_2dslice writehdf5_2dslice proc~writehdf5_2dslice->interface~wfield_pipe proc~writehdf5_2dslice->interface~pwfield_pipe proc~writehdf5_part3d writehdf5_part3d proc~writehdf5_part3d->interface~pwpart_pipe proc~writehdf5_3d writehdf5_3d proc~writehdf5_3d->interface~pwfield_pipe proc~writehdf5_part2d writehdf5_part2d proc~writehdf5_part2d->interface~pwpart var panprocadd_h5_atribute_intCalledByGraph = svgPanZoom('#procadd_h5_atribute_intCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/add_h5_atribute_int.html"},{"title":"add_h5_atribute_v1_int – QuickPIC","text":"private subroutine add_h5_atribute_v1_int(objID, name, attribute) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: objID character(len=*), intent(in) :: name integer, intent(in), dimension(:) :: attribute Calls proc~~add_h5_atribute_v1_int~~CallsGraph proc~add_h5_atribute_v1_int add_h5_atribute_v1_int h5screate_simple_f h5screate_simple_f proc~add_h5_atribute_v1_int->h5screate_simple_f h5sclose_f h5sclose_f proc~add_h5_atribute_v1_int->h5sclose_f h5acreate_f h5acreate_f proc~add_h5_atribute_v1_int->h5acreate_f h5awrite_f h5awrite_f proc~add_h5_atribute_v1_int->h5awrite_f h5aclose_f h5aclose_f proc~add_h5_atribute_v1_int->h5aclose_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~add_h5_atribute_v1_int~~CalledByGraph proc~add_h5_atribute_v1_int add_h5_atribute_v1_int interface~add_h5_atribute add_h5_atribute interface~add_h5_atribute->proc~add_h5_atribute_v1_int proc~wrattr_dataset wrattr_dataset proc~wrattr_dataset->interface~add_h5_atribute proc~wrattr_file wrattr_file proc~wrattr_file->interface~add_h5_atribute proc~pwfield_2d pwfield_2d proc~pwfield_2d->proc~wrattr_dataset proc~pwfield_2d->proc~wrattr_file proc~pwpart_3d_pipe pwpart_3d_pipe proc~pwpart_3d_pipe->proc~wrattr_dataset proc~pwpart_3d_pipe->proc~wrattr_file proc~pwfield_2d_pipe pwfield_2d_pipe proc~pwfield_2d_pipe->proc~wrattr_dataset proc~pwfield_2d_pipe->proc~wrattr_file proc~wpart wpart proc~wpart->proc~wrattr_dataset proc~wpart->proc~wrattr_file proc~wfield_2d_pipe wfield_2d_pipe proc~wfield_2d_pipe->proc~wrattr_dataset proc~wfield_2d_pipe->proc~wrattr_file proc~pwpart_2d pwpart_2d proc~pwpart_2d->proc~wrattr_dataset proc~pwpart_2d->proc~wrattr_file proc~pwfield_3d pwfield_3d proc~pwfield_3d->proc~wrattr_dataset proc~pwfield_3d->proc~wrattr_file proc~pwfield_3d_pipe pwfield_3d_pipe proc~pwfield_3d_pipe->proc~wrattr_dataset proc~pwfield_3d_pipe->proc~wrattr_file interface~pwpart_pipe pwpart_pipe interface~pwpart_pipe->proc~pwpart_3d_pipe interface~wfield_pipe wfield_pipe interface~wfield_pipe->proc~wfield_2d_pipe interface~pwfield pwfield interface~pwfield->proc~pwfield_2d interface~pwfield->proc~pwfield_3d interface~pwpart pwpart interface~pwpart->proc~pwpart_2d interface~pwfield_pipe pwfield_pipe interface~pwfield_pipe->proc~pwfield_2d_pipe interface~pwfield_pipe->proc~pwfield_3d_pipe proc~writerst_part3d writerst_part3d proc~writerst_part3d->proc~wpart proc~writehdf5 writehdf5 proc~writehdf5->interface~pwfield proc~writehdf5_2dslice writehdf5_2dslice proc~writehdf5_2dslice->interface~wfield_pipe proc~writehdf5_2dslice->interface~pwfield_pipe proc~writehdf5_part3d writehdf5_part3d proc~writehdf5_part3d->interface~pwpart_pipe proc~writehdf5_3d writehdf5_3d proc~writehdf5_3d->interface~pwfield_pipe proc~writehdf5_part2d writehdf5_part2d proc~writehdf5_part2d->interface~pwpart var panprocadd_h5_atribute_v1_intCalledByGraph = svgPanZoom('#procadd_h5_atribute_v1_intCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/add_h5_atribute_v1_int.html"},{"title":"wrattr_file – QuickPIC","text":"private subroutine wrattr_file(this, file_id, xferID) Arguments Type Intent Optional Attributes Name class( hdf5file ), intent(in) :: this integer(kind=hid_t), intent(in) :: file_id integer(kind=hid_t) :: xferID Calls proc~~wrattr_file~~CallsGraph proc~wrattr_file wrattr_file h5screate_simple_f h5screate_simple_f proc~wrattr_file->h5screate_simple_f h5gclose_f h5gclose_f proc~wrattr_file->h5gclose_f h5gcreate_f h5gcreate_f proc~wrattr_file->h5gcreate_f h5gopen_f h5gopen_f proc~wrattr_file->h5gopen_f h5sclose_f h5sclose_f proc~wrattr_file->h5sclose_f h5dclose_f h5dclose_f proc~wrattr_file->h5dclose_f h5dwrite_f h5dwrite_f proc~wrattr_file->h5dwrite_f interface~add_h5_atribute add_h5_atribute proc~wrattr_file->interface~add_h5_atribute proc~detect_precision detect_precision proc~wrattr_file->proc~detect_precision proc~add_h5_atribute_str add_h5_atribute_str interface~add_h5_atribute->proc~add_h5_atribute_str proc~add_h5_atribute_int add_h5_atribute_int interface~add_h5_atribute->proc~add_h5_atribute_int proc~add_h5_atribute_v1_int add_h5_atribute_v1_int interface~add_h5_atribute->proc~add_h5_atribute_v1_int proc~add_h5_atribute_v1_single add_h5_atribute_v1_single interface~add_h5_atribute->proc~add_h5_atribute_v1_single proc~add_h5_atribute_single add_h5_atribute_single interface~add_h5_atribute->proc~add_h5_atribute_single proc~add_h5_atribute_str_v1 add_h5_atribute_str_v1 interface~add_h5_atribute->proc~add_h5_atribute_str_v1 proc~add_h5_atribute_str->h5screate_simple_f proc~add_h5_atribute_str->h5sclose_f h5tset_size_f h5tset_size_f proc~add_h5_atribute_str->h5tset_size_f h5acreate_f h5acreate_f proc~add_h5_atribute_str->h5acreate_f h5awrite_f h5awrite_f proc~add_h5_atribute_str->h5awrite_f h5tcopy_f h5tcopy_f proc~add_h5_atribute_str->h5tcopy_f h5aclose_f h5aclose_f proc~add_h5_atribute_str->h5aclose_f h5tclose_f h5tclose_f proc~add_h5_atribute_str->h5tclose_f proc~add_h5_atribute_int->h5screate_simple_f proc~add_h5_atribute_int->h5sclose_f proc~add_h5_atribute_int->h5acreate_f proc~add_h5_atribute_int->h5awrite_f proc~add_h5_atribute_int->h5aclose_f proc~add_h5_atribute_v1_int->h5screate_simple_f proc~add_h5_atribute_v1_int->h5sclose_f proc~add_h5_atribute_v1_int->h5acreate_f proc~add_h5_atribute_v1_int->h5awrite_f proc~add_h5_atribute_v1_int->h5aclose_f proc~add_h5_atribute_v1_single->h5screate_simple_f proc~add_h5_atribute_v1_single->h5sclose_f proc~add_h5_atribute_v1_single->proc~detect_precision proc~add_h5_atribute_v1_single->h5acreate_f proc~add_h5_atribute_v1_single->h5awrite_f proc~add_h5_atribute_v1_single->h5aclose_f proc~add_h5_atribute_single->h5screate_simple_f proc~add_h5_atribute_single->h5sclose_f proc~add_h5_atribute_single->proc~detect_precision proc~add_h5_atribute_single->h5acreate_f proc~add_h5_atribute_single->h5awrite_f proc~add_h5_atribute_single->h5aclose_f proc~add_h5_atribute_str_v1->h5screate_simple_f proc~add_h5_atribute_str_v1->h5sclose_f proc~add_h5_atribute_str_v1->h5tset_size_f proc~add_h5_atribute_str_v1->h5acreate_f proc~add_h5_atribute_str_v1->h5awrite_f proc~add_h5_atribute_str_v1->h5tcopy_f proc~add_h5_atribute_str_v1->h5aclose_f proc~add_h5_atribute_str_v1->h5tclose_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~wrattr_file~~CalledByGraph proc~wrattr_file wrattr_file proc~pwfield_2d pwfield_2d proc~pwfield_2d->proc~wrattr_file proc~pwpart_3d_pipe pwpart_3d_pipe proc~pwpart_3d_pipe->proc~wrattr_file proc~pwfield_2d_pipe pwfield_2d_pipe proc~pwfield_2d_pipe->proc~wrattr_file proc~wpart wpart proc~wpart->proc~wrattr_file proc~wfield_2d_pipe wfield_2d_pipe proc~wfield_2d_pipe->proc~wrattr_file proc~pwpart_2d pwpart_2d proc~pwpart_2d->proc~wrattr_file proc~pwfield_3d pwfield_3d proc~pwfield_3d->proc~wrattr_file proc~pwfield_3d_pipe pwfield_3d_pipe proc~pwfield_3d_pipe->proc~wrattr_file interface~pwpart_pipe pwpart_pipe interface~pwpart_pipe->proc~pwpart_3d_pipe interface~wfield_pipe wfield_pipe interface~wfield_pipe->proc~wfield_2d_pipe interface~pwfield pwfield interface~pwfield->proc~pwfield_2d interface~pwfield->proc~pwfield_3d interface~pwpart pwpart interface~pwpart->proc~pwpart_2d interface~pwfield_pipe pwfield_pipe interface~pwfield_pipe->proc~pwfield_2d_pipe interface~pwfield_pipe->proc~pwfield_3d_pipe proc~writerst_part3d writerst_part3d proc~writerst_part3d->proc~wpart proc~writehdf5 writehdf5 proc~writehdf5->interface~pwfield proc~writehdf5_2dslice writehdf5_2dslice proc~writehdf5_2dslice->interface~wfield_pipe proc~writehdf5_2dslice->interface~pwfield_pipe proc~writehdf5_part3d writehdf5_part3d proc~writehdf5_part3d->interface~pwpart_pipe proc~writehdf5_3d writehdf5_3d proc~writehdf5_3d->interface~pwfield_pipe proc~writehdf5_part2d writehdf5_part2d proc~writehdf5_part2d->interface~pwpart Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/wrattr_file.html"},{"title":"wrattr_dataset – QuickPIC","text":"private subroutine wrattr_dataset(this, dset_id, unit, name) Arguments Type Intent Optional Attributes Name class( hdf5file ), intent(in) :: this integer(kind=hid_t), intent(in) :: dset_id character(len=*), intent(in), optional :: unit character(len=*), intent(in), optional :: name Calls proc~~wrattr_dataset~~CallsGraph proc~wrattr_dataset wrattr_dataset interface~add_h5_atribute add_h5_atribute proc~wrattr_dataset->interface~add_h5_atribute proc~add_h5_atribute_str add_h5_atribute_str interface~add_h5_atribute->proc~add_h5_atribute_str proc~add_h5_atribute_int add_h5_atribute_int interface~add_h5_atribute->proc~add_h5_atribute_int proc~add_h5_atribute_v1_int add_h5_atribute_v1_int interface~add_h5_atribute->proc~add_h5_atribute_v1_int proc~add_h5_atribute_v1_single add_h5_atribute_v1_single interface~add_h5_atribute->proc~add_h5_atribute_v1_single proc~add_h5_atribute_single add_h5_atribute_single interface~add_h5_atribute->proc~add_h5_atribute_single proc~add_h5_atribute_str_v1 add_h5_atribute_str_v1 interface~add_h5_atribute->proc~add_h5_atribute_str_v1 h5screate_simple_f h5screate_simple_f proc~add_h5_atribute_str->h5screate_simple_f h5tset_size_f h5tset_size_f proc~add_h5_atribute_str->h5tset_size_f h5sclose_f h5sclose_f proc~add_h5_atribute_str->h5sclose_f h5acreate_f h5acreate_f proc~add_h5_atribute_str->h5acreate_f h5awrite_f h5awrite_f proc~add_h5_atribute_str->h5awrite_f h5tcopy_f h5tcopy_f proc~add_h5_atribute_str->h5tcopy_f h5aclose_f h5aclose_f proc~add_h5_atribute_str->h5aclose_f h5tclose_f h5tclose_f proc~add_h5_atribute_str->h5tclose_f proc~add_h5_atribute_int->h5screate_simple_f proc~add_h5_atribute_int->h5sclose_f proc~add_h5_atribute_int->h5acreate_f proc~add_h5_atribute_int->h5awrite_f proc~add_h5_atribute_int->h5aclose_f proc~add_h5_atribute_v1_int->h5screate_simple_f proc~add_h5_atribute_v1_int->h5sclose_f proc~add_h5_atribute_v1_int->h5acreate_f proc~add_h5_atribute_v1_int->h5awrite_f proc~add_h5_atribute_v1_int->h5aclose_f proc~add_h5_atribute_v1_single->h5screate_simple_f proc~add_h5_atribute_v1_single->h5sclose_f proc~add_h5_atribute_v1_single->h5acreate_f proc~add_h5_atribute_v1_single->h5awrite_f proc~detect_precision detect_precision proc~add_h5_atribute_v1_single->proc~detect_precision proc~add_h5_atribute_v1_single->h5aclose_f proc~add_h5_atribute_single->h5screate_simple_f proc~add_h5_atribute_single->h5sclose_f proc~add_h5_atribute_single->h5acreate_f proc~add_h5_atribute_single->h5awrite_f proc~add_h5_atribute_single->proc~detect_precision proc~add_h5_atribute_single->h5aclose_f proc~add_h5_atribute_str_v1->h5screate_simple_f proc~add_h5_atribute_str_v1->h5tset_size_f proc~add_h5_atribute_str_v1->h5sclose_f proc~add_h5_atribute_str_v1->h5acreate_f proc~add_h5_atribute_str_v1->h5awrite_f proc~add_h5_atribute_str_v1->h5tcopy_f proc~add_h5_atribute_str_v1->h5aclose_f proc~add_h5_atribute_str_v1->h5tclose_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~wrattr_dataset~~CalledByGraph proc~wrattr_dataset wrattr_dataset proc~pwfield_2d pwfield_2d proc~pwfield_2d->proc~wrattr_dataset proc~pwpart_3d_pipe pwpart_3d_pipe proc~pwpart_3d_pipe->proc~wrattr_dataset proc~pwfield_2d_pipe pwfield_2d_pipe proc~pwfield_2d_pipe->proc~wrattr_dataset proc~wpart wpart proc~wpart->proc~wrattr_dataset proc~wfield_2d_pipe wfield_2d_pipe proc~wfield_2d_pipe->proc~wrattr_dataset proc~pwpart_2d pwpart_2d proc~pwpart_2d->proc~wrattr_dataset proc~pwfield_3d pwfield_3d proc~pwfield_3d->proc~wrattr_dataset proc~pwfield_3d_pipe pwfield_3d_pipe proc~pwfield_3d_pipe->proc~wrattr_dataset interface~pwpart_pipe pwpart_pipe interface~pwpart_pipe->proc~pwpart_3d_pipe interface~wfield_pipe wfield_pipe interface~wfield_pipe->proc~wfield_2d_pipe interface~pwfield pwfield interface~pwfield->proc~pwfield_2d interface~pwfield->proc~pwfield_3d interface~pwpart pwpart interface~pwpart->proc~pwpart_2d interface~pwfield_pipe pwfield_pipe interface~pwfield_pipe->proc~pwfield_2d_pipe interface~pwfield_pipe->proc~pwfield_3d_pipe proc~writerst_part3d writerst_part3d proc~writerst_part3d->proc~wpart proc~writehdf5 writehdf5 proc~writehdf5->interface~pwfield proc~writehdf5_2dslice writehdf5_2dslice proc~writehdf5_2dslice->interface~wfield_pipe proc~writehdf5_2dslice->interface~pwfield_pipe proc~writehdf5_part3d writehdf5_part3d proc~writehdf5_part3d->interface~pwpart_pipe proc~writehdf5_3d writehdf5_3d proc~writehdf5_3d->interface~pwfield_pipe proc~writehdf5_part2d writehdf5_part2d proc~writehdf5_part2d->interface~pwpart Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/wrattr_dataset.html"},{"title":"pwfield_3d – QuickPIC","text":"private subroutine pwfield_3d(pp, perr, file, fd, gs, ls, noff, ierr) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( hdf5file ), intent(in) :: file real, intent(in), dimension(:,:,:) :: fd integer, intent(in), dimension(3) :: gs integer, intent(in), dimension(3) :: ls integer, intent(in), dimension(2) :: noff integer, intent(inout) :: ierr Calls proc~~pwfield_3d~~CallsGraph proc~pwfield_3d pwfield_3d h5screate_simple_f h5screate_simple_f proc~pwfield_3d->h5screate_simple_f h5gclose_f h5gclose_f proc~pwfield_3d->h5gclose_f h5pset_fapl_mpio_f h5pset_fapl_mpio_f proc~pwfield_3d->h5pset_fapl_mpio_f h5gopen_f h5gopen_f proc~pwfield_3d->h5gopen_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~pwfield_3d->h5sselect_hyperslab_f proc~wrattr_file wrattr_file proc~pwfield_3d->proc~wrattr_file h5fclose_f h5fclose_f proc~pwfield_3d->h5fclose_f h5sclose_f h5sclose_f proc~pwfield_3d->h5sclose_f h5open_f h5open_f proc~pwfield_3d->h5open_f h5pcreate_f h5pcreate_f proc~pwfield_3d->h5pcreate_f proc~wrattr_dataset wrattr_dataset proc~pwfield_3d->proc~wrattr_dataset h5dclose_f h5dclose_f proc~pwfield_3d->h5dclose_f proc~detect_precision detect_precision proc~pwfield_3d->proc~detect_precision h5dcreate_f h5dcreate_f proc~pwfield_3d->h5dcreate_f h5close_f h5close_f proc~pwfield_3d->h5close_f h5pclose_f h5pclose_f proc~pwfield_3d->h5pclose_f h5fcreate_f h5fcreate_f proc~pwfield_3d->h5fcreate_f h5pset_dxpl_mpio_f h5pset_dxpl_mpio_f proc~pwfield_3d->h5pset_dxpl_mpio_f proc~wrattr_file->h5screate_simple_f proc~wrattr_file->h5gclose_f proc~wrattr_file->h5gopen_f proc~wrattr_file->h5sclose_f proc~wrattr_file->h5dclose_f proc~wrattr_file->proc~detect_precision h5dwrite_f h5dwrite_f proc~wrattr_file->h5dwrite_f h5gcreate_f h5gcreate_f proc~wrattr_file->h5gcreate_f interface~add_h5_atribute add_h5_atribute proc~wrattr_file->interface~add_h5_atribute proc~wrattr_dataset->interface~add_h5_atribute proc~add_h5_atribute_str add_h5_atribute_str interface~add_h5_atribute->proc~add_h5_atribute_str proc~add_h5_atribute_int add_h5_atribute_int interface~add_h5_atribute->proc~add_h5_atribute_int proc~add_h5_atribute_v1_int add_h5_atribute_v1_int interface~add_h5_atribute->proc~add_h5_atribute_v1_int proc~add_h5_atribute_v1_single add_h5_atribute_v1_single interface~add_h5_atribute->proc~add_h5_atribute_v1_single proc~add_h5_atribute_single add_h5_atribute_single interface~add_h5_atribute->proc~add_h5_atribute_single proc~add_h5_atribute_str_v1 add_h5_atribute_str_v1 interface~add_h5_atribute->proc~add_h5_atribute_str_v1 proc~add_h5_atribute_str->h5screate_simple_f proc~add_h5_atribute_str->h5sclose_f h5tset_size_f h5tset_size_f proc~add_h5_atribute_str->h5tset_size_f h5acreate_f h5acreate_f proc~add_h5_atribute_str->h5acreate_f h5awrite_f h5awrite_f proc~add_h5_atribute_str->h5awrite_f h5tcopy_f h5tcopy_f proc~add_h5_atribute_str->h5tcopy_f h5aclose_f h5aclose_f proc~add_h5_atribute_str->h5aclose_f h5tclose_f h5tclose_f proc~add_h5_atribute_str->h5tclose_f proc~add_h5_atribute_int->h5screate_simple_f proc~add_h5_atribute_int->h5sclose_f proc~add_h5_atribute_int->h5acreate_f proc~add_h5_atribute_int->h5awrite_f proc~add_h5_atribute_int->h5aclose_f proc~add_h5_atribute_v1_int->h5screate_simple_f proc~add_h5_atribute_v1_int->h5sclose_f proc~add_h5_atribute_v1_int->h5acreate_f proc~add_h5_atribute_v1_int->h5awrite_f proc~add_h5_atribute_v1_int->h5aclose_f proc~add_h5_atribute_v1_single->h5screate_simple_f proc~add_h5_atribute_v1_single->h5sclose_f proc~add_h5_atribute_v1_single->proc~detect_precision proc~add_h5_atribute_v1_single->h5acreate_f proc~add_h5_atribute_v1_single->h5awrite_f proc~add_h5_atribute_v1_single->h5aclose_f proc~add_h5_atribute_single->h5screate_simple_f proc~add_h5_atribute_single->h5sclose_f proc~add_h5_atribute_single->proc~detect_precision proc~add_h5_atribute_single->h5acreate_f proc~add_h5_atribute_single->h5awrite_f proc~add_h5_atribute_single->h5aclose_f proc~add_h5_atribute_str_v1->h5screate_simple_f proc~add_h5_atribute_str_v1->h5sclose_f proc~add_h5_atribute_str_v1->h5tset_size_f proc~add_h5_atribute_str_v1->h5acreate_f proc~add_h5_atribute_str_v1->h5awrite_f proc~add_h5_atribute_str_v1->h5tcopy_f proc~add_h5_atribute_str_v1->h5aclose_f proc~add_h5_atribute_str_v1->h5tclose_f var panprocpwfield_3dCallsGraph = svgPanZoom('#procpwfield_3dCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~pwfield_3d~~CalledByGraph proc~pwfield_3d pwfield_3d interface~pwfield pwfield interface~pwfield->proc~pwfield_3d proc~writehdf5 writehdf5 proc~writehdf5->interface~pwfield Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/pwfield_3d.html"},{"title":"pwfield_2d – QuickPIC","text":"private subroutine pwfield_2d(pp, perr, file, fd, gs, ls, noff, ierr) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( hdf5file ), intent(in) :: file real, intent(in), dimension(:,:) :: fd integer, intent(in), dimension(2) :: gs integer, intent(in), dimension(2) :: ls integer, intent(in) :: noff integer, intent(inout) :: ierr Calls proc~~pwfield_2d~~CallsGraph proc~pwfield_2d pwfield_2d h5screate_simple_f h5screate_simple_f proc~pwfield_2d->h5screate_simple_f h5gclose_f h5gclose_f proc~pwfield_2d->h5gclose_f h5pset_fapl_mpio_f h5pset_fapl_mpio_f proc~pwfield_2d->h5pset_fapl_mpio_f h5gopen_f h5gopen_f proc~pwfield_2d->h5gopen_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~pwfield_2d->h5sselect_hyperslab_f proc~wrattr_file wrattr_file proc~pwfield_2d->proc~wrattr_file h5fclose_f h5fclose_f proc~pwfield_2d->h5fclose_f h5sclose_f h5sclose_f proc~pwfield_2d->h5sclose_f h5open_f h5open_f proc~pwfield_2d->h5open_f h5pcreate_f h5pcreate_f proc~pwfield_2d->h5pcreate_f proc~wrattr_dataset wrattr_dataset proc~pwfield_2d->proc~wrattr_dataset h5dclose_f h5dclose_f proc~pwfield_2d->h5dclose_f proc~detect_precision detect_precision proc~pwfield_2d->proc~detect_precision h5dcreate_f h5dcreate_f proc~pwfield_2d->h5dcreate_f h5close_f h5close_f proc~pwfield_2d->h5close_f h5pclose_f h5pclose_f proc~pwfield_2d->h5pclose_f h5fcreate_f h5fcreate_f proc~pwfield_2d->h5fcreate_f h5pset_dxpl_mpio_f h5pset_dxpl_mpio_f proc~pwfield_2d->h5pset_dxpl_mpio_f proc~wrattr_file->h5screate_simple_f proc~wrattr_file->h5gclose_f proc~wrattr_file->h5gopen_f proc~wrattr_file->h5sclose_f proc~wrattr_file->h5dclose_f proc~wrattr_file->proc~detect_precision h5dwrite_f h5dwrite_f proc~wrattr_file->h5dwrite_f h5gcreate_f h5gcreate_f proc~wrattr_file->h5gcreate_f interface~add_h5_atribute add_h5_atribute proc~wrattr_file->interface~add_h5_atribute proc~wrattr_dataset->interface~add_h5_atribute proc~add_h5_atribute_str add_h5_atribute_str interface~add_h5_atribute->proc~add_h5_atribute_str proc~add_h5_atribute_int add_h5_atribute_int interface~add_h5_atribute->proc~add_h5_atribute_int proc~add_h5_atribute_v1_int add_h5_atribute_v1_int interface~add_h5_atribute->proc~add_h5_atribute_v1_int proc~add_h5_atribute_v1_single add_h5_atribute_v1_single interface~add_h5_atribute->proc~add_h5_atribute_v1_single proc~add_h5_atribute_single add_h5_atribute_single interface~add_h5_atribute->proc~add_h5_atribute_single proc~add_h5_atribute_str_v1 add_h5_atribute_str_v1 interface~add_h5_atribute->proc~add_h5_atribute_str_v1 proc~add_h5_atribute_str->h5screate_simple_f proc~add_h5_atribute_str->h5sclose_f h5tset_size_f h5tset_size_f proc~add_h5_atribute_str->h5tset_size_f h5acreate_f h5acreate_f proc~add_h5_atribute_str->h5acreate_f h5awrite_f h5awrite_f proc~add_h5_atribute_str->h5awrite_f h5tcopy_f h5tcopy_f proc~add_h5_atribute_str->h5tcopy_f h5aclose_f h5aclose_f proc~add_h5_atribute_str->h5aclose_f h5tclose_f h5tclose_f proc~add_h5_atribute_str->h5tclose_f proc~add_h5_atribute_int->h5screate_simple_f proc~add_h5_atribute_int->h5sclose_f proc~add_h5_atribute_int->h5acreate_f proc~add_h5_atribute_int->h5awrite_f proc~add_h5_atribute_int->h5aclose_f proc~add_h5_atribute_v1_int->h5screate_simple_f proc~add_h5_atribute_v1_int->h5sclose_f proc~add_h5_atribute_v1_int->h5acreate_f proc~add_h5_atribute_v1_int->h5awrite_f proc~add_h5_atribute_v1_int->h5aclose_f proc~add_h5_atribute_v1_single->h5screate_simple_f proc~add_h5_atribute_v1_single->h5sclose_f proc~add_h5_atribute_v1_single->proc~detect_precision proc~add_h5_atribute_v1_single->h5acreate_f proc~add_h5_atribute_v1_single->h5awrite_f proc~add_h5_atribute_v1_single->h5aclose_f proc~add_h5_atribute_single->h5screate_simple_f proc~add_h5_atribute_single->h5sclose_f proc~add_h5_atribute_single->proc~detect_precision proc~add_h5_atribute_single->h5acreate_f proc~add_h5_atribute_single->h5awrite_f proc~add_h5_atribute_single->h5aclose_f proc~add_h5_atribute_str_v1->h5screate_simple_f proc~add_h5_atribute_str_v1->h5sclose_f proc~add_h5_atribute_str_v1->h5tset_size_f proc~add_h5_atribute_str_v1->h5acreate_f proc~add_h5_atribute_str_v1->h5awrite_f proc~add_h5_atribute_str_v1->h5tcopy_f proc~add_h5_atribute_str_v1->h5aclose_f proc~add_h5_atribute_str_v1->h5tclose_f var panprocpwfield_2dCallsGraph = svgPanZoom('#procpwfield_2dCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~pwfield_2d~~CalledByGraph proc~pwfield_2d pwfield_2d interface~pwfield pwfield interface~pwfield->proc~pwfield_2d proc~writehdf5 writehdf5 proc~writehdf5->interface~pwfield Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/pwfield_2d.html"},{"title":"pwfield_3d_pipe – QuickPIC","text":"private subroutine pwfield_3d_pipe(pp, perr, file, fd, gs, ls, noff, rtag, stag, id, ierr) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( hdf5file ), intent(in) :: file real, intent(in), dimension(:,:,:) :: fd integer, intent(in), dimension(3) :: gs integer, intent(in), dimension(3) :: ls integer, intent(in), dimension(2) :: noff integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id integer, intent(inout) :: ierr Calls proc~~pwfield_3d_pipe~~CallsGraph proc~pwfield_3d_pipe pwfield_3d_pipe h5gopen_f h5gopen_f proc~pwfield_3d_pipe->h5gopen_f proc~wrattr_file wrattr_file proc~pwfield_3d_pipe->proc~wrattr_file h5sclose_f h5sclose_f proc~pwfield_3d_pipe->h5sclose_f h5tcopy_f h5tcopy_f proc~pwfield_3d_pipe->h5tcopy_f h5aopen_by_name_f h5aopen_by_name_f proc~pwfield_3d_pipe->h5aopen_by_name_f mpi_isend mpi_isend proc~pwfield_3d_pipe->mpi_isend h5pset_dxpl_mpio_f h5pset_dxpl_mpio_f proc~pwfield_3d_pipe->h5pset_dxpl_mpio_f h5screate_simple_f h5screate_simple_f proc~pwfield_3d_pipe->h5screate_simple_f h5gclose_f h5gclose_f proc~pwfield_3d_pipe->h5gclose_f h5tset_size_f h5tset_size_f proc~pwfield_3d_pipe->h5tset_size_f h5open_f h5open_f proc~pwfield_3d_pipe->h5open_f h5pcreate_f h5pcreate_f proc~pwfield_3d_pipe->h5pcreate_f proc~wrattr_dataset wrattr_dataset proc~pwfield_3d_pipe->proc~wrattr_dataset h5dcreate_f h5dcreate_f proc~pwfield_3d_pipe->h5dcreate_f mpi_irecv mpi_irecv proc~pwfield_3d_pipe->mpi_irecv h5tclose_f h5tclose_f proc~pwfield_3d_pipe->h5tclose_f h5fclose_f h5fclose_f proc~pwfield_3d_pipe->h5fclose_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~pwfield_3d_pipe->h5sselect_hyperslab_f h5dclose_f h5dclose_f proc~pwfield_3d_pipe->h5dclose_f h5aread_f h5aread_f proc~pwfield_3d_pipe->h5aread_f h5close_f h5close_f proc~pwfield_3d_pipe->h5close_f h5pclose_f h5pclose_f proc~pwfield_3d_pipe->h5pclose_f h5pset_fapl_mpio_f h5pset_fapl_mpio_f proc~pwfield_3d_pipe->h5pset_fapl_mpio_f h5dopen_f h5dopen_f proc~pwfield_3d_pipe->h5dopen_f h5fopen_f h5fopen_f proc~pwfield_3d_pipe->h5fopen_f proc~detect_precision detect_precision proc~pwfield_3d_pipe->proc~detect_precision h5fcreate_f h5fcreate_f proc~pwfield_3d_pipe->h5fcreate_f mpi_wait mpi_wait proc~pwfield_3d_pipe->mpi_wait h5aclose_f h5aclose_f proc~pwfield_3d_pipe->h5aclose_f proc~wrattr_file->h5gopen_f proc~wrattr_file->h5sclose_f proc~wrattr_file->h5screate_simple_f proc~wrattr_file->h5gclose_f proc~wrattr_file->h5dclose_f proc~wrattr_file->proc~detect_precision h5dwrite_f h5dwrite_f proc~wrattr_file->h5dwrite_f h5gcreate_f h5gcreate_f proc~wrattr_file->h5gcreate_f interface~add_h5_atribute add_h5_atribute proc~wrattr_file->interface~add_h5_atribute proc~wrattr_dataset->interface~add_h5_atribute proc~add_h5_atribute_str add_h5_atribute_str interface~add_h5_atribute->proc~add_h5_atribute_str proc~add_h5_atribute_int add_h5_atribute_int interface~add_h5_atribute->proc~add_h5_atribute_int proc~add_h5_atribute_v1_int add_h5_atribute_v1_int interface~add_h5_atribute->proc~add_h5_atribute_v1_int proc~add_h5_atribute_v1_single add_h5_atribute_v1_single interface~add_h5_atribute->proc~add_h5_atribute_v1_single proc~add_h5_atribute_single add_h5_atribute_single interface~add_h5_atribute->proc~add_h5_atribute_single proc~add_h5_atribute_str_v1 add_h5_atribute_str_v1 interface~add_h5_atribute->proc~add_h5_atribute_str_v1 proc~add_h5_atribute_str->h5sclose_f proc~add_h5_atribute_str->h5tcopy_f proc~add_h5_atribute_str->h5screate_simple_f proc~add_h5_atribute_str->h5tset_size_f proc~add_h5_atribute_str->h5tclose_f proc~add_h5_atribute_str->h5aclose_f h5acreate_f h5acreate_f proc~add_h5_atribute_str->h5acreate_f h5awrite_f h5awrite_f proc~add_h5_atribute_str->h5awrite_f proc~add_h5_atribute_int->h5sclose_f proc~add_h5_atribute_int->h5screate_simple_f proc~add_h5_atribute_int->h5aclose_f proc~add_h5_atribute_int->h5acreate_f proc~add_h5_atribute_int->h5awrite_f proc~add_h5_atribute_v1_int->h5sclose_f proc~add_h5_atribute_v1_int->h5screate_simple_f proc~add_h5_atribute_v1_int->h5aclose_f proc~add_h5_atribute_v1_int->h5acreate_f proc~add_h5_atribute_v1_int->h5awrite_f proc~add_h5_atribute_v1_single->h5sclose_f proc~add_h5_atribute_v1_single->h5screate_simple_f proc~add_h5_atribute_v1_single->proc~detect_precision proc~add_h5_atribute_v1_single->h5aclose_f proc~add_h5_atribute_v1_single->h5acreate_f proc~add_h5_atribute_v1_single->h5awrite_f proc~add_h5_atribute_single->h5sclose_f proc~add_h5_atribute_single->h5screate_simple_f proc~add_h5_atribute_single->proc~detect_precision proc~add_h5_atribute_single->h5aclose_f proc~add_h5_atribute_single->h5acreate_f proc~add_h5_atribute_single->h5awrite_f proc~add_h5_atribute_str_v1->h5sclose_f proc~add_h5_atribute_str_v1->h5tcopy_f proc~add_h5_atribute_str_v1->h5screate_simple_f proc~add_h5_atribute_str_v1->h5tset_size_f proc~add_h5_atribute_str_v1->h5tclose_f proc~add_h5_atribute_str_v1->h5aclose_f proc~add_h5_atribute_str_v1->h5acreate_f proc~add_h5_atribute_str_v1->h5awrite_f var panprocpwfield_3d_pipeCallsGraph = svgPanZoom('#procpwfield_3d_pipeCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~pwfield_3d_pipe~~CalledByGraph proc~pwfield_3d_pipe pwfield_3d_pipe interface~pwfield_pipe pwfield_pipe interface~pwfield_pipe->proc~pwfield_3d_pipe proc~writehdf5_3d writehdf5_3d proc~writehdf5_3d->interface~pwfield_pipe proc~writehdf5_2dslice writehdf5_2dslice proc~writehdf5_2dslice->interface~pwfield_pipe Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/pwfield_3d_pipe.html"},{"title":"pwfield_2d_pipe – QuickPIC","text":"private subroutine pwfield_2d_pipe(pp, perr, file, fd, gs, ls, noff, rtag, stag, id, ierr) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( hdf5file ), intent(in) :: file real, intent(in), dimension(:,:) :: fd integer, intent(in), dimension(2) :: gs integer, intent(in), dimension(2) :: ls integer, intent(in), dimension(2) :: noff integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id integer, intent(inout) :: ierr Calls proc~~pwfield_2d_pipe~~CallsGraph proc~pwfield_2d_pipe pwfield_2d_pipe h5gopen_f h5gopen_f proc~pwfield_2d_pipe->h5gopen_f proc~wrattr_file wrattr_file proc~pwfield_2d_pipe->proc~wrattr_file h5sclose_f h5sclose_f proc~pwfield_2d_pipe->h5sclose_f h5tcopy_f h5tcopy_f proc~pwfield_2d_pipe->h5tcopy_f h5aopen_by_name_f h5aopen_by_name_f proc~pwfield_2d_pipe->h5aopen_by_name_f mpi_isend mpi_isend proc~pwfield_2d_pipe->mpi_isend h5pset_dxpl_mpio_f h5pset_dxpl_mpio_f proc~pwfield_2d_pipe->h5pset_dxpl_mpio_f h5screate_simple_f h5screate_simple_f proc~pwfield_2d_pipe->h5screate_simple_f h5gclose_f h5gclose_f proc~pwfield_2d_pipe->h5gclose_f h5tset_size_f h5tset_size_f proc~pwfield_2d_pipe->h5tset_size_f h5open_f h5open_f proc~pwfield_2d_pipe->h5open_f h5pcreate_f h5pcreate_f proc~pwfield_2d_pipe->h5pcreate_f proc~wrattr_dataset wrattr_dataset proc~pwfield_2d_pipe->proc~wrattr_dataset h5dcreate_f h5dcreate_f proc~pwfield_2d_pipe->h5dcreate_f mpi_irecv mpi_irecv proc~pwfield_2d_pipe->mpi_irecv h5tclose_f h5tclose_f proc~pwfield_2d_pipe->h5tclose_f h5fclose_f h5fclose_f proc~pwfield_2d_pipe->h5fclose_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~pwfield_2d_pipe->h5sselect_hyperslab_f h5dclose_f h5dclose_f proc~pwfield_2d_pipe->h5dclose_f h5aread_f h5aread_f proc~pwfield_2d_pipe->h5aread_f h5close_f h5close_f proc~pwfield_2d_pipe->h5close_f h5pclose_f h5pclose_f proc~pwfield_2d_pipe->h5pclose_f h5pset_fapl_mpio_f h5pset_fapl_mpio_f proc~pwfield_2d_pipe->h5pset_fapl_mpio_f h5dopen_f h5dopen_f proc~pwfield_2d_pipe->h5dopen_f h5fopen_f h5fopen_f proc~pwfield_2d_pipe->h5fopen_f proc~detect_precision detect_precision proc~pwfield_2d_pipe->proc~detect_precision h5fcreate_f h5fcreate_f proc~pwfield_2d_pipe->h5fcreate_f mpi_wait mpi_wait proc~pwfield_2d_pipe->mpi_wait h5aclose_f h5aclose_f proc~pwfield_2d_pipe->h5aclose_f proc~wrattr_file->h5gopen_f proc~wrattr_file->h5sclose_f proc~wrattr_file->h5screate_simple_f proc~wrattr_file->h5gclose_f proc~wrattr_file->h5dclose_f proc~wrattr_file->proc~detect_precision h5dwrite_f h5dwrite_f proc~wrattr_file->h5dwrite_f h5gcreate_f h5gcreate_f proc~wrattr_file->h5gcreate_f interface~add_h5_atribute add_h5_atribute proc~wrattr_file->interface~add_h5_atribute proc~wrattr_dataset->interface~add_h5_atribute proc~add_h5_atribute_str add_h5_atribute_str interface~add_h5_atribute->proc~add_h5_atribute_str proc~add_h5_atribute_int add_h5_atribute_int interface~add_h5_atribute->proc~add_h5_atribute_int proc~add_h5_atribute_v1_int add_h5_atribute_v1_int interface~add_h5_atribute->proc~add_h5_atribute_v1_int proc~add_h5_atribute_v1_single add_h5_atribute_v1_single interface~add_h5_atribute->proc~add_h5_atribute_v1_single proc~add_h5_atribute_single add_h5_atribute_single interface~add_h5_atribute->proc~add_h5_atribute_single proc~add_h5_atribute_str_v1 add_h5_atribute_str_v1 interface~add_h5_atribute->proc~add_h5_atribute_str_v1 proc~add_h5_atribute_str->h5sclose_f proc~add_h5_atribute_str->h5tcopy_f proc~add_h5_atribute_str->h5screate_simple_f proc~add_h5_atribute_str->h5tset_size_f proc~add_h5_atribute_str->h5tclose_f proc~add_h5_atribute_str->h5aclose_f h5acreate_f h5acreate_f proc~add_h5_atribute_str->h5acreate_f h5awrite_f h5awrite_f proc~add_h5_atribute_str->h5awrite_f proc~add_h5_atribute_int->h5sclose_f proc~add_h5_atribute_int->h5screate_simple_f proc~add_h5_atribute_int->h5aclose_f proc~add_h5_atribute_int->h5acreate_f proc~add_h5_atribute_int->h5awrite_f proc~add_h5_atribute_v1_int->h5sclose_f proc~add_h5_atribute_v1_int->h5screate_simple_f proc~add_h5_atribute_v1_int->h5aclose_f proc~add_h5_atribute_v1_int->h5acreate_f proc~add_h5_atribute_v1_int->h5awrite_f proc~add_h5_atribute_v1_single->h5sclose_f proc~add_h5_atribute_v1_single->h5screate_simple_f proc~add_h5_atribute_v1_single->proc~detect_precision proc~add_h5_atribute_v1_single->h5aclose_f proc~add_h5_atribute_v1_single->h5acreate_f proc~add_h5_atribute_v1_single->h5awrite_f proc~add_h5_atribute_single->h5sclose_f proc~add_h5_atribute_single->h5screate_simple_f proc~add_h5_atribute_single->proc~detect_precision proc~add_h5_atribute_single->h5aclose_f proc~add_h5_atribute_single->h5acreate_f proc~add_h5_atribute_single->h5awrite_f proc~add_h5_atribute_str_v1->h5sclose_f proc~add_h5_atribute_str_v1->h5tcopy_f proc~add_h5_atribute_str_v1->h5screate_simple_f proc~add_h5_atribute_str_v1->h5tset_size_f proc~add_h5_atribute_str_v1->h5tclose_f proc~add_h5_atribute_str_v1->h5aclose_f proc~add_h5_atribute_str_v1->h5acreate_f proc~add_h5_atribute_str_v1->h5awrite_f var panprocpwfield_2d_pipeCallsGraph = svgPanZoom('#procpwfield_2d_pipeCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~pwfield_2d_pipe~~CalledByGraph proc~pwfield_2d_pipe pwfield_2d_pipe interface~pwfield_pipe pwfield_pipe interface~pwfield_pipe->proc~pwfield_2d_pipe proc~writehdf5_3d writehdf5_3d proc~writehdf5_3d->interface~pwfield_pipe proc~writehdf5_2dslice writehdf5_2dslice proc~writehdf5_2dslice->interface~pwfield_pipe Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/pwfield_2d_pipe.html"},{"title":"wfield_2d_pipe – QuickPIC","text":"private subroutine wfield_2d_pipe(pp, perr, file, fd, gs, ls, noff, rtag, stag, id, ierr) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( hdf5file ), intent(in) :: file real, intent(in), dimension(:,:) :: fd integer, intent(in), dimension(2) :: gs integer, intent(in), dimension(2) :: ls integer, intent(in), dimension(2) :: noff integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id integer, intent(inout) :: ierr Calls proc~~wfield_2d_pipe~~CallsGraph proc~wfield_2d_pipe wfield_2d_pipe h5gopen_f h5gopen_f proc~wfield_2d_pipe->h5gopen_f proc~wrattr_file wrattr_file proc~wfield_2d_pipe->proc~wrattr_file h5sclose_f h5sclose_f proc~wfield_2d_pipe->h5sclose_f h5tcopy_f h5tcopy_f proc~wfield_2d_pipe->h5tcopy_f h5aopen_by_name_f h5aopen_by_name_f proc~wfield_2d_pipe->h5aopen_by_name_f mpi_isend mpi_isend proc~wfield_2d_pipe->mpi_isend h5screate_simple_f h5screate_simple_f proc~wfield_2d_pipe->h5screate_simple_f h5gclose_f h5gclose_f proc~wfield_2d_pipe->h5gclose_f h5tset_size_f h5tset_size_f proc~wfield_2d_pipe->h5tset_size_f h5open_f h5open_f proc~wfield_2d_pipe->h5open_f proc~wrattr_dataset wrattr_dataset proc~wfield_2d_pipe->proc~wrattr_dataset h5dcreate_f h5dcreate_f proc~wfield_2d_pipe->h5dcreate_f mpi_irecv mpi_irecv proc~wfield_2d_pipe->mpi_irecv h5tclose_f h5tclose_f proc~wfield_2d_pipe->h5tclose_f h5fclose_f h5fclose_f proc~wfield_2d_pipe->h5fclose_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~wfield_2d_pipe->h5sselect_hyperslab_f h5dclose_f h5dclose_f proc~wfield_2d_pipe->h5dclose_f h5aread_f h5aread_f proc~wfield_2d_pipe->h5aread_f h5close_f h5close_f proc~wfield_2d_pipe->h5close_f h5dopen_f h5dopen_f proc~wfield_2d_pipe->h5dopen_f h5fopen_f h5fopen_f proc~wfield_2d_pipe->h5fopen_f proc~detect_precision detect_precision proc~wfield_2d_pipe->proc~detect_precision h5fcreate_f h5fcreate_f proc~wfield_2d_pipe->h5fcreate_f mpi_wait mpi_wait proc~wfield_2d_pipe->mpi_wait h5aclose_f h5aclose_f proc~wfield_2d_pipe->h5aclose_f proc~wrattr_file->h5gopen_f proc~wrattr_file->h5sclose_f proc~wrattr_file->h5screate_simple_f proc~wrattr_file->h5gclose_f proc~wrattr_file->h5dclose_f proc~wrattr_file->proc~detect_precision h5dwrite_f h5dwrite_f proc~wrattr_file->h5dwrite_f h5gcreate_f h5gcreate_f proc~wrattr_file->h5gcreate_f interface~add_h5_atribute add_h5_atribute proc~wrattr_file->interface~add_h5_atribute proc~wrattr_dataset->interface~add_h5_atribute proc~add_h5_atribute_str add_h5_atribute_str interface~add_h5_atribute->proc~add_h5_atribute_str proc~add_h5_atribute_int add_h5_atribute_int interface~add_h5_atribute->proc~add_h5_atribute_int proc~add_h5_atribute_v1_int add_h5_atribute_v1_int interface~add_h5_atribute->proc~add_h5_atribute_v1_int proc~add_h5_atribute_v1_single add_h5_atribute_v1_single interface~add_h5_atribute->proc~add_h5_atribute_v1_single proc~add_h5_atribute_single add_h5_atribute_single interface~add_h5_atribute->proc~add_h5_atribute_single proc~add_h5_atribute_str_v1 add_h5_atribute_str_v1 interface~add_h5_atribute->proc~add_h5_atribute_str_v1 proc~add_h5_atribute_str->h5sclose_f proc~add_h5_atribute_str->h5tcopy_f proc~add_h5_atribute_str->h5screate_simple_f proc~add_h5_atribute_str->h5tset_size_f proc~add_h5_atribute_str->h5tclose_f proc~add_h5_atribute_str->h5aclose_f h5acreate_f h5acreate_f proc~add_h5_atribute_str->h5acreate_f h5awrite_f h5awrite_f proc~add_h5_atribute_str->h5awrite_f proc~add_h5_atribute_int->h5sclose_f proc~add_h5_atribute_int->h5screate_simple_f proc~add_h5_atribute_int->h5aclose_f proc~add_h5_atribute_int->h5acreate_f proc~add_h5_atribute_int->h5awrite_f proc~add_h5_atribute_v1_int->h5sclose_f proc~add_h5_atribute_v1_int->h5screate_simple_f proc~add_h5_atribute_v1_int->h5aclose_f proc~add_h5_atribute_v1_int->h5acreate_f proc~add_h5_atribute_v1_int->h5awrite_f proc~add_h5_atribute_v1_single->h5sclose_f proc~add_h5_atribute_v1_single->h5screate_simple_f proc~add_h5_atribute_v1_single->proc~detect_precision proc~add_h5_atribute_v1_single->h5aclose_f proc~add_h5_atribute_v1_single->h5acreate_f proc~add_h5_atribute_v1_single->h5awrite_f proc~add_h5_atribute_single->h5sclose_f proc~add_h5_atribute_single->h5screate_simple_f proc~add_h5_atribute_single->proc~detect_precision proc~add_h5_atribute_single->h5aclose_f proc~add_h5_atribute_single->h5acreate_f proc~add_h5_atribute_single->h5awrite_f proc~add_h5_atribute_str_v1->h5sclose_f proc~add_h5_atribute_str_v1->h5tcopy_f proc~add_h5_atribute_str_v1->h5screate_simple_f proc~add_h5_atribute_str_v1->h5tset_size_f proc~add_h5_atribute_str_v1->h5tclose_f proc~add_h5_atribute_str_v1->h5aclose_f proc~add_h5_atribute_str_v1->h5acreate_f proc~add_h5_atribute_str_v1->h5awrite_f var panprocwfield_2d_pipeCallsGraph = svgPanZoom('#procwfield_2d_pipeCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~wfield_2d_pipe~~CalledByGraph proc~wfield_2d_pipe wfield_2d_pipe interface~wfield_pipe wfield_pipe interface~wfield_pipe->proc~wfield_2d_pipe proc~writehdf5_2dslice writehdf5_2dslice proc~writehdf5_2dslice->interface~wfield_pipe Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/wfield_2d_pipe.html"},{"title":"pwpart_2d – QuickPIC","text":"private subroutine pwpart_2d(pp, perr, file, part, npp, dspl, delta, ierr) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( hdf5file ), intent(in) :: file real, intent(in), dimension(:,:) :: part integer, intent(in) :: npp integer, intent(in) :: dspl real, intent(in), dimension(2) :: delta integer, intent(inout) :: ierr Calls proc~~pwpart_2d~~CallsGraph proc~pwpart_2d pwpart_2d h5gopen_f h5gopen_f proc~pwpart_2d->h5gopen_f proc~wrattr_file wrattr_file proc~pwpart_2d->proc~wrattr_file h5aclose_f h5aclose_f proc~pwpart_2d->h5aclose_f h5sclose_f h5sclose_f proc~pwpart_2d->h5sclose_f mpi_comm_rank mpi_comm_rank proc~pwpart_2d->mpi_comm_rank h5pset_dxpl_mpio_f h5pset_dxpl_mpio_f proc~pwpart_2d->h5pset_dxpl_mpio_f h5screate_simple_f h5screate_simple_f proc~pwpart_2d->h5screate_simple_f h5gclose_f h5gclose_f proc~pwpart_2d->h5gclose_f h5pcreate_f h5pcreate_f proc~pwpart_2d->h5pcreate_f h5open_f h5open_f proc~pwpart_2d->h5open_f mpi_allreduce mpi_allreduce proc~pwpart_2d->mpi_allreduce h5acreate_f h5acreate_f proc~pwpart_2d->h5acreate_f proc~wrattr_dataset wrattr_dataset proc~pwpart_2d->proc~wrattr_dataset h5dcreate_f h5dcreate_f proc~pwpart_2d->h5dcreate_f mpi_comm_free mpi_comm_free proc~pwpart_2d->mpi_comm_free mpi_allgather mpi_allgather proc~pwpart_2d->mpi_allgather h5fclose_f h5fclose_f proc~pwpart_2d->h5fclose_f mpi_comm_split mpi_comm_split proc~pwpart_2d->mpi_comm_split h5sselect_hyperslab_f h5sselect_hyperslab_f proc~pwpart_2d->h5sselect_hyperslab_f h5dclose_f h5dclose_f proc~pwpart_2d->h5dclose_f h5close_f h5close_f proc~pwpart_2d->h5close_f h5pclose_f h5pclose_f proc~pwpart_2d->h5pclose_f h5pset_fapl_mpio_f h5pset_fapl_mpio_f proc~pwpart_2d->h5pset_fapl_mpio_f h5dwrite_f h5dwrite_f proc~pwpart_2d->h5dwrite_f h5awrite_f h5awrite_f proc~pwpart_2d->h5awrite_f proc~detect_precision detect_precision proc~pwpart_2d->proc~detect_precision mpi_comm_size mpi_comm_size proc~pwpart_2d->mpi_comm_size h5fcreate_f h5fcreate_f proc~pwpart_2d->h5fcreate_f proc~wrattr_file->h5gopen_f proc~wrattr_file->h5sclose_f proc~wrattr_file->h5screate_simple_f proc~wrattr_file->h5gclose_f proc~wrattr_file->h5dclose_f proc~wrattr_file->h5dwrite_f proc~wrattr_file->proc~detect_precision h5gcreate_f h5gcreate_f proc~wrattr_file->h5gcreate_f interface~add_h5_atribute add_h5_atribute proc~wrattr_file->interface~add_h5_atribute proc~wrattr_dataset->interface~add_h5_atribute proc~add_h5_atribute_str add_h5_atribute_str interface~add_h5_atribute->proc~add_h5_atribute_str proc~add_h5_atribute_int add_h5_atribute_int interface~add_h5_atribute->proc~add_h5_atribute_int proc~add_h5_atribute_v1_int add_h5_atribute_v1_int interface~add_h5_atribute->proc~add_h5_atribute_v1_int proc~add_h5_atribute_v1_single add_h5_atribute_v1_single interface~add_h5_atribute->proc~add_h5_atribute_v1_single proc~add_h5_atribute_single add_h5_atribute_single interface~add_h5_atribute->proc~add_h5_atribute_single proc~add_h5_atribute_str_v1 add_h5_atribute_str_v1 interface~add_h5_atribute->proc~add_h5_atribute_str_v1 proc~add_h5_atribute_str->h5aclose_f proc~add_h5_atribute_str->h5sclose_f proc~add_h5_atribute_str->h5screate_simple_f proc~add_h5_atribute_str->h5acreate_f proc~add_h5_atribute_str->h5awrite_f h5tset_size_f h5tset_size_f proc~add_h5_atribute_str->h5tset_size_f h5tcopy_f h5tcopy_f proc~add_h5_atribute_str->h5tcopy_f h5tclose_f h5tclose_f proc~add_h5_atribute_str->h5tclose_f proc~add_h5_atribute_int->h5aclose_f proc~add_h5_atribute_int->h5sclose_f proc~add_h5_atribute_int->h5screate_simple_f proc~add_h5_atribute_int->h5acreate_f proc~add_h5_atribute_int->h5awrite_f proc~add_h5_atribute_v1_int->h5aclose_f proc~add_h5_atribute_v1_int->h5sclose_f proc~add_h5_atribute_v1_int->h5screate_simple_f proc~add_h5_atribute_v1_int->h5acreate_f proc~add_h5_atribute_v1_int->h5awrite_f proc~add_h5_atribute_v1_single->h5aclose_f proc~add_h5_atribute_v1_single->h5sclose_f proc~add_h5_atribute_v1_single->h5screate_simple_f proc~add_h5_atribute_v1_single->h5acreate_f proc~add_h5_atribute_v1_single->h5awrite_f proc~add_h5_atribute_v1_single->proc~detect_precision proc~add_h5_atribute_single->h5aclose_f proc~add_h5_atribute_single->h5sclose_f proc~add_h5_atribute_single->h5screate_simple_f proc~add_h5_atribute_single->h5acreate_f proc~add_h5_atribute_single->h5awrite_f proc~add_h5_atribute_single->proc~detect_precision proc~add_h5_atribute_str_v1->h5aclose_f proc~add_h5_atribute_str_v1->h5sclose_f proc~add_h5_atribute_str_v1->h5screate_simple_f proc~add_h5_atribute_str_v1->h5acreate_f proc~add_h5_atribute_str_v1->h5awrite_f proc~add_h5_atribute_str_v1->h5tset_size_f proc~add_h5_atribute_str_v1->h5tcopy_f proc~add_h5_atribute_str_v1->h5tclose_f var panprocpwpart_2dCallsGraph = svgPanZoom('#procpwpart_2dCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~pwpart_2d~~CalledByGraph proc~pwpart_2d pwpart_2d interface~pwpart pwpart interface~pwpart->proc~pwpart_2d proc~writehdf5_part2d writehdf5_part2d proc~writehdf5_part2d->interface~pwpart Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/pwpart_2d.html"},{"title":"pwpart_3d_pipe – QuickPIC","text":"private subroutine pwpart_3d_pipe(pp, perr, file, part, npp, dspl, delta, rtag, stag, id, ierr) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( hdf5file ), intent(in) :: file real, intent(in), dimension(:,:) :: part integer, intent(in) :: npp integer, intent(in) :: dspl real, intent(in), dimension(3) :: delta integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id integer, intent(inout) :: ierr Calls proc~~pwpart_3d_pipe~~CallsGraph proc~pwpart_3d_pipe pwpart_3d_pipe h5gopen_f h5gopen_f proc~pwpart_3d_pipe->h5gopen_f proc~wrattr_file wrattr_file proc~pwpart_3d_pipe->proc~wrattr_file h5aclose_f h5aclose_f proc~pwpart_3d_pipe->h5aclose_f h5sclose_f h5sclose_f proc~pwpart_3d_pipe->h5sclose_f h5pset_chunk_f h5pset_chunk_f proc~pwpart_3d_pipe->h5pset_chunk_f mpi_comm_rank mpi_comm_rank proc~pwpart_3d_pipe->mpi_comm_rank mpi_isend mpi_isend proc~pwpart_3d_pipe->mpi_isend h5pset_dxpl_mpio_f h5pset_dxpl_mpio_f proc~pwpart_3d_pipe->h5pset_dxpl_mpio_f h5screate_simple_f h5screate_simple_f proc~pwpart_3d_pipe->h5screate_simple_f h5gclose_f h5gclose_f proc~pwpart_3d_pipe->h5gclose_f h5open_f h5open_f proc~pwpart_3d_pipe->h5open_f h5pcreate_f h5pcreate_f proc~pwpart_3d_pipe->h5pcreate_f mpi_allreduce mpi_allreduce proc~pwpart_3d_pipe->mpi_allreduce h5acreate_f h5acreate_f proc~pwpart_3d_pipe->h5acreate_f proc~wrattr_dataset wrattr_dataset proc~pwpart_3d_pipe->proc~wrattr_dataset h5dcreate_f h5dcreate_f proc~pwpart_3d_pipe->h5dcreate_f mpi_comm_free mpi_comm_free proc~pwpart_3d_pipe->mpi_comm_free mpi_allgather mpi_allgather proc~pwpart_3d_pipe->mpi_allgather mpi_irecv mpi_irecv proc~pwpart_3d_pipe->mpi_irecv h5aopen_f h5aopen_f proc~pwpart_3d_pipe->h5aopen_f h5fclose_f h5fclose_f proc~pwpart_3d_pipe->h5fclose_f mpi_comm_split mpi_comm_split proc~pwpart_3d_pipe->mpi_comm_split h5sselect_hyperslab_f h5sselect_hyperslab_f proc~pwpart_3d_pipe->h5sselect_hyperslab_f h5dclose_f h5dclose_f proc~pwpart_3d_pipe->h5dclose_f h5aread_f h5aread_f proc~pwpart_3d_pipe->h5aread_f h5close_f h5close_f proc~pwpart_3d_pipe->h5close_f h5pclose_f h5pclose_f proc~pwpart_3d_pipe->h5pclose_f h5dextend_f h5dextend_f proc~pwpart_3d_pipe->h5dextend_f h5pset_fapl_mpio_f h5pset_fapl_mpio_f proc~pwpart_3d_pipe->h5pset_fapl_mpio_f h5dopen_f h5dopen_f proc~pwpart_3d_pipe->h5dopen_f h5fopen_f h5fopen_f proc~pwpart_3d_pipe->h5fopen_f h5dwrite_f h5dwrite_f proc~pwpart_3d_pipe->h5dwrite_f h5awrite_f h5awrite_f proc~pwpart_3d_pipe->h5awrite_f proc~detect_precision detect_precision proc~pwpart_3d_pipe->proc~detect_precision mpi_comm_size mpi_comm_size proc~pwpart_3d_pipe->mpi_comm_size mpi_wait mpi_wait proc~pwpart_3d_pipe->mpi_wait h5fcreate_f h5fcreate_f proc~pwpart_3d_pipe->h5fcreate_f proc~wrattr_file->h5gopen_f proc~wrattr_file->h5sclose_f proc~wrattr_file->h5screate_simple_f proc~wrattr_file->h5gclose_f proc~wrattr_file->h5dclose_f proc~wrattr_file->h5dwrite_f proc~wrattr_file->proc~detect_precision h5gcreate_f h5gcreate_f proc~wrattr_file->h5gcreate_f interface~add_h5_atribute add_h5_atribute proc~wrattr_file->interface~add_h5_atribute proc~wrattr_dataset->interface~add_h5_atribute proc~add_h5_atribute_str add_h5_atribute_str interface~add_h5_atribute->proc~add_h5_atribute_str proc~add_h5_atribute_int add_h5_atribute_int interface~add_h5_atribute->proc~add_h5_atribute_int proc~add_h5_atribute_v1_int add_h5_atribute_v1_int interface~add_h5_atribute->proc~add_h5_atribute_v1_int proc~add_h5_atribute_v1_single add_h5_atribute_v1_single interface~add_h5_atribute->proc~add_h5_atribute_v1_single proc~add_h5_atribute_single add_h5_atribute_single interface~add_h5_atribute->proc~add_h5_atribute_single proc~add_h5_atribute_str_v1 add_h5_atribute_str_v1 interface~add_h5_atribute->proc~add_h5_atribute_str_v1 proc~add_h5_atribute_str->h5aclose_f proc~add_h5_atribute_str->h5sclose_f proc~add_h5_atribute_str->h5screate_simple_f proc~add_h5_atribute_str->h5acreate_f proc~add_h5_atribute_str->h5awrite_f h5tset_size_f h5tset_size_f proc~add_h5_atribute_str->h5tset_size_f h5tcopy_f h5tcopy_f proc~add_h5_atribute_str->h5tcopy_f h5tclose_f h5tclose_f proc~add_h5_atribute_str->h5tclose_f proc~add_h5_atribute_int->h5aclose_f proc~add_h5_atribute_int->h5sclose_f proc~add_h5_atribute_int->h5screate_simple_f proc~add_h5_atribute_int->h5acreate_f proc~add_h5_atribute_int->h5awrite_f proc~add_h5_atribute_v1_int->h5aclose_f proc~add_h5_atribute_v1_int->h5sclose_f proc~add_h5_atribute_v1_int->h5screate_simple_f proc~add_h5_atribute_v1_int->h5acreate_f proc~add_h5_atribute_v1_int->h5awrite_f proc~add_h5_atribute_v1_single->h5aclose_f proc~add_h5_atribute_v1_single->h5sclose_f proc~add_h5_atribute_v1_single->h5screate_simple_f proc~add_h5_atribute_v1_single->h5acreate_f proc~add_h5_atribute_v1_single->h5awrite_f proc~add_h5_atribute_v1_single->proc~detect_precision proc~add_h5_atribute_single->h5aclose_f proc~add_h5_atribute_single->h5sclose_f proc~add_h5_atribute_single->h5screate_simple_f proc~add_h5_atribute_single->h5acreate_f proc~add_h5_atribute_single->h5awrite_f proc~add_h5_atribute_single->proc~detect_precision proc~add_h5_atribute_str_v1->h5aclose_f proc~add_h5_atribute_str_v1->h5sclose_f proc~add_h5_atribute_str_v1->h5screate_simple_f proc~add_h5_atribute_str_v1->h5acreate_f proc~add_h5_atribute_str_v1->h5awrite_f proc~add_h5_atribute_str_v1->h5tset_size_f proc~add_h5_atribute_str_v1->h5tcopy_f proc~add_h5_atribute_str_v1->h5tclose_f var panprocpwpart_3d_pipeCallsGraph = svgPanZoom('#procpwpart_3d_pipeCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~pwpart_3d_pipe~~CalledByGraph proc~pwpart_3d_pipe pwpart_3d_pipe interface~pwpart_pipe pwpart_pipe interface~pwpart_pipe->proc~pwpart_3d_pipe proc~writehdf5_part3d writehdf5_part3d proc~writehdf5_part3d->interface~pwpart_pipe Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/pwpart_3d_pipe.html"},{"title":"wpart – QuickPIC","text":"public subroutine wpart(pp, perr, file, part, npp, dspl, ierr) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( hdf5file ), intent(in) :: file real, intent(in), dimension(:,:) :: part integer, intent(in) :: npp integer, intent(in) :: dspl integer, intent(inout) :: ierr Calls proc~~wpart~~CallsGraph proc~wpart wpart h5screate_simple_f h5screate_simple_f proc~wpart->h5screate_simple_f h5gclose_f h5gclose_f proc~wpart->h5gclose_f h5gopen_f h5gopen_f proc~wpart->h5gopen_f h5fclose_f h5fclose_f proc~wpart->h5fclose_f proc~wrattr_file wrattr_file proc~wpart->proc~wrattr_file h5sclose_f h5sclose_f proc~wpart->h5sclose_f h5open_f h5open_f proc~wpart->h5open_f h5acreate_f h5acreate_f proc~wpart->h5acreate_f h5awrite_f h5awrite_f proc~wpart->h5awrite_f proc~wrattr_dataset wrattr_dataset proc~wpart->proc~wrattr_dataset h5dclose_f h5dclose_f proc~wpart->h5dclose_f proc~detect_precision detect_precision proc~wpart->proc~detect_precision h5fcreate_f h5fcreate_f proc~wpart->h5fcreate_f h5dcreate_f h5dcreate_f proc~wpart->h5dcreate_f h5close_f h5close_f proc~wpart->h5close_f h5aclose_f h5aclose_f proc~wpart->h5aclose_f proc~wrattr_file->h5screate_simple_f proc~wrattr_file->h5gclose_f proc~wrattr_file->h5gopen_f proc~wrattr_file->h5sclose_f proc~wrattr_file->h5dclose_f proc~wrattr_file->proc~detect_precision h5dwrite_f h5dwrite_f proc~wrattr_file->h5dwrite_f h5gcreate_f h5gcreate_f proc~wrattr_file->h5gcreate_f interface~add_h5_atribute add_h5_atribute proc~wrattr_file->interface~add_h5_atribute proc~wrattr_dataset->interface~add_h5_atribute proc~add_h5_atribute_str add_h5_atribute_str interface~add_h5_atribute->proc~add_h5_atribute_str proc~add_h5_atribute_int add_h5_atribute_int interface~add_h5_atribute->proc~add_h5_atribute_int proc~add_h5_atribute_v1_int add_h5_atribute_v1_int interface~add_h5_atribute->proc~add_h5_atribute_v1_int proc~add_h5_atribute_v1_single add_h5_atribute_v1_single interface~add_h5_atribute->proc~add_h5_atribute_v1_single proc~add_h5_atribute_single add_h5_atribute_single interface~add_h5_atribute->proc~add_h5_atribute_single proc~add_h5_atribute_str_v1 add_h5_atribute_str_v1 interface~add_h5_atribute->proc~add_h5_atribute_str_v1 proc~add_h5_atribute_str->h5screate_simple_f proc~add_h5_atribute_str->h5sclose_f proc~add_h5_atribute_str->h5acreate_f proc~add_h5_atribute_str->h5awrite_f proc~add_h5_atribute_str->h5aclose_f h5tset_size_f h5tset_size_f proc~add_h5_atribute_str->h5tset_size_f h5tcopy_f h5tcopy_f proc~add_h5_atribute_str->h5tcopy_f h5tclose_f h5tclose_f proc~add_h5_atribute_str->h5tclose_f proc~add_h5_atribute_int->h5screate_simple_f proc~add_h5_atribute_int->h5sclose_f proc~add_h5_atribute_int->h5acreate_f proc~add_h5_atribute_int->h5awrite_f proc~add_h5_atribute_int->h5aclose_f proc~add_h5_atribute_v1_int->h5screate_simple_f proc~add_h5_atribute_v1_int->h5sclose_f proc~add_h5_atribute_v1_int->h5acreate_f proc~add_h5_atribute_v1_int->h5awrite_f proc~add_h5_atribute_v1_int->h5aclose_f proc~add_h5_atribute_v1_single->h5screate_simple_f proc~add_h5_atribute_v1_single->h5sclose_f proc~add_h5_atribute_v1_single->h5acreate_f proc~add_h5_atribute_v1_single->h5awrite_f proc~add_h5_atribute_v1_single->proc~detect_precision proc~add_h5_atribute_v1_single->h5aclose_f proc~add_h5_atribute_single->h5screate_simple_f proc~add_h5_atribute_single->h5sclose_f proc~add_h5_atribute_single->h5acreate_f proc~add_h5_atribute_single->h5awrite_f proc~add_h5_atribute_single->proc~detect_precision proc~add_h5_atribute_single->h5aclose_f proc~add_h5_atribute_str_v1->h5screate_simple_f proc~add_h5_atribute_str_v1->h5sclose_f proc~add_h5_atribute_str_v1->h5acreate_f proc~add_h5_atribute_str_v1->h5awrite_f proc~add_h5_atribute_str_v1->h5aclose_f proc~add_h5_atribute_str_v1->h5tset_size_f proc~add_h5_atribute_str_v1->h5tcopy_f proc~add_h5_atribute_str_v1->h5tclose_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~wpart~~CalledByGraph proc~wpart wpart proc~writerst_part3d writerst_part3d proc~writerst_part3d->proc~wpart Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/wpart.html"},{"title":"rpart – QuickPIC","text":"public subroutine rpart(pp, perr, file, part, npp, ierr) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( hdf5file ), intent(in) :: file real, intent(inout), dimension(:,:) :: part integer, intent(out) :: npp integer, intent(inout) :: ierr Calls proc~~rpart~~CallsGraph proc~rpart rpart h5screate_simple_f h5screate_simple_f proc~rpart->h5screate_simple_f h5gclose_f h5gclose_f proc~rpart->h5gclose_f h5gopen_f h5gopen_f proc~rpart->h5gopen_f h5dopen_f h5dopen_f proc~rpart->h5dopen_f h5fclose_f h5fclose_f proc~rpart->h5fclose_f h5aopen_f h5aopen_f proc~rpart->h5aopen_f h5sclose_f h5sclose_f proc~rpart->h5sclose_f h5open_f h5open_f proc~rpart->h5open_f h5fopen_f h5fopen_f proc~rpart->h5fopen_f h5aread_f h5aread_f proc~rpart->h5aread_f h5dclose_f h5dclose_f proc~rpart->h5dclose_f h5dread_f h5dread_f proc~rpart->h5dread_f proc~detect_precision detect_precision proc~rpart->proc~detect_precision h5close_f h5close_f proc~rpart->h5close_f h5aclose_f h5aclose_f proc~rpart->h5aclose_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rpart~~CalledByGraph proc~rpart rpart proc~readrst_part3d readrst_part3d proc~readrst_part3d->proc~rpart Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rpart.html"},{"title":"add_h5_atribute – QuickPIC","text":"private interface add_h5_atribute Calls interface~~add_h5_atribute~~CallsGraph interface~add_h5_atribute add_h5_atribute proc~add_h5_atribute_str add_h5_atribute_str interface~add_h5_atribute->proc~add_h5_atribute_str proc~add_h5_atribute_int add_h5_atribute_int interface~add_h5_atribute->proc~add_h5_atribute_int proc~add_h5_atribute_v1_int add_h5_atribute_v1_int interface~add_h5_atribute->proc~add_h5_atribute_v1_int proc~add_h5_atribute_v1_single add_h5_atribute_v1_single interface~add_h5_atribute->proc~add_h5_atribute_v1_single proc~add_h5_atribute_single add_h5_atribute_single interface~add_h5_atribute->proc~add_h5_atribute_single proc~add_h5_atribute_str_v1 add_h5_atribute_str_v1 interface~add_h5_atribute->proc~add_h5_atribute_str_v1 h5screate_simple_f h5screate_simple_f proc~add_h5_atribute_str->h5screate_simple_f h5tset_size_f h5tset_size_f proc~add_h5_atribute_str->h5tset_size_f h5sclose_f h5sclose_f proc~add_h5_atribute_str->h5sclose_f h5acreate_f h5acreate_f proc~add_h5_atribute_str->h5acreate_f h5awrite_f h5awrite_f proc~add_h5_atribute_str->h5awrite_f h5tcopy_f h5tcopy_f proc~add_h5_atribute_str->h5tcopy_f h5aclose_f h5aclose_f proc~add_h5_atribute_str->h5aclose_f h5tclose_f h5tclose_f proc~add_h5_atribute_str->h5tclose_f proc~add_h5_atribute_int->h5screate_simple_f proc~add_h5_atribute_int->h5sclose_f proc~add_h5_atribute_int->h5acreate_f proc~add_h5_atribute_int->h5awrite_f proc~add_h5_atribute_int->h5aclose_f proc~add_h5_atribute_v1_int->h5screate_simple_f proc~add_h5_atribute_v1_int->h5sclose_f proc~add_h5_atribute_v1_int->h5acreate_f proc~add_h5_atribute_v1_int->h5awrite_f proc~add_h5_atribute_v1_int->h5aclose_f proc~add_h5_atribute_v1_single->h5screate_simple_f proc~add_h5_atribute_v1_single->h5sclose_f proc~add_h5_atribute_v1_single->h5acreate_f proc~add_h5_atribute_v1_single->h5awrite_f proc~detect_precision detect_precision proc~add_h5_atribute_v1_single->proc~detect_precision proc~add_h5_atribute_v1_single->h5aclose_f proc~add_h5_atribute_single->h5screate_simple_f proc~add_h5_atribute_single->h5sclose_f proc~add_h5_atribute_single->h5acreate_f proc~add_h5_atribute_single->h5awrite_f proc~add_h5_atribute_single->proc~detect_precision proc~add_h5_atribute_single->h5aclose_f proc~add_h5_atribute_str_v1->h5screate_simple_f proc~add_h5_atribute_str_v1->h5tset_size_f proc~add_h5_atribute_str_v1->h5sclose_f proc~add_h5_atribute_str_v1->h5acreate_f proc~add_h5_atribute_str_v1->h5awrite_f proc~add_h5_atribute_str_v1->h5tcopy_f proc~add_h5_atribute_str_v1->h5aclose_f proc~add_h5_atribute_str_v1->h5tclose_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~add_h5_atribute~~CalledByGraph interface~add_h5_atribute add_h5_atribute proc~wrattr_dataset wrattr_dataset proc~wrattr_dataset->interface~add_h5_atribute proc~wrattr_file wrattr_file proc~wrattr_file->interface~add_h5_atribute proc~pwfield_2d pwfield_2d proc~pwfield_2d->proc~wrattr_dataset proc~pwfield_2d->proc~wrattr_file proc~pwpart_3d_pipe pwpart_3d_pipe proc~pwpart_3d_pipe->proc~wrattr_dataset proc~pwpart_3d_pipe->proc~wrattr_file proc~pwfield_2d_pipe pwfield_2d_pipe proc~pwfield_2d_pipe->proc~wrattr_dataset proc~pwfield_2d_pipe->proc~wrattr_file proc~wpart wpart proc~wpart->proc~wrattr_dataset proc~wpart->proc~wrattr_file proc~wfield_2d_pipe wfield_2d_pipe proc~wfield_2d_pipe->proc~wrattr_dataset proc~wfield_2d_pipe->proc~wrattr_file proc~pwpart_2d pwpart_2d proc~pwpart_2d->proc~wrattr_dataset proc~pwpart_2d->proc~wrattr_file proc~pwfield_3d pwfield_3d proc~pwfield_3d->proc~wrattr_dataset proc~pwfield_3d->proc~wrattr_file proc~pwfield_3d_pipe pwfield_3d_pipe proc~pwfield_3d_pipe->proc~wrattr_dataset proc~pwfield_3d_pipe->proc~wrattr_file interface~pwpart_pipe pwpart_pipe interface~pwpart_pipe->proc~pwpart_3d_pipe interface~wfield_pipe wfield_pipe interface~wfield_pipe->proc~wfield_2d_pipe interface~pwfield pwfield interface~pwfield->proc~pwfield_2d interface~pwfield->proc~pwfield_3d interface~pwpart pwpart interface~pwpart->proc~pwpart_2d interface~pwfield_pipe pwfield_pipe interface~pwfield_pipe->proc~pwfield_2d_pipe interface~pwfield_pipe->proc~pwfield_3d_pipe proc~writerst_part3d writerst_part3d proc~writerst_part3d->proc~wpart proc~writehdf5 writehdf5 proc~writehdf5->interface~pwfield proc~writehdf5_2dslice writehdf5_2dslice proc~writehdf5_2dslice->interface~wfield_pipe proc~writehdf5_2dslice->interface~pwfield_pipe proc~writehdf5_part3d writehdf5_part3d proc~writehdf5_part3d->interface~pwpart_pipe proc~writehdf5_3d writehdf5_3d proc~writehdf5_3d->interface~pwfield_pipe proc~writehdf5_part2d writehdf5_part2d proc~writehdf5_part2d->interface~pwpart Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures add_h5_atribute_str add_h5_atribute_str_v1 add_h5_atribute_single add_h5_atribute_v1_single add_h5_atribute_int add_h5_atribute_v1_int Module Procedures private subroutine add_h5_atribute_str (objID, name, attribute) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: objID character(len=*), intent(in) :: name character(len=*), intent(in) :: attribute private subroutine add_h5_atribute_str_v1 (objID, name, attribute) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: objID character(len=*), intent(in) :: name character(len=*), intent(in), dimension(:) :: attribute private subroutine add_h5_atribute_single (objID, name, attribute) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: objID character(len=*), intent(in) :: name real, intent(in) :: attribute private subroutine add_h5_atribute_v1_single (objID, name, attribute) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: objID character(len=*), intent(in) :: name real, intent(in), dimension(:) :: attribute private subroutine add_h5_atribute_int (objID, name, attribute) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: objID character(len=*), intent(in) :: name integer, intent(in) :: attribute private subroutine add_h5_atribute_v1_int (objID, name, attribute) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: objID character(len=*), intent(in) :: name integer, intent(in), dimension(:) :: attribute","tags":"","loc":"interface/add_h5_atribute.html"},{"title":"pwfield – QuickPIC","text":"public interface pwfield Calls interface~~pwfield~~CallsGraph interface~pwfield pwfield proc~pwfield_2d pwfield_2d interface~pwfield->proc~pwfield_2d proc~pwfield_3d pwfield_3d interface~pwfield->proc~pwfield_3d h5screate_simple_f h5screate_simple_f proc~pwfield_2d->h5screate_simple_f h5gclose_f h5gclose_f proc~pwfield_2d->h5gclose_f h5pset_fapl_mpio_f h5pset_fapl_mpio_f proc~pwfield_2d->h5pset_fapl_mpio_f h5gopen_f h5gopen_f proc~pwfield_2d->h5gopen_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~pwfield_2d->h5sselect_hyperslab_f proc~wrattr_file wrattr_file proc~pwfield_2d->proc~wrattr_file h5fclose_f h5fclose_f proc~pwfield_2d->h5fclose_f h5sclose_f h5sclose_f proc~pwfield_2d->h5sclose_f h5open_f h5open_f proc~pwfield_2d->h5open_f h5pcreate_f h5pcreate_f proc~pwfield_2d->h5pcreate_f proc~wrattr_dataset wrattr_dataset proc~pwfield_2d->proc~wrattr_dataset h5dclose_f h5dclose_f proc~pwfield_2d->h5dclose_f proc~detect_precision detect_precision proc~pwfield_2d->proc~detect_precision h5dcreate_f h5dcreate_f proc~pwfield_2d->h5dcreate_f h5close_f h5close_f proc~pwfield_2d->h5close_f h5pclose_f h5pclose_f proc~pwfield_2d->h5pclose_f h5fcreate_f h5fcreate_f proc~pwfield_2d->h5fcreate_f h5pset_dxpl_mpio_f h5pset_dxpl_mpio_f proc~pwfield_2d->h5pset_dxpl_mpio_f proc~pwfield_3d->h5screate_simple_f proc~pwfield_3d->h5gclose_f proc~pwfield_3d->h5pset_fapl_mpio_f proc~pwfield_3d->h5gopen_f proc~pwfield_3d->h5sselect_hyperslab_f proc~pwfield_3d->proc~wrattr_file proc~pwfield_3d->h5fclose_f proc~pwfield_3d->h5sclose_f proc~pwfield_3d->h5open_f proc~pwfield_3d->h5pcreate_f proc~pwfield_3d->proc~wrattr_dataset proc~pwfield_3d->h5dclose_f proc~pwfield_3d->proc~detect_precision proc~pwfield_3d->h5dcreate_f proc~pwfield_3d->h5close_f proc~pwfield_3d->h5pclose_f proc~pwfield_3d->h5fcreate_f proc~pwfield_3d->h5pset_dxpl_mpio_f proc~wrattr_file->h5screate_simple_f proc~wrattr_file->h5gclose_f proc~wrattr_file->h5gopen_f proc~wrattr_file->h5sclose_f proc~wrattr_file->h5dclose_f proc~wrattr_file->proc~detect_precision h5dwrite_f h5dwrite_f proc~wrattr_file->h5dwrite_f h5gcreate_f h5gcreate_f proc~wrattr_file->h5gcreate_f interface~add_h5_atribute add_h5_atribute proc~wrattr_file->interface~add_h5_atribute proc~wrattr_dataset->interface~add_h5_atribute proc~add_h5_atribute_str add_h5_atribute_str interface~add_h5_atribute->proc~add_h5_atribute_str proc~add_h5_atribute_int add_h5_atribute_int interface~add_h5_atribute->proc~add_h5_atribute_int proc~add_h5_atribute_v1_int add_h5_atribute_v1_int interface~add_h5_atribute->proc~add_h5_atribute_v1_int proc~add_h5_atribute_v1_single add_h5_atribute_v1_single interface~add_h5_atribute->proc~add_h5_atribute_v1_single proc~add_h5_atribute_single add_h5_atribute_single interface~add_h5_atribute->proc~add_h5_atribute_single proc~add_h5_atribute_str_v1 add_h5_atribute_str_v1 interface~add_h5_atribute->proc~add_h5_atribute_str_v1 proc~add_h5_atribute_str->h5screate_simple_f proc~add_h5_atribute_str->h5sclose_f h5tset_size_f h5tset_size_f proc~add_h5_atribute_str->h5tset_size_f h5acreate_f h5acreate_f proc~add_h5_atribute_str->h5acreate_f h5awrite_f h5awrite_f proc~add_h5_atribute_str->h5awrite_f h5tcopy_f h5tcopy_f proc~add_h5_atribute_str->h5tcopy_f h5aclose_f h5aclose_f proc~add_h5_atribute_str->h5aclose_f h5tclose_f h5tclose_f proc~add_h5_atribute_str->h5tclose_f proc~add_h5_atribute_int->h5screate_simple_f proc~add_h5_atribute_int->h5sclose_f proc~add_h5_atribute_int->h5acreate_f proc~add_h5_atribute_int->h5awrite_f proc~add_h5_atribute_int->h5aclose_f proc~add_h5_atribute_v1_int->h5screate_simple_f proc~add_h5_atribute_v1_int->h5sclose_f proc~add_h5_atribute_v1_int->h5acreate_f proc~add_h5_atribute_v1_int->h5awrite_f proc~add_h5_atribute_v1_int->h5aclose_f proc~add_h5_atribute_v1_single->h5screate_simple_f proc~add_h5_atribute_v1_single->h5sclose_f proc~add_h5_atribute_v1_single->proc~detect_precision proc~add_h5_atribute_v1_single->h5acreate_f proc~add_h5_atribute_v1_single->h5awrite_f proc~add_h5_atribute_v1_single->h5aclose_f proc~add_h5_atribute_single->h5screate_simple_f proc~add_h5_atribute_single->h5sclose_f proc~add_h5_atribute_single->proc~detect_precision proc~add_h5_atribute_single->h5acreate_f proc~add_h5_atribute_single->h5awrite_f proc~add_h5_atribute_single->h5aclose_f proc~add_h5_atribute_str_v1->h5screate_simple_f proc~add_h5_atribute_str_v1->h5sclose_f proc~add_h5_atribute_str_v1->h5tset_size_f proc~add_h5_atribute_str_v1->h5acreate_f proc~add_h5_atribute_str_v1->h5awrite_f proc~add_h5_atribute_str_v1->h5tcopy_f proc~add_h5_atribute_str_v1->h5aclose_f proc~add_h5_atribute_str_v1->h5tclose_f var paninterfacepwfieldCallsGraph = svgPanZoom('#interfacepwfieldCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~pwfield~~CalledByGraph interface~pwfield pwfield proc~writehdf5 writehdf5 proc~writehdf5->interface~pwfield Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures pwfield_3d pwfield_2d Module Procedures private subroutine pwfield_3d (pp, perr, file, fd, gs, ls, noff, ierr) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( hdf5file ), intent(in) :: file real, intent(in), dimension(:,:,:) :: fd integer, intent(in), dimension(3) :: gs integer, intent(in), dimension(3) :: ls integer, intent(in), dimension(2) :: noff integer, intent(inout) :: ierr private subroutine pwfield_2d (pp, perr, file, fd, gs, ls, noff, ierr) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( hdf5file ), intent(in) :: file real, intent(in), dimension(:,:) :: fd integer, intent(in), dimension(2) :: gs integer, intent(in), dimension(2) :: ls integer, intent(in) :: noff integer, intent(inout) :: ierr","tags":"","loc":"interface/pwfield.html"},{"title":"pwfield_pipe – QuickPIC","text":"public interface pwfield_pipe Calls interface~~pwfield_pipe~~CallsGraph interface~pwfield_pipe pwfield_pipe proc~pwfield_3d_pipe pwfield_3d_pipe interface~pwfield_pipe->proc~pwfield_3d_pipe proc~pwfield_2d_pipe pwfield_2d_pipe interface~pwfield_pipe->proc~pwfield_2d_pipe h5gopen_f h5gopen_f proc~pwfield_3d_pipe->h5gopen_f proc~wrattr_file wrattr_file proc~pwfield_3d_pipe->proc~wrattr_file h5sclose_f h5sclose_f proc~pwfield_3d_pipe->h5sclose_f h5tcopy_f h5tcopy_f proc~pwfield_3d_pipe->h5tcopy_f h5aopen_by_name_f h5aopen_by_name_f proc~pwfield_3d_pipe->h5aopen_by_name_f mpi_isend mpi_isend proc~pwfield_3d_pipe->mpi_isend h5pset_dxpl_mpio_f h5pset_dxpl_mpio_f proc~pwfield_3d_pipe->h5pset_dxpl_mpio_f h5screate_simple_f h5screate_simple_f proc~pwfield_3d_pipe->h5screate_simple_f h5gclose_f h5gclose_f proc~pwfield_3d_pipe->h5gclose_f h5tset_size_f h5tset_size_f proc~pwfield_3d_pipe->h5tset_size_f h5open_f h5open_f proc~pwfield_3d_pipe->h5open_f h5pcreate_f h5pcreate_f proc~pwfield_3d_pipe->h5pcreate_f proc~wrattr_dataset wrattr_dataset proc~pwfield_3d_pipe->proc~wrattr_dataset h5dcreate_f h5dcreate_f proc~pwfield_3d_pipe->h5dcreate_f mpi_irecv mpi_irecv proc~pwfield_3d_pipe->mpi_irecv h5tclose_f h5tclose_f proc~pwfield_3d_pipe->h5tclose_f h5fclose_f h5fclose_f proc~pwfield_3d_pipe->h5fclose_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~pwfield_3d_pipe->h5sselect_hyperslab_f h5dclose_f h5dclose_f proc~pwfield_3d_pipe->h5dclose_f h5aread_f h5aread_f proc~pwfield_3d_pipe->h5aread_f h5close_f h5close_f proc~pwfield_3d_pipe->h5close_f h5pclose_f h5pclose_f proc~pwfield_3d_pipe->h5pclose_f h5pset_fapl_mpio_f h5pset_fapl_mpio_f proc~pwfield_3d_pipe->h5pset_fapl_mpio_f h5dopen_f h5dopen_f proc~pwfield_3d_pipe->h5dopen_f h5fopen_f h5fopen_f proc~pwfield_3d_pipe->h5fopen_f proc~detect_precision detect_precision proc~pwfield_3d_pipe->proc~detect_precision h5fcreate_f h5fcreate_f proc~pwfield_3d_pipe->h5fcreate_f mpi_wait mpi_wait proc~pwfield_3d_pipe->mpi_wait h5aclose_f h5aclose_f proc~pwfield_3d_pipe->h5aclose_f proc~pwfield_2d_pipe->h5gopen_f proc~pwfield_2d_pipe->proc~wrattr_file proc~pwfield_2d_pipe->h5sclose_f proc~pwfield_2d_pipe->h5tcopy_f proc~pwfield_2d_pipe->h5aopen_by_name_f proc~pwfield_2d_pipe->mpi_isend proc~pwfield_2d_pipe->h5pset_dxpl_mpio_f proc~pwfield_2d_pipe->h5screate_simple_f proc~pwfield_2d_pipe->h5gclose_f proc~pwfield_2d_pipe->h5tset_size_f proc~pwfield_2d_pipe->h5open_f proc~pwfield_2d_pipe->h5pcreate_f proc~pwfield_2d_pipe->proc~wrattr_dataset proc~pwfield_2d_pipe->h5dcreate_f proc~pwfield_2d_pipe->mpi_irecv proc~pwfield_2d_pipe->h5tclose_f proc~pwfield_2d_pipe->h5fclose_f proc~pwfield_2d_pipe->h5sselect_hyperslab_f proc~pwfield_2d_pipe->h5dclose_f proc~pwfield_2d_pipe->h5aread_f proc~pwfield_2d_pipe->h5close_f proc~pwfield_2d_pipe->h5pclose_f proc~pwfield_2d_pipe->h5pset_fapl_mpio_f proc~pwfield_2d_pipe->h5dopen_f proc~pwfield_2d_pipe->h5fopen_f proc~pwfield_2d_pipe->proc~detect_precision proc~pwfield_2d_pipe->h5fcreate_f proc~pwfield_2d_pipe->mpi_wait proc~pwfield_2d_pipe->h5aclose_f proc~wrattr_file->h5gopen_f proc~wrattr_file->h5sclose_f proc~wrattr_file->h5screate_simple_f proc~wrattr_file->h5gclose_f proc~wrattr_file->h5dclose_f proc~wrattr_file->proc~detect_precision h5dwrite_f h5dwrite_f proc~wrattr_file->h5dwrite_f h5gcreate_f h5gcreate_f proc~wrattr_file->h5gcreate_f interface~add_h5_atribute add_h5_atribute proc~wrattr_file->interface~add_h5_atribute proc~wrattr_dataset->interface~add_h5_atribute proc~add_h5_atribute_str add_h5_atribute_str interface~add_h5_atribute->proc~add_h5_atribute_str proc~add_h5_atribute_int add_h5_atribute_int interface~add_h5_atribute->proc~add_h5_atribute_int proc~add_h5_atribute_v1_int add_h5_atribute_v1_int interface~add_h5_atribute->proc~add_h5_atribute_v1_int proc~add_h5_atribute_v1_single add_h5_atribute_v1_single interface~add_h5_atribute->proc~add_h5_atribute_v1_single proc~add_h5_atribute_single add_h5_atribute_single interface~add_h5_atribute->proc~add_h5_atribute_single proc~add_h5_atribute_str_v1 add_h5_atribute_str_v1 interface~add_h5_atribute->proc~add_h5_atribute_str_v1 proc~add_h5_atribute_str->h5sclose_f proc~add_h5_atribute_str->h5tcopy_f proc~add_h5_atribute_str->h5screate_simple_f proc~add_h5_atribute_str->h5tset_size_f proc~add_h5_atribute_str->h5tclose_f proc~add_h5_atribute_str->h5aclose_f h5acreate_f h5acreate_f proc~add_h5_atribute_str->h5acreate_f h5awrite_f h5awrite_f proc~add_h5_atribute_str->h5awrite_f proc~add_h5_atribute_int->h5sclose_f proc~add_h5_atribute_int->h5screate_simple_f proc~add_h5_atribute_int->h5aclose_f proc~add_h5_atribute_int->h5acreate_f proc~add_h5_atribute_int->h5awrite_f proc~add_h5_atribute_v1_int->h5sclose_f proc~add_h5_atribute_v1_int->h5screate_simple_f proc~add_h5_atribute_v1_int->h5aclose_f proc~add_h5_atribute_v1_int->h5acreate_f proc~add_h5_atribute_v1_int->h5awrite_f proc~add_h5_atribute_v1_single->h5sclose_f proc~add_h5_atribute_v1_single->h5screate_simple_f proc~add_h5_atribute_v1_single->proc~detect_precision proc~add_h5_atribute_v1_single->h5aclose_f proc~add_h5_atribute_v1_single->h5acreate_f proc~add_h5_atribute_v1_single->h5awrite_f proc~add_h5_atribute_single->h5sclose_f proc~add_h5_atribute_single->h5screate_simple_f proc~add_h5_atribute_single->proc~detect_precision proc~add_h5_atribute_single->h5aclose_f proc~add_h5_atribute_single->h5acreate_f proc~add_h5_atribute_single->h5awrite_f proc~add_h5_atribute_str_v1->h5sclose_f proc~add_h5_atribute_str_v1->h5tcopy_f proc~add_h5_atribute_str_v1->h5screate_simple_f proc~add_h5_atribute_str_v1->h5tset_size_f proc~add_h5_atribute_str_v1->h5tclose_f proc~add_h5_atribute_str_v1->h5aclose_f proc~add_h5_atribute_str_v1->h5acreate_f proc~add_h5_atribute_str_v1->h5awrite_f var paninterfacepwfield_pipeCallsGraph = svgPanZoom('#interfacepwfield_pipeCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~pwfield_pipe~~CalledByGraph interface~pwfield_pipe pwfield_pipe proc~writehdf5_3d writehdf5_3d proc~writehdf5_3d->interface~pwfield_pipe proc~writehdf5_2dslice writehdf5_2dslice proc~writehdf5_2dslice->interface~pwfield_pipe Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures pwfield_3d_pipe pwfield_2d_pipe Module Procedures private subroutine pwfield_3d_pipe (pp, perr, file, fd, gs, ls, noff, rtag, stag, id, ierr) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( hdf5file ), intent(in) :: file real, intent(in), dimension(:,:,:) :: fd integer, intent(in), dimension(3) :: gs integer, intent(in), dimension(3) :: ls integer, intent(in), dimension(2) :: noff integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id integer, intent(inout) :: ierr private subroutine pwfield_2d_pipe (pp, perr, file, fd, gs, ls, noff, rtag, stag, id, ierr) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( hdf5file ), intent(in) :: file real, intent(in), dimension(:,:) :: fd integer, intent(in), dimension(2) :: gs integer, intent(in), dimension(2) :: ls integer, intent(in), dimension(2) :: noff integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id integer, intent(inout) :: ierr","tags":"","loc":"interface/pwfield_pipe.html"},{"title":"wfield_pipe – QuickPIC","text":"public interface wfield_pipe Calls interface~~wfield_pipe~~CallsGraph interface~wfield_pipe wfield_pipe proc~wfield_2d_pipe wfield_2d_pipe interface~wfield_pipe->proc~wfield_2d_pipe h5gopen_f h5gopen_f proc~wfield_2d_pipe->h5gopen_f proc~wrattr_file wrattr_file proc~wfield_2d_pipe->proc~wrattr_file h5sclose_f h5sclose_f proc~wfield_2d_pipe->h5sclose_f h5tcopy_f h5tcopy_f proc~wfield_2d_pipe->h5tcopy_f h5aopen_by_name_f h5aopen_by_name_f proc~wfield_2d_pipe->h5aopen_by_name_f mpi_isend mpi_isend proc~wfield_2d_pipe->mpi_isend h5screate_simple_f h5screate_simple_f proc~wfield_2d_pipe->h5screate_simple_f h5gclose_f h5gclose_f proc~wfield_2d_pipe->h5gclose_f h5tset_size_f h5tset_size_f proc~wfield_2d_pipe->h5tset_size_f h5open_f h5open_f proc~wfield_2d_pipe->h5open_f proc~wrattr_dataset wrattr_dataset proc~wfield_2d_pipe->proc~wrattr_dataset h5dcreate_f h5dcreate_f proc~wfield_2d_pipe->h5dcreate_f mpi_irecv mpi_irecv proc~wfield_2d_pipe->mpi_irecv h5tclose_f h5tclose_f proc~wfield_2d_pipe->h5tclose_f h5fclose_f h5fclose_f proc~wfield_2d_pipe->h5fclose_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~wfield_2d_pipe->h5sselect_hyperslab_f h5dclose_f h5dclose_f proc~wfield_2d_pipe->h5dclose_f h5aread_f h5aread_f proc~wfield_2d_pipe->h5aread_f h5close_f h5close_f proc~wfield_2d_pipe->h5close_f h5dopen_f h5dopen_f proc~wfield_2d_pipe->h5dopen_f h5fopen_f h5fopen_f proc~wfield_2d_pipe->h5fopen_f proc~detect_precision detect_precision proc~wfield_2d_pipe->proc~detect_precision h5fcreate_f h5fcreate_f proc~wfield_2d_pipe->h5fcreate_f mpi_wait mpi_wait proc~wfield_2d_pipe->mpi_wait h5aclose_f h5aclose_f proc~wfield_2d_pipe->h5aclose_f proc~wrattr_file->h5gopen_f proc~wrattr_file->h5sclose_f proc~wrattr_file->h5screate_simple_f proc~wrattr_file->h5gclose_f proc~wrattr_file->h5dclose_f proc~wrattr_file->proc~detect_precision h5dwrite_f h5dwrite_f proc~wrattr_file->h5dwrite_f h5gcreate_f h5gcreate_f proc~wrattr_file->h5gcreate_f interface~add_h5_atribute add_h5_atribute proc~wrattr_file->interface~add_h5_atribute proc~wrattr_dataset->interface~add_h5_atribute proc~add_h5_atribute_str add_h5_atribute_str interface~add_h5_atribute->proc~add_h5_atribute_str proc~add_h5_atribute_int add_h5_atribute_int interface~add_h5_atribute->proc~add_h5_atribute_int proc~add_h5_atribute_v1_int add_h5_atribute_v1_int interface~add_h5_atribute->proc~add_h5_atribute_v1_int proc~add_h5_atribute_v1_single add_h5_atribute_v1_single interface~add_h5_atribute->proc~add_h5_atribute_v1_single proc~add_h5_atribute_single add_h5_atribute_single interface~add_h5_atribute->proc~add_h5_atribute_single proc~add_h5_atribute_str_v1 add_h5_atribute_str_v1 interface~add_h5_atribute->proc~add_h5_atribute_str_v1 proc~add_h5_atribute_str->h5sclose_f proc~add_h5_atribute_str->h5tcopy_f proc~add_h5_atribute_str->h5screate_simple_f proc~add_h5_atribute_str->h5tset_size_f proc~add_h5_atribute_str->h5tclose_f proc~add_h5_atribute_str->h5aclose_f h5acreate_f h5acreate_f proc~add_h5_atribute_str->h5acreate_f h5awrite_f h5awrite_f proc~add_h5_atribute_str->h5awrite_f proc~add_h5_atribute_int->h5sclose_f proc~add_h5_atribute_int->h5screate_simple_f proc~add_h5_atribute_int->h5aclose_f proc~add_h5_atribute_int->h5acreate_f proc~add_h5_atribute_int->h5awrite_f proc~add_h5_atribute_v1_int->h5sclose_f proc~add_h5_atribute_v1_int->h5screate_simple_f proc~add_h5_atribute_v1_int->h5aclose_f proc~add_h5_atribute_v1_int->h5acreate_f proc~add_h5_atribute_v1_int->h5awrite_f proc~add_h5_atribute_v1_single->h5sclose_f proc~add_h5_atribute_v1_single->h5screate_simple_f proc~add_h5_atribute_v1_single->proc~detect_precision proc~add_h5_atribute_v1_single->h5aclose_f proc~add_h5_atribute_v1_single->h5acreate_f proc~add_h5_atribute_v1_single->h5awrite_f proc~add_h5_atribute_single->h5sclose_f proc~add_h5_atribute_single->h5screate_simple_f proc~add_h5_atribute_single->proc~detect_precision proc~add_h5_atribute_single->h5aclose_f proc~add_h5_atribute_single->h5acreate_f proc~add_h5_atribute_single->h5awrite_f proc~add_h5_atribute_str_v1->h5sclose_f proc~add_h5_atribute_str_v1->h5tcopy_f proc~add_h5_atribute_str_v1->h5screate_simple_f proc~add_h5_atribute_str_v1->h5tset_size_f proc~add_h5_atribute_str_v1->h5tclose_f proc~add_h5_atribute_str_v1->h5aclose_f proc~add_h5_atribute_str_v1->h5acreate_f proc~add_h5_atribute_str_v1->h5awrite_f var paninterfacewfield_pipeCallsGraph = svgPanZoom('#interfacewfield_pipeCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~wfield_pipe~~CalledByGraph interface~wfield_pipe wfield_pipe proc~writehdf5_2dslice writehdf5_2dslice proc~writehdf5_2dslice->interface~wfield_pipe Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures wfield_2d_pipe Module Procedures private subroutine wfield_2d_pipe (pp, perr, file, fd, gs, ls, noff, rtag, stag, id, ierr) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( hdf5file ), intent(in) :: file real, intent(in), dimension(:,:) :: fd integer, intent(in), dimension(2) :: gs integer, intent(in), dimension(2) :: ls integer, intent(in), dimension(2) :: noff integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id integer, intent(inout) :: ierr","tags":"","loc":"interface/wfield_pipe.html"},{"title":"pwpart_pipe – QuickPIC","text":"public interface pwpart_pipe Calls interface~~pwpart_pipe~~CallsGraph interface~pwpart_pipe pwpart_pipe proc~pwpart_3d_pipe pwpart_3d_pipe interface~pwpart_pipe->proc~pwpart_3d_pipe h5gopen_f h5gopen_f proc~pwpart_3d_pipe->h5gopen_f proc~wrattr_file wrattr_file proc~pwpart_3d_pipe->proc~wrattr_file h5aclose_f h5aclose_f proc~pwpart_3d_pipe->h5aclose_f h5sclose_f h5sclose_f proc~pwpart_3d_pipe->h5sclose_f h5pset_chunk_f h5pset_chunk_f proc~pwpart_3d_pipe->h5pset_chunk_f mpi_comm_rank mpi_comm_rank proc~pwpart_3d_pipe->mpi_comm_rank mpi_isend mpi_isend proc~pwpart_3d_pipe->mpi_isend h5pset_dxpl_mpio_f h5pset_dxpl_mpio_f proc~pwpart_3d_pipe->h5pset_dxpl_mpio_f h5screate_simple_f h5screate_simple_f proc~pwpart_3d_pipe->h5screate_simple_f h5gclose_f h5gclose_f proc~pwpart_3d_pipe->h5gclose_f h5open_f h5open_f proc~pwpart_3d_pipe->h5open_f h5pcreate_f h5pcreate_f proc~pwpart_3d_pipe->h5pcreate_f mpi_allreduce mpi_allreduce proc~pwpart_3d_pipe->mpi_allreduce h5acreate_f h5acreate_f proc~pwpart_3d_pipe->h5acreate_f proc~wrattr_dataset wrattr_dataset proc~pwpart_3d_pipe->proc~wrattr_dataset h5dcreate_f h5dcreate_f proc~pwpart_3d_pipe->h5dcreate_f mpi_comm_free mpi_comm_free proc~pwpart_3d_pipe->mpi_comm_free mpi_allgather mpi_allgather proc~pwpart_3d_pipe->mpi_allgather mpi_irecv mpi_irecv proc~pwpart_3d_pipe->mpi_irecv h5aopen_f h5aopen_f proc~pwpart_3d_pipe->h5aopen_f h5fclose_f h5fclose_f proc~pwpart_3d_pipe->h5fclose_f mpi_comm_split mpi_comm_split proc~pwpart_3d_pipe->mpi_comm_split h5sselect_hyperslab_f h5sselect_hyperslab_f proc~pwpart_3d_pipe->h5sselect_hyperslab_f h5dclose_f h5dclose_f proc~pwpart_3d_pipe->h5dclose_f h5aread_f h5aread_f proc~pwpart_3d_pipe->h5aread_f h5close_f h5close_f proc~pwpart_3d_pipe->h5close_f h5pclose_f h5pclose_f proc~pwpart_3d_pipe->h5pclose_f h5dextend_f h5dextend_f proc~pwpart_3d_pipe->h5dextend_f h5pset_fapl_mpio_f h5pset_fapl_mpio_f proc~pwpart_3d_pipe->h5pset_fapl_mpio_f h5dopen_f h5dopen_f proc~pwpart_3d_pipe->h5dopen_f h5fopen_f h5fopen_f proc~pwpart_3d_pipe->h5fopen_f h5dwrite_f h5dwrite_f proc~pwpart_3d_pipe->h5dwrite_f h5awrite_f h5awrite_f proc~pwpart_3d_pipe->h5awrite_f proc~detect_precision detect_precision proc~pwpart_3d_pipe->proc~detect_precision mpi_comm_size mpi_comm_size proc~pwpart_3d_pipe->mpi_comm_size mpi_wait mpi_wait proc~pwpart_3d_pipe->mpi_wait h5fcreate_f h5fcreate_f proc~pwpart_3d_pipe->h5fcreate_f proc~wrattr_file->h5gopen_f proc~wrattr_file->h5sclose_f proc~wrattr_file->h5screate_simple_f proc~wrattr_file->h5gclose_f proc~wrattr_file->h5dclose_f proc~wrattr_file->h5dwrite_f proc~wrattr_file->proc~detect_precision h5gcreate_f h5gcreate_f proc~wrattr_file->h5gcreate_f interface~add_h5_atribute add_h5_atribute proc~wrattr_file->interface~add_h5_atribute proc~wrattr_dataset->interface~add_h5_atribute proc~add_h5_atribute_str add_h5_atribute_str interface~add_h5_atribute->proc~add_h5_atribute_str proc~add_h5_atribute_int add_h5_atribute_int interface~add_h5_atribute->proc~add_h5_atribute_int proc~add_h5_atribute_v1_int add_h5_atribute_v1_int interface~add_h5_atribute->proc~add_h5_atribute_v1_int proc~add_h5_atribute_v1_single add_h5_atribute_v1_single interface~add_h5_atribute->proc~add_h5_atribute_v1_single proc~add_h5_atribute_single add_h5_atribute_single interface~add_h5_atribute->proc~add_h5_atribute_single proc~add_h5_atribute_str_v1 add_h5_atribute_str_v1 interface~add_h5_atribute->proc~add_h5_atribute_str_v1 proc~add_h5_atribute_str->h5aclose_f proc~add_h5_atribute_str->h5sclose_f proc~add_h5_atribute_str->h5screate_simple_f proc~add_h5_atribute_str->h5acreate_f proc~add_h5_atribute_str->h5awrite_f h5tset_size_f h5tset_size_f proc~add_h5_atribute_str->h5tset_size_f h5tcopy_f h5tcopy_f proc~add_h5_atribute_str->h5tcopy_f h5tclose_f h5tclose_f proc~add_h5_atribute_str->h5tclose_f proc~add_h5_atribute_int->h5aclose_f proc~add_h5_atribute_int->h5sclose_f proc~add_h5_atribute_int->h5screate_simple_f proc~add_h5_atribute_int->h5acreate_f proc~add_h5_atribute_int->h5awrite_f proc~add_h5_atribute_v1_int->h5aclose_f proc~add_h5_atribute_v1_int->h5sclose_f proc~add_h5_atribute_v1_int->h5screate_simple_f proc~add_h5_atribute_v1_int->h5acreate_f proc~add_h5_atribute_v1_int->h5awrite_f proc~add_h5_atribute_v1_single->h5aclose_f proc~add_h5_atribute_v1_single->h5sclose_f proc~add_h5_atribute_v1_single->h5screate_simple_f proc~add_h5_atribute_v1_single->h5acreate_f proc~add_h5_atribute_v1_single->h5awrite_f proc~add_h5_atribute_v1_single->proc~detect_precision proc~add_h5_atribute_single->h5aclose_f proc~add_h5_atribute_single->h5sclose_f proc~add_h5_atribute_single->h5screate_simple_f proc~add_h5_atribute_single->h5acreate_f proc~add_h5_atribute_single->h5awrite_f proc~add_h5_atribute_single->proc~detect_precision proc~add_h5_atribute_str_v1->h5aclose_f proc~add_h5_atribute_str_v1->h5sclose_f proc~add_h5_atribute_str_v1->h5screate_simple_f proc~add_h5_atribute_str_v1->h5acreate_f proc~add_h5_atribute_str_v1->h5awrite_f proc~add_h5_atribute_str_v1->h5tset_size_f proc~add_h5_atribute_str_v1->h5tcopy_f proc~add_h5_atribute_str_v1->h5tclose_f var paninterfacepwpart_pipeCallsGraph = svgPanZoom('#interfacepwpart_pipeCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~pwpart_pipe~~CalledByGraph interface~pwpart_pipe pwpart_pipe proc~writehdf5_part3d writehdf5_part3d proc~writehdf5_part3d->interface~pwpart_pipe Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures pwpart_3d_pipe Module Procedures private subroutine pwpart_3d_pipe (pp, perr, file, part, npp, dspl, delta, rtag, stag, id, ierr) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( hdf5file ), intent(in) :: file real, intent(in), dimension(:,:) :: part integer, intent(in) :: npp integer, intent(in) :: dspl real, intent(in), dimension(3) :: delta integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id integer, intent(inout) :: ierr","tags":"","loc":"interface/pwpart_pipe.html"},{"title":"pwpart – QuickPIC","text":"public interface pwpart Calls interface~~pwpart~~CallsGraph interface~pwpart pwpart proc~pwpart_2d pwpart_2d interface~pwpart->proc~pwpart_2d h5gopen_f h5gopen_f proc~pwpart_2d->h5gopen_f proc~wrattr_file wrattr_file proc~pwpart_2d->proc~wrattr_file h5aclose_f h5aclose_f proc~pwpart_2d->h5aclose_f h5sclose_f h5sclose_f proc~pwpart_2d->h5sclose_f mpi_comm_rank mpi_comm_rank proc~pwpart_2d->mpi_comm_rank h5pset_dxpl_mpio_f h5pset_dxpl_mpio_f proc~pwpart_2d->h5pset_dxpl_mpio_f h5screate_simple_f h5screate_simple_f proc~pwpart_2d->h5screate_simple_f h5gclose_f h5gclose_f proc~pwpart_2d->h5gclose_f h5pcreate_f h5pcreate_f proc~pwpart_2d->h5pcreate_f h5open_f h5open_f proc~pwpart_2d->h5open_f mpi_allreduce mpi_allreduce proc~pwpart_2d->mpi_allreduce h5acreate_f h5acreate_f proc~pwpart_2d->h5acreate_f proc~wrattr_dataset wrattr_dataset proc~pwpart_2d->proc~wrattr_dataset h5dcreate_f h5dcreate_f proc~pwpart_2d->h5dcreate_f mpi_comm_free mpi_comm_free proc~pwpart_2d->mpi_comm_free mpi_allgather mpi_allgather proc~pwpart_2d->mpi_allgather h5fclose_f h5fclose_f proc~pwpart_2d->h5fclose_f mpi_comm_split mpi_comm_split proc~pwpart_2d->mpi_comm_split h5sselect_hyperslab_f h5sselect_hyperslab_f proc~pwpart_2d->h5sselect_hyperslab_f h5dclose_f h5dclose_f proc~pwpart_2d->h5dclose_f h5close_f h5close_f proc~pwpart_2d->h5close_f h5pclose_f h5pclose_f proc~pwpart_2d->h5pclose_f h5pset_fapl_mpio_f h5pset_fapl_mpio_f proc~pwpart_2d->h5pset_fapl_mpio_f h5dwrite_f h5dwrite_f proc~pwpart_2d->h5dwrite_f h5awrite_f h5awrite_f proc~pwpart_2d->h5awrite_f proc~detect_precision detect_precision proc~pwpart_2d->proc~detect_precision mpi_comm_size mpi_comm_size proc~pwpart_2d->mpi_comm_size h5fcreate_f h5fcreate_f proc~pwpart_2d->h5fcreate_f proc~wrattr_file->h5gopen_f proc~wrattr_file->h5sclose_f proc~wrattr_file->h5screate_simple_f proc~wrattr_file->h5gclose_f proc~wrattr_file->h5dclose_f proc~wrattr_file->h5dwrite_f proc~wrattr_file->proc~detect_precision h5gcreate_f h5gcreate_f proc~wrattr_file->h5gcreate_f interface~add_h5_atribute add_h5_atribute proc~wrattr_file->interface~add_h5_atribute proc~wrattr_dataset->interface~add_h5_atribute proc~add_h5_atribute_str add_h5_atribute_str interface~add_h5_atribute->proc~add_h5_atribute_str proc~add_h5_atribute_int add_h5_atribute_int interface~add_h5_atribute->proc~add_h5_atribute_int proc~add_h5_atribute_v1_int add_h5_atribute_v1_int interface~add_h5_atribute->proc~add_h5_atribute_v1_int proc~add_h5_atribute_v1_single add_h5_atribute_v1_single interface~add_h5_atribute->proc~add_h5_atribute_v1_single proc~add_h5_atribute_single add_h5_atribute_single interface~add_h5_atribute->proc~add_h5_atribute_single proc~add_h5_atribute_str_v1 add_h5_atribute_str_v1 interface~add_h5_atribute->proc~add_h5_atribute_str_v1 proc~add_h5_atribute_str->h5aclose_f proc~add_h5_atribute_str->h5sclose_f proc~add_h5_atribute_str->h5screate_simple_f proc~add_h5_atribute_str->h5acreate_f proc~add_h5_atribute_str->h5awrite_f h5tset_size_f h5tset_size_f proc~add_h5_atribute_str->h5tset_size_f h5tcopy_f h5tcopy_f proc~add_h5_atribute_str->h5tcopy_f h5tclose_f h5tclose_f proc~add_h5_atribute_str->h5tclose_f proc~add_h5_atribute_int->h5aclose_f proc~add_h5_atribute_int->h5sclose_f proc~add_h5_atribute_int->h5screate_simple_f proc~add_h5_atribute_int->h5acreate_f proc~add_h5_atribute_int->h5awrite_f proc~add_h5_atribute_v1_int->h5aclose_f proc~add_h5_atribute_v1_int->h5sclose_f proc~add_h5_atribute_v1_int->h5screate_simple_f proc~add_h5_atribute_v1_int->h5acreate_f proc~add_h5_atribute_v1_int->h5awrite_f proc~add_h5_atribute_v1_single->h5aclose_f proc~add_h5_atribute_v1_single->h5sclose_f proc~add_h5_atribute_v1_single->h5screate_simple_f proc~add_h5_atribute_v1_single->h5acreate_f proc~add_h5_atribute_v1_single->h5awrite_f proc~add_h5_atribute_v1_single->proc~detect_precision proc~add_h5_atribute_single->h5aclose_f proc~add_h5_atribute_single->h5sclose_f proc~add_h5_atribute_single->h5screate_simple_f proc~add_h5_atribute_single->h5acreate_f proc~add_h5_atribute_single->h5awrite_f proc~add_h5_atribute_single->proc~detect_precision proc~add_h5_atribute_str_v1->h5aclose_f proc~add_h5_atribute_str_v1->h5sclose_f proc~add_h5_atribute_str_v1->h5screate_simple_f proc~add_h5_atribute_str_v1->h5acreate_f proc~add_h5_atribute_str_v1->h5awrite_f proc~add_h5_atribute_str_v1->h5tset_size_f proc~add_h5_atribute_str_v1->h5tcopy_f proc~add_h5_atribute_str_v1->h5tclose_f var paninterfacepwpartCallsGraph = svgPanZoom('#interfacepwpartCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~pwpart~~CalledByGraph interface~pwpart pwpart proc~writehdf5_part2d writehdf5_part2d proc~writehdf5_part2d->interface~pwpart Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures pwpart_2d Module Procedures private subroutine pwpart_2d (pp, perr, file, part, npp, dspl, delta, ierr) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( hdf5file ), intent(in) :: file real, intent(in), dimension(:,:) :: part integer, intent(in) :: npp integer, intent(in) :: dspl real, intent(in), dimension(2) :: delta integer, intent(inout) :: ierr","tags":"","loc":"interface/pwpart.html"},{"title":"PPOISDX2 – QuickPIC","text":"interface public subroutine PPOISDX2(q, fx, fy, isign, ffd, ax, ay, affp, we, nx, ny, kstrt, ny2d, kxp2, j2blok, nyd) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(ny2d,kxp2,j2blok) :: q complex, intent(inout), dimension(ny2d,kxp2,j2blok) :: fx complex, intent(inout), dimension(ny2d,kxp2,j2blok) :: fy integer, intent(in) :: isign complex, intent(inout), dimension(nyd,kxp2,j2blok) :: ffd real, intent(in) :: ax real, intent(in) :: ay real, intent(in) :: affp real, intent(in) :: we integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kstrt integer, intent(in) :: ny2d integer, intent(in) :: kxp2 integer, intent(in) :: j2blok integer, intent(in) :: nyd","tags":"","loc":"interface/ppoisdx2.html"},{"title":"PPOISD2 – QuickPIC","text":"interface public subroutine PPOISD2(q, fx, fy, isign, ffd, ax, ay, affp, we, nx, ny, kstrt, nyv, kxp2, j2blok, nyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(nyv,kxp2+1,j2blok) :: q real, intent(inout), dimension(nyv,kxp2+1,j2blok) :: fx real, intent(inout), dimension(nyv,kxp2+1,j2blok) :: fy integer, intent(in) :: isign complex, intent(in), dimension(nyd,kxp2,j2blok) :: ffd real, intent(in) :: ax real, intent(in) :: ay real, intent(in) :: affp real, intent(in) :: we integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kstrt integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: j2blok integer, intent(in) :: nyd","tags":"","loc":"interface/ppoisd2.html"},{"title":"PPOISD22 – QuickPIC","text":"interface public subroutine PPOISD22(q, fxy, isign, ffd, ax, ay, affp, we, nx, ny, kstrt, nyv, kxp2, j2blok, nyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(nyv,kxp2+1,j2blok) :: q real, intent(inout), dimension(2,nyv,kxp2+1,j2blok) :: fxy integer, intent(in) :: isign complex, intent(in), dimension(nyd,kxp2,j2blok) :: ffd real, intent(in) :: ax real, intent(in) :: ay real, intent(in) :: affp real, intent(in) :: we integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kstrt integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: j2blok integer, intent(in) :: nyd","tags":"","loc":"interface/ppoisd22.html"},{"title":"PPOISD23 – QuickPIC","text":"interface public subroutine PPOISD23(q, fxy, isign, ffd, ax, ay, affp, we, nx, ny, kstrt, nyv, kxp2, j2blok, nyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(nyv,kxp2+1,j2blok) :: q real, intent(inout), dimension(3,nyv,kxp2+1,j2blok) :: fxy integer, intent(in) :: isign complex, intent(in), dimension(nyd,kxp2,j2blok) :: ffd real, intent(in) :: ax real, intent(in) :: ay real, intent(in) :: affp real, intent(in) :: we integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kstrt integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: j2blok integer, intent(in) :: nyd","tags":"","loc":"interface/ppoisd23.html"},{"title":"PBPOISD22 – QuickPIC","text":"interface public subroutine PBPOISD22(cu, bxy, bz, isign, ffd, ax, ay, affp, ci, wm, nx, ny, kstrt, nyv, kxp2, j2blok, nyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(2,nyv,kxp2+1,j2blok) :: cu real, intent(inout), dimension(2,nyv,kxp2+1,j2blok) :: bxy real, intent(inout), dimension(nyv,kxp2+1,j2blok) :: bz integer, intent(in) :: isign complex, intent(in), dimension(nyd,kxp2,j2blok) :: ffd real, intent(in) :: ax real, intent(in) :: ay real, intent(in) :: affp real, intent(in) :: ci real, intent(in) :: wm integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kstrt integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: j2blok integer, intent(in) :: nyd","tags":"","loc":"interface/pbpoisd22.html"},{"title":"PBPOISD23 – QuickPIC","text":"interface public subroutine PBPOISD23(cu, bxy, isign, ffd, ax, ay, affp, ci, wm, nx, ny, kstrt, nyv, kxp2, j2blok, nyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(3,nyv,kxp2+1,j2blok) :: cu real, intent(inout), dimension(3,nyv,kxp2+1,j2blok) :: bxy integer, intent(in) :: isign complex, intent(in), dimension(nyd,kxp2,j2blok) :: ffd real, intent(in) :: ax real, intent(in) :: ay real, intent(in) :: affp real, intent(in) :: ci real, intent(in) :: wm integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kstrt integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: j2blok integer, intent(in) :: nyd","tags":"","loc":"interface/pbpoisd23.html"},{"title":"PBPOISD22N_QP – QuickPIC","text":"interface Called by interface~~pbpoisd22n_qp~~CalledByGraph interface~pbpoisd22n_qp PBPOISD22N_QP proc~jpbpoisd23n_qp jpbpoisd23n_qp proc~jpbpoisd23n_qp->interface~pbpoisd22n_qp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine PBPOISD22N_QP(cu, dcu, amu, bxy, bz, isign, ffd, ax, ay, affp, ci, wm, nx, ny, kstrt, nyv, kxp2, j2blok, nyd, aa, dex) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(3,nyv,kxp2+1,j2blok) :: cu real, intent(inout), dimension(2,nyv,kxp2+1,j2blok) :: dcu real, intent(inout), dimension(3,nyv,kxp2+1,j2blok) :: amu real, intent(inout), dimension(2,nyv,kxp2+1,j2blok) :: bxy real, intent(inout), dimension(nyv,kxp2+1,j2blok) :: bz integer, intent(in) :: isign complex, intent(in), dimension(nyd,kxp2,j2blok) :: ffd real, intent(in) :: ax real, intent(in) :: ay real, intent(in) :: affp real, intent(in) :: ci real, intent(in) :: wm integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kstrt integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: j2blok integer, intent(in) :: nyd real, intent(in) :: aa real, intent(in) :: dex","tags":"","loc":"interface/pbpoisd22n_qp.html"},{"title":"MPPOISD22 – QuickPIC","text":"interface Called by interface~~mppoisd22~~CalledByGraph interface~mppoisd22 MPPOISD22 proc~ippoisd2init ippoisd2init proc~ippoisd2init->interface~mppoisd22 proc~init_fpois2d init_fpois2d proc~init_fpois2d->proc~ippoisd2init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine MPPOISD22(q, fxy, isign, ffd, ax, ay, affp, we, nx, ny, kstrt, nyv, kxp2, nyd) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(nyv,kxp2+1) :: q real, intent(inout), dimension(2,nyv,kxp2+1) :: fxy integer, intent(in) :: isign complex, intent(inout), dimension(nyd,kxp2) :: ffd real, intent(in) :: ax real, intent(in) :: ay real, intent(in) :: affp real, intent(inout) :: we integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kstrt integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: nyd","tags":"","loc":"interface/mppoisd22.html"},{"title":"MPPOISD23 – QuickPIC","text":"interface public subroutine MPPOISD23(q, fxy, isign, ffd, ax, ay, affp, we, nx, ny, kstrt, nyv, kxp2, nyd) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(nyv,kxp2+1) :: q real, intent(inout), dimension(3,nyv,kxp2+1) :: fxy integer, intent(in) :: isign complex, intent(inout), dimension(nyd,kxp2) :: ffd real, intent(in) :: ax real, intent(in) :: ay real, intent(in) :: affp real, intent(inout) :: we integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kstrt integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: nyd","tags":"","loc":"interface/mppoisd23.html"},{"title":"MPPOTPD2 – QuickPIC","text":"interface public subroutine MPPOTPD2(q, pot, ffd, we, nx, ny, kstrt, nyv, kxp2, nyd) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(nyv,kxp2+1) :: q real, intent(inout), dimension(nyv,kxp2+1) :: pot complex, intent(in), dimension(nyd,kxp2) :: ffd real, intent(inout) :: we integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kstrt integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: nyd","tags":"","loc":"interface/mppotpd2.html"},{"title":"MPPSMOOTHD2 – QuickPIC","text":"interface public subroutine MPPSMOOTHD2(q, qs, ffd, nx, ny, kstrt, nyv, kxp2, nyd) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(nyv,kxp2+1) :: q real, intent(inout), dimension(nyv,kxp2+1) :: qs complex, intent(in), dimension(nyd,kxp2) :: ffd integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kstrt integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: nyd","tags":"","loc":"interface/mppsmoothd2.html"},{"title":"MPPBBPOISD23 – QuickPIC","text":"interface Called by interface~~mppbbpoisd23~~CalledByGraph interface~mppbbpoisd23 MPPBBPOISD23 proc~jpbpoisd23 jpbpoisd23 proc~jpbpoisd23->interface~mppbbpoisd23 proc~ibfieldd2 ibfieldd2 proc~ibfieldd2->proc~jpbpoisd23 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine MPPBBPOISD23(cu, bxy, ffd, ci, wm, nx, ny, kstrt, nyv, kxp2, nyd) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(3,nyv,kxp2+1) :: cu real, intent(inout), dimension(3,nyv,kxp2+1) :: bxy complex, intent(in), dimension(nyd,kxp2) :: ffd real, intent(in) :: ci real, intent(inout) :: wm integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kstrt integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: nyd","tags":"","loc":"interface/mppbbpoisd23.html"},{"title":"init_beam3d – QuickPIC","text":"private subroutine init_beam3d(this, pp, perr, psp, pf, qbm, dt, ci, xdim) Arguments Type Intent Optional Attributes Name class( beam3d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( spect3d ), intent(in), pointer :: psp class( fdist3d ), intent(inout), target :: pf real, intent(in) :: qbm real, intent(in) :: dt real, intent(in) :: ci integer, intent(in) :: xdim Calls proc~~init_beam3d~~CallsGraph proc~init_beam3d init_beam3d mpi_wait mpi_wait proc~init_beam3d->mpi_wait Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/init_beam3d.html"},{"title":"end_beam3d – QuickPIC","text":"private subroutine end_beam3d(this) Arguments Type Intent Optional Attributes Name class( beam3d ), intent(inout) :: this Contents None","tags":"","loc":"proc/end_beam3d.html"},{"title":"qdeposit_beam3d – QuickPIC","text":"private subroutine qdeposit_beam3d(this, id1, id2, id3, tag1, tag2) Arguments Type Intent Optional Attributes Name class( beam3d ), intent(inout) :: this integer, intent(inout) :: id1 integer, intent(inout) :: id2 integer, intent(inout) :: id3 integer, intent(inout) :: tag1 integer, intent(inout) :: tag2 Calls proc~~qdeposit_beam3d~~CallsGraph proc~qdeposit_beam3d qdeposit_beam3d mpi_wait mpi_wait proc~qdeposit_beam3d->mpi_wait Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/qdeposit_beam3d.html"},{"title":"qdpcopy_beam3d – QuickPIC","text":"private subroutine qdpcopy_beam3d(this, q, slice) Arguments Type Intent Optional Attributes Name class( beam3d ), intent(inout) :: this class( field2d ), intent(inout) :: q integer, intent(in) :: slice Contents None","tags":"","loc":"proc/qdpcopy_beam3d.html"},{"title":"push_beam3d – QuickPIC","text":"private subroutine push_beam3d(this, ef, bf, dex, dez, rtag, stag, sid) Arguments Type Intent Optional Attributes Name class( beam3d ), intent(inout) :: this class( field3d ), intent(in) :: ef class( field3d ), intent(in) :: bf real, intent(in) :: dex real, intent(in) :: dez integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: sid Contents None","tags":"","loc":"proc/push_beam3d.html"},{"title":"pmove_beam3d – QuickPIC","text":"private subroutine pmove_beam3d(this, fd, rtag, stag, sid) Arguments Type Intent Optional Attributes Name class( beam3d ), intent(inout) :: this class( field3d ), intent(in) :: fd integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: sid Contents None","tags":"","loc":"proc/pmove_beam3d.html"},{"title":"writehdf5_beam3d – QuickPIC","text":"private subroutine writehdf5_beam3d(this, file, dspl, delta, rtag, stag, id) Arguments Type Intent Optional Attributes Name class( beam3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file integer, intent(in) :: dspl real, intent(in), dimension(3) :: delta integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id Contents None","tags":"","loc":"proc/writehdf5_beam3d.html"},{"title":"writerst_beam3d – QuickPIC","text":"private subroutine writerst_beam3d(this, file) Arguments Type Intent Optional Attributes Name class( beam3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file Contents None","tags":"","loc":"proc/writerst_beam3d.html"},{"title":"writeq_beam3d – QuickPIC","text":"private subroutine writeq_beam3d(this, file, rtag, stag, id) Arguments Type Intent Optional Attributes Name class( beam3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id Contents None","tags":"","loc":"proc/writeq_beam3d.html"},{"title":"writeqslice_beam3d – QuickPIC","text":"private subroutine writeqslice_beam3d(this, file, slice, spos, rtag, stag, id) Arguments Type Intent Optional Attributes Name class( beam3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file integer, intent(in) :: slice integer, intent(in) :: spos integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id Contents None","tags":"","loc":"proc/writeqslice_beam3d.html"},{"title":"readrst_beam3d – QuickPIC","text":"private subroutine readrst_beam3d(this, file) Arguments Type Intent Optional Attributes Name class( beam3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file Contents None","tags":"","loc":"proc/readrst_beam3d.html"},{"title":"init_species2d – QuickPIC","text":"private subroutine init_species2d(this, pp, perr, psp, pf, qbm, dt, ci, xdim, s) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( spect3d ), intent(in), pointer :: psp class( fdist2d ), intent(inout), target :: pf real, intent(in) :: qbm real, intent(in) :: dt real, intent(in) :: ci integer, intent(in) :: xdim real, intent(in) :: s Contents None","tags":"","loc":"proc/init_species2d.html"},{"title":"end_species2d – QuickPIC","text":"private subroutine end_species2d(this) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this Contents None","tags":"","loc":"proc/end_species2d.html"},{"title":"renew_species2d – QuickPIC","text":"private subroutine renew_species2d(this, s) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this real, intent(in) :: s Contents None","tags":"","loc":"proc/renew_species2d.html"},{"title":"qdp_species2d – QuickPIC","text":"private subroutine qdp_species2d(this, q) Arguments Type Intent Optional Attributes Name class( species2d ), intent(in) :: this class( field2d ), intent(inout) :: q Contents None","tags":"","loc":"proc/qdp_species2d.html"},{"title":"amjdp_species2d – QuickPIC","text":"private subroutine amjdp_species2d(this, ef, bf, psit, cu, amu, dcu, dex) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this class( field2d ), intent(in) :: ef class( field2d ), intent(in) :: bf class( field2d ), intent(in) :: psit class( field2d ), intent(inout) :: cu class( field2d ), intent(inout) :: amu class( field2d ), intent(inout) :: dcu real, intent(in) :: dex Contents None","tags":"","loc":"proc/amjdp_species2d.html"},{"title":"push_species2d – QuickPIC","text":"private subroutine push_species2d(this, ef, bf, psit, dex) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this class( field2d ), intent(in) :: ef class( field2d ), intent(in) :: bf class( field2d ), intent(in) :: psit real, intent(in) :: dex Contents None","tags":"","loc":"proc/push_species2d.html"},{"title":"pmove_species2d – QuickPIC","text":"private subroutine pmove_species2d(this, fd) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this class( field2d ), intent(in) :: fd Contents None","tags":"","loc":"proc/pmove_species2d.html"},{"title":"extpsi_species2d – QuickPIC","text":"private subroutine extpsi_species2d(this, psi, dex) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this class( field2d ), intent(in) :: psi real, intent(in) :: dex Contents None","tags":"","loc":"proc/extpsi_species2d.html"},{"title":"pcp_species2d – QuickPIC","text":"private subroutine pcp_species2d(this, fd) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this class( field2d ), intent(in) :: fd Contents None","tags":"","loc":"proc/pcp_species2d.html"},{"title":"pcb_species2d – QuickPIC","text":"private subroutine pcb_species2d(this) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this Contents None","tags":"","loc":"proc/pcb_species2d.html"},{"title":"psend_species2d – QuickPIC","text":"private subroutine psend_species2d(this, tag, id) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this integer, intent(in) :: tag integer, intent(inout) :: id Contents None","tags":"","loc":"proc/psend_species2d.html"},{"title":"precv_species2d – QuickPIC","text":"private subroutine precv_species2d(this, tag) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this integer, intent(in) :: tag Contents None","tags":"","loc":"proc/precv_species2d.html"},{"title":"writehdf5_species2d – QuickPIC","text":"private subroutine writehdf5_species2d(this, file, delta) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this class( hdf5file ), intent(in) :: file real, intent(in), dimension(2) :: delta Contents None","tags":"","loc":"proc/writehdf5_species2d.html"},{"title":"writeq_species2d – QuickPIC","text":"private subroutine writeq_species2d(this, file, rtag, stag, id) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this class( hdf5file ), intent(in) :: file integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id Contents None","tags":"","loc":"proc/writeq_species2d.html"},{"title":"writeqslice_species2d – QuickPIC","text":"private subroutine writeqslice_species2d(this, file, slice, spos, rtag, stag, id) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this class( hdf5file ), intent(in) :: file integer, intent(in) :: slice integer, intent(in) :: spos integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id Contents None","tags":"","loc":"proc/writeqslice_species2d.html"},{"title":"cbq_species2d – QuickPIC","text":"private subroutine cbq_species2d(this, pos) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this integer, intent(in) :: pos Contents None","tags":"","loc":"proc/cbq_species2d.html"},{"title":"getlidproc – QuickPIC","text":"private function getlidproc(this) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getlidproc.html"},{"title":"getlkstrt – QuickPIC","text":"private function getlkstrt(this) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getlkstrt.html"},{"title":"getlgrp – QuickPIC","text":"private function getlgrp(this) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getlgrp.html"},{"title":"getlnvp – QuickPIC","text":"private function getlnvp(this) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getlnvp.html"},{"title":"getnstage – QuickPIC","text":"private function getnstage(this) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getnstage.html"},{"title":"getstageid – QuickPIC","text":"private function getstageid(this) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getstageid.html"},{"title":"init_parallel_pipe – QuickPIC","text":"private subroutine init_parallel_pipe(this, nst) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(inout) :: this integer, intent(in) :: nst Calls proc~~init_parallel_pipe~~CallsGraph proc~init_parallel_pipe init_parallel_pipe mpi_comm_rank mpi_comm_rank proc~init_parallel_pipe->mpi_comm_rank mpi_comm_size mpi_comm_size proc~init_parallel_pipe->mpi_comm_size mpi_comm_split mpi_comm_split proc~init_parallel_pipe->mpi_comm_split Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/init_parallel_pipe.html"},{"title":"getlayout – QuickPIC","text":"private function getlayout(this) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getlayout.html"},{"title":"getnvpy – QuickPIC","text":"private function getnvpy(this) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getnvpy~2.html"},{"title":"getnvpx – QuickPIC","text":"private function getnvpx(this) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getnvpx~2.html"},{"title":"getnd2 – QuickPIC","text":"private function getnd2(this) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getnd2~2.html"},{"title":"getnd1 – QuickPIC","text":"private function getnd1(this) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getnd1~2.html"},{"title":"getnd2p – QuickPIC","text":"private function getnd2p(this) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getnd2p~2.html"},{"title":"getnd1p – QuickPIC","text":"private function getnd1p(this) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getnd1p~2.html"},{"title":"getdim – QuickPIC","text":"private function getdim(this) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getdim~2.html"},{"title":"getnoff – QuickPIC","text":"private function getnoff(this) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getnoff~2.html"},{"title":"getrf – QuickPIC","text":"private function getrf(this) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(in) :: this Return Value real,\n  dimension(:,:,:),pointer Contents None","tags":"","loc":"proc/getrf~2.html"},{"title":"add – QuickPIC","text":"private function add(this, that) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(in) :: this class( ufield2d ), intent(in) :: that Return Value class( ufield2d ),\n  allocatable Contents None","tags":"","loc":"proc/add.html"},{"title":"mult1 – QuickPIC","text":"private function mult1(this, value) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(in) :: this real, intent(in) :: value Return Value class( ufield2d ),\n  allocatable Contents None","tags":"","loc":"proc/mult1.html"},{"title":"mult2 – QuickPIC","text":"private function mult2(value, this) Arguments Type Intent Optional Attributes Name real, intent(in) :: value class( ufield2d ), intent(in) :: this Return Value class( ufield2d ),\n  allocatable Contents None","tags":"","loc":"proc/mult2.html"},{"title":"init_ufield2d – QuickPIC","text":"private subroutine init_ufield2d(this, pp, perr, psp, dim, layout, nvpx, nvpy) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( spect2d ), intent(in), pointer :: psp integer, intent(in) :: dim integer, intent(in) :: layout integer, intent(in) :: nvpx integer, intent(in) :: nvpy Contents None","tags":"","loc":"proc/init_ufield2d.html"},{"title":"init_ufield2d_k – QuickPIC","text":"private subroutine init_ufield2d_k(this, pp, perr, psp, dim, layout, nd1, nd2, nvpx, nvpy) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( spect2d ), intent(in), pointer :: psp integer, intent(in) :: dim integer, intent(in) :: layout integer, intent(in) :: nd1 integer, intent(in) :: nd2 integer, intent(in) :: nvpx integer, intent(in) :: nvpy Contents None","tags":"","loc":"proc/init_ufield2d_k.html"},{"title":"end_ufield2d – QuickPIC","text":"private subroutine end_ufield2d(this) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this Contents None","tags":"","loc":"proc/end_ufield2d.html"},{"title":"final_ufield2d – QuickPIC","text":"private subroutine final_ufield2d(this) Arguments Type Intent Optional Attributes Name type( ufield2d ), intent(inout) :: this Contents None","tags":"","loc":"proc/final_ufield2d.html"},{"title":"copyguard – QuickPIC","text":"private subroutine copyguard(this) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this Calls proc~~copyguard~~CallsGraph proc~copyguard copyguard proc~ppncguard2l PPNCGUARD2L proc~copyguard->proc~ppncguard2l mpi_wait mpi_wait proc~ppncguard2l->mpi_wait mpi_send mpi_send proc~ppncguard2l->mpi_send Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/copyguard.html"},{"title":"acopyguard – QuickPIC","text":"private subroutine acopyguard(this) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this Calls proc~~acopyguard~2~~CallsGraph proc~acopyguard~2 acopyguard proc~ppnacguard2l PPNACGUARD2L proc~acopyguard~2->proc~ppnacguard2l mpi_wait mpi_wait proc~ppnacguard2l->mpi_wait mpi_irecv mpi_irecv proc~ppnacguard2l->mpi_irecv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/acopyguard~2.html"},{"title":"writehdf5 – QuickPIC","text":"private subroutine writehdf5(this, file, dim) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this class( hdf5file ), intent(in) :: file integer, intent(in) :: dim Calls proc~~writehdf5~~CallsGraph proc~writehdf5 writehdf5 interface~pwfield pwfield proc~writehdf5->interface~pwfield proc~pwfield_2d pwfield_2d interface~pwfield->proc~pwfield_2d proc~pwfield_3d pwfield_3d interface~pwfield->proc~pwfield_3d h5screate_simple_f h5screate_simple_f proc~pwfield_2d->h5screate_simple_f h5gclose_f h5gclose_f proc~pwfield_2d->h5gclose_f h5pset_fapl_mpio_f h5pset_fapl_mpio_f proc~pwfield_2d->h5pset_fapl_mpio_f h5gopen_f h5gopen_f proc~pwfield_2d->h5gopen_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~pwfield_2d->h5sselect_hyperslab_f proc~wrattr_file wrattr_file proc~pwfield_2d->proc~wrattr_file h5fclose_f h5fclose_f proc~pwfield_2d->h5fclose_f h5sclose_f h5sclose_f proc~pwfield_2d->h5sclose_f h5open_f h5open_f proc~pwfield_2d->h5open_f h5pcreate_f h5pcreate_f proc~pwfield_2d->h5pcreate_f proc~wrattr_dataset wrattr_dataset proc~pwfield_2d->proc~wrattr_dataset h5dclose_f h5dclose_f proc~pwfield_2d->h5dclose_f proc~detect_precision detect_precision proc~pwfield_2d->proc~detect_precision h5dcreate_f h5dcreate_f proc~pwfield_2d->h5dcreate_f h5close_f h5close_f proc~pwfield_2d->h5close_f h5pclose_f h5pclose_f proc~pwfield_2d->h5pclose_f h5fcreate_f h5fcreate_f proc~pwfield_2d->h5fcreate_f h5pset_dxpl_mpio_f h5pset_dxpl_mpio_f proc~pwfield_2d->h5pset_dxpl_mpio_f proc~pwfield_3d->h5screate_simple_f proc~pwfield_3d->h5gclose_f proc~pwfield_3d->h5pset_fapl_mpio_f proc~pwfield_3d->h5gopen_f proc~pwfield_3d->h5sselect_hyperslab_f proc~pwfield_3d->proc~wrattr_file proc~pwfield_3d->h5fclose_f proc~pwfield_3d->h5sclose_f proc~pwfield_3d->h5open_f proc~pwfield_3d->h5pcreate_f proc~pwfield_3d->proc~wrattr_dataset proc~pwfield_3d->h5dclose_f proc~pwfield_3d->proc~detect_precision proc~pwfield_3d->h5dcreate_f proc~pwfield_3d->h5close_f proc~pwfield_3d->h5pclose_f proc~pwfield_3d->h5fcreate_f proc~pwfield_3d->h5pset_dxpl_mpio_f proc~wrattr_file->h5screate_simple_f proc~wrattr_file->h5gclose_f proc~wrattr_file->h5gopen_f proc~wrattr_file->h5sclose_f proc~wrattr_file->h5dclose_f proc~wrattr_file->proc~detect_precision h5dwrite_f h5dwrite_f proc~wrattr_file->h5dwrite_f h5gcreate_f h5gcreate_f proc~wrattr_file->h5gcreate_f interface~add_h5_atribute add_h5_atribute proc~wrattr_file->interface~add_h5_atribute proc~wrattr_dataset->interface~add_h5_atribute proc~add_h5_atribute_str add_h5_atribute_str interface~add_h5_atribute->proc~add_h5_atribute_str proc~add_h5_atribute_int add_h5_atribute_int interface~add_h5_atribute->proc~add_h5_atribute_int proc~add_h5_atribute_v1_int add_h5_atribute_v1_int interface~add_h5_atribute->proc~add_h5_atribute_v1_int proc~add_h5_atribute_v1_single add_h5_atribute_v1_single interface~add_h5_atribute->proc~add_h5_atribute_v1_single proc~add_h5_atribute_single add_h5_atribute_single interface~add_h5_atribute->proc~add_h5_atribute_single proc~add_h5_atribute_str_v1 add_h5_atribute_str_v1 interface~add_h5_atribute->proc~add_h5_atribute_str_v1 proc~add_h5_atribute_str->h5screate_simple_f proc~add_h5_atribute_str->h5sclose_f h5tset_size_f h5tset_size_f proc~add_h5_atribute_str->h5tset_size_f h5acreate_f h5acreate_f proc~add_h5_atribute_str->h5acreate_f h5awrite_f h5awrite_f proc~add_h5_atribute_str->h5awrite_f h5tcopy_f h5tcopy_f proc~add_h5_atribute_str->h5tcopy_f h5aclose_f h5aclose_f proc~add_h5_atribute_str->h5aclose_f h5tclose_f h5tclose_f proc~add_h5_atribute_str->h5tclose_f proc~add_h5_atribute_int->h5screate_simple_f proc~add_h5_atribute_int->h5sclose_f proc~add_h5_atribute_int->h5acreate_f proc~add_h5_atribute_int->h5awrite_f proc~add_h5_atribute_int->h5aclose_f proc~add_h5_atribute_v1_int->h5screate_simple_f proc~add_h5_atribute_v1_int->h5sclose_f proc~add_h5_atribute_v1_int->h5acreate_f proc~add_h5_atribute_v1_int->h5awrite_f proc~add_h5_atribute_v1_int->h5aclose_f proc~add_h5_atribute_v1_single->h5screate_simple_f proc~add_h5_atribute_v1_single->h5sclose_f proc~add_h5_atribute_v1_single->proc~detect_precision proc~add_h5_atribute_v1_single->h5acreate_f proc~add_h5_atribute_v1_single->h5awrite_f proc~add_h5_atribute_v1_single->h5aclose_f proc~add_h5_atribute_single->h5screate_simple_f proc~add_h5_atribute_single->h5sclose_f proc~add_h5_atribute_single->proc~detect_precision proc~add_h5_atribute_single->h5acreate_f proc~add_h5_atribute_single->h5awrite_f proc~add_h5_atribute_single->h5aclose_f proc~add_h5_atribute_str_v1->h5screate_simple_f proc~add_h5_atribute_str_v1->h5sclose_f proc~add_h5_atribute_str_v1->h5tset_size_f proc~add_h5_atribute_str_v1->h5acreate_f proc~add_h5_atribute_str_v1->h5awrite_f proc~add_h5_atribute_str_v1->h5tcopy_f proc~add_h5_atribute_str_v1->h5aclose_f proc~add_h5_atribute_str_v1->h5tclose_f var panprocwritehdf5CallsGraph = svgPanZoom('#procwritehdf5CallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/writehdf5.html"},{"title":"pipesend_ufield2d – QuickPIC","text":"private subroutine pipesend_ufield2d(this, stag, id) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this integer, intent(in) :: stag integer, intent(inout) :: id Calls proc~~pipesend_ufield2d~~CallsGraph proc~pipesend_ufield2d pipesend_ufield2d mpi_isend mpi_isend proc~pipesend_ufield2d->mpi_isend Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/pipesend_ufield2d.html"},{"title":"piperecv_ufield2d – QuickPIC","text":"private subroutine piperecv_ufield2d(this, rtag) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this integer, intent(in) :: rtag Calls proc~~piperecv_ufield2d~~CallsGraph proc~piperecv_ufield2d piperecv_ufield2d mpi_wait mpi_wait proc~piperecv_ufield2d->mpi_wait Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/piperecv_ufield2d.html"},{"title":"sum1 – QuickPIC","text":"private subroutine sum1(this, a1, a2) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this class( ufield2d ), intent(in), target :: a1 class( ufield2d ), intent(in), target :: a2 Contents None","tags":"","loc":"proc/sum1~2.html"},{"title":"sum2 – QuickPIC","text":"private subroutine sum2(this, a1, a2, dim, dim1, dim2) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this class( ufield2d ), intent(in), target :: a1 class( ufield2d ), intent(in), target :: a2 integer, intent(in), dimension(:) :: dim integer, intent(in), dimension(:) :: dim1 integer, intent(in), dimension(:) :: dim2 Contents None","tags":"","loc":"proc/sum2~2.html"},{"title":"minus1 – QuickPIC","text":"private subroutine minus1(this, a1, a2) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this class( ufield2d ), intent(in), target :: a1 class( ufield2d ), intent(in), target :: a2 Contents None","tags":"","loc":"proc/minus1~2.html"},{"title":"minus2 – QuickPIC","text":"private subroutine minus2(this, a1, a2, dim, dim1, dim2) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this class( ufield2d ), intent(in), target :: a1 class( ufield2d ), intent(in), target :: a2 integer, intent(in), dimension(:) :: dim integer, intent(in), dimension(:) :: dim1 integer, intent(in), dimension(:) :: dim2 Contents None","tags":"","loc":"proc/minus2~2.html"},{"title":"multiply1 – QuickPIC","text":"private subroutine multiply1(this, a1, value) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this class( ufield2d ), intent(in), target :: a1 real, intent(in) :: value Contents None","tags":"","loc":"proc/multiply1~2.html"},{"title":"multiply2 – QuickPIC","text":"private subroutine multiply2(this, a1, dim, dim1, value) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this class( ufield2d ), intent(in), target :: a1 integer, intent(in), dimension(:) :: dim integer, intent(in), dimension(:) :: dim1 real, intent(in), dimension(:) :: value Contents None","tags":"","loc":"proc/multiply2~2.html"},{"title":"asc – QuickPIC","text":"private subroutine asc(this, value) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this real, intent(in) :: value Contents None","tags":"","loc":"proc/asc~3.html"},{"title":"asa – QuickPIC","text":"private subroutine asa(this, that) Arguments Type Intent Optional Attributes Name class( ufield2d ), intent(inout) :: this class( ufield2d ), intent(in), target :: that Contents None","tags":"","loc":"proc/asa~3.html"},{"title":"getgcells – QuickPIC","text":"private function getgcells(this) Arguments Type Intent Optional Attributes Name class( field3d ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/getgcells~2.html"},{"title":"getrs – QuickPIC","text":"private function getrs(this) Arguments Type Intent Optional Attributes Name class( field3d ), intent(in) :: this Return Value class( ufield3d ),\n  pointer Contents None","tags":"","loc":"proc/getrs~2.html"},{"title":"init_field3d – QuickPIC","text":"private subroutine init_field3d(this, pp, perr, psp, dim) Arguments Type Intent Optional Attributes Name class( field3d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( spect3d ), intent(in), pointer :: psp integer, intent(in) :: dim Contents None","tags":"","loc":"proc/init_field3d.html"},{"title":"end_field3d – QuickPIC","text":"private subroutine end_field3d(this) Arguments Type Intent Optional Attributes Name class( field3d ), intent(inout) :: this Contents None","tags":"","loc":"proc/end_field3d.html"},{"title":"pipecg_field3d – QuickPIC","text":"private subroutine pipecg_field3d(this, rtag, stag, rid, sid) Arguments Type Intent Optional Attributes Name class( field3d ), intent(inout) :: this integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: rid integer, intent(inout) :: sid Contents None","tags":"","loc":"proc/pipecg_field3d.html"},{"title":"acopyguard_field3d – QuickPIC","text":"private subroutine acopyguard_field3d(this, rtag, stag, id) Arguments Type Intent Optional Attributes Name class( field3d ), intent(inout) :: this integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id Contents None","tags":"","loc":"proc/acopyguard_field3d.html"},{"title":"writehdf5_3d – QuickPIC","text":"private subroutine writehdf5_3d(this, file, dim, rtag, stag, id) Arguments Type Intent Optional Attributes Name class( field3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file integer, intent(in) :: dim integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id Contents None","tags":"","loc":"proc/writehdf5_3d~2.html"},{"title":"writehdf5_2dslice – QuickPIC","text":"private subroutine writehdf5_2dslice(this, file, dim, slice, spos, rtag, stag, id) Arguments Type Intent Optional Attributes Name class( field3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file integer, intent(in) :: dim integer, intent(in) :: slice integer, intent(in) :: spos integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id Contents None","tags":"","loc":"proc/writehdf5_2dslice~2.html"},{"title":"asc – QuickPIC","text":"private subroutine asc(this, value) Arguments Type Intent Optional Attributes Name class( field3d ), intent(inout) :: this real, intent(in) :: value Contents None","tags":"","loc":"proc/asc~4.html"},{"title":"asa – QuickPIC","text":"private subroutine asa(this, that) Arguments Type Intent Optional Attributes Name class( field3d ), intent(inout) :: this class( field3d ), intent(inout) :: that Contents None","tags":"","loc":"proc/asa~4.html"},{"title":"sum – QuickPIC","text":"private subroutine sum(this, a1, a2) Arguments Type Intent Optional Attributes Name class( field3d ), intent(inout) :: this class( field3d ), intent(in) :: a1 class( field3d ), intent(in) :: a2 Contents None","tags":"","loc":"proc/sum~2.html"},{"title":"minus – QuickPIC","text":"private subroutine minus(this, a1, a2) Arguments Type Intent Optional Attributes Name class( field3d ), intent(inout) :: this class( field3d ), intent(in) :: a1 class( field3d ), intent(in) :: a2 Contents None","tags":"","loc":"proc/minus~2.html"},{"title":"multiply – QuickPIC","text":"private subroutine multiply(this, a1, value) Arguments Type Intent Optional Attributes Name class( field3d ), intent(inout) :: this class( field3d ), intent(in) :: a1 real, intent(in) :: value Contents None","tags":"","loc":"proc/multiply~2.html"},{"title":"get_pois2table – QuickPIC","text":"public function get_pois2table(pp, perr, psp, ax, ay, affp) result(table) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( spect2d ), intent(in), pointer :: psp real, intent(in) :: ax real, intent(in) :: ay real, intent(in) :: affp Return Value type( fpois2d ),\n  pointer Called by proc~~get_pois2table~~CalledByGraph proc~get_pois2table get_pois2table proc~init_field2d init_field2d proc~init_field2d->proc~get_pois2table Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_pois2table.html"},{"title":"init_fpois2d – QuickPIC","text":"private subroutine init_fpois2d(this, pp, perr, psp, nx, ny, ax, ay, affp) Arguments Type Intent Optional Attributes Name class( fpois2d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( spect2d ), intent(in), pointer :: psp integer, intent(in) :: nx integer, intent(in) :: ny real, intent(in) :: ax real, intent(in) :: ay real, intent(in) :: affp Calls proc~~init_fpois2d~~CallsGraph proc~init_fpois2d init_fpois2d proc~ippoisd2init ippoisd2init proc~init_fpois2d->proc~ippoisd2init interface~mppoisd22 MPPOISD22 proc~ippoisd2init->interface~mppoisd22 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/init_fpois2d.html"},{"title":"end_fpois2d – QuickPIC","text":"private subroutine end_fpois2d(this) Arguments Type Intent Optional Attributes Name class( fpois2d ), intent(inout) :: this Contents None","tags":"","loc":"proc/end_fpois2d.html"},{"title":"ippoisd2init – QuickPIC","text":"private subroutine ippoisd2init(this, ax, ay, affp, nx, ny, kstrt) Arguments Type Intent Optional Attributes Name class( fpois2d ), intent(in) :: this real, intent(in) :: ax real, intent(in) :: ay real, intent(in) :: affp integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kstrt Calls proc~~ippoisd2init~~CallsGraph proc~ippoisd2init ippoisd2init interface~mppoisd22 MPPOISD22 proc~ippoisd2init->interface~mppoisd22 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~ippoisd2init~~CalledByGraph proc~ippoisd2init ippoisd2init proc~init_fpois2d init_fpois2d proc~init_fpois2d->proc~ippoisd2init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ippoisd2init.html"},{"title":"ipotd2 – QuickPIC","text":"private subroutine ipotd2(this, q, fx, we) Arguments Type Intent Optional Attributes Name class( fpois2d ), intent(in) :: this class( ufield2d ), intent(inout) :: q class( ufield2d ), intent(inout) :: fx real, intent(inout) :: we Calls proc~~ipotd2~~CallsGraph proc~ipotd2 ipotd2 proc~ippoisd2 ippoisd2 proc~ipotd2->proc~ippoisd2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ipotd2.html"},{"title":"ippoisd2 – QuickPIC","text":"private subroutine ippoisd2(this, q, fx, isign, we) Arguments Type Intent Optional Attributes Name class( fpois2d ), intent(in) :: this real, intent(inout), dimension(:,:,:), pointer :: q real, intent(inout), dimension(:,:,:), pointer :: fx integer, intent(in) :: isign real, intent(inout) :: we Called by proc~~ippoisd2~~CalledByGraph proc~ippoisd2 ippoisd2 proc~ipotd2 ipotd2 proc~ipotd2->proc~ippoisd2 proc~ismoothfd2 ismoothfd2 proc~ismoothfd2->proc~ippoisd2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ippoisd2.html"},{"title":"ismoothfd2 – QuickPIC","text":"private subroutine ismoothfd2(this, f, fs) Arguments Type Intent Optional Attributes Name class( fpois2d ), intent(in) :: this class( ufield2d ), intent(inout) :: f class( ufield2d ), intent(inout) :: fs Calls proc~~ismoothfd2~~CallsGraph proc~ismoothfd2 ismoothfd2 proc~ippoisd2 ippoisd2 proc~ismoothfd2->proc~ippoisd2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ismoothfd2.html"},{"title":"ippoisd23 – QuickPIC","text":"private subroutine ippoisd23(this, q, fxy, we) Arguments Type Intent Optional Attributes Name class( fpois2d ), intent(in) :: this class( ufield2d ), intent(inout) :: q class( ufield2d ), intent(inout) :: fxy real, intent(inout) :: we Contents None","tags":"","loc":"proc/ippoisd23.html"},{"title":"ibfieldd2 – QuickPIC","text":"private subroutine ibfieldd2(this, cu, bxy, ci, wm) Arguments Type Intent Optional Attributes Name class( fpois2d ), intent(in) :: this class( ufield2d ), intent(inout) :: cu class( ufield2d ), intent(inout) :: bxy real, intent(in) :: ci real, intent(inout) :: wm Calls proc~~ibfieldd2~~CallsGraph proc~ibfieldd2 ibfieldd2 proc~jpbpoisd23 jpbpoisd23 proc~ibfieldd2->proc~jpbpoisd23 interface~mppbbpoisd23 MPPBBPOISD23 proc~jpbpoisd23->interface~mppbbpoisd23 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ibfieldd2.html"},{"title":"jpbpoisd23 – QuickPIC","text":"private subroutine jpbpoisd23(this, cu, bxy, isign, ci, wm) Arguments Type Intent Optional Attributes Name class( fpois2d ), intent(in) :: this real, intent(inout), dimension(:,:,:), pointer :: cu real, intent(inout), dimension(:,:,:), pointer :: bxy integer, intent(in) :: isign real, intent(in) :: ci real, intent(inout) :: wm Calls proc~~jpbpoisd23~~CallsGraph proc~jpbpoisd23 jpbpoisd23 interface~mppbbpoisd23 MPPBBPOISD23 proc~jpbpoisd23->interface~mppbbpoisd23 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~jpbpoisd23~~CalledByGraph proc~jpbpoisd23 jpbpoisd23 proc~ibfieldd2 ibfieldd2 proc~ibfieldd2->proc~jpbpoisd23 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/jpbpoisd23.html"},{"title":"jpbpoisd23n_qp – QuickPIC","text":"private subroutine jpbpoisd23n_qp(this, cu, dcu, amu, bxy, ci, c, dex, wm) Arguments Type Intent Optional Attributes Name class( fpois2d ), intent(in) :: this class( ufield2d ), intent(inout) :: cu class( ufield2d ), intent(inout) :: dcu class( ufield2d ), intent(inout) :: amu class( ufield2d ), intent(inout) :: bxy real, intent(in) :: ci real, intent(in) :: c real, intent(in) :: dex real, intent(inout) :: wm Calls proc~~jpbpoisd23n_qp~~CallsGraph proc~jpbpoisd23n_qp jpbpoisd23n_qp interface~pbpoisd22n_qp PBPOISD22N_QP proc~jpbpoisd23n_qp->interface~pbpoisd22n_qp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/jpbpoisd23n_qp.html"},{"title":"PPRTPOSE – QuickPIC","text":"public subroutine PPRTPOSE(f, g, s, t, nx, ny, kxp, kyp, kstrt, nvp, nxv, nyv, kxpd, kypd) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(nxv,kypd) :: f real, intent(inout), dimension(nyv,kxpd) :: g real, intent(inout), dimension((kxp+1)*(kyp+1)) :: s real, intent(inout), dimension((kxp+1)*(kyp+1)) :: t integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kxp integer, intent(in) :: kyp integer, intent(in) :: kstrt integer, intent(in) :: nvp integer, intent(in) :: nxv integer, intent(in) :: nyv integer, intent(in) :: kxpd integer, intent(in) :: kypd Calls proc~~pprtpose~2~~CallsGraph proc~pprtpose~2 PPRTPOSE mpi_wait mpi_wait proc~pprtpose~2->mpi_wait mpi_irecv mpi_irecv proc~pprtpose~2->mpi_irecv mpi_send mpi_send proc~pprtpose~2->mpi_send Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/pprtpose~2.html"},{"title":"PPRNTPOSE – QuickPIC","text":"public subroutine PPRNTPOSE(f, g, s, t, nx, ny, kxp, kyp, kstrt, nvp, ndim, nxv, nyv, kxpd, kypd) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(ndim,nxv,kypd) :: f real, intent(inout), dimension(ndim,nyv,kxpd) :: g real, intent(inout), dimension(ndim,(kxp+1)*(kyp+1)) :: s real, intent(inout), dimension(ndim,(kxp+1)*(kyp+1)) :: t integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kxp integer, intent(in) :: kyp integer, intent(in) :: kstrt integer, intent(in) :: nvp integer, intent(in) :: ndim integer, intent(in) :: nxv integer, intent(in) :: nyv integer, intent(in) :: kxpd integer, intent(in) :: kypd Calls proc~~pprntpose~2~~CallsGraph proc~pprntpose~2 PPRNTPOSE mpi_wait mpi_wait proc~pprntpose~2->mpi_wait mpi_irecv mpi_irecv proc~pprntpose~2->mpi_irecv mpi_send mpi_send proc~pprntpose~2->mpi_send Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/pprntpose~2.html"},{"title":"WPFST2RINIT – QuickPIC","text":"interface Called by interface~~wpfst2rinit~~CalledByGraph interface~wpfst2rinit WPFST2RINIT proc~init_fft2d init_fft2d proc~init_fft2d->interface~wpfst2rinit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine WPFST2RINIT(mixup, sctd, indx, indy, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(nxhyd) :: mixup complex, intent(inout), dimension(nxyd) :: sctd integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: nxhyd integer, intent(in) :: nxyd","tags":"","loc":"interface/wpfst2rinit.html"},{"title":"WPFSST2R – QuickPIC","text":"interface public subroutine WPFSST2R(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nxvh, nyv, kxp2, kyp, kypd, kxp2d, jblok, kblok, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout) :: f real, intent(inout), dimension(nyv,kxp2d,jblok) :: g real, intent(inout), dimension(kxp2+1,kyp+1,kblok) :: bs real, intent(inout), dimension(kxp2+1,kyp+1,jblok) :: br integer, intent(in) :: isign integer, intent(in) :: ntpose integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd real, intent(inout) :: ttp integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: nxvh integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: kyp integer, intent(in) :: kypd integer, intent(in) :: kxp2d integer, intent(in) :: jblok integer, intent(in) :: kblok integer, intent(in) :: nxhyd integer, intent(in) :: nxyd","tags":"","loc":"interface/wpfsst2r.html"},{"title":"WPFSCT2R – QuickPIC","text":"interface public subroutine WPFSCT2R(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nxvh, nyv, kxp2, kyp, kypd, kxp2d, jblok, kblok, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout) :: f real, intent(inout), dimension(nyv,kxp2d,jblok) :: g real, intent(inout), dimension(kxp2+1,kyp+1,kblok) :: bs real, intent(inout), dimension(kxp2+1,kyp+1,jblok) :: br integer, intent(in) :: isign integer, intent(in) :: ntpose integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd real, intent(inout) :: ttp integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: nxvh integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: kyp integer, intent(in) :: kypd integer, intent(in) :: kxp2d integer, intent(in) :: jblok integer, intent(in) :: kblok integer, intent(in) :: nxhyd integer, intent(in) :: nxyd","tags":"","loc":"interface/wpfsct2r.html"},{"title":"WPFCST2R – QuickPIC","text":"interface public subroutine WPFCST2R(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nxvh, nyv, kxp2, kyp, kypd, kxp2d, jblok, kblok, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout) :: f real, intent(inout), dimension(nyv,kxp2d,jblok) :: g real, intent(inout), dimension(kxp2+1,kyp+1,kblok) :: bs real, intent(inout), dimension(kxp2+1,kyp+1,jblok) :: br integer, intent(in) :: isign integer, intent(in) :: ntpose integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd real, intent(inout) :: ttp integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: nxvh integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: kyp integer, intent(in) :: kypd integer, intent(in) :: kxp2d integer, intent(in) :: jblok integer, intent(in) :: kblok integer, intent(in) :: nxhyd integer, intent(in) :: nxyd","tags":"","loc":"interface/wpfcst2r.html"},{"title":"WPFCCT2R – QuickPIC","text":"interface public subroutine WPFCCT2R(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nxvh, nyv, kxp2, kyp, kypd, kxp2d, jblok, kblok, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout) :: f real, intent(inout), dimension(nyv,kxp2d,jblok) :: g real, intent(inout), dimension(kxp2+1,kyp+1,kblok) :: bs real, intent(inout), dimension(kxp2+1,kyp+1,jblok) :: br integer, intent(in) :: isign integer, intent(in) :: ntpose integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd real, intent(inout) :: ttp integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: nxvh integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: kyp integer, intent(in) :: kypd integer, intent(in) :: kxp2d integer, intent(in) :: jblok integer, intent(in) :: kblok integer, intent(in) :: nxhyd integer, intent(in) :: nxyd","tags":"","loc":"interface/wpfcct2r.html"},{"title":"WPFCST2R2 – QuickPIC","text":"interface public subroutine WPFCST2R2(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nxvh, nyv, kxp2, kyp, kypd, kxp2d, jblok, kblok, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout) :: f real, intent(inout), dimension(2,nyv,kxp2d,jblok) :: g real, intent(inout), dimension(2,kxp2+1,kyp+1,kblok) :: bs real, intent(inout), dimension(2,kxp2+1,kyp+1,jblok) :: br integer, intent(in) :: isign integer, intent(in) :: ntpose integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd real, intent(inout) :: ttp integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: nxvh integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: kyp integer, intent(in) :: kypd integer, intent(in) :: kxp2d integer, intent(in) :: jblok integer, intent(in) :: kblok integer, intent(in) :: nxhyd integer, intent(in) :: nxyd","tags":"","loc":"interface/wpfcst2r2.html"},{"title":"WPFSCT2R2 – QuickPIC","text":"interface public subroutine WPFSCT2R2(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nxvh, nyv, kxp2, kyp, kypd, kxp2d, jblok, kblok, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout) :: f real, intent(inout), dimension(2,nyv,kxp2d,jblok) :: g real, intent(inout), dimension(2,kxp2+1,kyp+1,kblok) :: bs real, intent(inout), dimension(2,kxp2+1,kyp+1,jblok) :: br integer, intent(in) :: isign integer, intent(in) :: ntpose integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd real, intent(inout) :: ttp integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: nxvh integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: kyp integer, intent(in) :: kypd integer, intent(in) :: kxp2d integer, intent(in) :: jblok integer, intent(in) :: kblok integer, intent(in) :: nxhyd integer, intent(in) :: nxyd","tags":"","loc":"interface/wpfsct2r2.html"},{"title":"WPFCST2R3 – QuickPIC","text":"interface public subroutine WPFCST2R3(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nxvh, nyv, kxp2, kyp, kypd, kxp2d, jblok, kblok, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout) :: f real, intent(inout), dimension(3,nyv,kxp2d,jblok) :: g real, intent(inout), dimension(3,kxp2+1,kyp+1,kblok) :: bs real, intent(inout), dimension(3,kxp2+1,kyp+1,jblok) :: br integer, intent(in) :: isign integer, intent(in) :: ntpose integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd real, intent(inout) :: ttp integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: nxvh integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: kyp integer, intent(in) :: kypd integer, intent(in) :: kxp2d integer, intent(in) :: jblok integer, intent(in) :: kblok integer, intent(in) :: nxhyd integer, intent(in) :: nxyd","tags":"","loc":"interface/wpfcst2r3.html"},{"title":"WPFSCT2R3 – QuickPIC","text":"interface public subroutine WPFSCT2R3(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nxvh, nyv, kxp2, kyp, kypd, kxp2d, jblok, kblok, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout) :: f real, intent(inout), dimension(3,nyv,kxp2d,jblok) :: g real, intent(inout), dimension(3,kxp2+1,kyp+1,kblok) :: bs real, intent(inout), dimension(3,kxp2+1,kyp+1,jblok) :: br integer, intent(in) :: isign integer, intent(in) :: ntpose integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd real, intent(inout) :: ttp integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: nxvh integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: kyp integer, intent(in) :: kypd integer, intent(in) :: kxp2d integer, intent(in) :: jblok integer, intent(in) :: kblok integer, intent(in) :: nxhyd integer, intent(in) :: nxyd","tags":"","loc":"interface/wpfsct2r3.html"},{"title":"WPFS3T2R3 – QuickPIC","text":"interface public subroutine WPFS3T2R3(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nxvh, nyv, kxp2, kyp, kypd, kxp2d, jblok, kblok, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout) :: f real, intent(inout), dimension(3,nyv,kxp2d,jblok) :: g real, intent(inout), dimension(3,kxp2+1,kyp+1,kblok) :: bs real, intent(inout), dimension(3,kxp2+1,kyp+1,jblok) :: br integer, intent(in) :: isign integer, intent(in) :: ntpose integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd real, intent(inout) :: ttp integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: nxvh integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: kyp integer, intent(in) :: kypd integer, intent(in) :: kxp2d integer, intent(in) :: jblok integer, intent(in) :: kblok integer, intent(in) :: nxhyd integer, intent(in) :: nxyd","tags":"","loc":"interface/wpfs3t2r3.html"},{"title":"PDIVFD2 – QuickPIC","text":"interface public subroutine PDIVFD2(f, df, nx, ny, kstrt, ndim, nyv, kxp2, j2blok) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(ndim,nyv,kxp2+1,j2blok) :: f real, intent(inout), dimension(nyv,kxp2+1,j2blok) :: df integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kstrt integer, intent(in) :: ndim integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: j2blok","tags":"","loc":"interface/pdivfd2.html"},{"title":"PGRADFD2 – QuickPIC","text":"interface public subroutine PGRADFD2(df, f, nx, ny, kstrt, ndim, nyv, kxp2, j2blok) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(nyv,kxp2+1,j2blok) :: df real, intent(inout), dimension(ndim,nyv,kxp2+1,j2blok) :: f integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kstrt integer, intent(in) :: ndim integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: j2blok","tags":"","loc":"interface/pgradfd2.html"},{"title":"PCURLFD2 – QuickPIC","text":"interface public subroutine PCURLFD2(f, g, nx, ny, kstrt, nyv, kxp2, j2blok) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(3,nyv,kxp2+1,j2blok) :: f real, intent(inout), dimension(3,nyv,kxp2+1,j2blok) :: g integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kstrt integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: j2blok","tags":"","loc":"interface/pcurlfd2.html"},{"title":"PCURLFD22 – QuickPIC","text":"interface Called by interface~~pcurlfd22~~CalledByGraph interface~pcurlfd22 PCURLFD22 proc~ipcurlfd2 ipcurlfd2 proc~ipcurlfd2->interface~pcurlfd22 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine PCURLFD22(f, g, nx, ny, kstrt, nyv, kxp2, j2blok) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(2,nyv,kxp2+1,j2blok) :: f real, intent(inout), dimension(nyv,kxp2+1,j2blok) :: g integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kstrt integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: j2blok","tags":"","loc":"interface/pcurlfd22.html"},{"title":"WPPFSST2RM – QuickPIC","text":"interface public subroutine WPPFSST2RM(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nvp, nxvh, nyv, kxp2, kyp, kypd, kxp2d, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(2*nxvh,kypd) :: f real, intent(inout), dimension(nyv,kxp2d) :: g real, intent(inout), dimension(kxp2+1,kyp+1) :: bs real, intent(inout), dimension(kxp2+1,kyp+1) :: br integer, intent(in) :: isign integer, intent(in) :: ntpose integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd real, intent(inout) :: ttp integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: nvp integer, intent(in) :: nxvh integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: kyp integer, intent(in) :: kypd integer, intent(in) :: kxp2d integer, intent(in) :: nxhyd integer, intent(in) :: nxyd","tags":"","loc":"interface/wppfsst2rm.html"},{"title":"WPPFSCT2RM – QuickPIC","text":"interface public subroutine WPPFSCT2RM(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nvp, nxvh, nyv, kxp2, kyp, kypd, kxp2d, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(2*nxvh,kypd) :: f real, intent(inout), dimension(nyv,kxp2d) :: g real, intent(inout), dimension(kxp2+1,kyp+1) :: bs real, intent(inout), dimension(kxp2+1,kyp+1) :: br integer, intent(in) :: isign integer, intent(in) :: ntpose integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd real, intent(inout) :: ttp integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: nvp integer, intent(in) :: nxvh integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: kyp integer, intent(in) :: kypd integer, intent(in) :: kxp2d integer, intent(in) :: nxhyd integer, intent(in) :: nxyd","tags":"","loc":"interface/wppfsct2rm.html"},{"title":"WPPFCST2RM – QuickPIC","text":"interface public subroutine WPPFCST2RM(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nvp, nxvh, nyv, kxp2, kyp, kypd, kxp2d, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(2*nxvh,kypd) :: f real, intent(inout), dimension(nyv,kxp2d) :: g real, intent(inout), dimension(kxp2+1,kyp+1) :: bs real, intent(inout), dimension(kxp2+1,kyp+1) :: br integer, intent(in) :: isign integer, intent(in) :: ntpose integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd real, intent(inout) :: ttp integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: nvp integer, intent(in) :: nxvh integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: kyp integer, intent(in) :: kypd integer, intent(in) :: kxp2d integer, intent(in) :: nxhyd integer, intent(in) :: nxyd","tags":"","loc":"interface/wppfcst2rm.html"},{"title":"WPPFCCT2RM – QuickPIC","text":"interface public subroutine WPPFCCT2RM(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nvp, nxvh, nyv, kxp2, kyp, kypd, kxp2d, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(2*nxvh,kypd) :: f real, intent(inout), dimension(nyv,kxp2d) :: g real, intent(inout), dimension(kxp2+1,kyp+1) :: bs real, intent(inout), dimension(kxp2+1,kyp+1) :: br integer, intent(in) :: isign integer, intent(in) :: ntpose integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd real, intent(inout) :: ttp integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: nvp integer, intent(in) :: nxvh integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: kyp integer, intent(in) :: kypd integer, intent(in) :: kxp2d integer, intent(in) :: nxhyd integer, intent(in) :: nxyd","tags":"","loc":"interface/wppfcct2rm.html"},{"title":"PPFST2RMXX – QuickPIC","text":"interface public subroutine PPFST2RMXX(f, isign, mixup, sctd, indx, indy, kstrt, kypi, kypp, nxvh, kypd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(2*nxvh,kypd) :: f integer, intent(in) :: isign integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: kypi integer, intent(in) :: kypp integer, intent(in) :: nxvh integer, intent(in) :: kypd integer, intent(in) :: nxhyd integer, intent(in) :: nxyd","tags":"","loc":"interface/ppfst2rmxx.html"},{"title":"PPFCT2RMXX – QuickPIC","text":"interface public subroutine PPFCT2RMXX(f, isign, mixup, sctd, indx, indy, kstrt, kypi, kypp, nxvh, kypd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(2*nxvh,kypd) :: f integer, intent(in) :: isign integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: kypi integer, intent(in) :: kypp integer, intent(in) :: nxvh integer, intent(in) :: kypd integer, intent(in) :: nxhyd integer, intent(in) :: nxyd","tags":"","loc":"interface/ppfct2rmxx.html"},{"title":"PPFST2RMXY – QuickPIC","text":"interface public subroutine PPFST2RMXY(g, isign, mixup, sctd, indx, indy, kstrt, kxpi, kxpp, nyv, kxpd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(nyv,kxpd) :: g integer, intent(in) :: isign integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: kxpi integer, intent(in) :: kxpp integer, intent(in) :: nyv integer, intent(in) :: kxpd integer, intent(in) :: nxhyd integer, intent(in) :: nxyd","tags":"","loc":"interface/ppfst2rmxy.html"},{"title":"PPFCT2RMXY – QuickPIC","text":"interface public subroutine PPFCT2RMXY(g, isign, mixup, sctd, indx, indy, kstrt, kxpi, kxpp, nyv, kxpd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(nyv,kxpd) :: g integer, intent(in) :: isign integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: kxpi integer, intent(in) :: kxpp integer, intent(in) :: nyv integer, intent(in) :: kxpd integer, intent(in) :: nxhyd integer, intent(in) :: nxyd","tags":"","loc":"interface/ppfct2rmxy.html"},{"title":"WPPFCST2RM2 – QuickPIC","text":"interface Called by interface~~wppfcst2rm2~~CalledByGraph interface~wppfcst2rm2 WPPFCST2RM2 proc~iwpfsst2r iwpfsst2r proc~iwpfsst2r->interface~wppfcst2rm2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine WPPFCST2RM2(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nvp, nxvh, nyv, kxp2, kyp, kypd, kxp2d, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(2,2*nxvh,kypd) :: f real, intent(inout), dimension(2,nyv,kxp2d) :: g real, intent(inout), dimension(2,kxp2+1,kyp+1) :: bs real, intent(inout), dimension(2,kxp2+1,kyp+1) :: br integer, intent(in) :: isign integer, intent(in) :: ntpose integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd real, intent(inout) :: ttp integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: nvp integer, intent(in) :: nxvh integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: kyp integer, intent(in) :: kypd integer, intent(in) :: kxp2d integer, intent(in) :: nxhyd integer, intent(in) :: nxyd","tags":"","loc":"interface/wppfcst2rm2.html"},{"title":"WPPFSCT2RM2 – QuickPIC","text":"interface Called by interface~~wppfsct2rm2~~CalledByGraph interface~wppfsct2rm2 WPPFSCT2RM2 proc~iwpfcct2r iwpfcct2r proc~iwpfcct2r->interface~wppfsct2rm2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine WPPFSCT2RM2(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nvp, nxvh, nyv, kxp2, kyp, kypd, kxp2d, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(2,2*nxvh,kypd) :: f real, intent(inout), dimension(2,nyv,kxp2d) :: g real, intent(inout), dimension(2,kxp2+1,kyp+1) :: bs real, intent(inout), dimension(2,kxp2+1,kyp+1) :: br integer, intent(in) :: isign integer, intent(in) :: ntpose integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd real, intent(inout) :: ttp integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: nvp integer, intent(in) :: nxvh integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: kyp integer, intent(in) :: kypd integer, intent(in) :: kxp2d integer, intent(in) :: nxhyd integer, intent(in) :: nxyd","tags":"","loc":"interface/wppfsct2rm2.html"},{"title":"PPFCST2RM2X – QuickPIC","text":"interface public subroutine PPFCST2RM2X(f, isign, mixup, sctd, indx, indy, kstrt, kypi, kypp, nxvh, kypd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(2,2*nxvh,kypd) :: f integer, intent(in) :: isign integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: kypi integer, intent(in) :: kypp integer, intent(in) :: nxvh integer, intent(in) :: kypd integer, intent(in) :: nxhyd integer, intent(in) :: nxyd","tags":"","loc":"interface/ppfcst2rm2x.html"},{"title":"PPFSCT2RM2X – QuickPIC","text":"interface public subroutine PPFSCT2RM2X(f, isign, mixup, sctd, indx, indy, kstrt, kypi, kypp, nxvh, kypd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(2,2*nxvh,kypd) :: f integer, intent(in) :: isign integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: kypi integer, intent(in) :: kypp integer, intent(in) :: nxvh integer, intent(in) :: kypd integer, intent(in) :: nxhyd integer, intent(in) :: nxyd","tags":"","loc":"interface/ppfsct2rm2x.html"},{"title":"PPFSCT2RM2Y – QuickPIC","text":"interface public subroutine PPFSCT2RM2Y(g, isign, mixup, sctd, indx, indy, kstrt, kxpi, kxpp, nyv, kxpd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(2,nyv,kxpd) :: g integer, intent(in) :: isign integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: kxpi integer, intent(in) :: kxpp integer, intent(in) :: nyv integer, intent(in) :: kxpd integer, intent(in) :: nxhyd integer, intent(in) :: nxyd","tags":"","loc":"interface/ppfsct2rm2y.html"},{"title":"PPFCST2RM2Y – QuickPIC","text":"interface public subroutine PPFCST2RM2Y(g, isign, mixup, sctd, indx, indy, kstrt, kxpi, kxpp, nyv, kxpd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(2,nyv,kxpd) :: g integer, intent(in) :: isign integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: kxpi integer, intent(in) :: kxpp integer, intent(in) :: nyv integer, intent(in) :: kxpd integer, intent(in) :: nxhyd integer, intent(in) :: nxyd","tags":"","loc":"interface/ppfcst2rm2y.html"},{"title":"WPPFCST2RM3 – QuickPIC","text":"interface Called by interface~~wppfcst2rm3~~CalledByGraph interface~wppfcst2rm3 WPPFCST2RM3 proc~iwpfsst2r iwpfsst2r proc~iwpfsst2r->interface~wppfcst2rm3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine WPPFCST2RM3(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nvp, nxvh, nyv, kxp2, kyp, kypd, kxp2d, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(3,2*nxvh,kypd) :: f real, intent(inout), dimension(3,nyv,kxp2d) :: g real, intent(inout), dimension(3,kxp2+1,kyp+1) :: bs real, intent(inout), dimension(3,kxp2+1,kyp+1) :: br integer, intent(in) :: isign integer, intent(in) :: ntpose integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd real, intent(inout) :: ttp integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: nvp integer, intent(in) :: nxvh integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: kyp integer, intent(in) :: kypd integer, intent(in) :: kxp2d integer, intent(in) :: nxhyd integer, intent(in) :: nxyd","tags":"","loc":"interface/wppfcst2rm3.html"},{"title":"WPPFSCT2RM3 – QuickPIC","text":"interface Called by interface~~wppfsct2rm3~~CalledByGraph interface~wppfsct2rm3 WPPFSCT2RM3 proc~iwpfcct2r iwpfcct2r proc~iwpfcct2r->interface~wppfsct2rm3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine WPPFSCT2RM3(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nvp, nxvh, nyv, kxp2, kyp, kypd, kxp2d, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(3,2*nxvh,kypd) :: f real, intent(inout), dimension(3,nyv,kxp2d) :: g real, intent(inout), dimension(3,kxp2+1,kyp+1) :: bs real, intent(inout), dimension(3,kxp2+1,kyp+1) :: br integer, intent(in) :: isign integer, intent(in) :: ntpose integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd real, intent(inout) :: ttp integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: nvp integer, intent(in) :: nxvh integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: kyp integer, intent(in) :: kypd integer, intent(in) :: kxp2d integer, intent(in) :: nxhyd integer, intent(in) :: nxyd","tags":"","loc":"interface/wppfsct2rm3.html"},{"title":"PPFCSST2RM3X – QuickPIC","text":"interface public subroutine PPFCSST2RM3X(f, isign, mixup, sctd, indx, indy, kstrt, kypi, kypp, nxvh, kypd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(3,2*nxvh,kypd) :: f integer, intent(in) :: isign integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: kypi integer, intent(in) :: kypp integer, intent(in) :: nxvh integer, intent(in) :: kypd integer, intent(in) :: nxhyd integer, intent(in) :: nxyd","tags":"","loc":"interface/ppfcsst2rm3x.html"},{"title":"PPFSCCT2RM3X – QuickPIC","text":"interface public subroutine PPFSCCT2RM3X(f, isign, mixup, sctd, indx, indy, kstrt, kypi, kypp, nxvh, kypd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(3,2*nxvh,kypd) :: f integer, intent(in) :: isign integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: kypi integer, intent(in) :: kypp integer, intent(in) :: nxvh integer, intent(in) :: kypd integer, intent(in) :: nxhyd integer, intent(in) :: nxyd","tags":"","loc":"interface/ppfscct2rm3x.html"},{"title":"PPFSCST2RM3Y – QuickPIC","text":"interface public subroutine PPFSCST2RM3Y(g, isign, mixup, sctd, indx, indy, kstrt, kxpi, kxpp, nyv, kxpd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(3,nyv,kxpd) :: g integer, intent(in) :: isign integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: kxpi integer, intent(in) :: kxpp integer, intent(in) :: nyv integer, intent(in) :: kxpd integer, intent(in) :: nxhyd integer, intent(in) :: nxyd","tags":"","loc":"interface/ppfscst2rm3y.html"},{"title":"PPFCSCT2RM3Y – QuickPIC","text":"interface public subroutine PPFCSCT2RM3Y(g, isign, mixup, sctd, indx, indy, kstrt, kxpi, kxpp, nyv, kxpd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(3,nyv,kxpd) :: g integer, intent(in) :: isign integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: kxpi integer, intent(in) :: kxpp integer, intent(in) :: nyv integer, intent(in) :: kxpd integer, intent(in) :: nxhyd integer, intent(in) :: nxyd","tags":"","loc":"interface/ppfcsct2rm3y.html"},{"title":"WPPFSCT2RM4 – QuickPIC","text":"interface public subroutine WPPFSCT2RM4(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nvp, nxvh, nyv, kxp2, kyp, kypd, kxp2d, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(4,2*nxvh,kypd) :: f real, intent(inout), dimension(4,nyv,kxp2d) :: g real, intent(inout), dimension(4,kxp2+1,kyp+1) :: bs real, intent(inout), dimension(4,kxp2+1,kyp+1) :: br integer, intent(in) :: isign integer, intent(in) :: ntpose integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd real, intent(inout) :: ttp integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: nvp integer, intent(in) :: nxvh integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: kyp integer, intent(in) :: kypd integer, intent(in) :: kxp2d integer, intent(in) :: nxhyd integer, intent(in) :: nxyd","tags":"","loc":"interface/wppfsct2rm4.html"},{"title":"PPFSCCST2RM4X – QuickPIC","text":"interface public subroutine PPFSCCST2RM4X(f, isign, mixup, sctd, indx, indy, kstrt, kypi, kypp, nxvh, kypd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(4,2*nxvh,kypd) :: f integer, intent(in) :: isign integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: kypi integer, intent(in) :: kypp integer, intent(in) :: nxvh integer, intent(in) :: kypd integer, intent(in) :: nxhyd integer, intent(in) :: nxyd","tags":"","loc":"interface/ppfsccst2rm4x.html"},{"title":"PPFSCSCT2RM4Y – QuickPIC","text":"interface public subroutine PPFSCSCT2RM4Y(g, isign, mixup, sctd, indx, indy, kstrt, kxpi, kxpp, nyv, kxpd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(4,nyv,kxpd) :: g integer, intent(in) :: isign integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: kxpi integer, intent(in) :: kxpp integer, intent(in) :: nyv integer, intent(in) :: kxpd integer, intent(in) :: nxhyd integer, intent(in) :: nxyd","tags":"","loc":"interface/ppfscsct2rm4y.html"},{"title":"WPPFSCT2RM22 – QuickPIC","text":"interface public subroutine WPPFSCT2RM22(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nvp, nxvh, nyv, kxp2, kyp, kypd, kxp2d, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(2,2*nxvh,kypd) :: f real, intent(inout), dimension(2,nyv,kxp2d) :: g real, intent(inout), dimension(2,kxp2+1,kyp+1) :: bs real, intent(inout), dimension(2,kxp2+1,kyp+1) :: br integer, intent(in) :: isign integer, intent(in) :: ntpose integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd real, intent(inout) :: ttp integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: nvp integer, intent(in) :: nxvh integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: kyp integer, intent(in) :: kypd integer, intent(in) :: kxp2d integer, intent(in) :: nxhyd integer, intent(in) :: nxyd","tags":"","loc":"interface/wppfsct2rm22.html"},{"title":"PPFSCCST2RM22X – QuickPIC","text":"interface public subroutine PPFSCCST2RM22X(f, isign, mixup, sctd, indx, indy, kstrt, kypi, kypp, nxvh, kypd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(2,2*nxvh,kypd) :: f integer, intent(in) :: isign integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: kypi integer, intent(in) :: kypp integer, intent(in) :: nxvh integer, intent(in) :: kypd integer, intent(in) :: nxhyd integer, intent(in) :: nxyd","tags":"","loc":"interface/ppfsccst2rm22x.html"},{"title":"PPFSCSCT2RM22Y – QuickPIC","text":"interface public subroutine PPFSCSCT2RM22Y(g, isign, mixup, sctd, indx, indy, kstrt, kxpi, kxpp, nyv, kxpd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(2,nyv,kxpd) :: g integer, intent(in) :: isign integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: kxpi integer, intent(in) :: kxpp integer, intent(in) :: nyv integer, intent(in) :: kxpd integer, intent(in) :: nxhyd integer, intent(in) :: nxyd","tags":"","loc":"interface/ppfscsct2rm22y.html"},{"title":"WPPFSST2RM23 – QuickPIC","text":"interface Called by interface~~wppfsst2rm23~~CalledByGraph interface~wppfsst2rm23 WPPFSST2RM23 proc~iwpfs3t2r iwpfs3t2r proc~iwpfs3t2r->interface~wppfsst2rm23 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine WPPFSST2RM23(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nvp, nxvh, nyv, kxp2, kyp, kypd, kxp2d, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(3,2*nxvh,kypd) :: f real, intent(inout), dimension(3,nyv,kxp2d) :: g real, intent(inout), dimension(3,kxp2+1,kyp+1) :: bs real, intent(inout), dimension(3,kxp2+1,kyp+1) :: br integer, intent(in) :: isign integer, intent(in) :: ntpose integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd real, intent(inout) :: ttp integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: nvp integer, intent(in) :: nxvh integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: kyp integer, intent(in) :: kypd integer, intent(in) :: kxp2d integer, intent(in) :: nxhyd integer, intent(in) :: nxyd","tags":"","loc":"interface/wppfsst2rm23.html"},{"title":"PPFSSCT2RM32X – QuickPIC","text":"interface public subroutine PPFSSCT2RM32X(f, isign, mixup, sctd, indx, indy, kstrt, kypi, kypp, nxvh, kypd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(3,2*nxvh,kypd) :: f integer, intent(in) :: isign integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: kypi integer, intent(in) :: kypp integer, intent(in) :: nxvh integer, intent(in) :: kypd integer, intent(in) :: nxhyd integer, intent(in) :: nxyd","tags":"","loc":"interface/ppfssct2rm32x.html"},{"title":"PPFSSCT2RM23Y – QuickPIC","text":"interface public subroutine PPFSSCT2RM23Y(g, isign, mixup, sctd, indx, indy, kstrt, kxpi, kxpp, nyv, kxpd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(3,nyv,kxpd) :: g integer, intent(in) :: isign integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: kxpi integer, intent(in) :: kxpp integer, intent(in) :: nyv integer, intent(in) :: kxpd integer, intent(in) :: nxhyd integer, intent(in) :: nxyd","tags":"","loc":"interface/ppfssct2rm23y.html"},{"title":"MPPDIVFD2 – QuickPIC","text":"interface public subroutine MPPDIVFD2(f, df, nx, ny, kstrt, ndim, nyv, kxp2) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(3,nyv,kxp2+1) :: f real, intent(inout), dimension(nyv,kxp2+1) :: df integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kstrt integer, intent(in) :: ndim integer, intent(in) :: nyv integer, intent(in) :: kxp2","tags":"","loc":"interface/mppdivfd2.html"},{"title":"MPPGRADFD2 – QuickPIC","text":"interface public subroutine MPPGRADFD2(df, f, nx, ny, kstrt, ndim, nyv, kxp2) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(nyv,kxp2+1) :: df real, intent(inout), dimension(3,nyv,kxp2+1) :: f integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kstrt integer, intent(in) :: ndim integer, intent(in) :: nyv integer, intent(in) :: kxp2","tags":"","loc":"interface/mppgradfd2.html"},{"title":"MPPCURLFD2 – QuickPIC","text":"interface Called by interface~~mppcurlfd2~~CalledByGraph interface~mppcurlfd2 MPPCURLFD2 proc~ipcurlfd2 ipcurlfd2 proc~ipcurlfd2->interface~mppcurlfd2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine MPPCURLFD2(f, g, nx, ny, kstrt, nyv, kxp2) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(3,nyv,kxp2+1) :: f real, intent(inout), dimension(3,nyv,kxp2+1) :: g integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kstrt integer, intent(in) :: nyv integer, intent(in) :: kxp2","tags":"","loc":"interface/mppcurlfd2.html"},{"title":"perrors_class – QuickPIC","text":"Uses mpi parallel_class module~~perrors_class~~UsesGraph module~perrors_class perrors_class mpi mpi module~perrors_class->mpi module~parallel_class parallel_class module~perrors_class->module~parallel_class module~parallel_class->mpi omp_lib omp_lib module~parallel_class->omp_lib Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~perrors_class~~UsedByGraph module~perrors_class perrors_class module~part3d_class part3d_class module~part3d_class->module~perrors_class module~spect3d_class spect3d_class module~part3d_class->module~spect3d_class module~fdist3d_class fdist3d_class module~part3d_class->module~fdist3d_class module~ufield3d_class ufield3d_class module~part3d_class->module~ufield3d_class module~hdf5io_class hdf5io_class module~part3d_class->module~hdf5io_class module~spect3d_class->module~perrors_class module~spect2d_class spect2d_class module~spect3d_class->module~spect2d_class module~fpois2d_class fpois2d_class module~fpois2d_class->module~perrors_class module~fpois2d_class->module~spect2d_class module~ufield2d_class ufield2d_class module~fpois2d_class->module~ufield2d_class module~field3d_class field3d_class module~field3d_class->module~perrors_class module~field3d_class->module~spect3d_class module~field3d_class->module~ufield3d_class module~field3d_class->module~hdf5io_class module~spect2d_class->module~perrors_class module~fft2d_class fft2d_class module~fft2d_class->module~perrors_class module~fft2d_class->module~spect2d_class module~fft2d_class->module~ufield2d_class module~input_class input_class module~input_class->module~perrors_class module~input_class->module~spect3d_class module~field2d_class field2d_class module~field2d_class->module~perrors_class module~field2d_class->module~fpois2d_class module~field2d_class->module~field3d_class module~field2d_class->module~spect2d_class module~field2d_class->module~fft2d_class module~field2d_class->module~ufield3d_class module~field2d_class->module~ufield2d_class module~field2d_class->module~hdf5io_class module~simulation_class simulation_class module~simulation_class->module~perrors_class module~simulation_class->module~spect3d_class module~simulation_class->module~field3d_class module~simulation_class->module~spect2d_class module~simulation_class->module~input_class module~simulation_class->module~field2d_class module~simulation_class->module~fdist3d_class module~species2d_class species2d_class module~simulation_class->module~species2d_class module~beam3d_class beam3d_class module~simulation_class->module~beam3d_class module~simulation_class->module~hdf5io_class module~fdist2d_class fdist2d_class module~simulation_class->module~fdist2d_class module~fdist3d_class->module~perrors_class module~fdist3d_class->module~spect3d_class module~fdist3d_class->module~input_class module~fdist3d_class->module~ufield3d_class module~ufield3d_class->module~perrors_class module~ufield3d_class->module~spect3d_class module~ufield3d_class->module~ufield2d_class module~ufield3d_class->module~hdf5io_class module~species2d_class->module~perrors_class module~species2d_class->module~spect3d_class module~species2d_class->module~field3d_class module~species2d_class->module~spect2d_class module~species2d_class->module~field2d_class module~part2d_class part2d_class module~species2d_class->module~part2d_class module~species2d_class->module~hdf5io_class module~species2d_class->module~fdist2d_class module~beam3d_class->module~perrors_class module~beam3d_class->module~part3d_class module~beam3d_class->module~spect3d_class module~beam3d_class->module~field3d_class module~beam3d_class->module~field2d_class module~beam3d_class->module~fdist3d_class module~beam3d_class->module~hdf5io_class module~ufield2d_class->module~perrors_class module~ufield2d_class->module~spect2d_class module~ufield2d_class->module~hdf5io_class module~part2d_class->module~perrors_class module~part2d_class->module~spect2d_class module~part2d_class->module~ufield2d_class module~part2d_class->module~hdf5io_class module~part2d_class->module~fdist2d_class module~hdf5io_class->module~perrors_class module~fdist2d_class->module~perrors_class module~fdist2d_class->module~spect2d_class module~fdist2d_class->module~input_class module~fdist2d_class->module~ufield2d_class program~quickpic quickpic program~quickpic->module~simulation_class var panmoduleperrors_classUsedByGraph = svgPanZoom('#moduleperrors_classUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables itime dtime Derived Types perrors Subroutines init_perrors set_ename end_perrors equit werrfl0 werrfl1 werrfl2 setmonitor Variables Type Visibility Attributes Name Initial integer, private, dimension(4), save :: itime double precision, private, save :: dtime Derived Types type, public :: perrors Components Type Visibility Attributes Name Initial class( parallel ), public, pointer :: p => null() integer, private :: eunit = 2 integer, private :: monitor = 0 Type-Bound Procedures generic, public :: new => init_perrors generic, public :: del => end_perrors procedure, private :: init_perrors procedure, private :: end_perrors procedure, public :: equit procedure, public :: werrfl0 procedure, public :: werrfl1 procedure, public :: werrfl2 procedure, public :: setmonitor Subroutines private subroutine init_perrors (this, prl, eunit, monitor) Arguments Type Intent Optional Attributes Name class( perrors ), intent(inout) :: this class( parallel ), intent(in), pointer :: prl integer, intent(in) :: eunit integer, intent(in) :: monitor private subroutine set_ename (eunit, ename) Arguments Type Intent Optional Attributes Name integer, intent(in) :: eunit character(len=*), intent(in) :: ename private subroutine end_perrors (this) Arguments Type Intent Optional Attributes Name class( perrors ), intent(inout) :: this private subroutine equit (this, estr) Arguments Type Intent Optional Attributes Name class( perrors ), intent(in) :: this character(len=*), intent(in), optional :: estr private subroutine werrfl0 (this, estr) Arguments Type Intent Optional Attributes Name class( perrors ), intent(in) :: this character(len=*), intent(in) :: estr private subroutine werrfl1 (this, estr) Arguments Type Intent Optional Attributes Name class( perrors ), intent(in) :: this character(len=*), intent(in) :: estr private subroutine werrfl2 (this, estr) Arguments Type Intent Optional Attributes Name class( perrors ), intent(in) :: this character(len=*), intent(in) :: estr private subroutine setmonitor (this, moniter) Arguments Type Intent Optional Attributes Name class( perrors ), intent(inout) :: this integer, intent(in) :: moniter","tags":"","loc":"module/perrors_class.html"},{"title":"spect2d_class – QuickPIC","text":"Uses perrors_class parallel_pipe_class module~~spect2d_class~~UsesGraph module~spect2d_class spect2d_class module~perrors_class perrors_class module~spect2d_class->module~perrors_class module~parallel_pipe_class parallel_pipe_class module~spect2d_class->module~parallel_pipe_class mpi mpi module~perrors_class->mpi module~parallel_class parallel_class module~perrors_class->module~parallel_class module~parallel_pipe_class->mpi module~parallel_pipe_class->module~parallel_class module~parallel_class->mpi omp_lib omp_lib module~parallel_class->omp_lib Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~spect2d_class~~UsedByGraph module~spect2d_class spect2d_class module~spect3d_class spect3d_class module~spect3d_class->module~spect2d_class module~fpois2d_class fpois2d_class module~fpois2d_class->module~spect2d_class module~ufield2d_class ufield2d_class module~fpois2d_class->module~ufield2d_class module~fft2d_class fft2d_class module~fft2d_class->module~spect2d_class module~fft2d_class->module~ufield2d_class module~field2d_class field2d_class module~field2d_class->module~spect2d_class module~field2d_class->module~fpois2d_class module~field2d_class->module~fft2d_class module~field2d_class->module~ufield2d_class module~field3d_class field3d_class module~field2d_class->module~field3d_class module~ufield3d_class ufield3d_class module~field2d_class->module~ufield3d_class module~simulation_class simulation_class module~simulation_class->module~spect2d_class module~simulation_class->module~spect3d_class module~simulation_class->module~field2d_class module~species2d_class species2d_class module~simulation_class->module~species2d_class module~fdist2d_class fdist2d_class module~simulation_class->module~fdist2d_class module~simulation_class->module~field3d_class module~input_class input_class module~simulation_class->module~input_class module~fdist3d_class fdist3d_class module~simulation_class->module~fdist3d_class module~beam3d_class beam3d_class module~simulation_class->module~beam3d_class module~species2d_class->module~spect2d_class module~species2d_class->module~spect3d_class module~species2d_class->module~field2d_class module~part2d_class part2d_class module~species2d_class->module~part2d_class module~species2d_class->module~fdist2d_class module~species2d_class->module~field3d_class module~ufield2d_class->module~spect2d_class module~part2d_class->module~spect2d_class module~part2d_class->module~ufield2d_class module~part2d_class->module~fdist2d_class module~fdist2d_class->module~spect2d_class module~fdist2d_class->module~ufield2d_class module~fdist2d_class->module~input_class module~part3d_class part3d_class module~part3d_class->module~spect3d_class module~part3d_class->module~fdist3d_class module~part3d_class->module~ufield3d_class module~field3d_class->module~spect3d_class module~field3d_class->module~ufield3d_class module~input_class->module~spect3d_class module~fdist3d_class->module~spect3d_class module~fdist3d_class->module~input_class module~fdist3d_class->module~ufield3d_class module~ufield3d_class->module~spect3d_class module~ufield3d_class->module~ufield2d_class program~quickpic quickpic program~quickpic->module~simulation_class module~beam3d_class->module~spect3d_class module~beam3d_class->module~field2d_class module~beam3d_class->module~part3d_class module~beam3d_class->module~field3d_class module~beam3d_class->module~fdist3d_class var panmodulespect2d_classUsedByGraph = svgPanZoom('#modulespect2d_classUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types spect2d Functions getindx getindy getpsolver getinorder Subroutines init_spect2d end_spect2d Derived Types type, public :: spect2d Components Type Visibility Attributes Name Initial integer, private :: indx integer, private :: indy integer, private :: psolver integer, private :: inorder class( perrors ), public, pointer :: err => null() class( parallel_pipe ), public, pointer :: p => null() Type-Bound Procedures procedure, private :: init_spect2d procedure, private :: end_spect2d generic, public :: new => init_spect2d generic, public :: del => end_spect2d procedure, public :: getindx procedure, public :: getindy procedure, public :: getpsolver procedure, public :: getinorder Functions private function getindx (this) Arguments Type Intent Optional Attributes Name class( spect2d ), intent(in) :: this Return Value integer private function getindy (this) Arguments Type Intent Optional Attributes Name class( spect2d ), intent(in) :: this Return Value integer private function getpsolver (this) Arguments Type Intent Optional Attributes Name class( spect2d ), intent(in) :: this Return Value integer private function getinorder (this) Arguments Type Intent Optional Attributes Name class( spect2d ), intent(in) :: this Return Value integer Subroutines private subroutine init_spect2d (this, pp, perr, indx, indy, psolver, inorder) Arguments Type Intent Optional Attributes Name class( spect2d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: psolver integer, intent(in) :: inorder private subroutine end_spect2d (this) Arguments Type Intent Optional Attributes Name class( spect2d ), intent(inout) :: this","tags":"","loc":"module/spect2d_class.html"},{"title":"input_class – QuickPIC","text":"Uses perrors_class parallel_class parallel_pipe_class spect3d_class mpi json_module module~~input_class~~UsesGraph module~input_class input_class module~spect3d_class spect3d_class module~input_class->module~spect3d_class module~parallel_class parallel_class module~input_class->module~parallel_class module~perrors_class perrors_class module~input_class->module~perrors_class json_module json_module module~input_class->json_module module~parallel_pipe_class parallel_pipe_class module~input_class->module~parallel_pipe_class mpi mpi module~input_class->mpi module~spect3d_class->module~perrors_class module~spect3d_class->module~parallel_pipe_class module~spect2d_class spect2d_class module~spect3d_class->module~spect2d_class module~parallel_class->mpi omp_lib omp_lib module~parallel_class->omp_lib module~perrors_class->module~parallel_class module~perrors_class->mpi module~parallel_pipe_class->module~parallel_class module~parallel_pipe_class->mpi module~spect2d_class->module~perrors_class module~spect2d_class->module~parallel_pipe_class var panmoduleinput_classUsesGraph = svgPanZoom('#moduleinput_classUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~input_class~~UsedByGraph module~input_class input_class module~fdist3d_class fdist3d_class module~fdist3d_class->module~input_class module~simulation_class simulation_class module~simulation_class->module~input_class module~simulation_class->module~fdist3d_class module~fdist2d_class fdist2d_class module~simulation_class->module~fdist2d_class module~species2d_class species2d_class module~simulation_class->module~species2d_class module~beam3d_class beam3d_class module~simulation_class->module~beam3d_class module~fdist2d_class->module~input_class module~part3d_class part3d_class module~part3d_class->module~fdist3d_class module~species2d_class->module~fdist2d_class module~part2d_class part2d_class module~species2d_class->module~part2d_class program~quickpic quickpic program~quickpic->module~simulation_class module~beam3d_class->module~fdist3d_class module~beam3d_class->module~part3d_class module~part2d_class->module~fdist2d_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables class erstr sp err p pp Derived Types input_json Functions found Subroutines read_input_json initialize set_json_core_in_file load_file print_to_string load_from_string json_file_get_object json_file_get_integer json_file_get_double json_file_get_logical json_file_get_string json_file_get_integer_vec json_file_get_double_vec json_file_get_logical_vec json_file_get_string_vec json_file_get_alloc_string_vec json_file_get_root json_file_variable_info Variables Type Visibility Attributes Name Initial character(len=10), private, save :: class = 'input:' character(len=128), private, save :: erstr type( spect3d ), private, save, target :: sp type( perrors ), private, save, target :: err type( parallel ), private, save, target :: p type( parallel_pipe ), private, save, target :: pp Derived Types type, public :: input_json Components Type Visibility Attributes Name Initial class( spect3d ), public, pointer :: sp => null() class( perrors ), public, pointer :: err => null() class( parallel ), public, pointer :: p => null() class( parallel_pipe ), public, pointer :: pp => null() type(json_file), private, pointer :: input => null() Type-Bound Procedures generic, public :: new => read_input_json generic, public :: get => json_file_get_object, json_file_get_integer, json_file_get_double, json_file_get_logical, json_file_get_string, json_file_get_integer_vec, json_file_get_double_vec, json_file_get_logical_vec, json_file_get_string_vec, json_file_get_alloc_string_vec, json_file_get_root generic, public :: info => json_file_variable_info procedure, public :: found procedure, private :: read_input_json procedure, private :: set_json_core_in_file procedure, private :: initialize procedure, private :: print_to_string procedure, private :: load_file procedure, private :: load_from_string procedure, private :: json_file_get_root procedure, private :: json_file_get_alloc_string_vec procedure, private :: json_file_get_string_vec procedure, private :: json_file_get_logical_vec procedure, private :: json_file_get_double_vec procedure, private :: json_file_get_integer_vec procedure, private :: json_file_get_string procedure, private :: json_file_get_logical procedure, private :: json_file_get_double procedure, private :: json_file_get_integer procedure, private :: json_file_get_object procedure, private :: json_file_variable_info Functions private function found (this, path) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path Return Value logical Subroutines private subroutine read_input_json (this) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this private subroutine initialize (this, verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys, no_whitespace, unescape_strings, comment_char, path_mode, path_separator, compress_vectors, allow_duplicate_keys) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this logical, intent(in), optional :: verbose logical, intent(in), optional :: compact_reals logical, intent(in), optional :: print_signs character(len=*), intent(in), optional :: real_format integer, intent(in), optional :: spaces_per_tab logical, intent(in), optional :: strict_type_checking logical, intent(in), optional :: trailing_spaces_significant logical, intent(in), optional :: case_sensitive_keys logical, intent(in), optional :: no_whitespace logical, intent(in), optional :: unescape_strings character(len=1), intent(in), optional :: comment_char integer, intent(in), optional :: path_mode character(len=1), intent(in), optional :: path_separator logical, intent(in), optional :: compress_vectors logical, intent(in), optional :: allow_duplicate_keys private subroutine set_json_core_in_file (this, core) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this type(json_core), intent(in) :: core private subroutine load_file (this, filename, unit) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: filename integer, intent(in), optional :: unit private subroutine print_to_string (this, str) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=:), intent(out), allocatable :: str private subroutine load_from_string (this, str) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: str private subroutine json_file_get_object (this, path, p) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path type(json_value), intent(out), pointer :: p private subroutine json_file_get_integer (this, path, val) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path integer, intent(out) :: val private subroutine json_file_get_double (this, path, val) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path real, intent(out) :: val private subroutine json_file_get_logical (this, path, val) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path logical, intent(out) :: val private subroutine json_file_get_string (this, path, val) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path character(len=:), intent(out), allocatable :: val private subroutine json_file_get_integer_vec (this, path, vec) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path integer, intent(out), dimension(:), allocatable :: vec private subroutine json_file_get_double_vec (this, path, vec) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path real, intent(out), dimension(:), allocatable :: vec private subroutine json_file_get_logical_vec (this, path, vec) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path logical, intent(out), dimension(:), allocatable :: vec private subroutine json_file_get_string_vec (this, path, vec) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path character(len=*), intent(out), dimension(:), allocatable :: vec private subroutine json_file_get_alloc_string_vec (this, path, vec, ilen) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path character(len=:), intent(out), dimension(:), allocatable :: vec integer, intent(out), dimension(:), allocatable :: ilen private subroutine json_file_get_root (this, p) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this type(json_value), intent(out), pointer :: p private subroutine json_file_variable_info (this, path, n_children) Arguments Type Intent Optional Attributes Name class( input_json ), intent(inout) :: this character(len=*), intent(in) :: path integer, intent(out) :: n_children","tags":"","loc":"module/input_class.html"},{"title":"fft2d_class – QuickPIC","text":"Uses perrors_class parallel_pipe_class spect2d_class ufield2d_class fft2d_lib module~~fft2d_class~~UsesGraph module~fft2d_class fft2d_class module~spect2d_class spect2d_class module~fft2d_class->module~spect2d_class module~perrors_class perrors_class module~fft2d_class->module~perrors_class module~fft2d_lib fft2d_lib module~fft2d_class->module~fft2d_lib module~parallel_pipe_class parallel_pipe_class module~fft2d_class->module~parallel_pipe_class module~ufield2d_class ufield2d_class module~fft2d_class->module~ufield2d_class module~spect2d_class->module~perrors_class module~spect2d_class->module~parallel_pipe_class mpi mpi module~perrors_class->mpi module~parallel_class parallel_class module~perrors_class->module~parallel_class module~fft2d_lib->mpi module~parallel_pipe_class->mpi module~parallel_pipe_class->module~parallel_class module~ufield2d_class->module~spect2d_class module~ufield2d_class->module~perrors_class module~ufield2d_class->module~parallel_pipe_class module~hdf5io_class hdf5io_class module~ufield2d_class->module~hdf5io_class module~ufield2d_class->mpi module~ufield2d_lib ufield2d_lib module~ufield2d_class->module~ufield2d_lib module~hdf5io_class->module~perrors_class module~hdf5io_class->module~parallel_pipe_class module~hdf5io_class->mpi HDF5 HDF5 module~hdf5io_class->HDF5 module~parallel_class->mpi omp_lib omp_lib module~parallel_class->omp_lib module~ufield2d_lib->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~fft2d_class~~UsedByGraph module~fft2d_class fft2d_class module~field2d_class field2d_class module~field2d_class->module~fft2d_class module~species2d_class species2d_class module~species2d_class->module~field2d_class module~beam3d_class beam3d_class module~beam3d_class->module~field2d_class module~simulation_class simulation_class module~simulation_class->module~field2d_class module~simulation_class->module~species2d_class module~simulation_class->module~beam3d_class program~quickpic quickpic program~quickpic->module~simulation_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables class erstr numtables table_list Derived Types fft2d fft2d_link Functions get_fft2table Subroutines init_fft2d end_fft2d iwpfsst2r iwpfcct2r iwpfs3t2r ipdivfd2 ipgradfd2 ipcurlfd2 Variables Type Visibility Attributes Name Initial character(len=10), private, save :: class = 'fft2d:' character(len=128), private, save :: erstr integer, private, save :: numtables = 0 type( fft2d_link ), private, target, save :: table_list Derived Types type, public :: fft2d Components Type Visibility Attributes Name Initial class( spect2d ), public, pointer :: sp => null() class( perrors ), public, pointer :: err => null() class( parallel_pipe ), public, pointer :: p => null() integer, private, dimension(2) :: ind integer, private :: nrc integer, private, dimension(:), pointer :: mixup complex, private, dimension(:), pointer :: sct Type-Bound Procedures generic, public :: new => init_fft2d generic, public :: del => end_fft2d generic, public :: fsst => iwpfsst2r generic, public :: fcct => iwpfcct2r generic, public :: fs3t => iwpfs3t2r generic, public :: divf => ipdivfd2 generic, public :: gradf => ipgradfd2 generic, public :: curlf => ipcurlfd2 procedure, private :: init_fft2d procedure, private :: end_fft2d procedure, private :: iwpfs3t2r procedure, private :: iwpfcct2r procedure, private :: iwpfsst2r procedure, private :: ipcurlfd2 procedure, private :: ipgradfd2 procedure, private :: ipdivfd2 type, private :: fft2d_link Components Type Visibility Attributes Name Initial type( fft2d_link ), public, pointer :: next => null() type( fft2d ), public, pointer :: table => null() integer, public :: refcount Functions public function get_fft2table (pp, perr, psp, indx, indy) result(table) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( spect2d ), intent(in), pointer :: psp integer, intent(in) :: indx integer, intent(in) :: indy Return Value type( fft2d ),\n  pointer Subroutines private subroutine init_fft2d (this, pp, perr, psp, indx, indy, nrc) Arguments Type Intent Optional Attributes Name class( fft2d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( spect2d ), intent(in), pointer :: psp integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: nrc private subroutine end_fft2d (this) Arguments Type Intent Optional Attributes Name class( fft2d ), intent(inout) :: this private subroutine iwpfsst2r (this, rspace, krspace, isign) Arguments Type Intent Optional Attributes Name class( fft2d ), intent(in) :: this class( ufield2d ), intent(inout) :: rspace class( ufield2d ), intent(inout) :: krspace integer, intent(in) :: isign private subroutine iwpfcct2r (this, rspace, krspace, isign) Arguments Type Intent Optional Attributes Name class( fft2d ), intent(in) :: this class( ufield2d ), intent(inout) :: rspace class( ufield2d ), intent(inout) :: krspace integer, intent(in) :: isign private subroutine iwpfs3t2r (this, rspace, krspace, isign) Arguments Type Intent Optional Attributes Name class( fft2d ), intent(in) :: this class( ufield2d ), intent(inout) :: rspace class( ufield2d ), intent(inout) :: krspace integer, intent(in) :: isign private subroutine ipdivfd2 (this, krspace, kdspace) Arguments Type Intent Optional Attributes Name class( fft2d ), intent(in) :: this class( ufield2d ), intent(inout) :: krspace class( ufield2d ), intent(inout) :: kdspace private subroutine ipgradfd2 (this, krspace, kdspace) Arguments Type Intent Optional Attributes Name class( fft2d ), intent(in) :: this class( ufield2d ), intent(inout) :: krspace class( ufield2d ), intent(inout) :: kdspace private subroutine ipcurlfd2 (this, krspace, kdspace) Arguments Type Intent Optional Attributes Name class( fft2d ), intent(in) :: this class( ufield2d ), intent(inout) :: krspace class( ufield2d ), intent(inout) :: kdspace","tags":"","loc":"module/fft2d_class.html"},{"title":"part3d_lib – QuickPIC","text":"Used by module~~part3d_lib~~UsedByGraph module~part3d_lib part3d_lib module~fdist3d_class fdist3d_class module~fdist3d_class->module~part3d_lib module~part3d_class part3d_class module~part3d_class->module~part3d_lib module~part3d_class->module~fdist3d_class module~beam3d_class beam3d_class module~beam3d_class->module~fdist3d_class module~beam3d_class->module~part3d_class module~simulation_class simulation_class module~simulation_class->module~fdist3d_class module~simulation_class->module~beam3d_class program~quickpic quickpic program~quickpic->module~simulation_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces PRVDIST32_RANDOM PGPOST32L PGBPUSH32L_QP PMOVE32 Interfaces interface public subroutine PRVDIST32_RANDOM(part, qm, edges, npp, nps, vtx, vty, vtz, vdx, vdy, vdz, npx, npy, npz, nx, ny, nz, ipbc, idimp, npmax, mblok, nblok, idps, sigx, sigy, sigz, x0, y0, z0, cx, cy, lquiet, ierr) Arguments Type Intent Optional Attributes Name real, intent(inout) :: part real, intent(in) :: qm real, intent(in) :: edges integer, intent(inout) :: npp integer, intent(inout) :: nps real, intent(in) :: vtx real, intent(in) :: vty real, intent(in) :: vtz real, intent(in) :: vdx real, intent(in) :: vdy real, intent(in) :: vdz integer, intent(in) :: npx integer, intent(in) :: npy integer, intent(in) :: npz integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz integer, intent(in) :: ipbc integer, intent(in) :: idimp integer, intent(in) :: npmax integer, intent(in) :: mblok integer, intent(in) :: nblok integer, intent(in) :: idps real, intent(in) :: sigx real, intent(in) :: sigy real, intent(in) :: sigz real, intent(in) :: x0 real, intent(in) :: y0 real, intent(in) :: z0 real, intent(in) :: cx real, intent(in) :: cy logical, intent(in) :: lquiet integer, intent(inout) :: ierr interface public subroutine PGPOST32L(part, q, npp, noff, idimp, npmax, mnblok, nxv, nypmx, nzpmx, idds) Arguments Type Intent Optional Attributes Name real, intent(inout) :: part real, intent(inout) :: q integer, intent(in) :: npp integer, intent(in) :: noff integer, intent(in) :: idimp integer, intent(in) :: npmax integer, intent(in) :: mnblok integer, intent(in) :: nxv integer, intent(in) :: nypmx integer, intent(in) :: nzpmx integer, intent(in) :: idds interface public subroutine PGBPUSH32L_QP(part, fxyz, bxyz, npp, noff, qbm, dt, dtc, ek, nx, ny, nz, idimp, npmax, mnblok, nxv, nypmx, nzpmx, idds, ipbc, deltax, deltaz, cofd) Arguments Type Intent Optional Attributes Name real, intent(inout) :: part real, intent(inout) :: fxyz real, intent(inout) :: bxyz integer, intent(inout) :: npp integer, intent(in) :: noff real, intent(in) :: qbm real, intent(in) :: dt real, intent(in) :: dtc real, intent(in) :: ek integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz integer, intent(in) :: idimp integer, intent(in) :: npmax integer, intent(in) :: mnblok integer, intent(in) :: nxv integer, intent(in) :: nypmx integer, intent(in) :: nzpmx integer, intent(in) :: idds integer, intent(in) :: ipbc real, intent(in) :: deltax real, intent(in) :: deltaz real, intent(in) :: cofd interface public subroutine PMOVE32(part, edges, npp, sbufr, sbufl, rbufr, rbufl, ihole, pbuff, jsr, jsl, jss, ny, nz, kstrt, nvpy, nvpz, idimp, npmax, mblok, nblok, idps, nbmax, idds, ntmax, tag1, tag2, id, info) Arguments Type Intent Optional Attributes Name real, intent(inout) :: part real, intent(in) :: edges integer, intent(inout) :: npp real, intent(in) :: sbufr real, intent(in) :: sbufl real, intent(in) :: rbufr real, intent(in) :: rbufl integer, intent(in) :: ihole real, intent(inout) :: pbuff integer, intent(in) :: jsr integer, intent(in) :: jsl integer, intent(in) :: jss integer, intent(in) :: ny integer, intent(in) :: nz integer, intent(in) :: kstrt integer, intent(in) :: nvpy integer, intent(in) :: nvpz integer, intent(in) :: idimp integer, intent(in) :: npmax integer, intent(in) :: mblok integer, intent(in) :: nblok integer, intent(in) :: idps integer, intent(in) :: nbmax integer, intent(in) :: idds integer, intent(in) :: ntmax integer, intent(in) :: tag1 integer, intent(in) :: tag2 integer, intent(inout) :: id integer, intent(inout) :: info","tags":"","loc":"module/part3d_lib.html"},{"title":"part2d_lib – QuickPIC","text":"Uses mpi module~~part2d_lib~~UsesGraph module~part2d_lib part2d_lib mpi mpi module~part2d_lib->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~part2d_lib~~UsedByGraph module~part2d_lib part2d_lib module~part2d_class part2d_class module~part2d_class->module~part2d_lib module~species2d_class species2d_class module~species2d_class->module~part2d_class module~simulation_class simulation_class module~simulation_class->module~species2d_class program~quickpic quickpic program~quickpic->module~simulation_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Common Blocks PPARMS Interfaces PPDBLKP2L PPPMOVIN2L PPPCHECK2L PPGPPOST2L PPGRDCJPPOST2L_QP PPGRBPPUSHF23L_QP PPPORDER2LA PPPORDERF2LA PPPORDER2LB WPGPSIPOST2L_QP PPPCOPYOUT2 Subroutines PPPMOVE2 Common Blocks common /PPARMS/ Type Attributes Name Initial integer :: nproc integer :: lgrp integer :: mreal integer :: mint integer :: mcplx integer :: mdouble integer :: lworld $(function () {\n    $('[data-toggle=\"popover\"]').popover()\n    }) Interfaces interface public subroutine PPDBLKP2L(part, kpic, npp, noff, nppmx, idimp, npmax, mx, my, mx1, mxyp1, irc) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(idimp,npmax) :: part integer, intent(inout), dimension(mxyp1) :: kpic integer, intent(in) :: npp integer, intent(in) :: noff integer, intent(inout) :: nppmx integer, intent(in) :: idimp integer, intent(in) :: npmax integer, intent(in) :: mx integer, intent(in) :: my integer, intent(in) :: mx1 integer, intent(in) :: mxyp1 integer, intent(inout) :: irc interface public subroutine PPPMOVIN2L(part, ppart, kpic, npp, noff, nppmx, idimp, npmax, mx, my, mx1, mxyp1, irc) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(idimp,npmax) :: part real, intent(inout), dimension(idimp,nppmx,mxyp1) :: ppart integer, intent(inout), dimension(mxyp1) :: kpic integer, intent(in) :: npp integer, intent(in) :: noff integer, intent(in) :: nppmx integer, intent(in) :: idimp integer, intent(in) :: npmax integer, intent(in) :: mx integer, intent(in) :: my integer, intent(in) :: mx1 integer, intent(in) :: mxyp1 integer, intent(inout) :: irc interface public subroutine PPPCHECK2L(ppart, kpic, noff, nyp, idimp, nppmx, nx, mx, my, mx1, myp1, irc) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(idimp,nppmx,mx1*myp1) :: ppart integer, intent(in), dimension(mx1*myp1) :: kpic integer, intent(in) :: noff integer, intent(in) :: nyp integer, intent(in) :: idimp integer, intent(in) :: nppmx integer, intent(in) :: nx integer, intent(in) :: mx integer, intent(in) :: my integer, intent(in) :: mx1 integer, intent(in) :: myp1 integer, intent(inout) :: irc interface public subroutine PPGPPOST2L(ppart, q, kpic, noff, idimp, nppmx, mx, my, nxv, nypmx, mx1, mxyp1) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(idimp,nppmx,mxyp1) :: ppart real, intent(inout), dimension(nxv,nypmx) :: q integer, intent(in), dimension(mxyp1) :: kpic integer, intent(in) :: noff integer, intent(in) :: idimp integer, intent(in) :: nppmx integer, intent(in) :: mx integer, intent(in) :: my integer, intent(in) :: nxv integer, intent(in) :: nypmx integer, intent(in) :: mx1 integer, intent(in) :: mxyp1 interface public subroutine PPGRDCJPPOST2L_QP(ppart, fxy, bxy, psit, cu, dcu, amu, kpic, noff, nyp, qbm, dt, ci, idimp, nppmx, nx, mx, my, nxv, nypmx, mx1, mxyp1, dex) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(idimp,nppmx,mxyp1) :: ppart real, intent(in), dimension(2,nxv,nypmx) :: fxy real, intent(in), dimension(3,nxv,nypmx) :: bxy real, intent(in), dimension(nxv,nypmx) :: psit real, intent(inout), dimension(3,nxv,nypmx) :: cu real, intent(inout), dimension(2,nxv,nypmx) :: dcu real, intent(inout), dimension(3,nxv,nypmx) :: amu integer, intent(in), dimension(mxyp1) :: kpic integer, intent(in) :: noff integer, intent(in) :: nyp real, intent(in) :: qbm real, intent(in) :: dt real, intent(in) :: ci integer, intent(in) :: idimp integer, intent(in) :: nppmx integer, intent(in) :: nx integer, intent(in) :: mx integer, intent(in) :: my integer, intent(in) :: nxv integer, intent(in) :: nypmx integer, intent(in) :: mx1 integer, intent(in) :: mxyp1 real, intent(in) :: dex interface public subroutine PPGRBPPUSHF23L_QP(ppart, fxy, bxy, psit, kpic, ncl, ihole, noff, nyp, qbm, dt, dtc, ci, ek, idimp, nppmx, nx, ny, mx, my, nxv, nypmx, mx1, mxyp1, ntmax, irc, dex) Arguments Type Intent Optional Attributes Name real :: ppart real :: fxy real :: bxy real :: psit integer :: kpic integer :: ncl integer :: ihole integer :: noff integer :: nyp real :: qbm real :: dt real :: dtc real :: ci real :: ek integer :: idimp integer :: nppmx integer :: nx integer :: ny integer :: mx integer :: my integer :: nxv integer :: nypmx integer :: mx1 integer :: mxyp1 integer :: ntmax integer :: irc real :: dex interface public subroutine PPPORDER2LA(ppart, ppbuff, sbufl, sbufr, kpic, ncl, ihole, ncll, nclr, noff, nyp, idimp, nppmx, nx, ny, mx, my, mx1, myp1, npbmx, ntmax, nbmax, irc) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(idimp,nppmx,mx1*myp1) :: ppart real, intent(inout), dimension(idimp,npbmx,mx1*myp1) :: ppbuff real, intent(inout), dimension(idimp,nbmax) :: sbufl real, intent(inout), dimension(idimp,nbmax) :: sbufr integer, intent(in), dimension(mx1*myp1) :: kpic integer, intent(inout), dimension(8,mx1*myp1) :: ncl integer, intent(inout), dimension(2,ntmax+1,mx1*myp1) :: ihole integer, intent(inout), dimension(3,mx1) :: ncll integer, intent(inout), dimension(3,mx1) :: nclr integer, intent(in) :: noff integer, intent(in) :: nyp integer, intent(in) :: idimp integer, intent(in) :: nppmx integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: mx integer, intent(in) :: my integer, intent(in) :: mx1 integer, intent(in) :: myp1 integer, intent(in) :: npbmx integer, intent(in) :: ntmax integer, intent(in) :: nbmax integer, intent(inout) :: irc interface public subroutine PPPORDERF2LA(ppart, ppbuff, sbufl, sbufr, ncl, ihole, ncll, nclr, idimp, nppmx, mx1, myp1, npbmx, ntmax, nbmax, irc) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(idimp,nppmx,mx1*myp1) :: ppart real, intent(inout), dimension(idimp,npbmx,mx1*myp1) :: ppbuff real, intent(inout), dimension(idimp,nbmax) :: sbufl real, intent(inout), dimension(idimp,nbmax) :: sbufr integer, intent(inout), dimension(8,mx1*myp1) :: ncl integer, intent(in), dimension(2,ntmax+1,mx1*myp1) :: ihole integer, intent(inout), dimension(3,mx1) :: ncll integer, intent(inout), dimension(3,mx1) :: nclr integer, intent(in) :: idimp integer, intent(in) :: nppmx integer, intent(in) :: mx1 integer, intent(in) :: myp1 integer, intent(in) :: npbmx integer, intent(in) :: ntmax integer, intent(in) :: nbmax integer, intent(inout) :: irc interface public subroutine PPPORDER2LB(ppart, ppbuff, rbufl, rbufr, kpic, ncl, ihole, mcll, mclr, idimp, nppmx, mx1, myp1, npbmx, ntmax, nbmax, irc) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(idimp,nppmx,mx1*myp1) :: ppart real, intent(in), dimension(idimp,npbmx,mx1*myp1) :: ppbuff real, intent(in), dimension(idimp,nbmax) :: rbufl real, intent(in), dimension(idimp,nbmax) :: rbufr integer, intent(inout), dimension(mx1*myp1) :: kpic integer, intent(in), dimension(8,mx1*myp1) :: ncl integer, intent(in), dimension(2,ntmax+1,mx1*myp1) :: ihole integer, intent(in), dimension(3,mx1) :: mcll integer, intent(in), dimension(3,mx1) :: mclr integer, intent(in) :: idimp integer, intent(in) :: nppmx integer, intent(in) :: mx1 integer, intent(in) :: myp1 integer, intent(in) :: npbmx integer, intent(in) :: ntmax integer, intent(in) :: nbmax integer, intent(inout) :: irc interface public subroutine WPGPSIPOST2L_QP(ppart, psi, kpic, qbm, noff, nyp, idimp, nppmx, nx, mx, my, nxv, nypmx, mx1, mxyp1, dex) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(idimp,nppmx,mxyp1) :: ppart real, intent(in), dimension(nxv,nypmx) :: psi integer, intent(in), dimension(mxyp1) :: kpic real, intent(in) :: qbm integer, intent(in) :: noff integer, intent(in) :: nyp integer, intent(in) :: idimp integer, intent(in) :: nppmx integer, intent(in) :: nx integer, intent(in) :: mx integer, intent(in) :: my integer, intent(in) :: nxv integer, intent(in) :: nypmx integer, intent(in) :: mx1 integer, intent(in) :: mxyp1 real, intent(in) :: dex interface public subroutine PPPCOPYOUT2(part, ppart, kpic, npp, npmax, nppmx, idimp, mxyp1, irc) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(idimp,npmax) :: part real, intent(in), dimension(idimp,nppmx,mxyp1) :: ppart integer, intent(in), dimension(mxyp1) :: kpic integer, intent(inout) :: npp integer, intent(in) :: npmax integer, intent(in) :: nppmx integer, intent(in) :: idimp integer, intent(in) :: mxyp1 integer, intent(inout) :: irc Subroutines public subroutine PPPMOVE2 (sbufr, sbufl, rbufr, rbufl, ncll, nclr, mcll, mclr, kstrt, nvp, idimp, nbmax, mx1) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(idimp,nbmax) :: sbufr real, intent(in), dimension(idimp,nbmax) :: sbufl real, intent(inout), dimension(idimp,nbmax) :: rbufr real, intent(inout), dimension(idimp,nbmax) :: rbufl integer, intent(in), dimension(3,mx1) :: ncll integer, intent(in), dimension(3,mx1) :: nclr integer, intent(inout), dimension(3,mx1) :: mcll integer, intent(inout), dimension(3,mx1) :: mclr integer, intent(in) :: kstrt integer, intent(in) :: nvp integer, intent(in) :: idimp integer, intent(in) :: nbmax integer, intent(in) :: mx1","tags":"","loc":"module/part2d_lib.html"},{"title":"part3d_class – QuickPIC","text":"Uses perrors_class parallel_pipe_class spect3d_class fdist3d_class ufield3d_class part3d_lib hdf5io_class mpi module~~part3d_class~~UsesGraph module~part3d_class part3d_class module~spect3d_class spect3d_class module~part3d_class->module~spect3d_class module~part3d_lib part3d_lib module~part3d_class->module~part3d_lib module~perrors_class perrors_class module~part3d_class->module~perrors_class module~fdist3d_class fdist3d_class module~part3d_class->module~fdist3d_class module~ufield3d_class ufield3d_class module~part3d_class->module~ufield3d_class module~parallel_pipe_class parallel_pipe_class module~part3d_class->module~parallel_pipe_class module~hdf5io_class hdf5io_class module~part3d_class->module~hdf5io_class mpi mpi module~part3d_class->mpi module~spect3d_class->module~perrors_class module~spect3d_class->module~parallel_pipe_class module~spect2d_class spect2d_class module~spect3d_class->module~spect2d_class module~perrors_class->mpi module~parallel_class parallel_class module~perrors_class->module~parallel_class module~fdist3d_class->module~spect3d_class module~fdist3d_class->module~part3d_lib module~fdist3d_class->module~perrors_class module~fdist3d_class->module~ufield3d_class module~fdist3d_class->module~parallel_pipe_class module~input_class input_class module~fdist3d_class->module~input_class module~ufield3d_class->module~spect3d_class module~ufield3d_class->module~perrors_class module~ufield3d_class->module~parallel_pipe_class module~ufield3d_class->module~hdf5io_class module~ufield3d_class->mpi module~ufield3d_lib ufield3d_lib module~ufield3d_class->module~ufield3d_lib module~ufield2d_class ufield2d_class module~ufield3d_class->module~ufield2d_class module~parallel_pipe_class->mpi module~parallel_pipe_class->module~parallel_class module~hdf5io_class->module~perrors_class module~hdf5io_class->module~parallel_pipe_class module~hdf5io_class->mpi HDF5 HDF5 module~hdf5io_class->HDF5 module~parallel_class->mpi omp_lib omp_lib module~parallel_class->omp_lib module~spect2d_class->module~perrors_class module~spect2d_class->module~parallel_pipe_class module~input_class->module~spect3d_class module~input_class->module~perrors_class module~input_class->module~parallel_pipe_class module~input_class->mpi module~input_class->module~parallel_class json_module json_module module~input_class->json_module module~ufield2d_class->module~perrors_class module~ufield2d_class->module~parallel_pipe_class module~ufield2d_class->module~hdf5io_class module~ufield2d_class->mpi module~ufield2d_class->module~spect2d_class module~ufield2d_lib ufield2d_lib module~ufield2d_class->module~ufield2d_lib module~ufield2d_lib->mpi var panmodulepart3d_classUsesGraph = svgPanZoom('#modulepart3d_classUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~part3d_class~~UsedByGraph module~part3d_class part3d_class module~beam3d_class beam3d_class module~beam3d_class->module~part3d_class module~simulation_class simulation_class module~simulation_class->module~beam3d_class program~quickpic quickpic program~quickpic->module~simulation_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables class erstr sbufl sbufr rbufl rbufr ihole szbuf Derived Types part3d Functions getnpp Subroutines init_part3d end_part3d qdeposit partpush pmove writehdf5_part3d writerst_part3d readrst_part3d Variables Type Visibility Attributes Name Initial character(len=10), private :: class = 'part3d:' character(len=128), private :: erstr real, private, dimension(:,:), allocatable :: sbufl real, private, dimension(:,:), allocatable :: sbufr real, private, dimension(:,:), allocatable :: rbufl real, private, dimension(:,:), allocatable :: rbufr integer, private, dimension(:), allocatable :: ihole integer, private :: szbuf = 0 Derived Types type, public :: part3d Components Type Visibility Attributes Name Initial class( spect3d ), public, pointer :: sp => null() class( perrors ), public, pointer :: err => null() class( parallel_pipe ), public, pointer :: p => null() real, private :: qbm real, private :: dt real, private :: ci integer, private :: npmax integer, private :: nbmax integer, private :: xdim integer, private :: npp = 0 real, private, dimension(:,:), pointer :: part => null() real, private, dimension(:,:), pointer :: pbuff => null() Type-Bound Procedures generic, public :: new => init_part3d generic, public :: del => end_part3d generic, public :: push => partpush generic, public :: pmv => pmove generic, public :: qdp => qdeposit generic, public :: wr => writehdf5_part3d generic, public :: wrst => writerst_part3d generic, public :: rrst => readrst_part3d procedure, private :: init_part3d procedure, private :: end_part3d procedure, private :: partpush procedure, private :: pmove procedure, private :: writehdf5_part3d procedure, private :: qdeposit procedure, private :: readrst_part3d procedure, private :: writerst_part3d procedure, public :: getnpp Functions private function getnpp (this) Arguments Type Intent Optional Attributes Name class( part3d ), intent(in) :: this Return Value integer Subroutines private subroutine init_part3d (this, pp, perr, psp, pf, fd, qbm, dt, ci, xdim) Arguments Type Intent Optional Attributes Name class( part3d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( spect3d ), intent(in), pointer :: psp class( fdist3d ), intent(inout) :: pf class( ufield3d ), intent(in), pointer :: fd real, intent(in) :: qbm real, intent(in) :: dt real, intent(in) :: ci integer, intent(in) :: xdim private subroutine end_part3d (this) Arguments Type Intent Optional Attributes Name class( part3d ), intent(inout) :: this private subroutine qdeposit (this, q) Arguments Type Intent Optional Attributes Name class( part3d ), intent(in) :: this class( ufield3d ), intent(in), pointer :: q private subroutine partpush (this, ef, bf, dex, dez) Arguments Type Intent Optional Attributes Name class( part3d ), intent(inout) :: this class( ufield3d ), intent(in), pointer :: ef class( ufield3d ), intent(in), pointer :: bf real, intent(in) :: dex real, intent(in) :: dez private subroutine pmove (this, fd, rtag, stag, sid) Arguments Type Intent Optional Attributes Name class( part3d ), intent(inout) :: this class( ufield3d ), intent(in), pointer :: fd integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: sid private subroutine writehdf5_part3d (this, file, dspl, delta, rtag, stag, id) Arguments Type Intent Optional Attributes Name class( part3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file integer, intent(in) :: dspl real, intent(in), dimension(3) :: delta integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id private subroutine writerst_part3d (this, file) Arguments Type Intent Optional Attributes Name class( part3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file private subroutine readrst_part3d (this, file) Arguments Type Intent Optional Attributes Name class( part3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file","tags":"","loc":"module/part3d_class.html"},{"title":"simulation_class – QuickPIC","text":"Uses parallel_class parallel_pipe_class perrors_class spect3d_class spect2d_class field2d_class fdist2d_class field3d_class beam3d_class species2d_class fdist3d_class hdf5io_class input_class mpi module~~simulation_class~~UsesGraph module~simulation_class simulation_class module~spect3d_class spect3d_class module~simulation_class->module~spect3d_class module~parallel_class parallel_class module~simulation_class->module~parallel_class module~input_class input_class module~simulation_class->module~input_class module~spect2d_class spect2d_class module~simulation_class->module~spect2d_class module~field3d_class field3d_class module~simulation_class->module~field3d_class module~field2d_class field2d_class module~simulation_class->module~field2d_class module~perrors_class perrors_class module~simulation_class->module~perrors_class module~fdist3d_class fdist3d_class module~simulation_class->module~fdist3d_class module~parallel_pipe_class parallel_pipe_class module~simulation_class->module~parallel_pipe_class module~beam3d_class beam3d_class module~simulation_class->module~beam3d_class module~hdf5io_class hdf5io_class module~simulation_class->module~hdf5io_class module~species2d_class species2d_class module~simulation_class->module~species2d_class mpi mpi module~simulation_class->mpi module~fdist2d_class fdist2d_class module~simulation_class->module~fdist2d_class module~spect3d_class->module~spect2d_class module~spect3d_class->module~perrors_class module~spect3d_class->module~parallel_pipe_class module~parallel_class->mpi omp_lib omp_lib module~parallel_class->omp_lib module~input_class->module~spect3d_class module~input_class->module~parallel_class module~input_class->module~perrors_class module~input_class->module~parallel_pipe_class module~input_class->mpi json_module json_module module~input_class->json_module module~spect2d_class->module~perrors_class module~spect2d_class->module~parallel_pipe_class module~field3d_class->module~spect3d_class module~field3d_class->module~perrors_class module~field3d_class->module~parallel_pipe_class module~field3d_class->module~hdf5io_class module~ufield3d_class ufield3d_class module~field3d_class->module~ufield3d_class module~field2d_class->module~spect2d_class module~field2d_class->module~field3d_class module~field2d_class->module~perrors_class module~field2d_class->module~parallel_pipe_class module~field2d_class->module~hdf5io_class module~fpois2d_class fpois2d_class module~field2d_class->module~fpois2d_class module~fft2d_class fft2d_class module~field2d_class->module~fft2d_class module~field2d_class->module~ufield3d_class module~ufield2d_class ufield2d_class module~field2d_class->module~ufield2d_class module~perrors_class->module~parallel_class module~perrors_class->mpi module~fdist3d_class->module~spect3d_class module~fdist3d_class->module~input_class module~fdist3d_class->module~perrors_class module~fdist3d_class->module~parallel_pipe_class module~part3d_lib part3d_lib module~fdist3d_class->module~part3d_lib module~fdist3d_class->module~ufield3d_class module~parallel_pipe_class->module~parallel_class module~parallel_pipe_class->mpi module~beam3d_class->module~spect3d_class module~beam3d_class->module~field3d_class module~beam3d_class->module~field2d_class module~beam3d_class->module~perrors_class module~beam3d_class->module~fdist3d_class module~beam3d_class->module~parallel_pipe_class module~beam3d_class->module~hdf5io_class module~beam3d_class->mpi module~part3d_class part3d_class module~beam3d_class->module~part3d_class module~hdf5io_class->module~perrors_class module~hdf5io_class->module~parallel_pipe_class module~hdf5io_class->mpi HDF5 HDF5 module~hdf5io_class->HDF5 module~species2d_class->module~spect3d_class module~species2d_class->module~spect2d_class module~species2d_class->module~field3d_class module~species2d_class->module~field2d_class module~species2d_class->module~perrors_class module~species2d_class->module~parallel_pipe_class module~species2d_class->module~hdf5io_class module~species2d_class->module~fdist2d_class module~part2d_class part2d_class module~species2d_class->module~part2d_class module~fdist2d_class->module~input_class module~fdist2d_class->module~spect2d_class module~fdist2d_class->module~perrors_class module~fdist2d_class->module~parallel_pipe_class module~fdist2d_class->module~ufield2d_class module~part3d_class->module~spect3d_class module~part3d_class->module~perrors_class module~part3d_class->module~fdist3d_class module~part3d_class->module~parallel_pipe_class module~part3d_class->module~hdf5io_class module~part3d_class->mpi module~part3d_class->module~part3d_lib module~part3d_class->module~ufield3d_class module~fpois2d_class->module~spect2d_class module~fpois2d_class->module~perrors_class module~fpois2d_class->module~parallel_pipe_class module~fpois2d_class->module~ufield2d_class module~fpois2d_lib fpois2d_lib module~fpois2d_class->module~fpois2d_lib module~fft2d_class->module~spect2d_class module~fft2d_class->module~perrors_class module~fft2d_class->module~parallel_pipe_class module~fft2d_class->module~ufield2d_class module~fft2d_lib fft2d_lib module~fft2d_class->module~fft2d_lib module~ufield3d_class->module~spect3d_class module~ufield3d_class->module~perrors_class module~ufield3d_class->module~parallel_pipe_class module~ufield3d_class->module~hdf5io_class module~ufield3d_class->mpi module~ufield3d_class->module~ufield2d_class module~ufield3d_lib ufield3d_lib module~ufield3d_class->module~ufield3d_lib module~ufield2d_class->module~spect2d_class module~ufield2d_class->module~perrors_class module~ufield2d_class->module~parallel_pipe_class module~ufield2d_class->module~hdf5io_class module~ufield2d_class->mpi module~ufield2d_lib ufield2d_lib module~ufield2d_class->module~ufield2d_lib module~part2d_class->module~spect2d_class module~part2d_class->module~perrors_class module~part2d_class->module~parallel_pipe_class module~part2d_class->module~hdf5io_class module~part2d_class->mpi module~part2d_class->module~fdist2d_class module~part2d_class->module~ufield2d_class module~part2d_lib part2d_lib module~part2d_class->module~part2d_lib module~part2d_lib->mpi module~ufield2d_lib->mpi module~fft2d_lib->mpi var panmodulesimulation_classUsesGraph = svgPanZoom('#modulesimulation_classUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~simulation_class~~UsedByGraph module~simulation_class simulation_class program~quickpic quickpic program~quickpic->module~simulation_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables class erstr Derived Types fdist2d_wrap fdist3d_wrap sim_fields sim_beams sim_species sim_diag simulation Functions ntag Subroutines init_simulation end_simulation init_sim_fields end_sim_fields init_sim_beams end_sim_beams init_sim_species end_sim_species go_simulation init_diag diag_simulation Variables Type Visibility Attributes Name Initial character(len=20), private, save :: class = 'simulation: ' character(len=128), private, save :: erstr Derived Types type, private :: fdist2d_wrap Components Type Visibility Attributes Name Initial class( fdist2d ), public, allocatable :: p type, private :: fdist3d_wrap Components Type Visibility Attributes Name Initial class( fdist3d ), public, allocatable :: p type, private :: sim_fields Components Type Visibility Attributes Name Initial class( parallel_pipe ), private, pointer :: p => null() class( perrors ), private, pointer :: err => null() class( spect3d ), private, pointer :: sp3 => null() class( spect2d ), private, pointer :: sp2 => null() type( field2d ), private, allocatable :: qb type( field2d ), private, allocatable :: qe type( field2d ), private, allocatable :: psit type( field2d ), private, allocatable :: psi type( field2d ), private, allocatable :: div_vpot type( field2d ), private, allocatable :: reg type( field2d ), private, allocatable :: fxy type( field2d ), private, allocatable :: bxyz type( field2d ), private, allocatable :: cu type( field2d ), private, allocatable :: dcu type( field2d ), private, allocatable :: amu type( field2d ), private, allocatable :: epw type( field2d ), private, allocatable :: epwb type( field3d ), private, allocatable :: bexyz type( field3d ), private, allocatable :: bbxyz type( field3d ), private, allocatable :: psi3d type( field3d ), private, allocatable :: cu3d Type-Bound Procedures generic, public :: new => init_sim_fields generic, public :: del => end_sim_fields procedure, private :: end_sim_fields procedure, private :: init_sim_fields type, private :: sim_beams Components Type Visibility Attributes Name Initial class( parallel_pipe ), private, pointer :: p => null() class( perrors ), private, pointer :: err => null() class( spect3d ), private, pointer :: sp3 => null() class( spect2d ), private, pointer :: sp2 => null() type( beam3d ), private, dimension(:), allocatable :: beam type( fdist3d_wrap ), private, dimension(:), allocatable :: pf Type-Bound Procedures generic, public :: new => init_sim_beams generic, public :: del => end_sim_beams procedure, private :: end_sim_beams procedure, private :: init_sim_beams type, private :: sim_species Components Type Visibility Attributes Name Initial class( parallel_pipe ), private, pointer :: p => null() class( perrors ), private, pointer :: err => null() class( spect3d ), private, pointer :: sp3 => null() class( spect2d ), private, pointer :: sp2 => null() type( fdist2d_wrap ), private, dimension(:), allocatable :: pf type( species2d ), private, dimension(:), allocatable :: spe Type-Bound Procedures generic, public :: new => init_sim_species generic, public :: del => end_sim_species procedure, private :: end_sim_species procedure, private :: init_sim_species type, private :: sim_diag Components Type Visibility Attributes Name Initial class( parallel_pipe ), private, pointer :: p => null() class( perrors ), private, pointer :: err => null() class( spect3d ), private, pointer :: sp3 => null() class( spect2d ), private, pointer :: sp2 => null() type( hdf5file ), private :: file class(*), private, pointer :: obj => null() integer, private, allocatable :: slice integer, private, allocatable :: slice_pos integer, private, allocatable :: psample integer, private, allocatable :: dim integer, private :: df type, public :: simulation Components Type Visibility Attributes Name Initial type( input_json ), private, pointer :: in => null() class( parallel_pipe ), private, pointer :: p => null() class( perrors ), private, pointer :: err => null() class( spect3d ), private, pointer :: sp3 => null() class( spect2d ), private, pointer :: sp2 => null() type( sim_fields ), private :: fields type( sim_beams ), private :: beams type( sim_species ), private :: species type( sim_diag ), private, dimension(:), allocatable :: diag integer, private :: iter integer, private :: nstep3d integer, private :: nstep2d integer, private :: start3d integer, private :: nbeams integer, private :: nspecies integer, private :: tstep integer, private, dimension(8) :: tag integer, private, dimension(:), allocatable :: tag_spe integer, private, dimension(:), allocatable :: id_spe integer, private, dimension(:), allocatable :: id integer, private, dimension(:), allocatable :: tag_beam integer, private, dimension(:), allocatable :: id_beam integer, private, dimension(:,:), allocatable :: id_bq integer, private, dimension(:,:), allocatable :: tag_bq real, private :: dex real, private :: dxi real, private :: dex2 real, private :: dt Type-Bound Procedures generic, public :: new => init_simulation generic, public :: del => end_simulation generic, public :: go => go_simulation procedure, private :: end_simulation procedure, private :: init_simulation procedure, private :: diag_simulation procedure, private :: init_diag procedure, private :: go_simulation Functions private function ntag () Arguments None Return Value integer Subroutines private subroutine init_simulation (this) Arguments Type Intent Optional Attributes Name class( simulation ), intent(inout) :: this private subroutine end_simulation (this) Arguments Type Intent Optional Attributes Name class( simulation ), intent(inout) :: this private subroutine init_sim_fields (this, input) Arguments Type Intent Optional Attributes Name class( sim_fields ), intent(inout) :: this type( input_json ), intent(inout), pointer :: input private subroutine end_sim_fields (this) Arguments Type Intent Optional Attributes Name class( sim_fields ), intent(inout) :: this private subroutine init_sim_beams (this, input, fields) Arguments Type Intent Optional Attributes Name class( sim_beams ), intent(inout) :: this type( input_json ), intent(inout), pointer :: input class( sim_fields ), intent(inout) :: fields private subroutine end_sim_beams (this) Arguments Type Intent Optional Attributes Name class( sim_beams ), intent(inout) :: this private subroutine init_sim_species (this, input, fields, s) Arguments Type Intent Optional Attributes Name class( sim_species ), intent(inout) :: this type( input_json ), intent(inout), pointer :: input class( sim_fields ), intent(inout) :: fields real, intent(in) :: s private subroutine end_sim_species (this) Arguments Type Intent Optional Attributes Name class( sim_species ), intent(inout) :: this private subroutine go_simulation (this) Arguments Type Intent Optional Attributes Name class( simulation ), intent(inout) :: this private subroutine init_diag (this) Arguments Type Intent Optional Attributes Name class( simulation ), intent(inout), target :: this private subroutine diag_simulation (this) Arguments Type Intent Optional Attributes Name class( simulation ), intent(inout) :: this","tags":"","loc":"module/simulation_class.html"},{"title":"field2d_class – QuickPIC","text":"Uses perrors_class parallel_pipe_class spect2d_class field3d_class ufield2d_class ufield3d_class fft2d_class fpois2d_class hdf5io_class module~~field2d_class~~UsesGraph module~field2d_class field2d_class module~fpois2d_class fpois2d_class module~field2d_class->module~fpois2d_class module~field3d_class field3d_class module~field2d_class->module~field3d_class module~spect2d_class spect2d_class module~field2d_class->module~spect2d_class module~fft2d_class fft2d_class module~field2d_class->module~fft2d_class module~perrors_class perrors_class module~field2d_class->module~perrors_class module~ufield3d_class ufield3d_class module~field2d_class->module~ufield3d_class module~parallel_pipe_class parallel_pipe_class module~field2d_class->module~parallel_pipe_class module~ufield2d_class ufield2d_class module~field2d_class->module~ufield2d_class module~hdf5io_class hdf5io_class module~field2d_class->module~hdf5io_class module~fpois2d_class->module~spect2d_class module~fpois2d_class->module~perrors_class module~fpois2d_class->module~parallel_pipe_class module~fpois2d_class->module~ufield2d_class module~fpois2d_lib fpois2d_lib module~fpois2d_class->module~fpois2d_lib module~field3d_class->module~perrors_class module~field3d_class->module~ufield3d_class module~field3d_class->module~parallel_pipe_class module~field3d_class->module~hdf5io_class module~spect3d_class spect3d_class module~field3d_class->module~spect3d_class module~spect2d_class->module~perrors_class module~spect2d_class->module~parallel_pipe_class module~fft2d_class->module~spect2d_class module~fft2d_class->module~perrors_class module~fft2d_class->module~parallel_pipe_class module~fft2d_class->module~ufield2d_class module~fft2d_lib fft2d_lib module~fft2d_class->module~fft2d_lib module~parallel_class parallel_class module~perrors_class->module~parallel_class mpi mpi module~perrors_class->mpi module~ufield3d_class->module~perrors_class module~ufield3d_class->module~parallel_pipe_class module~ufield3d_class->module~ufield2d_class module~ufield3d_class->module~hdf5io_class module~ufield3d_class->module~spect3d_class module~ufield3d_class->mpi module~ufield3d_lib ufield3d_lib module~ufield3d_class->module~ufield3d_lib module~parallel_pipe_class->module~parallel_class module~parallel_pipe_class->mpi module~ufield2d_class->module~spect2d_class module~ufield2d_class->module~perrors_class module~ufield2d_class->module~parallel_pipe_class module~ufield2d_class->module~hdf5io_class module~ufield2d_class->mpi module~ufield2d_lib ufield2d_lib module~ufield2d_class->module~ufield2d_lib module~hdf5io_class->module~perrors_class module~hdf5io_class->module~parallel_pipe_class module~hdf5io_class->mpi HDF5 HDF5 module~hdf5io_class->HDF5 module~spect3d_class->module~spect2d_class module~spect3d_class->module~perrors_class module~spect3d_class->module~parallel_pipe_class module~parallel_class->mpi omp_lib omp_lib module~parallel_class->omp_lib module~ufield2d_lib->mpi module~fft2d_lib->mpi var panmodulefield2d_classUsesGraph = svgPanZoom('#modulefield2d_classUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~field2d_class~~UsedByGraph module~field2d_class field2d_class module~species2d_class species2d_class module~species2d_class->module~field2d_class module~beam3d_class beam3d_class module~beam3d_class->module~field2d_class module~simulation_class simulation_class module~simulation_class->module~field2d_class module~simulation_class->module~species2d_class module~simulation_class->module~beam3d_class program~quickpic quickpic program~quickpic->module~simulation_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables class erstr Derived Types field2d Functions getstate getgcells getrs getks Subroutines init_field2d end_field2d fftrk_field2d fftkr_field2d divf_field2d gradf_field2d curlf_field2d potential_field2d smoothf_field2d elfield_field2d bfield_field2d bfield_qp_field2d copyguard_field2d acopyguard_field2d pipesend_field2d piperecv_field2d asc copyto copyfrom copyadd asa sum1 sum2 minus1 minus2 multiply1 multiply2 writehdf5_field2d Variables Type Visibility Attributes Name Initial character(len=10), private, save :: class = 'field2d:' character(len=128), private, save :: erstr Derived Types type, public :: field2d Components Type Visibility Attributes Name Initial class( spect2d ), public, pointer :: sp => null() class( perrors ), public, pointer :: err => null() class( parallel_pipe ), public, pointer :: p => null() class( ufield2d ), private, pointer :: rs => null() class( ufield2d ), private, pointer :: ks => null() class( fft2d ), private, pointer :: ft => null() class( fpois2d ), private, pointer :: pt => null() integer, private :: state integer, private :: gcells Type-Bound Procedures generic, public :: new => init_field2d generic, public :: del => end_field2d generic, public :: fftrk => fftrk_field2d generic, public :: fftkr => fftkr_field2d generic, public :: div => divf_field2d generic, public :: grad => gradf_field2d generic, public :: curl => curlf_field2d generic, public :: pot => potential_field2d generic, public :: smooth => smoothf_field2d generic, public :: elf => elfield_field2d generic, public :: bf => bfield_field2d generic, public :: bfqp => bfield_qp_field2d generic, public :: cg => copyguard_field2d generic, public :: ag => acopyguard_field2d generic, public :: psend => pipesend_field2d generic, public :: precv => piperecv_field2d generic, public :: cp => copyfrom generic, public :: ca => copyadd generic, public :: cb => copyto generic, public :: as => asc, asa generic, public :: add => sum1, sum2 generic, public :: sub => minus1, minus2 generic, public :: mult => multiply1, multiply2 generic, public :: wr => writehdf5_field2d procedure, private :: end_field2d procedure, private :: init_field2d procedure, private :: divf_field2d procedure, private :: fftkr_field2d procedure, private :: fftrk_field2d procedure, private :: potential_field2d procedure, private :: curlf_field2d procedure, private :: gradf_field2d procedure, private :: bfield_field2d procedure, private :: elfield_field2d procedure, private :: smoothf_field2d procedure, private :: copyguard_field2d procedure, private :: bfield_qp_field2d procedure, private :: pipesend_field2d procedure, private :: acopyguard_field2d procedure, private :: multiply1 procedure, private :: minus1 procedure, private :: sum1 procedure, private :: asa procedure, private :: asc procedure, private :: piperecv_field2d procedure, private :: minus2 procedure, private :: sum2 procedure, private :: multiply2 procedure, private :: writehdf5_field2d procedure, private :: copyadd procedure, private :: copyto procedure, private :: copyfrom procedure, public :: getks procedure, public :: getrs procedure, public :: getgcells procedure, public :: getstate Functions private function getstate (this) Arguments Type Intent Optional Attributes Name class( field2d ), intent(in) :: this Return Value integer private function getgcells (this) Arguments Type Intent Optional Attributes Name class( field2d ), intent(in) :: this Return Value integer private function getrs (this) Arguments Type Intent Optional Attributes Name class( field2d ), intent(in) :: this Return Value class( ufield2d ),\n  pointer private function getks (this) Arguments Type Intent Optional Attributes Name class( field2d ), intent(in) :: this Return Value class( ufield2d ),\n  pointer Subroutines private subroutine init_field2d (this, pp, perr, psp, dim, fftflag, state, gcells) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( spect2d ), intent(in), pointer :: psp integer, intent(in) :: dim logical, intent(in) :: fftflag integer, intent(in), optional :: state integer, intent(in), optional :: gcells private subroutine end_field2d (this) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this private subroutine fftrk_field2d (this, kind) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this integer, intent(in) :: kind private subroutine fftkr_field2d (this, kind) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this integer, intent(in) :: kind private subroutine divf_field2d (this, that) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(inout) :: that private subroutine gradf_field2d (this, that) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(inout) :: that private subroutine curlf_field2d (this, that) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(inout) :: that private subroutine potential_field2d (this, that) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(inout) :: that private subroutine smoothf_field2d (this, that) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(inout) :: that private subroutine elfield_field2d (this, that) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(inout) :: that private subroutine bfield_field2d (this, that) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(inout) :: that private subroutine bfield_qp_field2d (cu, dcu, amu, bxy, c, dex) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: cu class( field2d ), intent(inout) :: dcu class( field2d ), intent(inout) :: amu class( field2d ), intent(inout) :: bxy real, intent(in) :: c real, intent(in) :: dex private subroutine copyguard_field2d (this) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this private subroutine acopyguard_field2d (this) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this private subroutine pipesend_field2d (this, stag, id) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this integer, intent(in) :: stag integer, intent(inout) :: id private subroutine piperecv_field2d (this, rtag) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this integer, intent(in) :: rtag private subroutine asc (this, value) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this real, intent(in) :: value private subroutine copyto (this, that, lpos, sdim, ddim) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field3d ), intent(in) :: that integer, intent(in) :: lpos integer, intent(in), dimension(:) :: sdim integer, intent(in), dimension(:) :: ddim private subroutine copyfrom (this, that, lpos, sdim, ddim) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field3d ), intent(in) :: that integer, intent(in) :: lpos integer, intent(in), dimension(:) :: sdim integer, intent(in), dimension(:) :: ddim private subroutine copyadd (this, that, lpos, sdim, ddim) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field3d ), intent(in) :: that integer, intent(in) :: lpos integer, intent(in), dimension(:) :: sdim integer, intent(in), dimension(:) :: ddim private subroutine asa (this, that) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(inout) :: that private subroutine sum1 (this, a1, a2) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(in) :: a1 class( field2d ), intent(in) :: a2 private subroutine sum2 (this, a1, a2, dim, dim1, dim2) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(in) :: a1 class( field2d ), intent(in) :: a2 integer, intent(in), dimension(:) :: dim integer, intent(in), dimension(:) :: dim1 integer, intent(in), dimension(:) :: dim2 private subroutine minus1 (this, a1, a2) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(in) :: a1 class( field2d ), intent(in) :: a2 private subroutine minus2 (this, a1, a2, dim, dim1, dim2) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(in) :: a1 class( field2d ), intent(in) :: a2 integer, intent(in), dimension(:) :: dim integer, intent(in), dimension(:) :: dim1 integer, intent(in), dimension(:) :: dim2 private subroutine multiply1 (this, a1, value) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(in) :: a1 real, intent(in) :: value private subroutine multiply2 (this, a1, dim, dim1, value) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( field2d ), intent(in) :: a1 integer, intent(in), dimension(:) :: dim integer, intent(in), dimension(:) :: dim1 real, intent(in), dimension(:) :: value private subroutine writehdf5_field2d (this, file, dim) Arguments Type Intent Optional Attributes Name class( field2d ), intent(inout) :: this class( hdf5file ), intent(in) :: file integer, intent(in) :: dim","tags":"","loc":"module/field2d_class.html"},{"title":"ufield3d_class – QuickPIC","text":"Uses perrors_class parallel_pipe_class spect3d_class ufield3d_lib ufield2d_class hdf5io_class mpi module~~ufield3d_class~~UsesGraph module~ufield3d_class ufield3d_class module~spect3d_class spect3d_class module~ufield3d_class->module~spect3d_class module~perrors_class perrors_class module~ufield3d_class->module~perrors_class module~ufield3d_lib ufield3d_lib module~ufield3d_class->module~ufield3d_lib module~parallel_pipe_class parallel_pipe_class module~ufield3d_class->module~parallel_pipe_class module~ufield2d_class ufield2d_class module~ufield3d_class->module~ufield2d_class mpi mpi module~ufield3d_class->mpi module~hdf5io_class hdf5io_class module~ufield3d_class->module~hdf5io_class module~spect3d_class->module~perrors_class module~spect3d_class->module~parallel_pipe_class module~spect2d_class spect2d_class module~spect3d_class->module~spect2d_class module~perrors_class->mpi module~parallel_class parallel_class module~perrors_class->module~parallel_class module~parallel_pipe_class->mpi module~parallel_pipe_class->module~parallel_class module~ufield2d_class->module~perrors_class module~ufield2d_class->module~parallel_pipe_class module~ufield2d_class->mpi module~ufield2d_class->module~hdf5io_class module~ufield2d_class->module~spect2d_class module~ufield2d_lib ufield2d_lib module~ufield2d_class->module~ufield2d_lib module~hdf5io_class->module~perrors_class module~hdf5io_class->module~parallel_pipe_class module~hdf5io_class->mpi HDF5 HDF5 module~hdf5io_class->HDF5 module~parallel_class->mpi omp_lib omp_lib module~parallel_class->omp_lib module~spect2d_class->module~perrors_class module~spect2d_class->module~parallel_pipe_class module~ufield2d_lib->mpi var panmoduleufield3d_classUsesGraph = svgPanZoom('#moduleufield3d_classUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~ufield3d_class~~UsedByGraph module~ufield3d_class ufield3d_class module~fdist3d_class fdist3d_class module~fdist3d_class->module~ufield3d_class module~part3d_class part3d_class module~part3d_class->module~ufield3d_class module~part3d_class->module~fdist3d_class module~field3d_class field3d_class module~field3d_class->module~ufield3d_class module~field2d_class field2d_class module~field2d_class->module~ufield3d_class module~field2d_class->module~field3d_class module~species2d_class species2d_class module~species2d_class->module~field3d_class module~species2d_class->module~field2d_class module~beam3d_class beam3d_class module~beam3d_class->module~fdist3d_class module~beam3d_class->module~part3d_class module~beam3d_class->module~field3d_class module~beam3d_class->module~field2d_class module~simulation_class simulation_class module~simulation_class->module~fdist3d_class module~simulation_class->module~field3d_class module~simulation_class->module~field2d_class module~simulation_class->module~species2d_class module~simulation_class->module~beam3d_class program~quickpic quickpic program~quickpic->module~simulation_class var panmoduleufield3d_classUsedByGraph = svgPanZoom('#moduleufield3d_classUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables class erstr Derived Types ufield3d Functions getnvpy getnvpx getnvpz getnd2 getnd1 getnd3 getnd3p getnd2p getnd1p getdim getnoff getrf Subroutines init_ufield3d end_ufield3d final_ufield3d copyguard_pipe acopyguard copyin copyout copyadd writehdf5_3d writehdf5_2dslice sum minus multiply asc asa Variables Type Visibility Attributes Name Initial character(len=10), private, save :: class = 'ufield3d:' character(len=128), private, save :: erstr Derived Types type, public :: ufield3d Components Type Visibility Attributes Name Initial class( spect3d ), public, pointer :: sp => null() class( perrors ), public, pointer :: err => null() class( parallel_pipe ), public, pointer :: p => null() integer, private :: dim integer, private, dimension(2) :: noff integer, private :: nd1 integer, private :: nvpx integer, private :: nd1p integer, private :: nd2 integer, private :: nvpy integer, private :: nd2p integer, private :: nd3 integer, private :: nvpz integer, private :: nd3p real, private, dimension(:,:,:,:), pointer :: rf => null() Finalizations Procedures final :: final_ufield3d","tags":"","loc":"module/ufield3d_class.html"},{"title":"fdist3d_class – QuickPIC","text":"Uses perrors_class parallel_pipe_class spect3d_class ufield3d_class part3d_lib input_class module~~fdist3d_class~~UsesGraph module~fdist3d_class fdist3d_class module~spect3d_class spect3d_class module~fdist3d_class->module~spect3d_class module~input_class input_class module~fdist3d_class->module~input_class module~part3d_lib part3d_lib module~fdist3d_class->module~part3d_lib module~perrors_class perrors_class module~fdist3d_class->module~perrors_class module~ufield3d_class ufield3d_class module~fdist3d_class->module~ufield3d_class module~parallel_pipe_class parallel_pipe_class module~fdist3d_class->module~parallel_pipe_class module~spect3d_class->module~perrors_class module~spect3d_class->module~parallel_pipe_class module~spect2d_class spect2d_class module~spect3d_class->module~spect2d_class module~input_class->module~spect3d_class module~input_class->module~perrors_class module~input_class->module~parallel_pipe_class module~parallel_class parallel_class module~input_class->module~parallel_class json_module json_module module~input_class->json_module mpi mpi module~input_class->mpi module~perrors_class->module~parallel_class module~perrors_class->mpi module~ufield3d_class->module~spect3d_class module~ufield3d_class->module~perrors_class module~ufield3d_class->module~parallel_pipe_class module~ufield3d_lib ufield3d_lib module~ufield3d_class->module~ufield3d_lib module~ufield2d_class ufield2d_class module~ufield3d_class->module~ufield2d_class module~ufield3d_class->mpi module~hdf5io_class hdf5io_class module~ufield3d_class->module~hdf5io_class module~parallel_pipe_class->module~parallel_class module~parallel_pipe_class->mpi module~parallel_class->mpi omp_lib omp_lib module~parallel_class->omp_lib module~spect2d_class->module~perrors_class module~spect2d_class->module~parallel_pipe_class module~ufield2d_class->module~perrors_class module~ufield2d_class->module~parallel_pipe_class module~ufield2d_class->module~spect2d_class module~ufield2d_class->mpi module~ufield2d_class->module~hdf5io_class module~ufield2d_lib ufield2d_lib module~ufield2d_class->module~ufield2d_lib module~hdf5io_class->module~perrors_class module~hdf5io_class->module~parallel_pipe_class module~hdf5io_class->mpi HDF5 HDF5 module~hdf5io_class->HDF5 module~ufield2d_lib->mpi var panmodulefdist3d_classUsesGraph = svgPanZoom('#modulefdist3d_classUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~fdist3d_class~~UsedByGraph module~fdist3d_class fdist3d_class module~part3d_class part3d_class module~part3d_class->module~fdist3d_class module~beam3d_class beam3d_class module~beam3d_class->module~fdist3d_class module~beam3d_class->module~part3d_class module~simulation_class simulation_class module~simulation_class->module~fdist3d_class module~simulation_class->module~beam3d_class program~quickpic quickpic program~quickpic->module~simulation_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables class erstr Abstract Interfaces ab_dist3d ab_init_fdist3d Derived Types fdist3d fdist3d_000 Functions getnpf getnpmax Subroutines end_fdist3d init_fdist3d_000 dist3d_000 Variables Type Visibility Attributes Name Initial character(len=10), private, save :: class = 'fdist3d:' character(len=128), private, save :: erstr Abstract Interfaces abstract interface private subroutine ab_dist3d(this, part3d, npp, fd) Arguments Type Intent Optional Attributes Name class( fdist3d ), intent(inout) :: this real, intent(inout), dimension(:,:), pointer :: part3d integer, intent(inout) :: npp class( ufield3d ), intent(in), pointer :: fd abstract interface private subroutine ab_init_fdist3d(this, input, i) Arguments Type Intent Optional Attributes Name class( fdist3d ), intent(inout) :: this type( input_json ), intent(inout), pointer :: input integer, intent(in) :: i Derived Types type, public, abstract :: fdist3d Components Type Visibility Attributes Name Initial class( spect3d ), public, pointer :: sp => null() class( perrors ), public, pointer :: err => null() class( parallel_pipe ), public, pointer :: p => null() integer, private :: npf integer, private :: npmax Type-Bound Procedures generic, public :: new => init_fdist3d generic, public :: del => end_fdist3d generic, public :: dist => dist3d procedure(ab_init_fdist3d), private :: init_fdist3d procedure, private :: end_fdist3d procedure(ab_dist3d), private :: dist3d procedure, public :: getnpmax procedure, public :: getnpf type, public, extends( fdist3d ) :: fdist3d_000 Components Type Visibility Attributes Name Initial class( spect3d ), public, pointer :: sp => null() class( perrors ), public, pointer :: err => null() class( parallel_pipe ), public, pointer :: p => null() integer, private :: npx integer, private :: npy integer, private :: npz real, private :: qm real, private :: sigx real, private :: sigy real, private :: sigz real, private :: bcx real, private :: bcy real, private :: bcz real, private :: sigvx real, private :: sigvy real, private :: sigvz real, private :: cx1 real, private :: cx2 real, private :: cx3 real, private :: cy1 real, private :: cy2 real, private :: cy3 real, private :: gamma real, private :: np logical, private :: quiet Type-Bound Procedures generic, public :: new => init_fdist3d generic, public :: del => end_fdist3d generic, public :: dist => dist3d procedure, public :: getnpmax procedure, public :: getnpf procedure, private :: init_fdist3d => init_fdist3d_000 procedure, private :: dist3d => dist3d_000 Functions private function getnpf (this) Arguments Type Intent Optional Attributes Name class( fdist3d ), intent(in) :: this Return Value integer private function getnpmax (this) Arguments Type Intent Optional Attributes Name class( fdist3d ), intent(in) :: this Return Value integer Subroutines private subroutine end_fdist3d (this) Arguments Type Intent Optional Attributes Name class( fdist3d ), intent(inout) :: this private subroutine init_fdist3d_000 (this, input, i) Arguments Type Intent Optional Attributes Name class( fdist3d_000 ), intent(inout) :: this type( input_json ), intent(inout), pointer :: input integer, intent(in) :: i private subroutine dist3d_000 (this, part3d, npp, fd) Arguments Type Intent Optional Attributes Name class( fdist3d_000 ), intent(inout) :: this real, intent(inout), dimension(:,:), pointer :: part3d integer, intent(inout) :: npp class( ufield3d ), intent(in), pointer :: fd","tags":"","loc":"module/fdist3d_class.html"},{"title":"parallel_class – QuickPIC","text":"Uses mpi omp_lib module~~parallel_class~~UsesGraph module~parallel_class parallel_class omp_lib omp_lib module~parallel_class->omp_lib mpi mpi module~parallel_class->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~parallel_class~~UsedByGraph module~parallel_class parallel_class module~perrors_class perrors_class module~perrors_class->module~parallel_class module~input_class input_class module~input_class->module~parallel_class module~input_class->module~perrors_class module~parallel_pipe_class parallel_pipe_class module~input_class->module~parallel_pipe_class module~spect3d_class spect3d_class module~input_class->module~spect3d_class module~parallel_pipe_class->module~parallel_class module~simulation_class simulation_class module~simulation_class->module~parallel_class module~simulation_class->module~perrors_class module~simulation_class->module~input_class module~simulation_class->module~parallel_pipe_class module~simulation_class->module~spect3d_class module~field3d_class field3d_class module~simulation_class->module~field3d_class module~spect2d_class spect2d_class module~simulation_class->module~spect2d_class module~field2d_class field2d_class module~simulation_class->module~field2d_class module~fdist3d_class fdist3d_class module~simulation_class->module~fdist3d_class module~species2d_class species2d_class module~simulation_class->module~species2d_class module~beam3d_class beam3d_class module~simulation_class->module~beam3d_class module~hdf5io_class hdf5io_class module~simulation_class->module~hdf5io_class module~fdist2d_class fdist2d_class module~simulation_class->module~fdist2d_class module~part3d_class part3d_class module~part3d_class->module~perrors_class module~part3d_class->module~parallel_pipe_class module~part3d_class->module~spect3d_class module~part3d_class->module~fdist3d_class module~ufield3d_class ufield3d_class module~part3d_class->module~ufield3d_class module~part3d_class->module~hdf5io_class module~spect3d_class->module~perrors_class module~spect3d_class->module~parallel_pipe_class module~spect3d_class->module~spect2d_class module~fpois2d_class fpois2d_class module~fpois2d_class->module~perrors_class module~fpois2d_class->module~parallel_pipe_class module~fpois2d_class->module~spect2d_class module~ufield2d_class ufield2d_class module~fpois2d_class->module~ufield2d_class module~field3d_class->module~perrors_class module~field3d_class->module~parallel_pipe_class module~field3d_class->module~spect3d_class module~field3d_class->module~ufield3d_class module~field3d_class->module~hdf5io_class module~spect2d_class->module~perrors_class module~spect2d_class->module~parallel_pipe_class module~fft2d_class fft2d_class module~fft2d_class->module~perrors_class module~fft2d_class->module~parallel_pipe_class module~fft2d_class->module~spect2d_class module~fft2d_class->module~ufield2d_class module~field2d_class->module~perrors_class module~field2d_class->module~parallel_pipe_class module~field2d_class->module~fpois2d_class module~field2d_class->module~field3d_class module~field2d_class->module~spect2d_class module~field2d_class->module~fft2d_class module~field2d_class->module~ufield3d_class module~field2d_class->module~ufield2d_class module~field2d_class->module~hdf5io_class module~fdist3d_class->module~perrors_class module~fdist3d_class->module~input_class module~fdist3d_class->module~parallel_pipe_class module~fdist3d_class->module~spect3d_class module~fdist3d_class->module~ufield3d_class module~ufield3d_class->module~perrors_class module~ufield3d_class->module~parallel_pipe_class module~ufield3d_class->module~spect3d_class module~ufield3d_class->module~ufield2d_class module~ufield3d_class->module~hdf5io_class module~species2d_class->module~perrors_class module~species2d_class->module~parallel_pipe_class module~species2d_class->module~spect3d_class module~species2d_class->module~field3d_class module~species2d_class->module~spect2d_class module~species2d_class->module~field2d_class module~part2d_class part2d_class module~species2d_class->module~part2d_class module~species2d_class->module~hdf5io_class module~species2d_class->module~fdist2d_class module~beam3d_class->module~perrors_class module~beam3d_class->module~parallel_pipe_class module~beam3d_class->module~part3d_class module~beam3d_class->module~spect3d_class module~beam3d_class->module~field3d_class module~beam3d_class->module~field2d_class module~beam3d_class->module~fdist3d_class module~beam3d_class->module~hdf5io_class program~quickpic quickpic program~quickpic->module~simulation_class module~ufield2d_class->module~perrors_class module~ufield2d_class->module~parallel_pipe_class module~ufield2d_class->module~spect2d_class module~ufield2d_class->module~hdf5io_class module~part2d_class->module~perrors_class module~part2d_class->module~parallel_pipe_class module~part2d_class->module~spect2d_class module~part2d_class->module~ufield2d_class module~part2d_class->module~hdf5io_class module~part2d_class->module~fdist2d_class module~hdf5io_class->module~perrors_class module~hdf5io_class->module~parallel_pipe_class module~fdist2d_class->module~perrors_class module~fdist2d_class->module~input_class module~fdist2d_class->module~parallel_pipe_class module~fdist2d_class->module~spect2d_class module~fdist2d_class->module~ufield2d_class var panmoduleparallel_classUsedByGraph = svgPanZoom('#moduleparallel_classUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types parallel Functions getnvp getidproc getkstrt getlworld getmint getmreal getmdouble getmcplx getmchar Subroutines init_parallel ppinit2 init_omp end_parallel Derived Types type, public :: parallel Components Type Visibility Attributes Name Initial integer, private :: nvp integer, private :: idproc integer, private :: kstrt integer, private :: mreal integer, private :: mint integer, private :: mcplx integer, private :: mdouble integer, private :: mchar integer, private :: lworld Type-Bound Procedures generic, public :: new => init_parallel generic, public :: del => end_parallel procedure, public :: getnvp procedure, public :: getidproc procedure, public :: getkstrt procedure, public :: getlworld procedure, public :: getmreal procedure, public :: getmint procedure, public :: getmdouble procedure, public :: getmcplx procedure, public :: getmchar procedure, private :: init_parallel procedure, private :: end_parallel Functions private function getnvp (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer private function getidproc (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer private function getkstrt (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer private function getlworld (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer private function getmint (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer private function getmreal (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer private function getmdouble (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer private function getmcplx (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer private function getmchar (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(in) :: this Return Value integer Subroutines private subroutine init_parallel (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(inout) :: this private subroutine ppinit2 (idproc, nvp, lworld, mint, mreal, mdouble, mcplx, mchar) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: idproc integer, intent(inout) :: nvp integer, intent(inout) :: lworld integer, intent(inout) :: mint integer, intent(inout) :: mreal integer, intent(inout) :: mdouble integer, intent(inout) :: mcplx integer, intent(inout) :: mchar private subroutine init_omp (nth) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nth private subroutine end_parallel (this) Arguments Type Intent Optional Attributes Name class( parallel ), intent(inout) :: this","tags":"","loc":"module/parallel_class.html"},{"title":"part2d_class – QuickPIC","text":"Uses perrors_class parallel_pipe_class spect2d_class fdist2d_class ufield2d_class part2d_lib hdf5io_class mpi module~~part2d_class~~UsesGraph module~part2d_class part2d_class module~spect2d_class spect2d_class module~part2d_class->module~spect2d_class module~part2d_lib part2d_lib module~part2d_class->module~part2d_lib module~perrors_class perrors_class module~part2d_class->module~perrors_class module~parallel_pipe_class parallel_pipe_class module~part2d_class->module~parallel_pipe_class module~ufield2d_class ufield2d_class module~part2d_class->module~ufield2d_class mpi mpi module~part2d_class->mpi module~hdf5io_class hdf5io_class module~part2d_class->module~hdf5io_class module~fdist2d_class fdist2d_class module~part2d_class->module~fdist2d_class module~spect2d_class->module~perrors_class module~spect2d_class->module~parallel_pipe_class module~part2d_lib->mpi module~perrors_class->mpi module~parallel_class parallel_class module~perrors_class->module~parallel_class module~parallel_pipe_class->mpi module~parallel_pipe_class->module~parallel_class module~ufield2d_class->module~spect2d_class module~ufield2d_class->module~perrors_class module~ufield2d_class->module~parallel_pipe_class module~ufield2d_class->mpi module~ufield2d_class->module~hdf5io_class module~ufield2d_lib ufield2d_lib module~ufield2d_class->module~ufield2d_lib module~hdf5io_class->module~perrors_class module~hdf5io_class->module~parallel_pipe_class module~hdf5io_class->mpi HDF5 HDF5 module~hdf5io_class->HDF5 module~fdist2d_class->module~spect2d_class module~fdist2d_class->module~perrors_class module~fdist2d_class->module~parallel_pipe_class module~fdist2d_class->module~ufield2d_class module~input_class input_class module~fdist2d_class->module~input_class module~parallel_class->mpi omp_lib omp_lib module~parallel_class->omp_lib module~input_class->module~perrors_class module~input_class->module~parallel_pipe_class module~input_class->mpi module~input_class->module~parallel_class module~spect3d_class spect3d_class module~input_class->module~spect3d_class json_module json_module module~input_class->json_module module~ufield2d_lib->mpi module~spect3d_class->module~spect2d_class module~spect3d_class->module~perrors_class module~spect3d_class->module~parallel_pipe_class var panmodulepart2d_classUsesGraph = svgPanZoom('#modulepart2d_classUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~part2d_class~~UsedByGraph module~part2d_class part2d_class module~species2d_class species2d_class module~species2d_class->module~part2d_class module~simulation_class simulation_class module~simulation_class->module~species2d_class program~quickpic quickpic program~quickpic->module~simulation_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables class erstr mx my mx1 myp1 mxyp1 ppbuff szpbuf sbufl sbufr rbufl rbufr szbufs ncll nclr mcll mclr sznbufs Derived Types part2d Subroutines init_part2d end_part2d renew_part2d qdeposit amjdeposit partpush pmove extractpsi partcopy partcopyback pipesend_part2d piperecv_part2d writehdf5_part2d Variables Type Visibility Attributes Name Initial character(len=10), private :: class = 'part2d:' character(len=128), private :: erstr integer, private :: mx = 16 integer, private :: my = 16 integer, private :: mx1 integer, private :: myp1 integer, private :: mxyp1 real, private, dimension(:,:,:), allocatable :: ppbuff integer, private :: szpbuf = 0 real, private, dimension(:,:), allocatable :: sbufl real, private, dimension(:,:), allocatable :: sbufr real, private, dimension(:,:), allocatable :: rbufl real, private, dimension(:,:), allocatable :: rbufr integer, private :: szbufs = 0 integer, private, dimension(:,:), allocatable :: ncll integer, private, dimension(:,:), allocatable :: nclr integer, private, dimension(:,:), allocatable :: mcll integer, private, dimension(:,:), allocatable :: mclr integer, private :: sznbufs = 0 Derived Types type, public :: part2d Components Type Visibility Attributes Name Initial class( spect2d ), public, pointer :: sp => null() class( perrors ), public, pointer :: err => null() class( parallel_pipe ), public, pointer :: p => null() real, private :: qbm real, private :: dt real, private :: ci integer, private :: npmax integer, private :: nbmax integer, private :: np integer, private :: xdim integer, private :: npp = 0 real, private, dimension(:,:), pointer :: part => null() real, private, dimension(:,:,:), pointer :: ppart => null() integer, private :: nppmx integer, private :: nppmx0 integer, private :: nbmaxp integer, private :: ntmaxp integer, private :: npbmx integer, private :: irc = 0 integer, private, dimension(:,:), pointer :: ncl => null() integer, private, dimension(:,:,:), pointer :: ihole => null() integer, private, dimension(:), pointer :: kpic => null() Type-Bound Procedures generic, public :: new => init_part2d generic, public :: renew => renew_part2d generic, public :: del => end_part2d generic, public :: qdp => qdeposit generic, public :: amjdp => amjdeposit generic, public :: push => partpush generic, public :: pmv => pmove generic, public :: extpsi => extractpsi generic, public :: pcp => partcopy generic, public :: pcb => partcopyback generic, public :: psend => pipesend_part2d generic, public :: precv => piperecv_part2d generic, public :: wr => writehdf5_part2d procedure, private :: renew_part2d procedure, private :: init_part2d procedure, private :: end_part2d procedure, private :: qdeposit procedure, private :: amjdeposit procedure, private :: partpush procedure, private :: pmove procedure, private :: extractpsi procedure, private :: partcopy procedure, private :: partcopyback procedure, private :: pipesend_part2d procedure, private :: writehdf5_part2d procedure, private :: piperecv_part2d Subroutines private subroutine init_part2d (this, pp, perr, psp, pf, fd, qbm, dt, ci, xdim, s) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( spect2d ), intent(in), pointer :: psp class( fdist2d ), intent(inout) :: pf class( ufield2d ), intent(in), pointer :: fd real, intent(in) :: qbm real, intent(in) :: dt real, intent(in) :: ci integer, intent(in) :: xdim real, intent(in) :: s private subroutine end_part2d (this) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this private subroutine renew_part2d (this, pf, fd, s) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this class( fdist2d ), intent(inout) :: pf class( ufield2d ), intent(in), pointer :: fd real, intent(in) :: s private subroutine qdeposit (this, q) Arguments Type Intent Optional Attributes Name class( part2d ), intent(in) :: this class( ufield2d ), intent(in), pointer :: q private subroutine amjdeposit (this, ef, bf, psit, cu, amu, dcu, dex) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this class( ufield2d ), intent(in), pointer :: ef class( ufield2d ), intent(in), pointer :: bf class( ufield2d ), intent(in), pointer :: psit class( ufield2d ), intent(in), pointer :: cu class( ufield2d ), intent(in), pointer :: amu class( ufield2d ), intent(in), pointer :: dcu real, intent(in) :: dex private subroutine partpush (this, ef, bf, psit, dex) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this class( ufield2d ), intent(in), pointer :: ef class( ufield2d ), intent(in), pointer :: bf class( ufield2d ), intent(in), pointer :: psit real, intent(in) :: dex private subroutine pmove (this, fd) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this class( ufield2d ), intent(in), pointer :: fd private subroutine extractpsi (this, psi, dex) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this class( ufield2d ), intent(in), pointer :: psi real, intent(in) :: dex private subroutine partcopy (this, fd) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this class( ufield2d ), intent(in), pointer :: fd private subroutine partcopyback (this) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this private subroutine pipesend_part2d (this, tag, id) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this integer, intent(in) :: tag integer, intent(inout) :: id private subroutine piperecv_part2d (this, fd, tag) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this class( ufield2d ), intent(in), pointer :: fd integer, intent(in) :: tag private subroutine writehdf5_part2d (this, file, delta) Arguments Type Intent Optional Attributes Name class( part2d ), intent(inout) :: this class( hdf5file ), intent(in) :: file real, intent(in), dimension(2) :: delta","tags":"","loc":"module/part2d_class.html"},{"title":"spect3d_class – QuickPIC","text":"Uses perrors_class parallel_pipe_class spect2d_class module~~spect3d_class~~UsesGraph module~spect3d_class spect3d_class module~perrors_class perrors_class module~spect3d_class->module~perrors_class module~spect2d_class spect2d_class module~spect3d_class->module~spect2d_class module~parallel_pipe_class parallel_pipe_class module~spect3d_class->module~parallel_pipe_class mpi mpi module~perrors_class->mpi module~parallel_class parallel_class module~perrors_class->module~parallel_class module~spect2d_class->module~perrors_class module~spect2d_class->module~parallel_pipe_class module~parallel_pipe_class->mpi module~parallel_pipe_class->module~parallel_class module~parallel_class->mpi omp_lib omp_lib module~parallel_class->omp_lib Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~spect3d_class~~UsedByGraph module~spect3d_class spect3d_class module~part3d_class part3d_class module~part3d_class->module~spect3d_class module~fdist3d_class fdist3d_class module~part3d_class->module~fdist3d_class module~ufield3d_class ufield3d_class module~part3d_class->module~ufield3d_class module~field3d_class field3d_class module~field3d_class->module~spect3d_class module~field3d_class->module~ufield3d_class module~input_class input_class module~input_class->module~spect3d_class module~simulation_class simulation_class module~simulation_class->module~spect3d_class module~simulation_class->module~field3d_class module~simulation_class->module~input_class module~simulation_class->module~fdist3d_class module~beam3d_class beam3d_class module~simulation_class->module~beam3d_class module~species2d_class species2d_class module~simulation_class->module~species2d_class module~fdist2d_class fdist2d_class module~simulation_class->module~fdist2d_class module~field2d_class field2d_class module~simulation_class->module~field2d_class module~fdist3d_class->module~spect3d_class module~fdist3d_class->module~input_class module~fdist3d_class->module~ufield3d_class module~ufield3d_class->module~spect3d_class module~beam3d_class->module~spect3d_class module~beam3d_class->module~part3d_class module~beam3d_class->module~field3d_class module~beam3d_class->module~fdist3d_class module~beam3d_class->module~field2d_class module~species2d_class->module~spect3d_class module~species2d_class->module~field3d_class module~species2d_class->module~fdist2d_class module~species2d_class->module~field2d_class module~part2d_class part2d_class module~species2d_class->module~part2d_class module~fdist2d_class->module~input_class program~quickpic quickpic program~quickpic->module~simulation_class module~field2d_class->module~field3d_class module~field2d_class->module~ufield3d_class module~part2d_class->module~fdist2d_class var panmodulespect3d_classUsedByGraph = svgPanZoom('#modulespect3d_classUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types spect3d Functions getindz Subroutines init_spect3d end_spect3d Derived Types type, public, extends( spect2d ) :: spect3d Components Type Visibility Attributes Name Initial class( perrors ), public, pointer :: err => null() class( parallel_pipe ), public, pointer :: p => null() integer, private :: indz Type-Bound Procedures generic, public :: del => end_spect2d procedure, public :: getindx procedure, public :: getindy procedure, public :: getpsolver procedure, public :: getinorder procedure, private :: init_spect3d procedure, private :: end_spect2d => end_spect3d generic, public :: new => init_spect2d, init_spect3d procedure, public :: getindz Functions private function getindz (this) Arguments Type Intent Optional Attributes Name class( spect3d ), intent(in) :: this Return Value integer Subroutines private subroutine init_spect3d (this, pp, perr, indx, indy, indz, psolver, inorder) Arguments Type Intent Optional Attributes Name class( spect3d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: indz integer, intent(in) :: psolver integer, intent(in) :: inorder private subroutine end_spect3d (this) Arguments Type Intent Optional Attributes Name class( spect3d ), intent(inout) :: this","tags":"","loc":"module/spect3d_class.html"},{"title":"ufield2d_lib – QuickPIC","text":"Uses mpi module~~ufield2d_lib~~UsesGraph module~ufield2d_lib ufield2d_lib mpi mpi module~ufield2d_lib->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~ufield2d_lib~~UsedByGraph module~ufield2d_lib ufield2d_lib module~ufield2d_class ufield2d_class module~ufield2d_class->module~ufield2d_lib module~fpois2d_class fpois2d_class module~fpois2d_class->module~ufield2d_class module~fft2d_class fft2d_class module~fft2d_class->module~ufield2d_class module~field2d_class field2d_class module~field2d_class->module~ufield2d_class module~field2d_class->module~fpois2d_class module~field2d_class->module~fft2d_class module~ufield3d_class ufield3d_class module~field2d_class->module~ufield3d_class module~field3d_class field3d_class module~field2d_class->module~field3d_class module~ufield3d_class->module~ufield2d_class module~part2d_class part2d_class module~part2d_class->module~ufield2d_class module~fdist2d_class fdist2d_class module~part2d_class->module~fdist2d_class module~fdist2d_class->module~ufield2d_class module~part3d_class part3d_class module~part3d_class->module~ufield3d_class module~fdist3d_class fdist3d_class module~part3d_class->module~fdist3d_class module~field3d_class->module~ufield3d_class module~simulation_class simulation_class module~simulation_class->module~field2d_class module~simulation_class->module~fdist2d_class module~simulation_class->module~field3d_class module~simulation_class->module~fdist3d_class module~beam3d_class beam3d_class module~simulation_class->module~beam3d_class module~species2d_class species2d_class module~simulation_class->module~species2d_class module~fdist3d_class->module~ufield3d_class module~beam3d_class->module~field2d_class module~beam3d_class->module~part3d_class module~beam3d_class->module~field3d_class module~beam3d_class->module~fdist3d_class module~species2d_class->module~field2d_class module~species2d_class->module~part2d_class module~species2d_class->module~fdist2d_class module~species2d_class->module~field3d_class program~quickpic quickpic program~quickpic->module~simulation_class var panmoduleufield2d_libUsedByGraph = svgPanZoom('#moduleufield2d_libUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines PPNCGUARD2L PPNACGUARD2L Subroutines public subroutine PPNCGUARD2L (f, nyp, kstrt, nvp, nxv, nypmx, lgrp, mreal) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(nxv,nypmx) :: f integer, intent(in) :: nyp integer, intent(in) :: kstrt integer, intent(in) :: nvp integer, intent(in) :: nxv integer, intent(in) :: nypmx integer, intent(in) :: lgrp integer, intent(in) :: mreal public subroutine PPNACGUARD2L (f, scr, nyp, nx, ndim, kstrt, nvp, nxv, nypmx, lgrp, mreal) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(ndim,nxv,nypmx) :: f real, intent(inout), dimension(ndim,nxv) :: scr integer, intent(in) :: nyp integer, intent(in) :: nx integer, intent(in) :: ndim integer, intent(in) :: kstrt integer, intent(in) :: nvp integer, intent(in) :: nxv integer, intent(in) :: nypmx integer, intent(in) :: lgrp integer, intent(in) :: mreal","tags":"","loc":"module/ufield2d_lib.html"},{"title":"ufield3d_lib – QuickPIC","text":"Used by module~~ufield3d_lib~~UsedByGraph module~ufield3d_lib ufield3d_lib module~ufield3d_class ufield3d_class module~ufield3d_class->module~ufield3d_lib module~fdist3d_class fdist3d_class module~fdist3d_class->module~ufield3d_class module~part3d_class part3d_class module~part3d_class->module~ufield3d_class module~part3d_class->module~fdist3d_class module~field3d_class field3d_class module~field3d_class->module~ufield3d_class module~field2d_class field2d_class module~field2d_class->module~ufield3d_class module~field2d_class->module~field3d_class module~species2d_class species2d_class module~species2d_class->module~field3d_class module~species2d_class->module~field2d_class module~beam3d_class beam3d_class module~beam3d_class->module~fdist3d_class module~beam3d_class->module~part3d_class module~beam3d_class->module~field3d_class module~beam3d_class->module~field2d_class module~simulation_class simulation_class module~simulation_class->module~fdist3d_class module~simulation_class->module~field3d_class module~simulation_class->module~field2d_class module~simulation_class->module~species2d_class module~simulation_class->module~beam3d_class program~quickpic quickpic program~quickpic->module~simulation_class var panmoduleufield3d_libUsedByGraph = svgPanZoom('#moduleufield3d_libUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces PCGUARD32L PACGUARD32L PAGUARD32L Interfaces interface public subroutine PCGUARD32L(f, scs, kstrt, nvpy, nvpz, nxv, nypmx, nzpmx, mblok, nblok, kyp, kzp, ngds, tag1, tag2, rid, sid, ierr) Arguments Type Intent Optional Attributes Name real, intent(inout) :: f real, intent(inout) :: scs integer, intent(in) :: kstrt integer, intent(in) :: nvpy integer, intent(in) :: nvpz integer, intent(in) :: nxv integer, intent(in) :: nypmx integer, intent(in) :: nzpmx integer, intent(in) :: mblok integer, intent(in) :: nblok integer, intent(in) :: kyp integer, intent(in) :: kzp integer, intent(in) :: ngds integer, intent(in) :: tag1 integer, intent(in) :: tag2 integer, intent(inout) :: rid integer, intent(inout) :: sid integer, intent(inout) :: ierr interface public subroutine PACGUARD32L(f, scs, kstrt, nvpy, nvpz, nx, nxv, nypmx, nzpmx, mblok, nblok, kyp, kzp, ngds) Arguments Type Intent Optional Attributes Name real, intent(inout) :: f real, intent(inout) :: scs integer, intent(in) :: kstrt integer, intent(in) :: nvpy integer, intent(in) :: nvpz integer, intent(in) :: nx integer, intent(in) :: nxv integer, intent(in) :: nypmx integer, intent(in) :: nzpmx integer, intent(in) :: mblok integer, intent(in) :: nblok integer, intent(in) :: kyp integer, intent(in) :: kzp integer, intent(in) :: ngds interface public subroutine PAGUARD32L(f, scs, scr, kstrt, nvpy, nvpz, nx, nxv, nypmx, nzpmx, mblok, nblok, kyp, kzp, ngds, tag1, tag2, id, ierr) Arguments Type Intent Optional Attributes Name real, intent(inout) :: f real, intent(inout) :: scs real, intent(inout) :: scr integer, intent(in) :: kstrt integer, intent(in) :: nvpy integer, intent(in) :: nvpz integer, intent(in) :: nx integer, intent(in) :: nxv integer, intent(in) :: nypmx integer, intent(in) :: nzpmx integer, intent(in) :: mblok integer, intent(in) :: nblok integer, intent(in) :: kyp integer, intent(in) :: kzp integer, intent(in) :: ngds integer, intent(in) :: tag1 integer, intent(in) :: tag2 integer, intent(inout) :: id integer, intent(inout) :: ierr","tags":"","loc":"module/ufield3d_lib.html"},{"title":"fdist2d_class – QuickPIC","text":"Uses perrors_class parallel_pipe_class spect2d_class ufield2d_class input_class module~~fdist2d_class~~UsesGraph module~fdist2d_class fdist2d_class module~spect2d_class spect2d_class module~fdist2d_class->module~spect2d_class module~input_class input_class module~fdist2d_class->module~input_class module~perrors_class perrors_class module~fdist2d_class->module~perrors_class module~parallel_pipe_class parallel_pipe_class module~fdist2d_class->module~parallel_pipe_class module~ufield2d_class ufield2d_class module~fdist2d_class->module~ufield2d_class module~spect2d_class->module~perrors_class module~spect2d_class->module~parallel_pipe_class module~input_class->module~perrors_class module~input_class->module~parallel_pipe_class module~spect3d_class spect3d_class module~input_class->module~spect3d_class module~parallel_class parallel_class module~input_class->module~parallel_class json_module json_module module~input_class->json_module mpi mpi module~input_class->mpi module~perrors_class->module~parallel_class module~perrors_class->mpi module~parallel_pipe_class->module~parallel_class module~parallel_pipe_class->mpi module~ufield2d_class->module~spect2d_class module~ufield2d_class->module~perrors_class module~ufield2d_class->module~parallel_pipe_class module~ufield2d_lib ufield2d_lib module~ufield2d_class->module~ufield2d_lib module~hdf5io_class hdf5io_class module~ufield2d_class->module~hdf5io_class module~ufield2d_class->mpi module~spect3d_class->module~spect2d_class module~spect3d_class->module~perrors_class module~spect3d_class->module~parallel_pipe_class module~parallel_class->mpi omp_lib omp_lib module~parallel_class->omp_lib module~ufield2d_lib->mpi module~hdf5io_class->module~perrors_class module~hdf5io_class->module~parallel_pipe_class module~hdf5io_class->mpi HDF5 HDF5 module~hdf5io_class->HDF5 var panmodulefdist2d_classUsesGraph = svgPanZoom('#modulefdist2d_classUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~fdist2d_class~~UsedByGraph module~fdist2d_class fdist2d_class module~part2d_class part2d_class module~part2d_class->module~fdist2d_class module~species2d_class species2d_class module~species2d_class->module~fdist2d_class module~species2d_class->module~part2d_class module~simulation_class simulation_class module~simulation_class->module~fdist2d_class module~simulation_class->module~species2d_class program~quickpic quickpic program~quickpic->module~simulation_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables class erstr Abstract Interfaces ab_dist2d ab_init_fdist2d Derived Types fdist2d fdist2d_000 Functions getnpf getnpmax Subroutines end_fdist2d init_fdist2d_000 dist2d_000 Variables Type Visibility Attributes Name Initial character(len=10), private, save :: class = 'fdist2d:' character(len=128), private, save :: erstr Abstract Interfaces abstract interface private subroutine ab_dist2d(this, part2d, npp, fd, s) Arguments Type Intent Optional Attributes Name class( fdist2d ), intent(inout) :: this real, intent(inout), dimension(:,:), pointer :: part2d integer, intent(inout) :: npp class( ufield2d ), intent(in), pointer :: fd real, intent(in) :: s abstract interface private subroutine ab_init_fdist2d(this, input, i) Arguments Type Intent Optional Attributes Name class( fdist2d ), intent(inout) :: this type( input_json ), intent(inout), pointer :: input integer, intent(in) :: i Derived Types type, public, abstract :: fdist2d Components Type Visibility Attributes Name Initial class( spect2d ), public, pointer :: sp => null() class( perrors ), public, pointer :: err => null() class( parallel_pipe ), public, pointer :: p => null() integer, private :: npf integer, private :: npmax Type-Bound Procedures generic, public :: new => init_fdist2d generic, public :: del => end_fdist2d generic, public :: dist => dist2d procedure(ab_init_fdist2d), private :: init_fdist2d procedure, private :: end_fdist2d procedure(ab_dist2d), private :: dist2d procedure, public :: getnpmax procedure, public :: getnpf type, public, extends( fdist2d ) :: fdist2d_000 Components Type Visibility Attributes Name Initial class( spect2d ), public, pointer :: sp => null() class( perrors ), public, pointer :: err => null() class( parallel_pipe ), public, pointer :: p => null() integer, private :: xppc integer, private :: yppc real, private :: qm real, private :: den character(len=:), private, allocatable :: long_prof real, private, dimension(:), allocatable :: s real, private, dimension(:), allocatable :: fs Type-Bound Procedures generic, public :: new => init_fdist2d generic, public :: del => end_fdist2d generic, public :: dist => dist2d procedure, public :: getnpmax procedure, public :: getnpf procedure, private :: init_fdist2d => init_fdist2d_000 procedure, private :: dist2d => dist2d_000 Functions private function getnpf (this) Arguments Type Intent Optional Attributes Name class( fdist2d ), intent(in) :: this Return Value integer private function getnpmax (this) Arguments Type Intent Optional Attributes Name class( fdist2d ), intent(in) :: this Return Value integer Subroutines private subroutine end_fdist2d (this) Arguments Type Intent Optional Attributes Name class( fdist2d ), intent(inout) :: this private subroutine init_fdist2d_000 (this, input, i) Arguments Type Intent Optional Attributes Name class( fdist2d_000 ), intent(inout) :: this type( input_json ), intent(inout), pointer :: input integer, intent(in) :: i private subroutine dist2d_000 (this, part2d, npp, fd, s) Arguments Type Intent Optional Attributes Name class( fdist2d_000 ), intent(inout) :: this real, intent(inout), dimension(:,:), pointer :: part2d integer, intent(inout) :: npp class( ufield2d ), intent(in), pointer :: fd real, intent(in) :: s","tags":"","loc":"module/fdist2d_class.html"},{"title":"hdf5io_class – QuickPIC","text":"Uses perrors_class parallel_pipe_class HDF5 mpi module~~hdf5io_class~~UsesGraph module~hdf5io_class hdf5io_class module~perrors_class perrors_class module~hdf5io_class->module~perrors_class mpi mpi module~hdf5io_class->mpi module~parallel_pipe_class parallel_pipe_class module~hdf5io_class->module~parallel_pipe_class HDF5 HDF5 module~hdf5io_class->HDF5 module~perrors_class->mpi module~parallel_class parallel_class module~perrors_class->module~parallel_class module~parallel_pipe_class->mpi module~parallel_pipe_class->module~parallel_class module~parallel_class->mpi omp_lib omp_lib module~parallel_class->omp_lib Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~hdf5io_class~~UsedByGraph module~hdf5io_class hdf5io_class module~part3d_class part3d_class module~part3d_class->module~hdf5io_class module~ufield3d_class ufield3d_class module~part3d_class->module~ufield3d_class module~fdist3d_class fdist3d_class module~part3d_class->module~fdist3d_class module~field3d_class field3d_class module~field3d_class->module~hdf5io_class module~field3d_class->module~ufield3d_class module~field2d_class field2d_class module~field2d_class->module~hdf5io_class module~field2d_class->module~field3d_class module~field2d_class->module~ufield3d_class module~ufield2d_class ufield2d_class module~field2d_class->module~ufield2d_class module~fpois2d_class fpois2d_class module~field2d_class->module~fpois2d_class module~fft2d_class fft2d_class module~field2d_class->module~fft2d_class module~simulation_class simulation_class module~simulation_class->module~hdf5io_class module~simulation_class->module~field3d_class module~simulation_class->module~field2d_class module~beam3d_class beam3d_class module~simulation_class->module~beam3d_class module~species2d_class species2d_class module~simulation_class->module~species2d_class module~simulation_class->module~fdist3d_class module~fdist2d_class fdist2d_class module~simulation_class->module~fdist2d_class module~ufield3d_class->module~hdf5io_class module~ufield3d_class->module~ufield2d_class module~part2d_class part2d_class module~part2d_class->module~hdf5io_class module~part2d_class->module~ufield2d_class module~part2d_class->module~fdist2d_class module~beam3d_class->module~hdf5io_class module~beam3d_class->module~part3d_class module~beam3d_class->module~field3d_class module~beam3d_class->module~field2d_class module~beam3d_class->module~fdist3d_class module~ufield2d_class->module~hdf5io_class module~species2d_class->module~hdf5io_class module~species2d_class->module~field3d_class module~species2d_class->module~field2d_class module~species2d_class->module~part2d_class module~species2d_class->module~fdist2d_class module~fpois2d_class->module~ufield2d_class module~fft2d_class->module~ufield2d_class module~fdist3d_class->module~ufield3d_class program~quickpic quickpic program~quickpic->module~simulation_class module~fdist2d_class->module~ufield2d_class var panmodulehdf5io_classUsedByGraph = svgPanZoom('#modulehdf5io_classUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces add_h5_atribute pwfield pwfield_pipe wfield_pipe pwpart_pipe pwpart Derived Types hdf5file Functions detect_precision Subroutines init_hdf5file add_h5_atribute_str add_h5_atribute_str_v1 add_h5_atribute_single add_h5_atribute_v1_single add_h5_atribute_int add_h5_atribute_v1_int wrattr_file wrattr_dataset pwfield_3d pwfield_2d pwfield_3d_pipe pwfield_2d_pipe wfield_2d_pipe pwpart_2d pwpart_3d_pipe wpart rpart Interfaces private interface add_h5_atribute private subroutine add_h5_atribute_str (objID, name, attribute) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: objID character(len=*), intent(in) :: name character(len=*), intent(in) :: attribute private subroutine add_h5_atribute_str_v1 (objID, name, attribute) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: objID character(len=*), intent(in) :: name character(len=*), intent(in), dimension(:) :: attribute private subroutine add_h5_atribute_single (objID, name, attribute) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: objID character(len=*), intent(in) :: name real, intent(in) :: attribute private subroutine add_h5_atribute_v1_single (objID, name, attribute) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: objID character(len=*), intent(in) :: name real, intent(in), dimension(:) :: attribute private subroutine add_h5_atribute_int (objID, name, attribute) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: objID character(len=*), intent(in) :: name integer, intent(in) :: attribute private subroutine add_h5_atribute_v1_int (objID, name, attribute) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: objID character(len=*), intent(in) :: name integer, intent(in), dimension(:) :: attribute public interface pwfield private subroutine pwfield_3d (pp, perr, file, fd, gs, ls, noff, ierr) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( hdf5file ), intent(in) :: file real, intent(in), dimension(:,:,:) :: fd integer, intent(in), dimension(3) :: gs integer, intent(in), dimension(3) :: ls integer, intent(in), dimension(2) :: noff integer, intent(inout) :: ierr private subroutine pwfield_2d (pp, perr, file, fd, gs, ls, noff, ierr) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( hdf5file ), intent(in) :: file real, intent(in), dimension(:,:) :: fd integer, intent(in), dimension(2) :: gs integer, intent(in), dimension(2) :: ls integer, intent(in) :: noff integer, intent(inout) :: ierr public interface pwfield_pipe private subroutine pwfield_3d_pipe (pp, perr, file, fd, gs, ls, noff, rtag, stag, id, ierr) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( hdf5file ), intent(in) :: file real, intent(in), dimension(:,:,:) :: fd integer, intent(in), dimension(3) :: gs integer, intent(in), dimension(3) :: ls integer, intent(in), dimension(2) :: noff integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id integer, intent(inout) :: ierr private subroutine pwfield_2d_pipe (pp, perr, file, fd, gs, ls, noff, rtag, stag, id, ierr) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( hdf5file ), intent(in) :: file real, intent(in), dimension(:,:) :: fd integer, intent(in), dimension(2) :: gs integer, intent(in), dimension(2) :: ls integer, intent(in), dimension(2) :: noff integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id integer, intent(inout) :: ierr public interface wfield_pipe private subroutine wfield_2d_pipe (pp, perr, file, fd, gs, ls, noff, rtag, stag, id, ierr) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( hdf5file ), intent(in) :: file real, intent(in), dimension(:,:) :: fd integer, intent(in), dimension(2) :: gs integer, intent(in), dimension(2) :: ls integer, intent(in), dimension(2) :: noff integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id integer, intent(inout) :: ierr public interface pwpart_pipe private subroutine pwpart_3d_pipe (pp, perr, file, part, npp, dspl, delta, rtag, stag, id, ierr) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( hdf5file ), intent(in) :: file real, intent(in), dimension(:,:) :: part integer, intent(in) :: npp integer, intent(in) :: dspl real, intent(in), dimension(3) :: delta integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id integer, intent(inout) :: ierr public interface pwpart private subroutine pwpart_2d (pp, perr, file, part, npp, dspl, delta, ierr) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( hdf5file ), intent(in) :: file real, intent(in), dimension(:,:) :: part integer, intent(in) :: npp integer, intent(in) :: dspl real, intent(in), dimension(2) :: delta integer, intent(inout) :: ierr Derived Types type, public :: hdf5file Components Type Visibility Attributes Name Initial character(len=100), private :: filename = 'file.h5' character(len=100), private :: timeunits = 'a.u.' character(len=100), private :: dataname = 'Data' character(len=100), private :: units = 'a.u.' character(len=100), private :: label = 'Data' character(len=100), private :: ty = 'grid' integer, private :: n = 1 integer, private :: rank = 2 real, private :: t = 1.0 real, private :: dt = 1.0 character(len=100), private, dimension(3) :: axisname = (/'x1', 'x2', 'x3'/) character(len=100), private, dimension(3) :: axislabel = (/'x1', 'x2', 'x3'/) character(len=100), private, dimension(3) :: axisunits = (/'a.u.', 'a.u.', 'a.u.'/) real, private, dimension(3) :: axismax = (/1.0, 1.0, 1.0/) real, private, dimension(3) :: axismin = (/0.0, 0.0, 0.0/) Type-Bound Procedures generic, public :: new => init_hdf5file procedure, private :: init_hdf5file Functions private function detect_precision () Arguments None Return Value integer(kind=hid_t) Subroutines private subroutine init_hdf5file (this, filename, timeunits, ty, n, t, dt, axisname, axislabel, axisunits, axismax, axismin, dataname, units, label, rank) Arguments Type Intent Optional Attributes Name class( hdf5file ), intent(inout) :: this character(len=*), intent(in), optional :: filename character(len=*), intent(in), optional :: timeunits character(len=*), intent(in), optional :: ty integer, intent(in), optional :: n real, intent(in), optional :: t real, intent(in), optional :: dt character(len=*), intent(in), optional dimension(3) :: axisname character(len=*), intent(in), optional dimension(3) :: axislabel character(len=*), intent(in), optional dimension(3) :: axisunits real, intent(in), optional dimension(3) :: axismax real, intent(in), optional dimension(3) :: axismin character(len=*), intent(in), optional :: dataname character(len=*), intent(in), optional :: units character(len=*), intent(in), optional :: label integer, intent(in), optional :: rank private subroutine add_h5_atribute_str (objID, name, attribute) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: objID character(len=*), intent(in) :: name character(len=*), intent(in) :: attribute private subroutine add_h5_atribute_str_v1 (objID, name, attribute) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: objID character(len=*), intent(in) :: name character(len=*), intent(in), dimension(:) :: attribute private subroutine add_h5_atribute_single (objID, name, attribute) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: objID character(len=*), intent(in) :: name real, intent(in) :: attribute private subroutine add_h5_atribute_v1_single (objID, name, attribute) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: objID character(len=*), intent(in) :: name real, intent(in), dimension(:) :: attribute private subroutine add_h5_atribute_int (objID, name, attribute) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: objID character(len=*), intent(in) :: name integer, intent(in) :: attribute private subroutine add_h5_atribute_v1_int (objID, name, attribute) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: objID character(len=*), intent(in) :: name integer, intent(in), dimension(:) :: attribute private subroutine wrattr_file (this, file_id, xferID) Arguments Type Intent Optional Attributes Name class( hdf5file ), intent(in) :: this integer(kind=hid_t), intent(in) :: file_id integer(kind=hid_t) :: xferID private subroutine wrattr_dataset (this, dset_id, unit, name) Arguments Type Intent Optional Attributes Name class( hdf5file ), intent(in) :: this integer(kind=hid_t), intent(in) :: dset_id character(len=*), intent(in), optional :: unit character(len=*), intent(in), optional :: name private subroutine pwfield_3d (pp, perr, file, fd, gs, ls, noff, ierr) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( hdf5file ), intent(in) :: file real, intent(in), dimension(:,:,:) :: fd integer, intent(in), dimension(3) :: gs integer, intent(in), dimension(3) :: ls integer, intent(in), dimension(2) :: noff integer, intent(inout) :: ierr private subroutine pwfield_2d (pp, perr, file, fd, gs, ls, noff, ierr) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( hdf5file ), intent(in) :: file real, intent(in), dimension(:,:) :: fd integer, intent(in), dimension(2) :: gs integer, intent(in), dimension(2) :: ls integer, intent(in) :: noff integer, intent(inout) :: ierr private subroutine pwfield_3d_pipe (pp, perr, file, fd, gs, ls, noff, rtag, stag, id, ierr) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( hdf5file ), intent(in) :: file real, intent(in), dimension(:,:,:) :: fd integer, intent(in), dimension(3) :: gs integer, intent(in), dimension(3) :: ls integer, intent(in), dimension(2) :: noff integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id integer, intent(inout) :: ierr private subroutine pwfield_2d_pipe (pp, perr, file, fd, gs, ls, noff, rtag, stag, id, ierr) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( hdf5file ), intent(in) :: file real, intent(in), dimension(:,:) :: fd integer, intent(in), dimension(2) :: gs integer, intent(in), dimension(2) :: ls integer, intent(in), dimension(2) :: noff integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id integer, intent(inout) :: ierr private subroutine wfield_2d_pipe (pp, perr, file, fd, gs, ls, noff, rtag, stag, id, ierr) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( hdf5file ), intent(in) :: file real, intent(in), dimension(:,:) :: fd integer, intent(in), dimension(2) :: gs integer, intent(in), dimension(2) :: ls integer, intent(in), dimension(2) :: noff integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id integer, intent(inout) :: ierr private subroutine pwpart_2d (pp, perr, file, part, npp, dspl, delta, ierr) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( hdf5file ), intent(in) :: file real, intent(in), dimension(:,:) :: part integer, intent(in) :: npp integer, intent(in) :: dspl real, intent(in), dimension(2) :: delta integer, intent(inout) :: ierr private subroutine pwpart_3d_pipe (pp, perr, file, part, npp, dspl, delta, rtag, stag, id, ierr) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( hdf5file ), intent(in) :: file real, intent(in), dimension(:,:) :: part integer, intent(in) :: npp integer, intent(in) :: dspl real, intent(in), dimension(3) :: delta integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id integer, intent(inout) :: ierr public subroutine wpart (pp, perr, file, part, npp, dspl, ierr) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( hdf5file ), intent(in) :: file real, intent(in), dimension(:,:) :: part integer, intent(in) :: npp integer, intent(in) :: dspl integer, intent(inout) :: ierr public subroutine rpart (pp, perr, file, part, npp, ierr) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( hdf5file ), intent(in) :: file real, intent(inout), dimension(:,:) :: part integer, intent(out) :: npp integer, intent(inout) :: ierr","tags":"","loc":"module/hdf5io_class.html"},{"title":"fpois2d_lib – QuickPIC","text":"Used by module~~fpois2d_lib~~UsedByGraph module~fpois2d_lib fpois2d_lib module~fpois2d_class fpois2d_class module~fpois2d_class->module~fpois2d_lib module~field2d_class field2d_class module~field2d_class->module~fpois2d_class module~species2d_class species2d_class module~species2d_class->module~field2d_class module~beam3d_class beam3d_class module~beam3d_class->module~field2d_class module~simulation_class simulation_class module~simulation_class->module~field2d_class module~simulation_class->module~species2d_class module~simulation_class->module~beam3d_class program~quickpic quickpic program~quickpic->module~simulation_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces PPOISDX2 PPOISD2 PPOISD22 PPOISD23 PBPOISD22 PBPOISD23 PBPOISD22N_QP MPPOISD22 MPPOISD23 MPPOTPD2 MPPSMOOTHD2 MPPBBPOISD23 Interfaces interface public subroutine PPOISDX2(q, fx, fy, isign, ffd, ax, ay, affp, we, nx, ny, kstrt, ny2d, kxp2, j2blok, nyd) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(ny2d,kxp2,j2blok) :: q complex, intent(inout), dimension(ny2d,kxp2,j2blok) :: fx complex, intent(inout), dimension(ny2d,kxp2,j2blok) :: fy integer, intent(in) :: isign complex, intent(inout), dimension(nyd,kxp2,j2blok) :: ffd real, intent(in) :: ax real, intent(in) :: ay real, intent(in) :: affp real, intent(in) :: we integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kstrt integer, intent(in) :: ny2d integer, intent(in) :: kxp2 integer, intent(in) :: j2blok integer, intent(in) :: nyd interface public subroutine PPOISD2(q, fx, fy, isign, ffd, ax, ay, affp, we, nx, ny, kstrt, nyv, kxp2, j2blok, nyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(nyv,kxp2+1,j2blok) :: q real, intent(inout), dimension(nyv,kxp2+1,j2blok) :: fx real, intent(inout), dimension(nyv,kxp2+1,j2blok) :: fy integer, intent(in) :: isign complex, intent(in), dimension(nyd,kxp2,j2blok) :: ffd real, intent(in) :: ax real, intent(in) :: ay real, intent(in) :: affp real, intent(in) :: we integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kstrt integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: j2blok integer, intent(in) :: nyd interface public subroutine PPOISD22(q, fxy, isign, ffd, ax, ay, affp, we, nx, ny, kstrt, nyv, kxp2, j2blok, nyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(nyv,kxp2+1,j2blok) :: q real, intent(inout), dimension(2,nyv,kxp2+1,j2blok) :: fxy integer, intent(in) :: isign complex, intent(in), dimension(nyd,kxp2,j2blok) :: ffd real, intent(in) :: ax real, intent(in) :: ay real, intent(in) :: affp real, intent(in) :: we integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kstrt integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: j2blok integer, intent(in) :: nyd interface public subroutine PPOISD23(q, fxy, isign, ffd, ax, ay, affp, we, nx, ny, kstrt, nyv, kxp2, j2blok, nyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(nyv,kxp2+1,j2blok) :: q real, intent(inout), dimension(3,nyv,kxp2+1,j2blok) :: fxy integer, intent(in) :: isign complex, intent(in), dimension(nyd,kxp2,j2blok) :: ffd real, intent(in) :: ax real, intent(in) :: ay real, intent(in) :: affp real, intent(in) :: we integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kstrt integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: j2blok integer, intent(in) :: nyd interface public subroutine PBPOISD22(cu, bxy, bz, isign, ffd, ax, ay, affp, ci, wm, nx, ny, kstrt, nyv, kxp2, j2blok, nyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(2,nyv,kxp2+1,j2blok) :: cu real, intent(inout), dimension(2,nyv,kxp2+1,j2blok) :: bxy real, intent(inout), dimension(nyv,kxp2+1,j2blok) :: bz integer, intent(in) :: isign complex, intent(in), dimension(nyd,kxp2,j2blok) :: ffd real, intent(in) :: ax real, intent(in) :: ay real, intent(in) :: affp real, intent(in) :: ci real, intent(in) :: wm integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kstrt integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: j2blok integer, intent(in) :: nyd interface public subroutine PBPOISD23(cu, bxy, isign, ffd, ax, ay, affp, ci, wm, nx, ny, kstrt, nyv, kxp2, j2blok, nyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(3,nyv,kxp2+1,j2blok) :: cu real, intent(inout), dimension(3,nyv,kxp2+1,j2blok) :: bxy integer, intent(in) :: isign complex, intent(in), dimension(nyd,kxp2,j2blok) :: ffd real, intent(in) :: ax real, intent(in) :: ay real, intent(in) :: affp real, intent(in) :: ci real, intent(in) :: wm integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kstrt integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: j2blok integer, intent(in) :: nyd interface public subroutine PBPOISD22N_QP(cu, dcu, amu, bxy, bz, isign, ffd, ax, ay, affp, ci, wm, nx, ny, kstrt, nyv, kxp2, j2blok, nyd, aa, dex) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(3,nyv,kxp2+1,j2blok) :: cu real, intent(inout), dimension(2,nyv,kxp2+1,j2blok) :: dcu real, intent(inout), dimension(3,nyv,kxp2+1,j2blok) :: amu real, intent(inout), dimension(2,nyv,kxp2+1,j2blok) :: bxy real, intent(inout), dimension(nyv,kxp2+1,j2blok) :: bz integer, intent(in) :: isign complex, intent(in), dimension(nyd,kxp2,j2blok) :: ffd real, intent(in) :: ax real, intent(in) :: ay real, intent(in) :: affp real, intent(in) :: ci real, intent(in) :: wm integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kstrt integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: j2blok integer, intent(in) :: nyd real, intent(in) :: aa real, intent(in) :: dex interface public subroutine MPPOISD22(q, fxy, isign, ffd, ax, ay, affp, we, nx, ny, kstrt, nyv, kxp2, nyd) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(nyv,kxp2+1) :: q real, intent(inout), dimension(2,nyv,kxp2+1) :: fxy integer, intent(in) :: isign complex, intent(inout), dimension(nyd,kxp2) :: ffd real, intent(in) :: ax real, intent(in) :: ay real, intent(in) :: affp real, intent(inout) :: we integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kstrt integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: nyd interface public subroutine MPPOISD23(q, fxy, isign, ffd, ax, ay, affp, we, nx, ny, kstrt, nyv, kxp2, nyd) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(nyv,kxp2+1) :: q real, intent(inout), dimension(3,nyv,kxp2+1) :: fxy integer, intent(in) :: isign complex, intent(inout), dimension(nyd,kxp2) :: ffd real, intent(in) :: ax real, intent(in) :: ay real, intent(in) :: affp real, intent(inout) :: we integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kstrt integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: nyd interface public subroutine MPPOTPD2(q, pot, ffd, we, nx, ny, kstrt, nyv, kxp2, nyd) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(nyv,kxp2+1) :: q real, intent(inout), dimension(nyv,kxp2+1) :: pot complex, intent(in), dimension(nyd,kxp2) :: ffd real, intent(inout) :: we integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kstrt integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: nyd interface public subroutine MPPSMOOTHD2(q, qs, ffd, nx, ny, kstrt, nyv, kxp2, nyd) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(nyv,kxp2+1) :: q real, intent(inout), dimension(nyv,kxp2+1) :: qs complex, intent(in), dimension(nyd,kxp2) :: ffd integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kstrt integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: nyd interface public subroutine MPPBBPOISD23(cu, bxy, ffd, ci, wm, nx, ny, kstrt, nyv, kxp2, nyd) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(3,nyv,kxp2+1) :: cu real, intent(inout), dimension(3,nyv,kxp2+1) :: bxy complex, intent(in), dimension(nyd,kxp2) :: ffd real, intent(in) :: ci real, intent(inout) :: wm integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kstrt integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: nyd","tags":"","loc":"module/fpois2d_lib.html"},{"title":"beam3d_class – QuickPIC","text":"Uses perrors_class parallel_pipe_class spect3d_class fdist3d_class field3d_class field2d_class part3d_class hdf5io_class mpi module~~beam3d_class~~UsesGraph module~beam3d_class beam3d_class module~part3d_class part3d_class module~beam3d_class->module~part3d_class module~spect3d_class spect3d_class module~beam3d_class->module~spect3d_class module~field3d_class field3d_class module~beam3d_class->module~field3d_class module~field2d_class field2d_class module~beam3d_class->module~field2d_class module~perrors_class perrors_class module~beam3d_class->module~perrors_class module~fdist3d_class fdist3d_class module~beam3d_class->module~fdist3d_class module~parallel_pipe_class parallel_pipe_class module~beam3d_class->module~parallel_pipe_class module~hdf5io_class hdf5io_class module~beam3d_class->module~hdf5io_class mpi mpi module~beam3d_class->mpi module~part3d_class->module~spect3d_class module~part3d_class->module~perrors_class module~part3d_class->module~fdist3d_class module~part3d_class->module~parallel_pipe_class module~part3d_class->module~hdf5io_class module~part3d_class->mpi module~part3d_lib part3d_lib module~part3d_class->module~part3d_lib module~ufield3d_class ufield3d_class module~part3d_class->module~ufield3d_class module~spect3d_class->module~perrors_class module~spect3d_class->module~parallel_pipe_class module~spect2d_class spect2d_class module~spect3d_class->module~spect2d_class module~field3d_class->module~spect3d_class module~field3d_class->module~perrors_class module~field3d_class->module~parallel_pipe_class module~field3d_class->module~hdf5io_class module~field3d_class->module~ufield3d_class module~field2d_class->module~field3d_class module~field2d_class->module~perrors_class module~field2d_class->module~parallel_pipe_class module~field2d_class->module~hdf5io_class module~fpois2d_class fpois2d_class module~field2d_class->module~fpois2d_class module~field2d_class->module~spect2d_class module~fft2d_class fft2d_class module~field2d_class->module~fft2d_class module~field2d_class->module~ufield3d_class module~ufield2d_class ufield2d_class module~field2d_class->module~ufield2d_class module~perrors_class->mpi module~parallel_class parallel_class module~perrors_class->module~parallel_class module~fdist3d_class->module~spect3d_class module~fdist3d_class->module~perrors_class module~fdist3d_class->module~parallel_pipe_class module~fdist3d_class->module~part3d_lib module~input_class input_class module~fdist3d_class->module~input_class module~fdist3d_class->module~ufield3d_class module~parallel_pipe_class->mpi module~parallel_pipe_class->module~parallel_class module~hdf5io_class->module~perrors_class module~hdf5io_class->module~parallel_pipe_class module~hdf5io_class->mpi HDF5 HDF5 module~hdf5io_class->HDF5 module~fpois2d_class->module~perrors_class module~fpois2d_class->module~parallel_pipe_class module~fpois2d_class->module~spect2d_class module~fpois2d_class->module~ufield2d_class module~fpois2d_lib fpois2d_lib module~fpois2d_class->module~fpois2d_lib module~parallel_class->mpi omp_lib omp_lib module~parallel_class->omp_lib module~spect2d_class->module~perrors_class module~spect2d_class->module~parallel_pipe_class module~fft2d_class->module~perrors_class module~fft2d_class->module~parallel_pipe_class module~fft2d_class->module~spect2d_class module~fft2d_class->module~ufield2d_class module~fft2d_lib fft2d_lib module~fft2d_class->module~fft2d_lib module~input_class->module~spect3d_class module~input_class->module~perrors_class module~input_class->module~parallel_pipe_class module~input_class->mpi module~input_class->module~parallel_class json_module json_module module~input_class->json_module module~ufield3d_class->module~spect3d_class module~ufield3d_class->module~perrors_class module~ufield3d_class->module~parallel_pipe_class module~ufield3d_class->module~hdf5io_class module~ufield3d_class->mpi module~ufield3d_class->module~ufield2d_class module~ufield3d_lib ufield3d_lib module~ufield3d_class->module~ufield3d_lib module~ufield2d_class->module~perrors_class module~ufield2d_class->module~parallel_pipe_class module~ufield2d_class->module~hdf5io_class module~ufield2d_class->mpi module~ufield2d_class->module~spect2d_class module~ufield2d_lib ufield2d_lib module~ufield2d_class->module~ufield2d_lib module~ufield2d_lib->mpi module~fft2d_lib->mpi var panmodulebeam3d_classUsesGraph = svgPanZoom('#modulebeam3d_classUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~beam3d_class~~UsedByGraph module~beam3d_class beam3d_class module~simulation_class simulation_class module~simulation_class->module~beam3d_class program~quickpic quickpic program~quickpic->module~simulation_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables class erstr Derived Types beam3d Subroutines init_beam3d end_beam3d qdeposit_beam3d qdpcopy_beam3d push_beam3d pmove_beam3d writehdf5_beam3d writerst_beam3d writeq_beam3d writeqslice_beam3d readrst_beam3d Variables Type Visibility Attributes Name Initial character(len=10), private :: class = 'beam3d:' character(len=128), private :: erstr Derived Types type, public :: beam3d Components Type Visibility Attributes Name Initial class( spect3d ), public, pointer :: sp => null() class( perrors ), public, pointer :: err => null() class( parallel_pipe ), public, pointer :: p => null() class( part3d ), private, pointer :: pd class( field3d ), private, pointer :: q => null() class( fdist3d ), private, pointer :: pf => null() Type-Bound Procedures generic, public :: new => init_beam3d generic, public :: del => end_beam3d generic, public :: push => push_beam3d generic, public :: pmv => pmove_beam3d generic, public :: qdp => qdeposit_beam3d, qdpcopy_beam3d generic, public :: wr => writehdf5_beam3d generic, public :: wrq => writeq_beam3d, writeqslice_beam3d generic, public :: wrst => writerst_beam3d generic, public :: rrst => readrst_beam3d procedure, private :: init_beam3d procedure, private :: end_beam3d procedure, private :: push_beam3d procedure, private :: pmove_beam3d procedure, private :: writehdf5_beam3d procedure, private :: qdeposit_beam3d procedure, private :: readrst_beam3d procedure, private :: writerst_beam3d procedure, private :: writeqslice_beam3d procedure, private :: writeq_beam3d procedure, private :: qdpcopy_beam3d Subroutines private subroutine init_beam3d (this, pp, perr, psp, pf, qbm, dt, ci, xdim) Arguments Type Intent Optional Attributes Name class( beam3d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( spect3d ), intent(in), pointer :: psp class( fdist3d ), intent(inout), target :: pf real, intent(in) :: qbm real, intent(in) :: dt real, intent(in) :: ci integer, intent(in) :: xdim private subroutine end_beam3d (this) Arguments Type Intent Optional Attributes Name class( beam3d ), intent(inout) :: this private subroutine qdeposit_beam3d (this, id1, id2, id3, tag1, tag2) Arguments Type Intent Optional Attributes Name class( beam3d ), intent(inout) :: this integer, intent(inout) :: id1 integer, intent(inout) :: id2 integer, intent(inout) :: id3 integer, intent(inout) :: tag1 integer, intent(inout) :: tag2 private subroutine qdpcopy_beam3d (this, q, slice) Arguments Type Intent Optional Attributes Name class( beam3d ), intent(inout) :: this class( field2d ), intent(inout) :: q integer, intent(in) :: slice private subroutine push_beam3d (this, ef, bf, dex, dez, rtag, stag, sid) Arguments Type Intent Optional Attributes Name class( beam3d ), intent(inout) :: this class( field3d ), intent(in) :: ef class( field3d ), intent(in) :: bf real, intent(in) :: dex real, intent(in) :: dez integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: sid private subroutine pmove_beam3d (this, fd, rtag, stag, sid) Arguments Type Intent Optional Attributes Name class( beam3d ), intent(inout) :: this class( field3d ), intent(in) :: fd integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: sid private subroutine writehdf5_beam3d (this, file, dspl, delta, rtag, stag, id) Arguments Type Intent Optional Attributes Name class( beam3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file integer, intent(in) :: dspl real, intent(in), dimension(3) :: delta integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id private subroutine writerst_beam3d (this, file) Arguments Type Intent Optional Attributes Name class( beam3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file private subroutine writeq_beam3d (this, file, rtag, stag, id) Arguments Type Intent Optional Attributes Name class( beam3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id private subroutine writeqslice_beam3d (this, file, slice, spos, rtag, stag, id) Arguments Type Intent Optional Attributes Name class( beam3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file integer, intent(in) :: slice integer, intent(in) :: spos integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id private subroutine readrst_beam3d (this, file) Arguments Type Intent Optional Attributes Name class( beam3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file","tags":"","loc":"module/beam3d_class.html"},{"title":"species2d_class – QuickPIC","text":"Uses perrors_class parallel_pipe_class spect2d_class spect3d_class fdist2d_class field2d_class field3d_class part2d_class hdf5io_class module~~species2d_class~~UsesGraph module~species2d_class species2d_class module~spect3d_class spect3d_class module~species2d_class->module~spect3d_class module~field3d_class field3d_class module~species2d_class->module~field3d_class module~spect2d_class spect2d_class module~species2d_class->module~spect2d_class module~field2d_class field2d_class module~species2d_class->module~field2d_class module~perrors_class perrors_class module~species2d_class->module~perrors_class module~parallel_pipe_class parallel_pipe_class module~species2d_class->module~parallel_pipe_class module~hdf5io_class hdf5io_class module~species2d_class->module~hdf5io_class module~part2d_class part2d_class module~species2d_class->module~part2d_class module~fdist2d_class fdist2d_class module~species2d_class->module~fdist2d_class module~spect3d_class->module~spect2d_class module~spect3d_class->module~perrors_class module~spect3d_class->module~parallel_pipe_class module~field3d_class->module~spect3d_class module~field3d_class->module~perrors_class module~field3d_class->module~parallel_pipe_class module~field3d_class->module~hdf5io_class module~ufield3d_class ufield3d_class module~field3d_class->module~ufield3d_class module~spect2d_class->module~perrors_class module~spect2d_class->module~parallel_pipe_class module~field2d_class->module~field3d_class module~field2d_class->module~spect2d_class module~field2d_class->module~perrors_class module~field2d_class->module~parallel_pipe_class module~field2d_class->module~hdf5io_class module~fpois2d_class fpois2d_class module~field2d_class->module~fpois2d_class module~fft2d_class fft2d_class module~field2d_class->module~fft2d_class module~field2d_class->module~ufield3d_class module~ufield2d_class ufield2d_class module~field2d_class->module~ufield2d_class module~parallel_class parallel_class module~perrors_class->module~parallel_class mpi mpi module~perrors_class->mpi module~parallel_pipe_class->module~parallel_class module~parallel_pipe_class->mpi module~hdf5io_class->module~perrors_class module~hdf5io_class->module~parallel_pipe_class HDF5 HDF5 module~hdf5io_class->HDF5 module~hdf5io_class->mpi module~part2d_class->module~spect2d_class module~part2d_class->module~perrors_class module~part2d_class->module~parallel_pipe_class module~part2d_class->module~hdf5io_class module~part2d_class->module~fdist2d_class module~part2d_lib part2d_lib module~part2d_class->module~part2d_lib module~part2d_class->module~ufield2d_class module~part2d_class->mpi module~fdist2d_class->module~spect2d_class module~fdist2d_class->module~perrors_class module~fdist2d_class->module~parallel_pipe_class module~input_class input_class module~fdist2d_class->module~input_class module~fdist2d_class->module~ufield2d_class module~fpois2d_class->module~spect2d_class module~fpois2d_class->module~perrors_class module~fpois2d_class->module~parallel_pipe_class module~fpois2d_class->module~ufield2d_class module~fpois2d_lib fpois2d_lib module~fpois2d_class->module~fpois2d_lib module~parallel_class->mpi omp_lib omp_lib module~parallel_class->omp_lib module~input_class->module~spect3d_class module~input_class->module~perrors_class module~input_class->module~parallel_pipe_class module~input_class->module~parallel_class module~input_class->mpi json_module json_module module~input_class->json_module module~fft2d_class->module~spect2d_class module~fft2d_class->module~perrors_class module~fft2d_class->module~parallel_pipe_class module~fft2d_class->module~ufield2d_class module~fft2d_lib fft2d_lib module~fft2d_class->module~fft2d_lib module~part2d_lib->mpi module~ufield3d_class->module~spect3d_class module~ufield3d_class->module~perrors_class module~ufield3d_class->module~parallel_pipe_class module~ufield3d_class->module~hdf5io_class module~ufield3d_class->module~ufield2d_class module~ufield3d_class->mpi module~ufield3d_lib ufield3d_lib module~ufield3d_class->module~ufield3d_lib module~ufield2d_class->module~spect2d_class module~ufield2d_class->module~perrors_class module~ufield2d_class->module~parallel_pipe_class module~ufield2d_class->module~hdf5io_class module~ufield2d_class->mpi module~ufield2d_lib ufield2d_lib module~ufield2d_class->module~ufield2d_lib module~ufield2d_lib->mpi module~fft2d_lib->mpi var panmodulespecies2d_classUsesGraph = svgPanZoom('#modulespecies2d_classUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~species2d_class~~UsedByGraph module~species2d_class species2d_class module~simulation_class simulation_class module~simulation_class->module~species2d_class program~quickpic quickpic program~quickpic->module~simulation_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables class erstr Derived Types species2d Subroutines init_species2d end_species2d renew_species2d qdp_species2d amjdp_species2d push_species2d pmove_species2d extpsi_species2d pcp_species2d pcb_species2d psend_species2d precv_species2d writehdf5_species2d writeq_species2d writeqslice_species2d cbq_species2d Variables Type Visibility Attributes Name Initial character(len=10), private :: class = 'species2d:' character(len=128), private :: erstr Derived Types type, public :: species2d Components Type Visibility Attributes Name Initial class( spect2d ), public, pointer :: sp => null() class( perrors ), public, pointer :: err => null() class( parallel_pipe ), public, pointer :: p => null() class( part2d ), private, pointer :: pd => null() class( field2d ), private, pointer :: q => null() class( field2d ), private, pointer :: qn => null() class( field2d ), private, pointer :: cu => null() class( field2d ), private, pointer :: amu => null() class( field2d ), private, pointer :: dcu => null() class( field3d ), private, pointer :: q3 => null() class( fdist2d ), private, pointer :: pf => null() Type-Bound Procedures generic, public :: new => init_species2d generic, public :: renew => renew_species2d generic, public :: del => end_species2d generic, public :: qdp => qdp_species2d generic, public :: amjdp => amjdp_species2d generic, public :: push => push_species2d generic, public :: pmv => pmove_species2d generic, public :: extpsi => extpsi_species2d generic, public :: pcp => pcp_species2d generic, public :: pcb => pcb_species2d generic, public :: psend => psend_species2d generic, public :: precv => precv_species2d generic, public :: wr => writehdf5_species2d generic, public :: wrq => writeq_species2d, writeqslice_species2d generic, public :: cbq => cbq_species2d procedure, private :: renew_species2d procedure, private :: init_species2d procedure, private :: end_species2d procedure, private :: qdp_species2d procedure, private :: amjdp_species2d procedure, private :: push_species2d procedure, private :: pmove_species2d procedure, private :: extpsi_species2d procedure, private :: pcp_species2d procedure, private :: pcb_species2d procedure, private :: psend_species2d procedure, private :: writehdf5_species2d procedure, private :: precv_species2d procedure, private :: writeqslice_species2d procedure, private :: writeq_species2d procedure, private :: cbq_species2d Subroutines private subroutine init_species2d (this, pp, perr, psp, pf, qbm, dt, ci, xdim, s) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( spect3d ), intent(in), pointer :: psp class( fdist2d ), intent(inout), target :: pf real, intent(in) :: qbm real, intent(in) :: dt real, intent(in) :: ci integer, intent(in) :: xdim real, intent(in) :: s private subroutine end_species2d (this) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this private subroutine renew_species2d (this, s) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this real, intent(in) :: s private subroutine qdp_species2d (this, q) Arguments Type Intent Optional Attributes Name class( species2d ), intent(in) :: this class( field2d ), intent(inout) :: q private subroutine amjdp_species2d (this, ef, bf, psit, cu, amu, dcu, dex) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this class( field2d ), intent(in) :: ef class( field2d ), intent(in) :: bf class( field2d ), intent(in) :: psit class( field2d ), intent(inout) :: cu class( field2d ), intent(inout) :: amu class( field2d ), intent(inout) :: dcu real, intent(in) :: dex private subroutine push_species2d (this, ef, bf, psit, dex) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this class( field2d ), intent(in) :: ef class( field2d ), intent(in) :: bf class( field2d ), intent(in) :: psit real, intent(in) :: dex private subroutine pmove_species2d (this, fd) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this class( field2d ), intent(in) :: fd private subroutine extpsi_species2d (this, psi, dex) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this class( field2d ), intent(in) :: psi real, intent(in) :: dex private subroutine pcp_species2d (this, fd) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this class( field2d ), intent(in) :: fd private subroutine pcb_species2d (this) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this private subroutine psend_species2d (this, tag, id) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this integer, intent(in) :: tag integer, intent(inout) :: id private subroutine precv_species2d (this, tag) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this integer, intent(in) :: tag private subroutine writehdf5_species2d (this, file, delta) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this class( hdf5file ), intent(in) :: file real, intent(in), dimension(2) :: delta private subroutine writeq_species2d (this, file, rtag, stag, id) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this class( hdf5file ), intent(in) :: file integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id private subroutine writeqslice_species2d (this, file, slice, spos, rtag, stag, id) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this class( hdf5file ), intent(in) :: file integer, intent(in) :: slice integer, intent(in) :: spos integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id private subroutine cbq_species2d (this, pos) Arguments Type Intent Optional Attributes Name class( species2d ), intent(inout) :: this integer, intent(in) :: pos","tags":"","loc":"module/species2d_class.html"},{"title":"parallel_pipe_class – QuickPIC","text":"Uses mpi parallel_class module~~parallel_pipe_class~~UsesGraph module~parallel_pipe_class parallel_pipe_class mpi mpi module~parallel_pipe_class->mpi module~parallel_class parallel_class module~parallel_pipe_class->module~parallel_class module~parallel_class->mpi omp_lib omp_lib module~parallel_class->omp_lib Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~parallel_pipe_class~~UsedByGraph module~parallel_pipe_class parallel_pipe_class module~part3d_class part3d_class module~part3d_class->module~parallel_pipe_class module~spect3d_class spect3d_class module~part3d_class->module~spect3d_class module~fdist3d_class fdist3d_class module~part3d_class->module~fdist3d_class module~ufield3d_class ufield3d_class module~part3d_class->module~ufield3d_class module~hdf5io_class hdf5io_class module~part3d_class->module~hdf5io_class module~spect3d_class->module~parallel_pipe_class module~spect2d_class spect2d_class module~spect3d_class->module~spect2d_class module~fpois2d_class fpois2d_class module~fpois2d_class->module~parallel_pipe_class module~fpois2d_class->module~spect2d_class module~ufield2d_class ufield2d_class module~fpois2d_class->module~ufield2d_class module~field3d_class field3d_class module~field3d_class->module~parallel_pipe_class module~field3d_class->module~spect3d_class module~field3d_class->module~ufield3d_class module~field3d_class->module~hdf5io_class module~spect2d_class->module~parallel_pipe_class module~fft2d_class fft2d_class module~fft2d_class->module~parallel_pipe_class module~fft2d_class->module~spect2d_class module~fft2d_class->module~ufield2d_class module~input_class input_class module~input_class->module~parallel_pipe_class module~input_class->module~spect3d_class module~field2d_class field2d_class module~field2d_class->module~parallel_pipe_class module~field2d_class->module~fpois2d_class module~field2d_class->module~field3d_class module~field2d_class->module~spect2d_class module~field2d_class->module~fft2d_class module~field2d_class->module~ufield3d_class module~field2d_class->module~ufield2d_class module~field2d_class->module~hdf5io_class module~simulation_class simulation_class module~simulation_class->module~parallel_pipe_class module~simulation_class->module~spect3d_class module~simulation_class->module~field3d_class module~simulation_class->module~spect2d_class module~simulation_class->module~input_class module~simulation_class->module~field2d_class module~simulation_class->module~fdist3d_class module~species2d_class species2d_class module~simulation_class->module~species2d_class module~beam3d_class beam3d_class module~simulation_class->module~beam3d_class module~simulation_class->module~hdf5io_class module~fdist2d_class fdist2d_class module~simulation_class->module~fdist2d_class module~fdist3d_class->module~parallel_pipe_class module~fdist3d_class->module~spect3d_class module~fdist3d_class->module~input_class module~fdist3d_class->module~ufield3d_class module~ufield3d_class->module~parallel_pipe_class module~ufield3d_class->module~spect3d_class module~ufield3d_class->module~ufield2d_class module~ufield3d_class->module~hdf5io_class module~species2d_class->module~parallel_pipe_class module~species2d_class->module~spect3d_class module~species2d_class->module~field3d_class module~species2d_class->module~spect2d_class module~species2d_class->module~field2d_class module~part2d_class part2d_class module~species2d_class->module~part2d_class module~species2d_class->module~hdf5io_class module~species2d_class->module~fdist2d_class module~beam3d_class->module~parallel_pipe_class module~beam3d_class->module~part3d_class module~beam3d_class->module~spect3d_class module~beam3d_class->module~field3d_class module~beam3d_class->module~field2d_class module~beam3d_class->module~fdist3d_class module~beam3d_class->module~hdf5io_class module~ufield2d_class->module~parallel_pipe_class module~ufield2d_class->module~spect2d_class module~ufield2d_class->module~hdf5io_class module~part2d_class->module~parallel_pipe_class module~part2d_class->module~spect2d_class module~part2d_class->module~ufield2d_class module~part2d_class->module~hdf5io_class module~part2d_class->module~fdist2d_class module~hdf5io_class->module~parallel_pipe_class module~fdist2d_class->module~parallel_pipe_class module~fdist2d_class->module~spect2d_class module~fdist2d_class->module~input_class module~fdist2d_class->module~ufield2d_class program~quickpic quickpic program~quickpic->module~simulation_class var panmoduleparallel_pipe_classUsedByGraph = svgPanZoom('#moduleparallel_pipe_classUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Common Blocks PPARMS Derived Types parallel_pipe Functions getlidproc getlkstrt getlgrp getlnvp getnstage getstageid Subroutines init_parallel_pipe Common Blocks common /PPARMS/ Type Attributes Name Initial integer :: nproc integer :: lgrp integer :: mreal integer :: mint integer :: mcplx integer :: mdouble integer :: lworld $(function () {\n    $('[data-toggle=\"popover\"]').popover()\n    }) Derived Types type, public, extends( parallel ) :: parallel_pipe Components Type Visibility Attributes Name Initial integer, private :: nstage = 1 integer, private :: stageid = 0 integer, private :: lidproc integer, private :: lkstrt integer, private :: lgrp integer, private :: lnvp Type-Bound Procedures generic, public :: del => end_parallel procedure, public :: getnvp procedure, public :: getidproc procedure, public :: getkstrt procedure, public :: getlworld procedure, public :: getmreal procedure, public :: getmint procedure, public :: getmdouble procedure, public :: getmcplx procedure, public :: getmchar procedure, public :: getnstage procedure, public :: getstageid procedure, public :: getlidproc procedure, public :: getlkstrt procedure, public :: getlgrp procedure, public :: getlnvp procedure, private :: init_parallel_pipe generic, public :: new => init_parallel, init_parallel_pipe Functions private function getlidproc (this) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in) :: this Return Value integer private function getlkstrt (this) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in) :: this Return Value integer private function getlgrp (this) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in) :: this Return Value integer private function getlnvp (this) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in) :: this Return Value integer private function getnstage (this) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in) :: this Return Value integer private function getstageid (this) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in) :: this Return Value integer Subroutines private subroutine init_parallel_pipe (this, nst) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(inout) :: this integer, intent(in) :: nst","tags":"","loc":"module/parallel_pipe_class.html"},{"title":"ufield2d_class – QuickPIC","text":"Uses perrors_class parallel_pipe_class spect2d_class ufield2d_lib hdf5io_class mpi module~~ufield2d_class~~UsesGraph module~ufield2d_class ufield2d_class module~spect2d_class spect2d_class module~ufield2d_class->module~spect2d_class module~ufield2d_lib ufield2d_lib module~ufield2d_class->module~ufield2d_lib module~perrors_class perrors_class module~ufield2d_class->module~perrors_class module~parallel_pipe_class parallel_pipe_class module~ufield2d_class->module~parallel_pipe_class module~hdf5io_class hdf5io_class module~ufield2d_class->module~hdf5io_class mpi mpi module~ufield2d_class->mpi module~spect2d_class->module~perrors_class module~spect2d_class->module~parallel_pipe_class module~ufield2d_lib->mpi module~perrors_class->mpi module~parallel_class parallel_class module~perrors_class->module~parallel_class module~parallel_pipe_class->mpi module~parallel_pipe_class->module~parallel_class module~hdf5io_class->module~perrors_class module~hdf5io_class->module~parallel_pipe_class module~hdf5io_class->mpi HDF5 HDF5 module~hdf5io_class->HDF5 module~parallel_class->mpi omp_lib omp_lib module~parallel_class->omp_lib Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~ufield2d_class~~UsedByGraph module~ufield2d_class ufield2d_class module~fpois2d_class fpois2d_class module~fpois2d_class->module~ufield2d_class module~fft2d_class fft2d_class module~fft2d_class->module~ufield2d_class module~field2d_class field2d_class module~field2d_class->module~ufield2d_class module~field2d_class->module~fpois2d_class module~field2d_class->module~fft2d_class module~ufield3d_class ufield3d_class module~field2d_class->module~ufield3d_class module~field3d_class field3d_class module~field2d_class->module~field3d_class module~ufield3d_class->module~ufield2d_class module~part2d_class part2d_class module~part2d_class->module~ufield2d_class module~fdist2d_class fdist2d_class module~part2d_class->module~fdist2d_class module~fdist2d_class->module~ufield2d_class module~part3d_class part3d_class module~part3d_class->module~ufield3d_class module~fdist3d_class fdist3d_class module~part3d_class->module~fdist3d_class module~field3d_class->module~ufield3d_class module~simulation_class simulation_class module~simulation_class->module~field2d_class module~simulation_class->module~fdist2d_class module~simulation_class->module~field3d_class module~simulation_class->module~fdist3d_class module~beam3d_class beam3d_class module~simulation_class->module~beam3d_class module~species2d_class species2d_class module~simulation_class->module~species2d_class module~fdist3d_class->module~ufield3d_class module~beam3d_class->module~field2d_class module~beam3d_class->module~part3d_class module~beam3d_class->module~field3d_class module~beam3d_class->module~fdist3d_class module~species2d_class->module~field2d_class module~species2d_class->module~part2d_class module~species2d_class->module~fdist2d_class module~species2d_class->module~field3d_class program~quickpic quickpic program~quickpic->module~simulation_class var panmoduleufield2d_classUsedByGraph = svgPanZoom('#moduleufield2d_classUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables class erstr scr szscr Derived Types ufield2d Functions getlayout getnvpy getnvpx getnd2 getnd1 getnd2p getnd1p getdim getnoff getrf add mult1 mult2 Subroutines init_ufield2d init_ufield2d_k end_ufield2d final_ufield2d copyguard acopyguard writehdf5 pipesend_ufield2d piperecv_ufield2d sum1 sum2 minus1 minus2 multiply1 multiply2 asc asa Variables Type Visibility Attributes Name Initial character(len=10), private, save :: class = 'ufield2d:' character(len=128), private, save :: erstr real, private, dimension(:), allocatable, save :: scr integer, private, save :: szscr = 0 Derived Types type, public :: ufield2d Components Type Visibility Attributes Name Initial class( spect2d ), public, pointer :: sp => null() class( perrors ), public, pointer :: err => null() class( parallel_pipe ), public, pointer :: p => null() integer, private :: layout integer, private :: dim integer, private :: noff integer, private :: nd1 integer, private :: nvpx integer, private :: nd1p integer, private :: nd2 integer, private :: nvpy integer, private :: nd2p real, private, dimension(:,:,:), pointer :: rf => null() real, private, dimension(:,:,:), pointer :: buff => null() Finalizations Procedures final :: final_ufield2d","tags":"","loc":"module/ufield2d_class.html"},{"title":"field3d_class – QuickPIC","text":"Uses perrors_class parallel_pipe_class spect3d_class ufield3d_class hdf5io_class module~~field3d_class~~UsesGraph module~field3d_class field3d_class module~spect3d_class spect3d_class module~field3d_class->module~spect3d_class module~perrors_class perrors_class module~field3d_class->module~perrors_class module~ufield3d_class ufield3d_class module~field3d_class->module~ufield3d_class module~parallel_pipe_class parallel_pipe_class module~field3d_class->module~parallel_pipe_class module~hdf5io_class hdf5io_class module~field3d_class->module~hdf5io_class module~spect3d_class->module~perrors_class module~spect3d_class->module~parallel_pipe_class module~spect2d_class spect2d_class module~spect3d_class->module~spect2d_class module~parallel_class parallel_class module~perrors_class->module~parallel_class mpi mpi module~perrors_class->mpi module~ufield3d_class->module~spect3d_class module~ufield3d_class->module~perrors_class module~ufield3d_class->module~parallel_pipe_class module~ufield3d_class->module~hdf5io_class module~ufield3d_lib ufield3d_lib module~ufield3d_class->module~ufield3d_lib module~ufield2d_class ufield2d_class module~ufield3d_class->module~ufield2d_class module~ufield3d_class->mpi module~parallel_pipe_class->module~parallel_class module~parallel_pipe_class->mpi module~hdf5io_class->module~perrors_class module~hdf5io_class->module~parallel_pipe_class HDF5 HDF5 module~hdf5io_class->HDF5 module~hdf5io_class->mpi module~parallel_class->mpi omp_lib omp_lib module~parallel_class->omp_lib module~spect2d_class->module~perrors_class module~spect2d_class->module~parallel_pipe_class module~ufield2d_class->module~perrors_class module~ufield2d_class->module~parallel_pipe_class module~ufield2d_class->module~hdf5io_class module~ufield2d_class->module~spect2d_class module~ufield2d_class->mpi module~ufield2d_lib ufield2d_lib module~ufield2d_class->module~ufield2d_lib module~ufield2d_lib->mpi var panmodulefield3d_classUsesGraph = svgPanZoom('#modulefield3d_classUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~field3d_class~~UsedByGraph module~field3d_class field3d_class module~species2d_class species2d_class module~species2d_class->module~field3d_class module~field2d_class field2d_class module~species2d_class->module~field2d_class module~field2d_class->module~field3d_class module~beam3d_class beam3d_class module~beam3d_class->module~field3d_class module~beam3d_class->module~field2d_class module~simulation_class simulation_class module~simulation_class->module~field3d_class module~simulation_class->module~species2d_class module~simulation_class->module~field2d_class module~simulation_class->module~beam3d_class program~quickpic quickpic program~quickpic->module~simulation_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables class erstr Derived Types field3d Functions getgcells getrs Subroutines init_field3d end_field3d pipecg_field3d acopyguard_field3d writehdf5_3d writehdf5_2dslice asc asa sum minus multiply Variables Type Visibility Attributes Name Initial character(len=10), private, save :: class = 'field3d:' character(len=128), private, save :: erstr Derived Types type, public :: field3d Components Type Visibility Attributes Name Initial class( spect3d ), public, pointer :: sp => null() class( perrors ), public, pointer :: err => null() class( parallel_pipe ), public, pointer :: p => null() class( ufield3d ), private, pointer :: rs => null() integer, private :: gcells Type-Bound Procedures generic, public :: new => init_field3d generic, public :: del => end_field3d generic, public :: pcg => pipecg_field3d generic, public :: ag => acopyguard_field3d generic, public :: wr => writehdf5_3d, writehdf5_2dslice generic, public :: as => asc, asa generic, public :: add => sum generic, public :: sub => minus generic, public :: mult => multiply procedure, private :: init_field3d procedure, private :: end_field3d procedure, private :: acopyguard_field3d procedure, private :: pipecg_field3d procedure, private :: writehdf5_2dslice procedure, private :: writehdf5_3d procedure, private :: multiply procedure, private :: minus procedure, private :: sum procedure, private :: asa procedure, private :: asc procedure, public :: getrs procedure, public :: getgcells Functions private function getgcells (this) Arguments Type Intent Optional Attributes Name class( field3d ), intent(in) :: this Return Value integer private function getrs (this) Arguments Type Intent Optional Attributes Name class( field3d ), intent(in) :: this Return Value class( ufield3d ),\n  pointer Subroutines private subroutine init_field3d (this, pp, perr, psp, dim) Arguments Type Intent Optional Attributes Name class( field3d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( spect3d ), intent(in), pointer :: psp integer, intent(in) :: dim private subroutine end_field3d (this) Arguments Type Intent Optional Attributes Name class( field3d ), intent(inout) :: this private subroutine pipecg_field3d (this, rtag, stag, rid, sid) Arguments Type Intent Optional Attributes Name class( field3d ), intent(inout) :: this integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: rid integer, intent(inout) :: sid private subroutine acopyguard_field3d (this, rtag, stag, id) Arguments Type Intent Optional Attributes Name class( field3d ), intent(inout) :: this integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id private subroutine writehdf5_3d (this, file, dim, rtag, stag, id) Arguments Type Intent Optional Attributes Name class( field3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file integer, intent(in) :: dim integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id private subroutine writehdf5_2dslice (this, file, dim, slice, spos, rtag, stag, id) Arguments Type Intent Optional Attributes Name class( field3d ), intent(inout) :: this class( hdf5file ), intent(in) :: file integer, intent(in) :: dim integer, intent(in) :: slice integer, intent(in) :: spos integer, intent(in) :: rtag integer, intent(in) :: stag integer, intent(inout) :: id private subroutine asc (this, value) Arguments Type Intent Optional Attributes Name class( field3d ), intent(inout) :: this real, intent(in) :: value private subroutine asa (this, that) Arguments Type Intent Optional Attributes Name class( field3d ), intent(inout) :: this class( field3d ), intent(inout) :: that private subroutine sum (this, a1, a2) Arguments Type Intent Optional Attributes Name class( field3d ), intent(inout) :: this class( field3d ), intent(in) :: a1 class( field3d ), intent(in) :: a2 private subroutine minus (this, a1, a2) Arguments Type Intent Optional Attributes Name class( field3d ), intent(inout) :: this class( field3d ), intent(in) :: a1 class( field3d ), intent(in) :: a2 private subroutine multiply (this, a1, value) Arguments Type Intent Optional Attributes Name class( field3d ), intent(inout) :: this class( field3d ), intent(in) :: a1 real, intent(in) :: value","tags":"","loc":"module/field3d_class.html"},{"title":"fpois2d_class – QuickPIC","text":"Uses perrors_class parallel_pipe_class spect2d_class ufield2d_class fpois2d_lib module~~fpois2d_class~~UsesGraph module~fpois2d_class fpois2d_class module~spect2d_class spect2d_class module~fpois2d_class->module~spect2d_class module~perrors_class perrors_class module~fpois2d_class->module~perrors_class module~parallel_pipe_class parallel_pipe_class module~fpois2d_class->module~parallel_pipe_class module~ufield2d_class ufield2d_class module~fpois2d_class->module~ufield2d_class module~fpois2d_lib fpois2d_lib module~fpois2d_class->module~fpois2d_lib module~spect2d_class->module~perrors_class module~spect2d_class->module~parallel_pipe_class mpi mpi module~perrors_class->mpi module~parallel_class parallel_class module~perrors_class->module~parallel_class module~parallel_pipe_class->mpi module~parallel_pipe_class->module~parallel_class module~ufield2d_class->module~spect2d_class module~ufield2d_class->module~perrors_class module~ufield2d_class->module~parallel_pipe_class module~hdf5io_class hdf5io_class module~ufield2d_class->module~hdf5io_class module~ufield2d_class->mpi module~ufield2d_lib ufield2d_lib module~ufield2d_class->module~ufield2d_lib module~hdf5io_class->module~perrors_class module~hdf5io_class->module~parallel_pipe_class module~hdf5io_class->mpi HDF5 HDF5 module~hdf5io_class->HDF5 module~parallel_class->mpi omp_lib omp_lib module~parallel_class->omp_lib module~ufield2d_lib->mpi var panmodulefpois2d_classUsesGraph = svgPanZoom('#modulefpois2d_classUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~fpois2d_class~~UsedByGraph module~fpois2d_class fpois2d_class module~field2d_class field2d_class module~field2d_class->module~fpois2d_class module~species2d_class species2d_class module~species2d_class->module~field2d_class module~beam3d_class beam3d_class module~beam3d_class->module~field2d_class module~simulation_class simulation_class module~simulation_class->module~field2d_class module~simulation_class->module~species2d_class module~simulation_class->module~beam3d_class program~quickpic quickpic program~quickpic->module~simulation_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables class erstr numtables table_list Derived Types fpois2d fpois2d_link Functions get_pois2table Subroutines init_fpois2d end_fpois2d ippoisd2init ipotd2 ippoisd2 ismoothfd2 ippoisd23 ibfieldd2 jpbpoisd23 jpbpoisd23n_qp Variables Type Visibility Attributes Name Initial character(len=10), private, save :: class = 'fpois2d:' character(len=128), private, save :: erstr integer, private, save :: numtables = 0 type( fpois2d_link ), private, target, save :: table_list Derived Types type, public :: fpois2d Components Type Visibility Attributes Name Initial class( spect2d ), public, pointer :: sp => null() class( perrors ), public, pointer :: err => null() class( parallel_pipe ), public, pointer :: p => null() integer, private, dimension(2) :: nd real, private, dimension(2) :: a real, private :: anorm complex, private, dimension(:,:), pointer :: ffc => null() real, private, dimension(:,:,:), pointer :: ffg => null() Type-Bound Procedures generic, public :: new => init_fpois2d generic, public :: del => end_fpois2d generic, public :: potential => ipotd2 generic, public :: smoothf => ismoothfd2 generic, public :: elfield => ippoisd23 generic, public :: bfield => ibfieldd2 generic, public :: bfield_qp => jpbpoisd23n_qp procedure, private :: init_fpois2d procedure, private :: end_fpois2d procedure, private :: ibfieldd2 procedure, private :: ippoisd23 procedure, private :: ismoothfd2 procedure, private :: ipotd2 procedure, private :: jpbpoisd23n_qp type, private :: fpois2d_link Components Type Visibility Attributes Name Initial type( fpois2d_link ), public, pointer :: next => null() type( fpois2d ), public, pointer :: table => null() integer, public :: refcount Functions public function get_pois2table (pp, perr, psp, ax, ay, affp) result(table) Arguments Type Intent Optional Attributes Name class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( spect2d ), intent(in), pointer :: psp real, intent(in) :: ax real, intent(in) :: ay real, intent(in) :: affp Return Value type( fpois2d ),\n  pointer Subroutines private subroutine init_fpois2d (this, pp, perr, psp, nx, ny, ax, ay, affp) Arguments Type Intent Optional Attributes Name class( fpois2d ), intent(inout) :: this class( parallel_pipe ), intent(in), pointer :: pp class( perrors ), intent(in), pointer :: perr class( spect2d ), intent(in), pointer :: psp integer, intent(in) :: nx integer, intent(in) :: ny real, intent(in) :: ax real, intent(in) :: ay real, intent(in) :: affp private subroutine end_fpois2d (this) Arguments Type Intent Optional Attributes Name class( fpois2d ), intent(inout) :: this private subroutine ippoisd2init (this, ax, ay, affp, nx, ny, kstrt) Arguments Type Intent Optional Attributes Name class( fpois2d ), intent(in) :: this real, intent(in) :: ax real, intent(in) :: ay real, intent(in) :: affp integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kstrt private subroutine ipotd2 (this, q, fx, we) Arguments Type Intent Optional Attributes Name class( fpois2d ), intent(in) :: this class( ufield2d ), intent(inout) :: q class( ufield2d ), intent(inout) :: fx real, intent(inout) :: we private subroutine ippoisd2 (this, q, fx, isign, we) Arguments Type Intent Optional Attributes Name class( fpois2d ), intent(in) :: this real, intent(inout), dimension(:,:,:), pointer :: q real, intent(inout), dimension(:,:,:), pointer :: fx integer, intent(in) :: isign real, intent(inout) :: we private subroutine ismoothfd2 (this, f, fs) Arguments Type Intent Optional Attributes Name class( fpois2d ), intent(in) :: this class( ufield2d ), intent(inout) :: f class( ufield2d ), intent(inout) :: fs private subroutine ippoisd23 (this, q, fxy, we) Arguments Type Intent Optional Attributes Name class( fpois2d ), intent(in) :: this class( ufield2d ), intent(inout) :: q class( ufield2d ), intent(inout) :: fxy real, intent(inout) :: we private subroutine ibfieldd2 (this, cu, bxy, ci, wm) Arguments Type Intent Optional Attributes Name class( fpois2d ), intent(in) :: this class( ufield2d ), intent(inout) :: cu class( ufield2d ), intent(inout) :: bxy real, intent(in) :: ci real, intent(inout) :: wm private subroutine jpbpoisd23 (this, cu, bxy, isign, ci, wm) Arguments Type Intent Optional Attributes Name class( fpois2d ), intent(in) :: this real, intent(inout), dimension(:,:,:), pointer :: cu real, intent(inout), dimension(:,:,:), pointer :: bxy integer, intent(in) :: isign real, intent(in) :: ci real, intent(inout) :: wm private subroutine jpbpoisd23n_qp (this, cu, dcu, amu, bxy, ci, c, dex, wm) Arguments Type Intent Optional Attributes Name class( fpois2d ), intent(in) :: this class( ufield2d ), intent(inout) :: cu class( ufield2d ), intent(inout) :: dcu class( ufield2d ), intent(inout) :: amu class( ufield2d ), intent(inout) :: bxy real, intent(in) :: ci real, intent(in) :: c real, intent(in) :: dex real, intent(inout) :: wm","tags":"","loc":"module/fpois2d_class.html"},{"title":"fft2d_lib – QuickPIC","text":"Uses mpi module~~fft2d_lib~~UsesGraph module~fft2d_lib fft2d_lib mpi mpi module~fft2d_lib->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~fft2d_lib~~UsedByGraph module~fft2d_lib fft2d_lib proc~pprntpose PPRNTPOSE proc~pprntpose->module~fft2d_lib module~fft2d_class fft2d_class module~fft2d_class->module~fft2d_lib proc~pprtpose PPRTPOSE proc~pprtpose->module~fft2d_lib module~field2d_class field2d_class module~field2d_class->module~fft2d_class module~species2d_class species2d_class module~species2d_class->module~field2d_class module~beam3d_class beam3d_class module~beam3d_class->module~field2d_class module~simulation_class simulation_class module~simulation_class->module~field2d_class module~simulation_class->module~species2d_class module~simulation_class->module~beam3d_class program~quickpic quickpic program~quickpic->module~simulation_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Common Blocks PPARMS Interfaces WPFST2RINIT WPFSST2R WPFSCT2R WPFCST2R WPFCCT2R WPFCST2R2 WPFSCT2R2 WPFCST2R3 WPFSCT2R3 WPFS3T2R3 PDIVFD2 PGRADFD2 PCURLFD2 PCURLFD22 WPPFSST2RM WPPFSCT2RM WPPFCST2RM WPPFCCT2RM PPFST2RMXX PPFCT2RMXX PPFST2RMXY PPFCT2RMXY WPPFCST2RM2 WPPFSCT2RM2 PPFCST2RM2X PPFSCT2RM2X PPFSCT2RM2Y PPFCST2RM2Y WPPFCST2RM3 WPPFSCT2RM3 PPFCSST2RM3X PPFSCCT2RM3X PPFSCST2RM3Y PPFCSCT2RM3Y WPPFSCT2RM4 PPFSCCST2RM4X PPFSCSCT2RM4Y WPPFSCT2RM22 PPFSCCST2RM22X PPFSCSCT2RM22Y WPPFSST2RM23 PPFSSCT2RM32X PPFSSCT2RM23Y MPPDIVFD2 MPPGRADFD2 MPPCURLFD2 Subroutines PPRTPOSE PPRNTPOSE Common Blocks common /PPARMS/ Type Attributes Name Initial integer :: nproc integer :: lgrp integer :: mreal integer :: mint integer :: mcplx integer :: mdouble integer :: lworld $(function () {\n    $('[data-toggle=\"popover\"]').popover()\n    }) Interfaces interface public subroutine WPFST2RINIT(mixup, sctd, indx, indy, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(nxhyd) :: mixup complex, intent(inout), dimension(nxyd) :: sctd integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: nxhyd integer, intent(in) :: nxyd interface public subroutine WPFSST2R(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nxvh, nyv, kxp2, kyp, kypd, kxp2d, jblok, kblok, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout) :: f real, intent(inout), dimension(nyv,kxp2d,jblok) :: g real, intent(inout), dimension(kxp2+1,kyp+1,kblok) :: bs real, intent(inout), dimension(kxp2+1,kyp+1,jblok) :: br integer, intent(in) :: isign integer, intent(in) :: ntpose integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd real, intent(inout) :: ttp integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: nxvh integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: kyp integer, intent(in) :: kypd integer, intent(in) :: kxp2d integer, intent(in) :: jblok integer, intent(in) :: kblok integer, intent(in) :: nxhyd integer, intent(in) :: nxyd interface public subroutine WPFSCT2R(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nxvh, nyv, kxp2, kyp, kypd, kxp2d, jblok, kblok, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout) :: f real, intent(inout), dimension(nyv,kxp2d,jblok) :: g real, intent(inout), dimension(kxp2+1,kyp+1,kblok) :: bs real, intent(inout), dimension(kxp2+1,kyp+1,jblok) :: br integer, intent(in) :: isign integer, intent(in) :: ntpose integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd real, intent(inout) :: ttp integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: nxvh integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: kyp integer, intent(in) :: kypd integer, intent(in) :: kxp2d integer, intent(in) :: jblok integer, intent(in) :: kblok integer, intent(in) :: nxhyd integer, intent(in) :: nxyd interface public subroutine WPFCST2R(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nxvh, nyv, kxp2, kyp, kypd, kxp2d, jblok, kblok, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout) :: f real, intent(inout), dimension(nyv,kxp2d,jblok) :: g real, intent(inout), dimension(kxp2+1,kyp+1,kblok) :: bs real, intent(inout), dimension(kxp2+1,kyp+1,jblok) :: br integer, intent(in) :: isign integer, intent(in) :: ntpose integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd real, intent(inout) :: ttp integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: nxvh integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: kyp integer, intent(in) :: kypd integer, intent(in) :: kxp2d integer, intent(in) :: jblok integer, intent(in) :: kblok integer, intent(in) :: nxhyd integer, intent(in) :: nxyd interface public subroutine WPFCCT2R(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nxvh, nyv, kxp2, kyp, kypd, kxp2d, jblok, kblok, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout) :: f real, intent(inout), dimension(nyv,kxp2d,jblok) :: g real, intent(inout), dimension(kxp2+1,kyp+1,kblok) :: bs real, intent(inout), dimension(kxp2+1,kyp+1,jblok) :: br integer, intent(in) :: isign integer, intent(in) :: ntpose integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd real, intent(inout) :: ttp integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: nxvh integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: kyp integer, intent(in) :: kypd integer, intent(in) :: kxp2d integer, intent(in) :: jblok integer, intent(in) :: kblok integer, intent(in) :: nxhyd integer, intent(in) :: nxyd interface public subroutine WPFCST2R2(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nxvh, nyv, kxp2, kyp, kypd, kxp2d, jblok, kblok, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout) :: f real, intent(inout), dimension(2,nyv,kxp2d,jblok) :: g real, intent(inout), dimension(2,kxp2+1,kyp+1,kblok) :: bs real, intent(inout), dimension(2,kxp2+1,kyp+1,jblok) :: br integer, intent(in) :: isign integer, intent(in) :: ntpose integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd real, intent(inout) :: ttp integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: nxvh integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: kyp integer, intent(in) :: kypd integer, intent(in) :: kxp2d integer, intent(in) :: jblok integer, intent(in) :: kblok integer, intent(in) :: nxhyd integer, intent(in) :: nxyd interface public subroutine WPFSCT2R2(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nxvh, nyv, kxp2, kyp, kypd, kxp2d, jblok, kblok, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout) :: f real, intent(inout), dimension(2,nyv,kxp2d,jblok) :: g real, intent(inout), dimension(2,kxp2+1,kyp+1,kblok) :: bs real, intent(inout), dimension(2,kxp2+1,kyp+1,jblok) :: br integer, intent(in) :: isign integer, intent(in) :: ntpose integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd real, intent(inout) :: ttp integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: nxvh integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: kyp integer, intent(in) :: kypd integer, intent(in) :: kxp2d integer, intent(in) :: jblok integer, intent(in) :: kblok integer, intent(in) :: nxhyd integer, intent(in) :: nxyd interface public subroutine WPFCST2R3(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nxvh, nyv, kxp2, kyp, kypd, kxp2d, jblok, kblok, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout) :: f real, intent(inout), dimension(3,nyv,kxp2d,jblok) :: g real, intent(inout), dimension(3,kxp2+1,kyp+1,kblok) :: bs real, intent(inout), dimension(3,kxp2+1,kyp+1,jblok) :: br integer, intent(in) :: isign integer, intent(in) :: ntpose integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd real, intent(inout) :: ttp integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: nxvh integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: kyp integer, intent(in) :: kypd integer, intent(in) :: kxp2d integer, intent(in) :: jblok integer, intent(in) :: kblok integer, intent(in) :: nxhyd integer, intent(in) :: nxyd interface public subroutine WPFSCT2R3(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nxvh, nyv, kxp2, kyp, kypd, kxp2d, jblok, kblok, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout) :: f real, intent(inout), dimension(3,nyv,kxp2d,jblok) :: g real, intent(inout), dimension(3,kxp2+1,kyp+1,kblok) :: bs real, intent(inout), dimension(3,kxp2+1,kyp+1,jblok) :: br integer, intent(in) :: isign integer, intent(in) :: ntpose integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd real, intent(inout) :: ttp integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: nxvh integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: kyp integer, intent(in) :: kypd integer, intent(in) :: kxp2d integer, intent(in) :: jblok integer, intent(in) :: kblok integer, intent(in) :: nxhyd integer, intent(in) :: nxyd interface public subroutine WPFS3T2R3(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nxvh, nyv, kxp2, kyp, kypd, kxp2d, jblok, kblok, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout) :: f real, intent(inout), dimension(3,nyv,kxp2d,jblok) :: g real, intent(inout), dimension(3,kxp2+1,kyp+1,kblok) :: bs real, intent(inout), dimension(3,kxp2+1,kyp+1,jblok) :: br integer, intent(in) :: isign integer, intent(in) :: ntpose integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd real, intent(inout) :: ttp integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: nxvh integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: kyp integer, intent(in) :: kypd integer, intent(in) :: kxp2d integer, intent(in) :: jblok integer, intent(in) :: kblok integer, intent(in) :: nxhyd integer, intent(in) :: nxyd interface public subroutine PDIVFD2(f, df, nx, ny, kstrt, ndim, nyv, kxp2, j2blok) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(ndim,nyv,kxp2+1,j2blok) :: f real, intent(inout), dimension(nyv,kxp2+1,j2blok) :: df integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kstrt integer, intent(in) :: ndim integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: j2blok interface public subroutine PGRADFD2(df, f, nx, ny, kstrt, ndim, nyv, kxp2, j2blok) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(nyv,kxp2+1,j2blok) :: df real, intent(inout), dimension(ndim,nyv,kxp2+1,j2blok) :: f integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kstrt integer, intent(in) :: ndim integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: j2blok interface public subroutine PCURLFD2(f, g, nx, ny, kstrt, nyv, kxp2, j2blok) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(3,nyv,kxp2+1,j2blok) :: f real, intent(inout), dimension(3,nyv,kxp2+1,j2blok) :: g integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kstrt integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: j2blok interface public subroutine PCURLFD22(f, g, nx, ny, kstrt, nyv, kxp2, j2blok) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(2,nyv,kxp2+1,j2blok) :: f real, intent(inout), dimension(nyv,kxp2+1,j2blok) :: g integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kstrt integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: j2blok interface public subroutine WPPFSST2RM(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nvp, nxvh, nyv, kxp2, kyp, kypd, kxp2d, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(2*nxvh,kypd) :: f real, intent(inout), dimension(nyv,kxp2d) :: g real, intent(inout), dimension(kxp2+1,kyp+1) :: bs real, intent(inout), dimension(kxp2+1,kyp+1) :: br integer, intent(in) :: isign integer, intent(in) :: ntpose integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd real, intent(inout) :: ttp integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: nvp integer, intent(in) :: nxvh integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: kyp integer, intent(in) :: kypd integer, intent(in) :: kxp2d integer, intent(in) :: nxhyd integer, intent(in) :: nxyd interface public subroutine WPPFSCT2RM(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nvp, nxvh, nyv, kxp2, kyp, kypd, kxp2d, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(2*nxvh,kypd) :: f real, intent(inout), dimension(nyv,kxp2d) :: g real, intent(inout), dimension(kxp2+1,kyp+1) :: bs real, intent(inout), dimension(kxp2+1,kyp+1) :: br integer, intent(in) :: isign integer, intent(in) :: ntpose integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd real, intent(inout) :: ttp integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: nvp integer, intent(in) :: nxvh integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: kyp integer, intent(in) :: kypd integer, intent(in) :: kxp2d integer, intent(in) :: nxhyd integer, intent(in) :: nxyd interface public subroutine WPPFCST2RM(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nvp, nxvh, nyv, kxp2, kyp, kypd, kxp2d, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(2*nxvh,kypd) :: f real, intent(inout), dimension(nyv,kxp2d) :: g real, intent(inout), dimension(kxp2+1,kyp+1) :: bs real, intent(inout), dimension(kxp2+1,kyp+1) :: br integer, intent(in) :: isign integer, intent(in) :: ntpose integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd real, intent(inout) :: ttp integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: nvp integer, intent(in) :: nxvh integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: kyp integer, intent(in) :: kypd integer, intent(in) :: kxp2d integer, intent(in) :: nxhyd integer, intent(in) :: nxyd interface public subroutine WPPFCCT2RM(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nvp, nxvh, nyv, kxp2, kyp, kypd, kxp2d, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(2*nxvh,kypd) :: f real, intent(inout), dimension(nyv,kxp2d) :: g real, intent(inout), dimension(kxp2+1,kyp+1) :: bs real, intent(inout), dimension(kxp2+1,kyp+1) :: br integer, intent(in) :: isign integer, intent(in) :: ntpose integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd real, intent(inout) :: ttp integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: nvp integer, intent(in) :: nxvh integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: kyp integer, intent(in) :: kypd integer, intent(in) :: kxp2d integer, intent(in) :: nxhyd integer, intent(in) :: nxyd interface public subroutine PPFST2RMXX(f, isign, mixup, sctd, indx, indy, kstrt, kypi, kypp, nxvh, kypd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(2*nxvh,kypd) :: f integer, intent(in) :: isign integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: kypi integer, intent(in) :: kypp integer, intent(in) :: nxvh integer, intent(in) :: kypd integer, intent(in) :: nxhyd integer, intent(in) :: nxyd interface public subroutine PPFCT2RMXX(f, isign, mixup, sctd, indx, indy, kstrt, kypi, kypp, nxvh, kypd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(2*nxvh,kypd) :: f integer, intent(in) :: isign integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: kypi integer, intent(in) :: kypp integer, intent(in) :: nxvh integer, intent(in) :: kypd integer, intent(in) :: nxhyd integer, intent(in) :: nxyd interface public subroutine PPFST2RMXY(g, isign, mixup, sctd, indx, indy, kstrt, kxpi, kxpp, nyv, kxpd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(nyv,kxpd) :: g integer, intent(in) :: isign integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: kxpi integer, intent(in) :: kxpp integer, intent(in) :: nyv integer, intent(in) :: kxpd integer, intent(in) :: nxhyd integer, intent(in) :: nxyd interface public subroutine PPFCT2RMXY(g, isign, mixup, sctd, indx, indy, kstrt, kxpi, kxpp, nyv, kxpd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(nyv,kxpd) :: g integer, intent(in) :: isign integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: kxpi integer, intent(in) :: kxpp integer, intent(in) :: nyv integer, intent(in) :: kxpd integer, intent(in) :: nxhyd integer, intent(in) :: nxyd interface public subroutine WPPFCST2RM2(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nvp, nxvh, nyv, kxp2, kyp, kypd, kxp2d, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(2,2*nxvh,kypd) :: f real, intent(inout), dimension(2,nyv,kxp2d) :: g real, intent(inout), dimension(2,kxp2+1,kyp+1) :: bs real, intent(inout), dimension(2,kxp2+1,kyp+1) :: br integer, intent(in) :: isign integer, intent(in) :: ntpose integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd real, intent(inout) :: ttp integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: nvp integer, intent(in) :: nxvh integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: kyp integer, intent(in) :: kypd integer, intent(in) :: kxp2d integer, intent(in) :: nxhyd integer, intent(in) :: nxyd interface public subroutine WPPFSCT2RM2(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nvp, nxvh, nyv, kxp2, kyp, kypd, kxp2d, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(2,2*nxvh,kypd) :: f real, intent(inout), dimension(2,nyv,kxp2d) :: g real, intent(inout), dimension(2,kxp2+1,kyp+1) :: bs real, intent(inout), dimension(2,kxp2+1,kyp+1) :: br integer, intent(in) :: isign integer, intent(in) :: ntpose integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd real, intent(inout) :: ttp integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: nvp integer, intent(in) :: nxvh integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: kyp integer, intent(in) :: kypd integer, intent(in) :: kxp2d integer, intent(in) :: nxhyd integer, intent(in) :: nxyd interface public subroutine PPFCST2RM2X(f, isign, mixup, sctd, indx, indy, kstrt, kypi, kypp, nxvh, kypd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(2,2*nxvh,kypd) :: f integer, intent(in) :: isign integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: kypi integer, intent(in) :: kypp integer, intent(in) :: nxvh integer, intent(in) :: kypd integer, intent(in) :: nxhyd integer, intent(in) :: nxyd interface public subroutine PPFSCT2RM2X(f, isign, mixup, sctd, indx, indy, kstrt, kypi, kypp, nxvh, kypd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(2,2*nxvh,kypd) :: f integer, intent(in) :: isign integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: kypi integer, intent(in) :: kypp integer, intent(in) :: nxvh integer, intent(in) :: kypd integer, intent(in) :: nxhyd integer, intent(in) :: nxyd interface public subroutine PPFSCT2RM2Y(g, isign, mixup, sctd, indx, indy, kstrt, kxpi, kxpp, nyv, kxpd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(2,nyv,kxpd) :: g integer, intent(in) :: isign integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: kxpi integer, intent(in) :: kxpp integer, intent(in) :: nyv integer, intent(in) :: kxpd integer, intent(in) :: nxhyd integer, intent(in) :: nxyd interface public subroutine PPFCST2RM2Y(g, isign, mixup, sctd, indx, indy, kstrt, kxpi, kxpp, nyv, kxpd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(2,nyv,kxpd) :: g integer, intent(in) :: isign integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: kxpi integer, intent(in) :: kxpp integer, intent(in) :: nyv integer, intent(in) :: kxpd integer, intent(in) :: nxhyd integer, intent(in) :: nxyd interface public subroutine WPPFCST2RM3(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nvp, nxvh, nyv, kxp2, kyp, kypd, kxp2d, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(3,2*nxvh,kypd) :: f real, intent(inout), dimension(3,nyv,kxp2d) :: g real, intent(inout), dimension(3,kxp2+1,kyp+1) :: bs real, intent(inout), dimension(3,kxp2+1,kyp+1) :: br integer, intent(in) :: isign integer, intent(in) :: ntpose integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd real, intent(inout) :: ttp integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: nvp integer, intent(in) :: nxvh integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: kyp integer, intent(in) :: kypd integer, intent(in) :: kxp2d integer, intent(in) :: nxhyd integer, intent(in) :: nxyd interface public subroutine WPPFSCT2RM3(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nvp, nxvh, nyv, kxp2, kyp, kypd, kxp2d, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(3,2*nxvh,kypd) :: f real, intent(inout), dimension(3,nyv,kxp2d) :: g real, intent(inout), dimension(3,kxp2+1,kyp+1) :: bs real, intent(inout), dimension(3,kxp2+1,kyp+1) :: br integer, intent(in) :: isign integer, intent(in) :: ntpose integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd real, intent(inout) :: ttp integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: nvp integer, intent(in) :: nxvh integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: kyp integer, intent(in) :: kypd integer, intent(in) :: kxp2d integer, intent(in) :: nxhyd integer, intent(in) :: nxyd interface public subroutine PPFCSST2RM3X(f, isign, mixup, sctd, indx, indy, kstrt, kypi, kypp, nxvh, kypd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(3,2*nxvh,kypd) :: f integer, intent(in) :: isign integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: kypi integer, intent(in) :: kypp integer, intent(in) :: nxvh integer, intent(in) :: kypd integer, intent(in) :: nxhyd integer, intent(in) :: nxyd interface public subroutine PPFSCCT2RM3X(f, isign, mixup, sctd, indx, indy, kstrt, kypi, kypp, nxvh, kypd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(3,2*nxvh,kypd) :: f integer, intent(in) :: isign integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: kypi integer, intent(in) :: kypp integer, intent(in) :: nxvh integer, intent(in) :: kypd integer, intent(in) :: nxhyd integer, intent(in) :: nxyd interface public subroutine PPFSCST2RM3Y(g, isign, mixup, sctd, indx, indy, kstrt, kxpi, kxpp, nyv, kxpd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(3,nyv,kxpd) :: g integer, intent(in) :: isign integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: kxpi integer, intent(in) :: kxpp integer, intent(in) :: nyv integer, intent(in) :: kxpd integer, intent(in) :: nxhyd integer, intent(in) :: nxyd interface public subroutine PPFCSCT2RM3Y(g, isign, mixup, sctd, indx, indy, kstrt, kxpi, kxpp, nyv, kxpd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(3,nyv,kxpd) :: g integer, intent(in) :: isign integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: kxpi integer, intent(in) :: kxpp integer, intent(in) :: nyv integer, intent(in) :: kxpd integer, intent(in) :: nxhyd integer, intent(in) :: nxyd interface public subroutine WPPFSCT2RM4(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nvp, nxvh, nyv, kxp2, kyp, kypd, kxp2d, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(4,2*nxvh,kypd) :: f real, intent(inout), dimension(4,nyv,kxp2d) :: g real, intent(inout), dimension(4,kxp2+1,kyp+1) :: bs real, intent(inout), dimension(4,kxp2+1,kyp+1) :: br integer, intent(in) :: isign integer, intent(in) :: ntpose integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd real, intent(inout) :: ttp integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: nvp integer, intent(in) :: nxvh integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: kyp integer, intent(in) :: kypd integer, intent(in) :: kxp2d integer, intent(in) :: nxhyd integer, intent(in) :: nxyd interface public subroutine PPFSCCST2RM4X(f, isign, mixup, sctd, indx, indy, kstrt, kypi, kypp, nxvh, kypd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(4,2*nxvh,kypd) :: f integer, intent(in) :: isign integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: kypi integer, intent(in) :: kypp integer, intent(in) :: nxvh integer, intent(in) :: kypd integer, intent(in) :: nxhyd integer, intent(in) :: nxyd interface public subroutine PPFSCSCT2RM4Y(g, isign, mixup, sctd, indx, indy, kstrt, kxpi, kxpp, nyv, kxpd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(4,nyv,kxpd) :: g integer, intent(in) :: isign integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: kxpi integer, intent(in) :: kxpp integer, intent(in) :: nyv integer, intent(in) :: kxpd integer, intent(in) :: nxhyd integer, intent(in) :: nxyd interface public subroutine WPPFSCT2RM22(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nvp, nxvh, nyv, kxp2, kyp, kypd, kxp2d, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(2,2*nxvh,kypd) :: f real, intent(inout), dimension(2,nyv,kxp2d) :: g real, intent(inout), dimension(2,kxp2+1,kyp+1) :: bs real, intent(inout), dimension(2,kxp2+1,kyp+1) :: br integer, intent(in) :: isign integer, intent(in) :: ntpose integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd real, intent(inout) :: ttp integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: nvp integer, intent(in) :: nxvh integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: kyp integer, intent(in) :: kypd integer, intent(in) :: kxp2d integer, intent(in) :: nxhyd integer, intent(in) :: nxyd interface public subroutine PPFSCCST2RM22X(f, isign, mixup, sctd, indx, indy, kstrt, kypi, kypp, nxvh, kypd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(2,2*nxvh,kypd) :: f integer, intent(in) :: isign integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: kypi integer, intent(in) :: kypp integer, intent(in) :: nxvh integer, intent(in) :: kypd integer, intent(in) :: nxhyd integer, intent(in) :: nxyd interface public subroutine PPFSCSCT2RM22Y(g, isign, mixup, sctd, indx, indy, kstrt, kxpi, kxpp, nyv, kxpd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(2,nyv,kxpd) :: g integer, intent(in) :: isign integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: kxpi integer, intent(in) :: kxpp integer, intent(in) :: nyv integer, intent(in) :: kxpd integer, intent(in) :: nxhyd integer, intent(in) :: nxyd interface public subroutine WPPFSST2RM23(f, g, bs, br, isign, ntpose, mixup, sctd, ttp, indx, indy, kstrt, nvp, nxvh, nyv, kxp2, kyp, kypd, kxp2d, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(3,2*nxvh,kypd) :: f real, intent(inout), dimension(3,nyv,kxp2d) :: g real, intent(inout), dimension(3,kxp2+1,kyp+1) :: bs real, intent(inout), dimension(3,kxp2+1,kyp+1) :: br integer, intent(in) :: isign integer, intent(in) :: ntpose integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd real, intent(inout) :: ttp integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: nvp integer, intent(in) :: nxvh integer, intent(in) :: nyv integer, intent(in) :: kxp2 integer, intent(in) :: kyp integer, intent(in) :: kypd integer, intent(in) :: kxp2d integer, intent(in) :: nxhyd integer, intent(in) :: nxyd interface public subroutine PPFSSCT2RM32X(f, isign, mixup, sctd, indx, indy, kstrt, kypi, kypp, nxvh, kypd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(3,2*nxvh,kypd) :: f integer, intent(in) :: isign integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: kypi integer, intent(in) :: kypp integer, intent(in) :: nxvh integer, intent(in) :: kypd integer, intent(in) :: nxhyd integer, intent(in) :: nxyd interface public subroutine PPFSSCT2RM23Y(g, isign, mixup, sctd, indx, indy, kstrt, kxpi, kxpp, nyv, kxpd, nxhyd, nxyd) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(3,nyv,kxpd) :: g integer, intent(in) :: isign integer, intent(in), dimension(nxhyd) :: mixup complex, intent(in), dimension(nxyd) :: sctd integer, intent(in) :: indx integer, intent(in) :: indy integer, intent(in) :: kstrt integer, intent(in) :: kxpi integer, intent(in) :: kxpp integer, intent(in) :: nyv integer, intent(in) :: kxpd integer, intent(in) :: nxhyd integer, intent(in) :: nxyd interface public subroutine MPPDIVFD2(f, df, nx, ny, kstrt, ndim, nyv, kxp2) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(3,nyv,kxp2+1) :: f real, intent(inout), dimension(nyv,kxp2+1) :: df integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kstrt integer, intent(in) :: ndim integer, intent(in) :: nyv integer, intent(in) :: kxp2 interface public subroutine MPPGRADFD2(df, f, nx, ny, kstrt, ndim, nyv, kxp2) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(nyv,kxp2+1) :: df real, intent(inout), dimension(3,nyv,kxp2+1) :: f integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kstrt integer, intent(in) :: ndim integer, intent(in) :: nyv integer, intent(in) :: kxp2 interface public subroutine MPPCURLFD2(f, g, nx, ny, kstrt, nyv, kxp2) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(3,nyv,kxp2+1) :: f real, intent(inout), dimension(3,nyv,kxp2+1) :: g integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kstrt integer, intent(in) :: nyv integer, intent(in) :: kxp2 Subroutines public subroutine PPRTPOSE (f, g, s, t, nx, ny, kxp, kyp, kstrt, nvp, nxv, nyv, kxpd, kypd) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(nxv,kypd) :: f real, intent(inout), dimension(nyv,kxpd) :: g real, intent(inout), dimension((kxp+1)*(kyp+1)) :: s real, intent(inout), dimension((kxp+1)*(kyp+1)) :: t integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kxp integer, intent(in) :: kyp integer, intent(in) :: kstrt integer, intent(in) :: nvp integer, intent(in) :: nxv integer, intent(in) :: nyv integer, intent(in) :: kxpd integer, intent(in) :: kypd public subroutine PPRNTPOSE (f, g, s, t, nx, ny, kxp, kyp, kstrt, nvp, ndim, nxv, nyv, kxpd, kypd) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(ndim,nxv,kypd) :: f real, intent(inout), dimension(ndim,nyv,kxpd) :: g real, intent(inout), dimension(ndim,(kxp+1)*(kyp+1)) :: s real, intent(inout), dimension(ndim,(kxp+1)*(kyp+1)) :: t integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: kxp integer, intent(in) :: kyp integer, intent(in) :: kstrt integer, intent(in) :: nvp integer, intent(in) :: ndim integer, intent(in) :: nxv integer, intent(in) :: nyv integer, intent(in) :: kxpd integer, intent(in) :: kypd","tags":"","loc":"module/fft2d_lib.html"},{"title":"quickpic – QuickPIC","text":"Uses simulation_class program~~quickpic~~UsesGraph program~quickpic quickpic module~simulation_class simulation_class program~quickpic->module~simulation_class module~spect3d_class spect3d_class module~simulation_class->module~spect3d_class module~parallel_class parallel_class module~simulation_class->module~parallel_class module~input_class input_class module~simulation_class->module~input_class module~spect2d_class spect2d_class module~simulation_class->module~spect2d_class module~field3d_class field3d_class module~simulation_class->module~field3d_class module~field2d_class field2d_class module~simulation_class->module~field2d_class module~perrors_class perrors_class module~simulation_class->module~perrors_class module~fdist3d_class fdist3d_class module~simulation_class->module~fdist3d_class module~parallel_pipe_class parallel_pipe_class module~simulation_class->module~parallel_pipe_class module~beam3d_class beam3d_class module~simulation_class->module~beam3d_class module~hdf5io_class hdf5io_class module~simulation_class->module~hdf5io_class module~species2d_class species2d_class module~simulation_class->module~species2d_class mpi mpi module~simulation_class->mpi module~fdist2d_class fdist2d_class module~simulation_class->module~fdist2d_class module~spect3d_class->module~spect2d_class module~spect3d_class->module~perrors_class module~spect3d_class->module~parallel_pipe_class module~parallel_class->mpi omp_lib omp_lib module~parallel_class->omp_lib module~input_class->module~spect3d_class module~input_class->module~parallel_class module~input_class->module~perrors_class module~input_class->module~parallel_pipe_class module~input_class->mpi json_module json_module module~input_class->json_module module~spect2d_class->module~perrors_class module~spect2d_class->module~parallel_pipe_class module~field3d_class->module~spect3d_class module~field3d_class->module~perrors_class module~field3d_class->module~parallel_pipe_class module~field3d_class->module~hdf5io_class module~ufield3d_class ufield3d_class module~field3d_class->module~ufield3d_class module~field2d_class->module~spect2d_class module~field2d_class->module~field3d_class module~field2d_class->module~perrors_class module~field2d_class->module~parallel_pipe_class module~field2d_class->module~hdf5io_class module~fpois2d_class fpois2d_class module~field2d_class->module~fpois2d_class module~fft2d_class fft2d_class module~field2d_class->module~fft2d_class module~field2d_class->module~ufield3d_class module~ufield2d_class ufield2d_class module~field2d_class->module~ufield2d_class module~perrors_class->module~parallel_class module~perrors_class->mpi module~fdist3d_class->module~spect3d_class module~fdist3d_class->module~input_class module~fdist3d_class->module~perrors_class module~fdist3d_class->module~parallel_pipe_class module~part3d_lib part3d_lib module~fdist3d_class->module~part3d_lib module~fdist3d_class->module~ufield3d_class module~parallel_pipe_class->module~parallel_class module~parallel_pipe_class->mpi module~beam3d_class->module~spect3d_class module~beam3d_class->module~field3d_class module~beam3d_class->module~field2d_class module~beam3d_class->module~perrors_class module~beam3d_class->module~fdist3d_class module~beam3d_class->module~parallel_pipe_class module~beam3d_class->module~hdf5io_class module~beam3d_class->mpi module~part3d_class part3d_class module~beam3d_class->module~part3d_class module~hdf5io_class->module~perrors_class module~hdf5io_class->module~parallel_pipe_class module~hdf5io_class->mpi HDF5 HDF5 module~hdf5io_class->HDF5 module~species2d_class->module~spect3d_class module~species2d_class->module~spect2d_class module~species2d_class->module~field3d_class module~species2d_class->module~field2d_class module~species2d_class->module~perrors_class module~species2d_class->module~parallel_pipe_class module~species2d_class->module~hdf5io_class module~species2d_class->module~fdist2d_class module~part2d_class part2d_class module~species2d_class->module~part2d_class module~fdist2d_class->module~input_class module~fdist2d_class->module~spect2d_class module~fdist2d_class->module~perrors_class module~fdist2d_class->module~parallel_pipe_class module~fdist2d_class->module~ufield2d_class module~part3d_class->module~spect3d_class module~part3d_class->module~perrors_class module~part3d_class->module~fdist3d_class module~part3d_class->module~parallel_pipe_class module~part3d_class->module~hdf5io_class module~part3d_class->mpi module~part3d_class->module~part3d_lib module~part3d_class->module~ufield3d_class module~fpois2d_class->module~spect2d_class module~fpois2d_class->module~perrors_class module~fpois2d_class->module~parallel_pipe_class module~fpois2d_class->module~ufield2d_class module~fpois2d_lib fpois2d_lib module~fpois2d_class->module~fpois2d_lib module~fft2d_class->module~spect2d_class module~fft2d_class->module~perrors_class module~fft2d_class->module~parallel_pipe_class module~fft2d_class->module~ufield2d_class module~fft2d_lib fft2d_lib module~fft2d_class->module~fft2d_lib module~ufield3d_class->module~spect3d_class module~ufield3d_class->module~perrors_class module~ufield3d_class->module~parallel_pipe_class module~ufield3d_class->module~hdf5io_class module~ufield3d_class->mpi module~ufield3d_class->module~ufield2d_class module~ufield3d_lib ufield3d_lib module~ufield3d_class->module~ufield3d_lib module~ufield2d_class->module~spect2d_class module~ufield2d_class->module~perrors_class module~ufield2d_class->module~parallel_pipe_class module~ufield2d_class->module~hdf5io_class module~ufield2d_class->mpi module~ufield2d_lib ufield2d_lib module~ufield2d_class->module~ufield2d_lib module~part2d_class->module~spect2d_class module~part2d_class->module~perrors_class module~part2d_class->module~parallel_pipe_class module~part2d_class->module~hdf5io_class module~part2d_class->mpi module~part2d_class->module~fdist2d_class module~part2d_class->module~ufield2d_class module~part2d_lib part2d_lib module~part2d_class->module~part2d_lib module~part2d_lib->mpi module~ufield2d_lib->mpi module~fft2d_lib->mpi var panprogramquickpicUsesGraph = svgPanZoom('#programquickpicUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables sim Variables Type Attributes Name Initial type( simulation ) :: sim","tags":"","loc":"program/quickpic.html"}]}